# 工具框架面试题
## Spring面试题
[Spring面试题（2020最新版）](https://thinkwon.blog.csdn.net/article/details/104397516)
### 对Spring的理解，项目中都用什么？怎么用的？对IOC、和AOP的理解及实现原理。
```markdown
Spring是一个开源框架，处于MVC模式中的控制层，它能应对需求快速的变化，其主要原因它有一种面向切面编程（AOP）的优势，其次它提升了系统性能，
因为通过依赖倒置机制（IOC），系统中用到的对象不是在系统加载时就全部实例化，而是在调用到这个类时才会实例化该类的对象，从而提升了系统性能。
这两个优秀的性能使得Spring受到许多J2EE公司的青睐，如阿里中使用最多的也是Spring相关技术。
Spring的优点：
1、降低了组件之间的耦合性，实现了软件各层之间的解耦。
2、可以使用容易提供的众多服务，如事务管理，消息服务，日志记录等。
3、容器提供了AOP技术，利用它很容易实现如权限拦截、运行期监控等功能。
Spring中AOP技术是设计模式中的动态代理模式。只需实现jdk提供的动态代理接口InvocationHandler，所有被代理对象的方法都由InvocationHandler接管实际的处理任务。
面向切面编程中还要理解切入点、切面、通知、织入等概念。
Spring中IOC则利用了Java强大的反射机制来实现。所谓依赖注入即组件之间的依赖关系由容器在运行期决定。其中依赖注入的方法有两种，通过构造函数注入，通过set方法进行注入。
```
### 1.什么是spring?
```markdown
Spring是一个轻量级Java开发框架，最早有Rod Johnson创建，目的是为了解决企业级应用开发的业务逻辑层和其他各层的耦合问题。
它是一个分层的JavaSE/JavaEE full-stack（一站式）轻量级开源框架，为开发Java应用程序提供全面的基础架构支持。
Spring负责基础架构，因此Java开发者可以专注于应用程序的开发。
Spring最根本的使命是解决企业级应用开发的复杂性，即简化Java开发。
Spring可以做很多事情，它为企业级开发提供给了丰富的功能，但是这些功能的底层都依赖于它的两个核心特性，也就是依赖注入（DI）和面向切面编程（AOP）。
为了降低Java开发的复杂性，Spring采取了以下4种关键策略
    - 基于POJO的轻量级和最小侵入性编程；
    - 通过依赖注入和面向接口实现松耦合；
    - 基于切面和惯例进行声明式编程；
    - 通过切面和模板减少样板式代码。
```
### 2.Spring框架的设计目标，设计理念，和核心是什么
```markdown
Spring设计目标：Spring为开发者提供一个一站式轻量级应用开发平台；
Spring设计理念：在JavaEE开发中，支持POJO和JavaBean开发方式，使应用面向接口开发，充分支持OO（面向对象）设计方法；
Spring通过IoC容器实现对象耦合关系的管理，并实现依赖反转，将对象之间的依赖关系交给IoC容器，实现解耦；
Spring框架的核心：IoC容器和AOP模块。通过IoC容器管理POJO对象以及他们之间的耦合关系；通过AOP以动态非侵入的方式增强服务。
IoC让相互协作的组件保持松散的耦合，而AOP编程允许你把遍布于应用各层的功能分离出来形成可重用的功能组件。
```
### 3.Spring的优缺点是什么？
```markdown
优点
    方便解耦，简化开发。Spring就是一个大工厂，可以将所有对象的创建和依赖关系的维护，交给Spring管理。
    AOP编程的支持。Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能。
    声明式事务的支持。只需要通过配置就可以完成对事务的管理，而无需手动编程。
    方便程序的测试。Spring对Junit4支持，可以通过注解方便的测试Spring程序。
    方便集成各种优秀框架。Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架的直接支持（如：Struts、Hibernate、MyBatis等）。
    降低JavaEE API的使用难度。Spring对JavaEE开发中非常难用的一些API（JDBC、JavaMail、远程调用等），都提供了封装，使这些API应用难度大大降低。
缺点
    - Spring明明一个很轻量级的框架，却给人感觉大而全
    - Spring依赖反射，反射影响性能
    - 使用门槛升高，入门Spring需要较长时间
```
### 4.Spring动态代理(JDK 动态代理和 CGLIB 动态代理)
```markdown

```

## SpringMVC面试题
[Spring MVC面试题（2020最新版）](https://blog.csdn.net/ThinkWon/article/details/104397427)
###[springmvc的面试知识点总结](https://www.cnblogs.com/yunjiandubu/p/10269713.html)
#### 1.springmvc的工作流程?
![](https://upload-images.jianshu.io/upload_images/3975098-58f33691fab32bbe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
```markdown
1.请求过来之后,dispatcherServlet的url-pattern拦截请求;
2.判断在springmvc中是否存在对应映射;
3.若不存在,判断是否配置mvc:default-servlet-handler/;
4.如果配置,就会找到目标资源,没有则显示404页面;
5.如果映射存在,则由handlerMapping获handlerExecutionChain对象;(注意两点:
    ① handlerMapping定义了请求到处理器之间的映射,如果发送的请求是没有映射的,那么得到的handlerExecutionChain也不为空,
    而是默认的defaultServletHTTPRequestHandler,用来处理静态资源等(配置了default-servlet-handler,否则报为404);
    ② handlerExecutionChain实际上包含了拦截器和目标方法.)
6.获取HandlerAdapter对象;(包含表单类型的校验,数据类型的转换,格式换等功能)
7.调用 interceptor拦截器的preHandle方法;
8.调用目标方法;
9.调用拦截器的postHandle方法;
10.处理视图时候,观察是否存在异常,存在异常,则由HandlerExceptionResolver来处理异常,并得到新的ModelAndView对象;不存在异常,则由ViewResolver视图解析器来解析视图;
11.调用拦截器的afterComplettion方法;
```
[浅谈SpringMVC执行过程](https://www.cnblogs.com/wangjiming/p/10487832.html)
#### 2.springmvc dispatcherservlet与handleradapter如何关联？
```markdown
DispatcherServlet拦截到请求之后,根据handlerMapping获取到handlerExecutionChain对象,然后,
在handlerExecutionChain对象不为null的情况下,根据handlerExecutionChain中的handler对象获取HandlerAdapter对象;
```
#### 3.有了springmvc的IOC容器,还需要spring的IOC容器吗?为什么?如何处理兼容问题?
```markdown
这个问题再进一步,换个方式提问即是否还需要在web.xml方法里面配置启动springIOC容器的ContextLoaderListener?
可以从正反两方面来回答,首先是需要,通常情况下,类似于数据源,事务,整合其他框架等都是放在spring的配置文件中,而不是springmvc的配置文件中, 
一般情况下,开发过程中的Service,Dao也都是放在spring的IOC容器当中;其次可以是不需要的,也可以都放在springmvc的配置文件当中,
当然需要分多个spring的配置文件,然后通过import节点导入到springmvc的配置文件当中.
几点要注意的地方:
1. springIOC容器和springmvc的IOC容器 扫描的部分有重合的地方,就会导致bean被创建2次,解决方案:使用 exclude-filter和include-filter配合
    来区分哪些bean交给springIOC容器,哪些bean交给springmvcIOC容器;
2. springmvc IOC容器里面的bean可以引用springIOC容器的bean,反之则不行,多个springIOC 容器之间可以设置为父子关系,以实现良好的解耦.
举个栗子,springIOC容器好比是全局作用域,springmvcIOC容器好比是局部作用域,局部的可以引用全局的,而全局的却不能引用局部的.
```
#### 4.tomcat容器如何与springmvc的dispatcherservlet通信的？
```markdown
Apache Tomcat软件是JavaServlet，JavaServerPages，Java ExpressionLanguage和JavaWebSocket技术的开源实现,
SpringMVC则是spring推出的基于servlet标准的MVC框架实现,由此可知,SpringMvc和Tomcat 的结合点就是Servlet.SpringMVC的
DispatcherServlet继承了HttpServlet,那么对于tomcat来说,springmvc实际就是一个Servlet.
一个http请求的具体处理流程:
1. 用户向tomcat容器发送一个请求;
2. tomcat容器接收到请求之后,分析客户的请求信息;
3. tomcat创建一个Httprequest对象,将用户的请求信息封装到该对象中;
4. tomcat创建一个HttpResponse对象;
5. tomcat调用HttpServlet的Service方法,将Httprequest,HTTPResponse传递给Httpservlet对象;
6. HttpServlet调用HttpRequest对象的有关方法,获取Http请求信息,HttpServlet调用HttpResponse对象的有关方法，生成响应数据;
7. tomcat把HttpServlet的响应结果传给Web客户.
要注意的几点东西:
①:web.xml配置文件的作用其实就是配置http请求和servlet之间的映射关系,通过这个配置文件,Tomcat可以把请求转发给不同的servlet实例;
②:springmvc也是servlet标准的一个实现,所有的http请求都映射到DispatcherServlet上去,这个时候,请求就已经由Tomcat转发到springmvc框架中去了,
接着再由DispatcherServlet将请求转发到各个Controller当中去.
```

## SpringBoot面试题
[Spring Boot面试题（2020最新版）](https://blog.csdn.net/ThinkWon/article/details/104397299)

## Mybatis面试题
[MyBatis面试题（2020最新版）](https://thinkwon.blog.csdn.net/article/details/101292950)
### 1.MyBatis是什么？
```markdown
MyBatis是一款优秀的持久层框架，一个半ORM（对象关系映射）框架，它支持定制化SQL、存储过程以及高级映射。
MyBatis避免了几乎所有的JDBC代码和手动设置参数以及获取结果集。MyBatis可以使用简单的XML或注解来配置和映射原生类型、接口和Java的POJO为数据库中的记录。
```
### 2.ORM是什么？
```markdown
ORM（Object Relational Mapping），对象关系映射，是一种为了解决关系型数据库数据与简单Java对象（POJO）的映射关系的技术。
简单的说，ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系型数据库中。
```
### 3.为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？
```markdown
Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。
而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。
```
### 4.传统JDBC开发存在的问题
```markdown
频繁创建数据库连接对象、释放，容易造成系统资源浪费，影响系统性能。可以使用连接池解决这个问题。但是使用jdbc需要自己实现连接池。
sql语句定义、参数设置、结果集处理存在硬编码。实际项目中sql语句变化的可能性较大，一旦发生变化，需要修改java代码，系统需要重新编译，重新发布。不好维护。
使用preparedStatement向占有位符号传参数存在硬编码，因为sql语句的where条件不一定，可能多也可能少，修改sql还要修改代码，系统不易维护。
结果集处理存在重复代码，处理麻烦。如果可以映射成Java对象会比较方便。
```
### 5.JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？
```markdown
1、数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库连接池可解决此问题。
解决：在mybatis-config.xml中配置数据链接池，使用连接池管理数据库连接。
2、Sql语句写在代码中造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。
解决：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。
3、向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。
解决：Mybatis自动将java对象映射至sql语句。
4、对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便。
解决：Mybatis自动将sql执行结果映射至java对象。
```
### 6.Mybatis优缺点
```markdown
优点：
    与传统的数据库访问技术相比，ORM有以下优点：
    基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML里，解除sql与程序代码的耦合，
        便于统一管理；提供XML标签，支持编写动态SQL语句，并可重用。
    与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接。
    很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持）
    提供映射标签，支持对象与数据库的ORM字段关系映射；提供对象关系映射标签，支持对象关系组件维护
    能够与Spring很好的集成。
缺点：
    SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求
    SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库
```
### 7.MyBatis的解析和运行原理
```markdown
MyBatis编程步骤是什么样的？
    1、 创建SqlSessionFactory
    2、 通过SqlSessionFactory创建SqlSession
    3、 通过sqlsession执行数据库操作
    4、 调用session.commit()提交事务
    5、 调用session.close()关闭会话       
请说说MyBatis的工作原理:
    1）读取MyBatis配置文件：mybatis-config.xml为MyBatis的全局配置文件，配置了MyBatis的运行环境等信息，例如数据库连接信息。
    2）加载映射文件。映射文件即SQL映射文件，该文件中配置了操作数据库的SQL语句，需要在MyBatis配置文件mybatis-config.xml中加载。
        mybatis-config.xml 文件可以加载多个映射文件，每个文件对应数据库中的一张表。
    3）构造会话工厂：通过MyBatis的环境等配置信息构建会话工厂SqlSessionFactory。
    4）创建会话对象：由会话工厂创建SqlSession对象，该对象中包含了执行SQL语句的所有方法。
    5）Executor执行器：MyBatis底层定义了一个Executor接口来操作数据库，它将根据SqlSession传递的参数动态地生成需要执行的 SQL语句，同时负责查询缓存的维护。
    6）MappedStatement对象：在Executor接口的执行方法中有一个MappedStatement类型的参数，该参数是对映射信息的封装，用于存储要映射的SQL语句的id、参数等信息。
    7）输入参数映射：输入参数类型可以是Map、List 等集合类型，也可以是基本数据类型和POJO类型。输入参数映射过程类似于JDBC对preparedStatement对象设置参数的过程。
    8）输出结果映射：输出结果类型可以是Map、List 等集合类型，也可以是基本数据类型和POJO类型。输出结果映射过程类似于JDBC对结果集的解析过程。
```
### 8.Mybatis都有哪些Executor执行器？它们之间的区别是什么？
```markdown
Mybatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。
SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。
ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，
    而是放置于Map<String, Statement>内，供下一次使用。简言之，就是重复使用Statement对象。
BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），
    它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。
作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内。
Mybatis中如何指定使用哪一种Executor执行器？
在Mybatis配置文件中，在设置（settings）可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法
传递ExecutorType类型参数，如SqlSession openSession(ExecutorType execType)。
配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（prepared statements）；BATCH 执行器将重用语句并执行批量更新。
```
## 中间件面试题

## Netty面试题
[Netty面试题（2020最新版）](https://blog.csdn.net/ThinkWon/article/details/104391081)

##SpringCloud面试题
[Spring Cloud面试题（2020最新版）](https://blog.csdn.net/ThinkWon/article/details/104397367)


