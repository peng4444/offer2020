## 链表算法题
[参考资料：cyc2018链表](https://cyc2018.github.io/CS-Notes/#/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E9%93%BE%E8%A1%A8)

### 链表
>> LeetCode对应题目：2,19,21,24,83,141,160，445，234，328，206，23,25，725,203
#### 0.链表数据结构
```markdown
class ListNode{
    private int val;
    private ListNode next;
    ListNode(int val){
        this.val = val;
    }
}
```
#### 206.链表反转
```java
//1.迭代循环
public ListNode revserseList(ListNode head){
    ListNode pre = null;
    ListNode next = null;
    while(head!=null){
        next = head.next;
        head.next = pre;
        pre = head;
        haed = next;
    }
    return pre;
}
//2.递归实现
public ListNode revserseList(ListNode head){
    if(head==null||head.next==null) return head;
    ListNode newList = reverseList(head.next);
    head.next.next = head;
    head.next = null;
    return newList; 
}
```


[Java数据结构和算法（七）——链表](https://www.cnblogs.com/ysocean/p/7928988.html)

[链表专题——面试中常见的链表问题](https://www.cnblogs.com/ZhaoxiCheung/p/Linked-list.html#undefined)

[链表算法经典十题总结](https://www.cnblogs.com/tojian/p/10055036.html)
#### 92.链表反转II-反转m到n
>> 反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。
```java
public ListNode reverseBetween(ListNode head,int m,int n){
    //先找第m个链表
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    ListNode pre = dummy;
    for(int i = 1;i<m;i++){
        pre = pre.next;
    }
    //在反转第m到第n个
    head = pre.next;
    for(int i = m;i<n;i++){
        ListNode next = head.next;
        head.next = next.next;
        next.next = pre.next;   
        pre.next = next;
    }
    return dummy.next;
}
//也可递归实现
```
#### 141.判断链表有环
```java
//双指针
public boolean hasCycle(ListNode head){
    ListNode fast = head;
    ListNode slow = head;
    while(fast!=null&&fast.next!=null){
        fast= fast.next.next;
        slow = slow.next;
        if(fast==slow) return true;
    }
    return false;
}
//Set集合
public boolean hasCycle(ListNode head){
    Set<ListNode> set = new HashSet<>();
    while(head!=null){
        if(!set.contains(head)){
            set.add(head);
            head = head.next;
        }else{
            return true;
        }   
    }
    return false;
}
```
#### 142.链表有环II-求入口
```java
 public ListNode detectCycle(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        boolean hasCycle = false;
        while(fast!=null&&fast.next!=null){
            fast = fast.next.next;
            slow = slow.next;
            if(slow==fast){
                hasCycle = true;
                break;
            }
        }
        if(hasCycle){
            ListNode curr = head;
            while(slow!=curr){
                slow = slow.next;
                curr = curr.next;
            }
            return curr;
        }else{
            return null;
        }
    }
//也可用HashSet实现
```
#### 21.合并有序链表-23.合并k个有序链表
```markdown
public ListNode mergeTwoList(ListNode l1,ListNode l2){
    ListNode dummy = new ListNode(0);
    ListNode curr  = dummy;
    while(l1!=null&&l2!=null){
        if(l1.val<l2.val){
            curr.next = l1;
            l1 = l1.next;
        }else{
            curr.next = l2;
            l2 = l2.next;
        }
        curr = curr.next;
    }
    curr.next = l1==null?l2:l1;
    return dummy.next;
}
```
#### 147.对链表进行插入排序-148.排序链表
```markdown
 public ListNode insertionSortList(ListNode head) {
        ListNode dummy = new ListNode(0);
        ListNode curr = dummy;
        while(head!=null){
            if(curr.next==null||curr.next.val>head.val){
                ListNode p = head.next;
                head.next = curr.next;
                curr.next = head;
                curr = dummy;
                head = p;
            }else{
                curr = curr.next;
            }
        }
        return dummy.next;
    }
```
#### 19. 删除链表的倒数第N个节点-输出倒数第n个节点
```markdown
public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode first = dummy;
        ListNode second = dummy;
        for(int i = 1;i<=n+1;i++){
            first = first.next;
        }
        while(first!=null){
            first = first.next;
            second = second.next;
        }
        second.next = second.next.next;
        return dummy.next;
    }
```
#### 2.链表相加
```markdown
public ListNode addInList (ListNode head1, ListNode head2) {
        ListNode dummy = new ListNode(0);
        ListNode p = head1;
        ListNode q = head2;
        ListNode curr = dummy;
        int carry = 0;
        while(p!=null||q!=null){
            int x = (p!=null)?p.val:0;
            int y = (q!=null)?q.val:0;
            int sum = carry + x + y;
            carry = sum/10;
            curr.next = new ListNode(sum%10);
            curr = curr.next;
            if(p!=null) p = p.next;
            if(q!=null) q = q.next;
        }
        if(carry>0) curr.next = new ListNode(carry);
        return dummy.next;
    }
```
#### 234. 判断回文链表            
```markdown
public boolean isPail (ListNode head) {
        // write code here
        List<Integer> list = new ArrayList<>();
        ListNode curr = head;
        while(curr!=null){
            list.add(curr.val);
            curr = curr.next;
        }
        int start= 0,end = list.size()-1;
        while(start<end){
            if(!list.get(start).equals(list.get(end))){
                return false;
            }
            start++;
            end--;
        }
        return true;
    }
```
#### 25. K 个一组翻转链表
```markdown
public ListNode reverseKGroup (ListNode head, int k) {
        // write code here
        ListNode dummy = new ListNode(0);
        ListNode pre = dummy;
        ListNode curr = head;
        ListNode next;
        dummy.next = head;
        int len = 0;
        while(head!=null) {
            len++;
            head = head.next;
        }
        head = dummy.next;
        for(int i = 0;i<len/k;i++){
            for(int j = 0;j<k-1;j++){
                next = curr.next;
                curr.next = next.next;
                next.next = pre.next;
                pre.next = next;
            }
            pre = curr;
            curr = pre.next;
        }
        return dummy.next;
    }
```

