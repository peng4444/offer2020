# 树算法题
[深入理解二叉树（超详细）](https://www.cnblogs.com/kalton/p/13689985.html)
[数据结构和算法：二叉树](https://www.cnblogs.com/gaofei200/p/13764654.html)
[LeetCode刷题总结-树篇（上）](https://www.cnblogs.com/liuzhen1995/p/11921771.html)
[LeetCode刷题总结-树篇（中）](https://www.cnblogs.com/liuzhen1995/p/11951163.html)

## 树的四大类
```markdown
树的自身特性：对称，翻转，打印，合并，剪枝，右视图，深度和广度
    树的类型：依据前序和中序(或者后序)遍历构造二叉树，依据前序遍历还原二叉树
二叉树遍历写法：递归、栈、还有什么？
哈夫曼编码
二叉排序树、二叉平衡树
判断是否是子树
手写打印二叉树的深度，递归和非递归都写了，并解释非递归的代码的含义
给你一棵二叉树，怎么获得它的镜像二叉树
判断二叉树从根节点到叶节点是否有和为target的路径
输出最深的叶子节点
已知二叉树的先序遍历序列，输出它的中序遍历序列。比如先序：ABC##D#E###，输出中序CBDEA。#表示空节点，中序输出不需要#
```
### 树的数据结构
```markdown
public class TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int x){
        val = x;
    }
}
```
### 树的遍历
[基于Java的二叉树的三种遍历方式的递归与非递归实现](https://www.cnblogs.com/chiaki/p/13543524.html)
#### 94,144,145,前序遍历-中序-后序
```markdown
public class preOrderRecur {
    List<Integer> res = new ArrayList<>();
    public List<Integer> preOrderTraversal(TreeNode root) {
        if (root != null) {
            res.add(root.val); // 根节点
            preOrderTraversal(root.left); // 左子树
            preOrderTraversal(root.right); // 右子树
        }
        return res;
    }
}
//迭代实现
public class preOrderIterator {
    List<Integer> res = new ArrayList<>();
    public List<Integer> inOrderTraversal(TreeNode root) {
        if (root == null) return res;
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while (!stack.isEmpty()) {
            root = stack.pop();
            res.add(root.val);
            // 右孩子压栈
            if (root.right != null) stack.push(root.right);
            // 左孩子压栈
            if (root.left != null) stack.push(root.left);
        }
        return res;
    }
}
```
#### 102.二叉树的层次遍历
```markdown
//递归实现
List<List<Integer>> ans = new ArrayList<>();
    public List<List<Integer>> levelOrder(TreeNode root) {
        if(root==null) return ans;
        help(root,0);
        return ans;
    }
    private void help(TreeNode node,Integer level){
        if(ans.size()==level){
            ans.add(new ArrayList<Integer>());
        }
        ans.get(level).add(node.val);
        if(node.left!=null) help(node.left,level+1);
        if(node.right!=null) help(node.right,level+1);
    }
//迭代实现，获取到每一层的节点个数
public List<List<Integer>> levelOrder (TreeNode root) {
        List<List<Integer>> ans = new ArrayList<>();
        if(root!=null){
            Queue<TreeNode> queue = new LinkedList<>();
            queue.offer(root);
            while(!queue.isEmpty()){
                int size = queue.size();
                ArrayList<Integer> list = new ArrayList<>();
                for(int i = 0;i<size;i++){
                    TreeNode temp = queue.poll();
                    list.add(temp.val);
                    if(temp.left!=null){
                        queue.offer(temp.left);
                    }
                    if(temp.right!=null){
                        queue.offer(temp.right);
                    }
                }
                ans.add(list);
            }
        }
        return ans;
    }
//从下往上层次遍历
public List<List<Integer>> levelOrderBottom(TreeNode root) {
        LinkedList<List<Integer>> ans = new LinkedList<>();
        if(root==null) return ans;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while(!queue.isEmpty()){
            List<Integer> oneLevel = new ArrayList<>();
            int count = queue.size();
            for(int i = 0;i<count;i++){
                TreeNode node = queue.poll();
                oneLevel.add(node.val);
                if(node.left!=null) queue.add(node.left);
                if(node.right!=null) queue.add(node.right);
            }
            ans.addFirst(oneLevel);
        }
        return ans;
    }
```
#### 107.二叉树的层次遍历（自底向上）
```markdown
public List<List<Integer>> levelOrderBottom(TreeNode root) {
        LinkedList<List<Integer>> ans = new LinkedList<>();
        if(root==null) return ans;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while(!queue.isEmpty()){
            List<Integer> oneLevel = new ArrayList<>();
            int count = queue.size();
            for(int i = 0;i<count;i++){
                TreeNode node = queue.poll();
                oneLevel.add(node.val);
                if(node.left!=null) queue.add(node.left);
                if(node.right!=null) queue.add(node.right);
            }
            ans.addFirst(oneLevel);
        }
        return ans;
    }
```
#### 637. 二叉树的层平均值
```markdown
public List<Double> averageOfLevels(TreeNode root) {
        List<Double> ans = new ArrayList<>();
        if(root==null) return ans;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while(!queue.isEmpty()){
            int cnt = queue.size();
            double sum = 0;
            for(int i = 0; i < cnt; i++){
                TreeNode node = queue.poll();
                sum+=node.val;
                if(node.left!=null) queue.add(node.left);
                if(node.right!=null) queue.add(node.right);
            }
            ans.add(sum/cnt);
        }
        return ans;
    }
```
#### 103.树的之自型遍历
```markdown
public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> ans = new ArrayList<>();
        if(root==null) return ans;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        int depth = 0;
        while(!queue.isEmpty()){
            int count = queue.size();
            List<Integer> list = new ArrayList<>();
            while(count>0){
                TreeNode node = queue.poll();
                if(depth%2==1){
                    list.add(0,node.val);
                }else{
                    list.add(node.val);
                }
                if(node.left!=null) queue.add(node.left);
                if(node.right!=null) queue.add(node.right);
                count--;
            }
            depth++;
            ans.add(list);
        }
        return ans;
    }
```
#### 589.N叉树的前序遍历,590. N叉树的后序遍历
```markdown
List<Integer> res = new ArrayList<>();
    public List<Integer> preorder(Node root) {
        Stack<Node> stack = new Stack<>();
        if(root==null) return res;
        stack.push(root);
        while(!stack.isEmpty()){
            Node node = stack.pop();
            res.add(node.val);
            for(int i = node.children.size()-1;i>=0;i--){
                stack.add(node.children.get(i));
            }
        }
        return res;
    }
```
#### 429.N叉树的层序遍历
```markdown
 public List<List<Integer>> levelOrder(Node root) {
        List<List<Integer>> res = new ArrayList<>();
        if(root==null){
            return res;
        }
        LinkedList<Node> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            int len = queue.size();
            List<Integer> list = new ArrayList<>();
            for(int i = 0;i<len;i++){
                Node node = queue.poll();
                list.add(node.val);
                List<Node> n_list = node.children;
                for(Node no:n_list){
                    queue.offer(no);
                }
            }
            res.add(list);
        }
        return res;
    }
```
### 二叉搜索树
#### 98. 验证二叉搜索树
```markdown
public boolean isValidBST(TreeNode root) {
        Stack<TreeNode> stack = new Stack<>();
        double inorder = - Double.MAX_VALUE;
        while(!stack.isEmpty()||root!=null){
            while(root!=null){
                stack.push(root);
                root = root.left;
            }
            root = stack.pop();
            if(root.val<=inorder){
                return false;
            }
            inorder = root.val;
            root = root.right;
        }
        return true;
    }
```
#### 95,96.不同的二叉搜索树
```markdown
//给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？
public int numTrees(int n) {
        int[] nums = new int[n+1];
        nums[0] = 1;
        nums[1] = 1;
        for(int i = 2;i<=n;i++){
            for(int j = 1;j<=i;j++){
                nums[i]+=nums[j-1]*nums[i-j];
            }
        }
        return nums[n];
    }
//给定一个整数 n，生成所有由 1 ... n 为节点所组成的 二叉搜索树 。
public List<TreeNode> generateTrees(int n) {
        if(n==0) return new LinkedList<TreeNode>();
        return help(1,n);
    }
    private List<TreeNode> help(int start,int end){
        List<TreeNode> res = new LinkedList<>();
        if(start>end){
            res.add(null);
            return res;
        }
        for(int i = start;i<=end;i++){
            List<TreeNode> subLeftTree = help(start,i-1);
            List<TreeNode> subRightTree = help(i+1,end);
            for(TreeNode left:subLeftTree){
                for(TreeNode right:subRightTree){
                    TreeNode node = new TreeNode(i);
                    node.left = left;
                    node.right = right;
                    res.add(node);
                }
            }
        }
        return res;
    }
```
#### 501. 二叉搜索树中的众数
```markdown
Map<Integer,Integer> map;
    public int[] findMode(TreeNode root) {
        if(root==null) return new int[]{};
        map = new HashMap<>();
        dfs(root);
        int max = map.get(root.val);
        for(Integer num:map.values()){
            if(max<num){
                max = num;
            }
        }
        List<Integer> list = new ArrayList<>();
        for(int a:map.keySet()){
            if(map.get(a)==max){
                list.add(a);
            }
        }
        int[] ans = new int[list.size()];
        for(int i = 0;i<list.size();i++){
            ans[i] = list.get(i);
        }
        return ans;
    }
    //遍历树
    public void dfs(TreeNode root){
        if(root==null){
            return;
        }
        map.put(root.val,map.getOrDefault(root.val,0)+1);
        dfs(root.left);
        dfs(root.right);
    }
```
#### 99. 恢复二叉搜索树
```markdown
//二叉搜索树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。
TreeNode t1,t2,pre;
    public void recoverTree(TreeNode root) {
        inorder(root);
        int temp = t1.val;
        t1.val = t2.val;
        t2.val = temp;
    }
    private void inorder(TreeNode root){
        if(root==null) return;
        inorder(root.left);
        if(pre!=null&&pre.val>root.val){
            if(t1==null) t1 = pre;
            t2  = root;
        }
        pre = root;
        inorder(root.right);
    }
```
#### 235. 二叉搜索树的最近公共祖先
```markdown
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(p.val==root.val) return p;
        if(q.val==root.val) return q;
        if(p.val>root.val&&q.val>root.val){
            return lowestCommonAncestor(root.right,p,q);
        }else if(p.val<root.val&&q.val<root.val){
            return lowestCommonAncestor(root.left,p,q);
        }else{
            return root;
        }
    }
```
### 树的极值
#### 104. 二叉树的最大深度
```markdown
public int maxDepth(TreeNode root) {
        // if(root==null) return 0;
        // else{
        //     int left = maxDepth(root.left);
        //     int right = maxDepth(root.right);
        //     return Math.max(left,right) + 1;
        // }
        if(root==null) return 0;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        int depth = 0;
        while(!queue.isEmpty()){
            int level = queue.size();
            depth++;
            for(int i = 0;i<level;i++){
                TreeNode curr = queue.poll();
                if(curr.left!=null){
                    queue.add(curr.left);
                }
                if(curr.right!=null){
                    queue.add(curr.right);
                }
            }
        }
        return depth;
    }
```
#### 559. N叉树的最大深度
```markdown
public int maxDepth(Node root) {
        if(root==null) return 0;
        if(root.children==null) return 1;
        int max = 0;
        for(Node node:root.children){
            max = Math.max(max,maxDepth(node));
        }
        return max + 1;
    }
```
#### 111. 二叉树的最小深度
```markdown
public int minDepth(TreeNode root) {
        // if(root==null) return 0;
        // int left = minDepth(root.left);
        // int right = minDepth(root.right);
        // return (left==0||right==0)?left+right+1:Math.min(left,right)+1;
        //BFS
        if(root==null) return 0;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int minDepth = 0;
        while(!queue.isEmpty()){
            int size = queue.size();
            minDepth++;
            for(int i = 0;i<size;i++){
                TreeNode temp = queue.poll();
                if(temp.left==null&&temp.right==null){
                    return minDepth;
                }
                if(temp.left!=null) queue.add(temp.left);
                if(temp.right!=null) queue.add(temp.right);
            }
        }
        return -1;
    }
```
#### 662.二叉树最大宽度
```markdown
private int maxWard = 0;
    public int widthOfBinaryTree(TreeNode root) {
        dfs(root,1,1,new ArrayList<>());
        return maxWard;
    }
    public void dfs(TreeNode root,int level,int index,List<Integer> list){
        if(root==null) return;
        if(level>list.size()) list.add(index);
        maxWard = Math.max(maxWard,index-list.get(level-1)+1);
        dfs(root.left,level+1,index*2,list);
        dfs(root.right,level+1,index*2+1,list);
    }
```
#### 543. 二叉树的直径/二叉树最长路径
```markdown
//一棵二叉树的直径长度是任意两个结点路径长度中的最大值。二叉树的每个节点的左右子树的高度和的最大值。
int max = 0;
    public int diameterOfBinaryTree(TreeNode root) {
        if(root!=null){
            getDepth(root);
            return max;
        }
        return 0;
    }
    public int getDepth(TreeNode root){
        if(root!=null){
            int right = getDepth(root.right);
            int left = getDepth(root.left);
            if(left+right>max){
                max = left + right;
            }
            return Math.max(right,left)+1;
        }
        return 0;
    }
```
#### 1372. 二叉树中的最长交错路径
```markdown
int max = 0;
    public int longestZigZag(TreeNode root) {
        dfs(root,true);
        return max;
    }
    public int dfs(TreeNode root,boolean isLeft){
        if(root==null) return 0;
        int r = dfs(root.right,false);
        int l = dfs(root.left,true);
        int big = l>r?l:r;
        if(big>max) max = big;
        if(isLeft){
            return r+1;
        }else{
            return l+1;
        }
    }
```
### 树判断
#### 100. 是否是相同的树
```markdown
public boolean isSameTree(TreeNode p, TreeNode q) {
        if(p==null&&q==null) return true;
        else if(p==null||q==null) return false;
        if(p.val!=q.val){
            return false;
        }
        boolean left = isSameTree(p.left,q.left);
        boolean right = isSameTree(p.right,q.right);
        return left && right;
    }
```
#### 101. 是否是对称二叉树
```markdown
public boolean isSymmetric(TreeNode root) {
        if(root==null) return true;
        return cmp(root.left,root.right);
    }
    //
    private boolean cmp(TreeNode node1,TreeNode node2){
        if(node1==null&&node2==null){
            return true;
        }
        if(node1==null||node2==null){
            return false;
        }
        if(node1.val!=node2.val){
            return false;
        }
        return cmp(node1.left,node2.right)&&cmp(node1.right,node2.left);
    }
```
#### 110.是否是平衡二叉树
```markdown
public boolean isBalanced(TreeNode root) {
        return maxDepth(root) != -1;
    }
    private int maxDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int left = maxDepth(root.left);
        int right = maxDepth(root.right);
        if (left == -1 || right == -1 || Math.abs(left - right) > 1) {
            return -1;
        }
        return Math.max(left, right) + 1;
    }
```
### 树
#### 236. 二叉树的最近公共祖先
```markdown
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root==null){
            return root;
        }
        if(root==p||root==q){
            return root;
        }
        TreeNode left = lowestCommonAncestor(root.left,p,q);
        TreeNode right = lowestCommonAncestor(root.right,p,q);
        if(left!=null&&right!=null){
            return root;
        }else if(left!=null){
            return left;
        }else if(right!=null){
            return right;
        }
        return null;
    }
```
#### 114. 将二叉树展开为链表
```markdown
public void flatten(TreeNode root) {
        Stack<TreeNode> stack = new Stack<>();
        while(root!=null||!stack.isEmpty()){
            while(root!=null){
                stack.push(root);
                root = root.left;
            }
            if(!stack.isEmpty()){
                TreeNode node = stack.pop();
                TreeNode temp = node.right;
                node.right = node.left;
                node.left = null;

                while(node.right!=null) node = node.right;
                node.right = temp;
                root = temp;
            }
        }
    }
```
#### 116,117.填充每个节点的下一个右侧节点指针
```markdown
public Node connect(Node root) {
        if(root==null){
            return null;
        }
        if(root.left!=null){
            root.left.next = root.right;
        }
        if(root.right!=null&&root.next!=null){
            root.right.next = root.next.left;
        }
        connect(root.left);
        connect(root.right);
        return root;
    }
public Node connect(Node root) {
        if (root == null) return null;
        if (root.right != null) {
            if (root.left != null) 
                root.left.next = root.right;
            root.right.next = getNext(root.next);
        } else if (root.left != null) {
            root.left.next = getNext(root.next);
        }
        connect(root.right);
        connect(root.left);
        return root;
    }
    public Node getNext(Node root){
        if (root == null) return null;
        if (root.left != null) return root.left;
        if (root.right != null) return root.right;
        return getNext(root.next);
    }
```
#### 199. 二叉树的右视图
```markdown
List<Integer> ans = new ArrayList<>();
    public List<Integer> rightSideView(TreeNode root) {
        //BFS 广度优先遍历 取每一层的最后一个元素
        // List<Integer> res = new ArrayList<>();
        // if(root==null) return res;
        // Queue<TreeNode> queue = new LinkedList<>();
        // queue.offer(root);
        // while(!queue.isEmpty()){
        //     int size = queue.size();
        //     for(int i = 0;i<size;i++){
        //         TreeNode temp = queue.poll();
        //         if(temp.left!=null){
        //             queue.offer(temp.left);
        //         }
        //         if(temp.right!=null){
        //             queue.offer(temp.right);
        //         }
        //         if(i==size-1){
        //             res.add(temp.val);
        //         }
        //     }
        // }
        // return res;
       
        dfs(root,0);
        return ans;
    }
    public void dfs(TreeNode root,int depth){
        if(root==null){
            return;
        }
        if(depth==ans.size()){
            ans.add(root.val);
        }
        depth++;
        dfs(root.right,depth);
        dfs(root.left,depth);
    }
```
### 二叉搜索树 95,98,99,230,450,501,701
### 满二叉树 894
### 完全二叉树 222,919,958
### 线段树 715,732,850
### 字典树 208,212,648
### 树段数组 307,315
### 树的拓展 114,117,297,834,998,508,652,865，1110
[Leetcode树](https://cyc2018.github.io/CS-Notes/#/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E6%A0%91)

### 完成
```markdown
104,110,543,226,617,112,101,111,687
```
### 未完成
```markdown
437,572,404,337,671,637,513,669,230,235,108,109,653,530,208,677,
```

### [一篇文章搞定面试中的二叉树题目(java实现)](https://www.jianshu.com/p/0190985635eb)
```java
public class Main{
    class TreeNode{
        int val;
        //左孩子
        TreeNode left;
        //右孩子
        TreeNode right;
    }
    //1.求二叉树的最大深度
    int maxDeath(TreeNode node){
        if(node==null){
            return 0;
        }
        int left = maxDeath(node.left);
        int right = maxDeath(node.right);
        return Math.max(left,right) + 1;
    }
    //2.求二叉树的最小深度
        int getMinDepth(TreeNode root){
            if(root == null){
                return 0;
            }
            return getMin(root);
        }
        int getMin(TreeNode root){
            if(root == null){
                return Integer.MAX_VALUE;
            }
            if(root.left == null&&root.right == null){
                return 1;
            }
            return Math.min(getMin(root.left),getMin(root.right)) + 1;
        }
    //3.求二叉树中节点的个数
        int numOfTreeNode(TreeNode root){
            if(root == null){
                return 0;
                
            }
            int left = numOfTreeNode(root.left);
            int right = numOfTreeNode(root.right);
            return left + right + 1;
        }
    //4.求二叉树中叶子节点的个数
        int numsOfNoChildNode(TreeNode root){
            if(root == null){
                return 0;
            }
            if(root.left==null&&root.right==null){
                return 1;
            }
            return numsOfNodeTreeNode(root.left)+numsOfNodeTreeNode(root.right);
            
        }
    //5.求二叉树中第k层节点的个数
    int numsOfkLevelTreeNode(TreeNode root,int k){
                if(root == null||k<1){
                    return 0;
                }
                if(k==1){
                    return 1;
                }
                int numsLeft = numsOfkLevelTreeNode(root.left,k-1);
                int numsRight = numsOfkLevelTreeNode(root.right,k-1);
                return numsLeft + numsRight;
            }
    //6.判断二叉树是否是平衡二叉树
        boolean isBalanced(TreeNode node){
            return maxDeath2(node)!=-1;
        }
        int maxDeath2(TreeNode node){
            if(node == null){
                return 0;
            }
            int left = maxDeath2(node.left);
            int right = maxDeath2(node.right);
            if(left==-1||right==-1||Math.abs(left-right)>1){
                return -1;
            }
            return Math.max(left, right) + 1;
        }
    //7.判断二叉树是否是完全二叉树
        boolean isCompleteTreeNode(TreeNode root){
            if(root == null){
                return false;
            }
            Queue<TreeNode> queue = new LinkedList<TreeNode>();
            queue.add(root);
            boolean result = true;
            boolean hasNoChild = false;
            while(!queue.isEmpty()){
                TreeNode current = queue.remove();
                if(hasNoChild){
                    if(current.left!=null||current.right!=null){
                        result = false;
                        break;
                    }
                }else{
                    if(current.left!=null&&current.right!=null){
                        queue.add(current.left);
                        queue.add(current.right);
                    }else if(current.left!=null&&current.right==null){
                        queue.add(current.left);
                        hasNoChild = true;
                        
                    }else if(current.left==null&&current.right!=null){
                        result = false;
                        break;
                    }else{
                        hasNoChild = true;
                    }
                }
                
            }
            return result;
        }
    //8.两个二叉树是否完全相同
        boolean isSameTreeNode(TreeNode t1,TreeNode t2){
            if(t1==null&&t2==null){
                return true;
            }
            else if(t1==null||t2==null){
                return false;
            }
            if(t1.val != t2.val){
                return false;
            }
            boolean left = isSameTreeNode(t1.left,t2.left);
            boolean right = isSameTreeNode(t1.right,t2.right);
            return left&&right;
            
        }
    //9.两个二叉树是否互为镜像
        boolean isMirror(TreeNode t1,TreeNode t2){
            if(t1==null&&t2==null){
                return true;
            }
            if(t1==null||t2==null){
                return false;
            }
            if(t1.val != t2.val){
                return false;
            }
            return isMirror(t1.left,t2.right)&&isMirror(t1.right,t2.left);
            
        }
    //10.翻转二叉树or镜像二叉树
        TreeNode mirrorTreeNode(TreeNode root){
            if(root == null){
                return null;
            }
            TreeNode left = mirrorTreeNode(root.left);
            TreeNode right = mirrorTreeNode(root.right);
            root.left = right;
            root.right = left;
            return root;
        }
    //11.求两个二叉树的最低公共祖先节点
        TreeNode getLastCommonParent(TreeNode root,TreeNode t1,TreeNode t2){
            if(findNode(root.left,t1)){
                if(findNode(root.right,t2)){
                    return root;
                }else{
                    return getLastCommonParent(root.left,t1,t2);
                }
            }else{
                if(findNode(root.left,t2)){
                    return root;
                }else{
                    return getLastCommonParent(root.right,t1,t2);
                }
            }
        }
        // 查找节点node是否在当前 二叉树中
        boolean findNode(TreeNode root,TreeNode node){
            if(root == null || node == null){
                return false;
            }
            if(root == node){
                return true;
            }
            boolean found = findNode(root.left,node);
            if(!found){
                found = findNode(root.right,node);
            }
            return found;
        }
    //12.二叉树的前序遍历
        ArrayList<Integer> preOrder(TreeNode root){
            Stack<TreeNode> stack = new Stack<TreeNode>();
            ArrayList<Integer> list = new ArrayList<Integer>();
            if(root == null){
                return list;
            }
            stack.push(root);
            while(!stack.empty()){
                TreeNode node = stack.pop();
                list.add(node.val);
                if(node.right!=null){
                    stack.push(node.right);
                }
                if(node.left != null){
                    stack.push(node.left);
                }
                
            }
            return list;
        }
    //递归解法
        ArrayList<Integer> preOrderReverse(TreeNode root){
            ArrayList<Integer> result = new ArrayList<Integer>();
            preOrder2(root,result);
            return result;
            
        }
        void preOrder2(TreeNode root,ArrayList<Integer> result){
            if(root == null){
                return;
            }
            result.add(root.val);
            preOrder2(root.left,result);
            preOrder2(root.right,result);
        }
    //13.二叉树的中序遍历
        ArrayList<Integer> inOrder(TreeNode root){
            ArrayList<Integer> list = new ArrayList<Integer>();
            Stack<TreeNode> stack = new Stack<TreeNode>();
            TreeNode current = root;
            while(current != null|| !stack.empty()){
                while(current != null){
                    stack.add(current);
                    current = current.left;
                }
                current = stack.peek();
                stack.pop();
                list.add(current.val);
                current = current.right;
                
            }
            return list;
            
        }
    //14.二叉树的后序遍历
        ArrayList<Integer> postOrder(TreeNode root){
            ArrayList<Integer> list = new ArrayList<Integer>();
            if(root == null){
                return list;
            }
            list.addAll(postOrder(root.left));
            list.addAll(postOrder(root.right));
            list.add(root.val);
            return list;
        }
    //15.前序遍历和后序遍历构造二叉树
        TreeNode buildTreeNode(int[] preorder,int[] inorder){
            if(preorder.length!=inorder.length){
                return null;
            }
            return myBuildTree(inorder,0,inorder.length-1,preorder,0,preorder.length-1);
        }
        TreeNode myBuildTree(int[] inorder,int instart,int inend,int[] preorder,int prestart,int preend){
            if(instart>inend){
                return null;
            }
            TreeNode root = new TreeNode(preorder[prestart]);
            int position = findPosition(inorder,instart,inend,preorder[start]);
            root.left = myBuildTree(inorder,instart,position-1,preorder,prestart+1,prestart+position-instart);
            root.right = myBuildTree(inorder,position+1,inend,preorder,position-inend+preend+1,preend);
            return root;
        }
        int findPosition(int[] arr,int start,int end,int key){
            int i;
            for(i = start;i<=end;i++){
                if(arr[i] == key){
                    return i;
                }
            }
            return -1;
        }
    //16.在二叉树中插入节点
        TreeNode insertNode(TreeNode root,TreeNode node){
            if(root == node){
                return node;
            }
            TreeNode tmp = new TreeNode();
            tmp = root;
            TreeNode last = null;
            while(tmp!=null){
                last = tmp;
                if(tmp.val>node.val){
                    tmp = tmp.left;
                }else{
                    tmp = tmp.right;
                }
            }
            if(last!=null){
                if(last.val>node.val){
                    last.left = node;
                }else{
                    last.right = node;
                }
            }
            return root;
        }
    //17.输入一个二叉树和一个整数，打印出二叉树中节点值的和等于输入整数所有的路径
        void findPath(TreeNode r,int i){
            if(root == null){
                return;
            }
            Stack<Integer> stack = new Stack<Integer>();
            int currentSum = 0;
            findPath(r, i, stack, currentSum);
            
        }
        void findPath(TreeNode r,int i,Stack<Integer> stack,int currentSum){
            currentSum+=r.val;
            stack.push(r.val);
            if(r.left==null&&r.right==null){
                if(currentSum==i){
                    for(int path:stack){
                        System.out.println(path);
                    }
                    
                }
            }
            if(r.left!=null){
                findPath(r.left, i, stack, currentSum);
            }
            if(r.right!=null){
                findPath(r.right, i, stack, currentSum);
            }
            stack.pop();
        }
    //18.二叉树的搜索区间
        ArrayList<Integer> result;
        ArrayList<Integer> searchRange(TreeNode root,int k1,int k2){
            result = new ArrayList<Integer>();
            searchHelper(root,k1,k2);
            return result;
        }
        void searchHelper(TreeNode root,int k1,int k2){
            if(root == null){
                return;
            }
            if(root.val>k1){
                searchHelper(root.left,k1,k2);
            }
            if(root.val>=k1&&root.val<=k2){
                result.add(root.val);
            }
            if(root.val<k2){
                searchHelper(root.right,k1,k2);
            }
        }
    // 19.二叉树的层次遍历     
        ArrayList<ArrayList<Integer>> levelOrder(TreeNode root){
            ArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>();
            if(root == null){
                return result;
            }
            Queue<TreeNode> queue = new LinkedList<TreeNode>();
            queue.offer(root);
            while(!queue.isEmpty()){
                int size = queue.size();
                ArrayList<<Integer> level = new ArrayList<Integer>();
                for(int i = 0;i < size ;i++){
                    TreeNode node = queue.poll();
                    level.add(node.val);
                    if(node.left != null){
                        queue.offer(node.left);
                    }
                    if(node.right != null){
                        queue.offer(node.right);
                    }
                } 
                result.add(Level);
            }
            return result;
        }
}
```
## 
