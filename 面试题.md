# 面试题总结
>> 1.Java中==与equals区别比较
```markdown
[听说你还搞不定java中的==和equals？](https://www.cnblogs.com/yichunguo/p/12383853.html)
==的作用是判断两个对象的地址是否相等，即判断两个对象是不是同一个对象。
基础对象类型==比较的是值，引用数据类型==比较的是内存地址。
equals():的作用也是判断两个对象是否相等，但是一般有两种情况：
情况1：类没有覆盖equals()方法。则通过equals()等价于==。
情况2：类覆盖了equals()方法，用来比较对象的内容是否相等。
```
>> 2.进程和线程的区别与联系
```markdown
进程是⼀个独⽴的运⾏环境，⽽线程是在进程中执⾏的⼀个任务。两个本质的区别是是否单独占有内存地址空间及其它系统资源（⽐如I/O）
进程是操作系统进⾏资源分配的基本单位，⽽线程是操作系统进⾏调度的基本单位，即CPU分配时间的单位 。一个进程在其执行过程中可以产生多个线程，
```
>> 3.equals()和hashCode()
```markdown
[HashCode()与equals()深入理解](https://www.cnblogs.com/moershiwei/p/12643626.html)
[听说你还搞不定java中的==和equals？](https://www.cnblogs.com/yichunguo/p/12383853.html)
1、如果两个对象equals为true ，他们的hashcode一定相等。
2、如果两个对象equals为false，他们的hashcode有可能相等。
3、如果两个对象hashcode相等，equals不一定为true。
4、如果两个对象hashcode不相等，equals一定为false。
```
>> 4.synchronized的不足之处
```markdown
1.如果临界区是只读操作，其实可以多线程一起执行，但是使用synchronized的话，同一时间只能有一个线程执行。
2.synchronized无法知道线程有没有成功获取到锁。
3.使用synchronized，如果临界区因为IO或者sleep方法等原因阻塞了，而当前线程没有释放锁，就会导致所有线程等待
```
>>5.synchronized和volatile的区别
```markdown
volatile只能用于变量，而synchronized可以修饰方法和代码块。volatile性能比synchronized要好。
多线程访问volatile不会发生阻塞，而synchronized可能发生阻塞。
volatile能够保证数据的可见性，但是不能保证数据的原子性，synchronized两者都能保证。
volatile主要是解决变量在多个线程之间的可见性，synchronized解决多个线程之间访问资源的同步性。
```
>>6.sleep()和wait()的区别联系
```markdown
wait可以指定时间，也可以不指定；而sleep必须指定时间。
wait释放cpu资源，同时释放锁；sleep释放cpu资源，但是不释放锁，所以易死锁。
wait必须放在同步块或同步⽅法中，⽽sleep可以再任意位置
sleep()通常被用于暂停执行，而wait()通常被用于线程间交互和通信
```
>> 7.JMM与Java内存区域划分的区别与联系
```markdown
区别
两者是不同的概念层次。JMM是抽象的，他是用来描述⼀组规则，通过这个规则来控制各个变量的访问方式，围绕原子性、有序性、可见性等
展开的。而Java运行时内存的划分是具体的，是JVM运行Java程序时，必要的内存划分。
联系
都存在私有数据区域和共享数据区域。⼀般来说，JMM中的主内存属于共享数据区域，他是包含了堆和方法区；
同样，JMM中的本地内存属于私有数据区域，包含了程序计数器、本地方法栈、虚拟机栈。
```
>> 8.NoClassDefFoundError 和 ClassNotFoundException 区别
[聊聊面试-NoClassDefFoundError 和 ClassNotFoundException 区别](https://www.cnblogs.com/xiao2shiqi/p/11740563.html)
```markdown
NoClassDefFoundError 是一种 Error，Error 在大多数情况下代表无法从程序中恢复的致命错误，产生的原因在于 JVM 或者 ClassLoader
在运行时类加载器在 classpath 下找不到需要的类定义（编译期是可以正常找到的，所以和 ClassNotFoundException 不同的是这是
一个运行期的 Error），这个时候虚拟机就会抛出 NoClassDefFoundError，通常造成该 ERROR 的原因是打包过程中漏掉了部分类，
或者 jar 包出现损坏或篡改，对应的 Class 在 classpath 中不可用等等原因。
ClassNotFoundException 是属于 Exception 的运行时异常，大多是可以从代码中恢复的异常类型，导致该异常的原因大多是因为使用 
Class.forName() 方法动态的加载类信息，但是这个类在类路径中并没有被找到，那么就会在运行时抛出 ClassNotFoundException
以上是大致的 NoClassDefFoundError 和 ClassNotFoundException 的区别，
那么延伸一下可以探讨 Java 类型体系中的 Error 和 Exception
```
>> 9.Error 和 Exception 的区别
```markdown
Error和Exception都是继承 Throwable 类，它们体现 Java 设计者在对异常的不同情况所进行的分类处理，在Java中只有 Throwable类的
实例才能被 try/catch 捕获或者声明抛出。Error 在大多数情况下代表程序出现了致命并且不可恢复的错误，它们大多都是不可预测的错误，
不需要也不能捕获和抛出，例如常见的 OutOfMemeryError，StackOverFlowError，还有本文提到的 NoClassDefFoundError，
他们都是 Error 的子类。Exception 属于程序错误，大多是人为编码所导致的，它们大多都可以预测，也可以通过程序处理让程序正常流程，
所以是需要进行捕获（try/catch）或者声明抛出（throw）的，Exception 还分两种情况，可检查异常 checked exception（编译期异常），
非检查异常 unchecked exception（运行期异常）
```
>> 一文摸透从输入URL到页面渲染的过程
[一文摸透从输入URL到页面渲染的过程](https://www.cnblogs.com/AhuntSun-blog/p/12641050.html)

