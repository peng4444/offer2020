# 面试题总结

[TOC]


## 一、Java基础
### 1.Java中==与equals区别比较
```markdown
[听说你还搞不定java中的==和equals？](https://www.cnblogs.com/yichunguo/p/12383853.html)
==的作用是判断两个对象的值是否相等，即判断两个对象是不是同一个对象。
基础对象类型==比较的是值，引用数据类型==比较的是内存地址。
equals():的作用也是判断两个对象是否相等，但是一般有两种情况：
    情况1：类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于==。
    情况2：类覆盖了equals()方法，用来比较对象的内容是否相等。
```
```java
public class test1 {
    public static void main(String[] args) {
        String a = new String("ab"); // a 为⼀个引⽤
        String b = new String("ab"); // b为另⼀个引⽤,对象的内容⼀样
        String aa = "ab"; // 放在常量池中
        String bb = "ab"; // 从常量池中查找
        if (aa == bb) // true
        System.out.println("aa==bb");
        if (a == b) // false，⾮同⼀对象
        System.out.println("a==b");
        if (a.equals(b)) // true
        System.out.println("aEQb");
        if (42 == 42.0) { // true
            System.out.println("true");
        }
    }
}
```
#### 1.1 所有整型包装类对象之间值的比较，全部使用equals方法比较。【阿里巴巴Java开发手册】
```markdown
在-128至127之间的赋值,Integer对象是在IntegerCache.cache产生，会复用已有对象，这个区间内的Integer值可以直接使用==进行判断，
但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用 equals 方法进行判断。
```
#### 1.2 浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用equals来判断。
### 2.equals()和hashCode()
```markdown
[HashCode()与equals()深入理解](https://www.cnblogs.com/moershiwei/p/12643626.html)
[听说你还搞不定java中的==和equals？](https://www.cnblogs.com/yichunguo/p/12383853.html)
1、如果两个对象equals为true ，他们的hashcode一定相等。
2、如果两个对象equals为false，他们的hashcode有可能相等。
3、如果两个对象hashcode相等，equals不一定为true。
4、如果两个对象hashcode不相等，equals一定为false。
```
### 8.NoClassDefFoundError 和 ClassNotFoundException 区别
[聊聊面试-NoClassDefFoundError 和 ClassNotFoundException 区别](https://www.cnblogs.com/xiao2shiqi/p/11740563.html)
```markdown
NoClassDefFoundError 是一种 Error，Error 在大多数情况下代表无法从程序中恢复的致命错误，产生的原因在于 JVM 或者 ClassLoader
在运行时类加载器在 classpath 下找不到需要的类定义（编译期是可以正常找到的，所以和 ClassNotFoundException 不同的是这是
一个运行期的 Error），这个时候虚拟机就会抛出 NoClassDefFoundError，通常造成该 ERROR 的原因是打包过程中漏掉了部分类，
或者 jar 包出现损坏或篡改，对应的 Class 在 classpath 中不可用等等原因。
ClassNotFoundException 是属于 Exception 的运行时异常，大多是可以从代码中恢复的异常类型，导致该异常的原因大多是因为使用 
Class.forName() 方法动态的加载类信息，但是这个类在类路径中并没有被找到，那么就会在运行时抛出 ClassNotFoundException
以上是大致的 NoClassDefFoundError 和 ClassNotFoundException 的区别，
那么延伸一下可以探讨 Java 类型体系中的 Error 和 Exception
```
### 9.Error 和 Exception 的区别
```markdown
Error和Exception都是继承 Throwable 类，它们体现 Java 设计者在对异常的不同情况所进行的分类处理，在Java中只有 Throwable类的
实例才能被 try/catch 捕获或者声明抛出。Error 在大多数情况下代表程序出现了致命并且不可恢复的错误，它们大多都是不可预测的错误，
不需要也不能捕获和抛出，例如常见的 OutOfMemeryError，StackOverFlowError，还有本文提到的 NoClassDefFoundError，
他们都是 Error 的子类。Exception 属于程序错误，大多是人为编码所导致的，它们大多都可以预测，也可以通过程序处理让程序正常流程，
所以是需要进行捕获（try/catch）或者声明抛出（throw）的，Exception 还分两种情况，可检查异常 checked exception（编译期异常），
非检查异常 unchecked exception（运行期异常）
```

## 多线程并发
### 1.进程和线程的区别与联系
```markdown
进程是⼀个独立的运行环境，而线程是在进程中执行的⼀个任务。一个进程在其执行过程中可以产生多个线程。
两个本质的区别是是否单独占有内存地址空间及其它系统资源（比如I/O）
进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位，即CPU分配时间的单位。
```
### 2.[多线程的四种实现方式](https://www.cnblogs.com/xpybsh/p/12818796.html)
#### 2.1 继承Thread类重写run()方法：
```markdown
  1. 创建一个继承于Thread类的子类
  2. 重写Thread类的run() --> 将此线程执行的操作声明在run()中
  3. 创建Thread类的子类的对象
  4. 通过此对象调用start()
```
#### 2.2 实现Runnable接口：
```markdown
  1. 创建一个实现Runnable接口的类
  2. 实现Runnable中的run()方法
  3. 创建实现类的对象
  4. 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象
  5. 通过Thread类的对象调用start()
```
#### 2.3 实现Callable接口
```markdown
 1.创建Callable的实现类
 2.实现call方法，将此线程需要执行的操作声明在call()中
 3.创建Callable接口实现类的对象
 4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象
 5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()
 6.获取Callable中call方法的返回值
```
#### 2.4线程池
```markdown
 1. 提供指定线程数量的线程池
 2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象
 3.关闭连接池
```|

### 8.synchronized的不足之处
```markdown
1.如果临界区是只读操作，其实可以多线程一起执行，但是使用synchronized的话，同一时间只能有一个线程执行。
2.synchronized无法知道线程有没有成功获取到锁。
3.使用synchronized，如果临界区因为IO或者sleep方法等原因阻塞了，而当前线程没有释放锁，就会导致所有线程等待
```
### 9.volatile特性和[面试中的volatile关键字](https://www.cnblogs.com/ArvinYL/p/12827641.html)
```markdown
被volatile修饰的共享变量，就具有了以下两点特性：
    保证了不同线程对该变量操作的**内存可见性**
    禁止指令重排序
内存可见性:
    可见性是指一个线程修改了共享变量的值，其他线程能够立即得知这个修改。
    volatile变量保证新值能够立马同步到主内存，使用时也立即从主内存中刷新，保证了多线程操作时变量的可见性。
JMM的特性
    原子性，有序性，可见性。
    原子性即一个操作或一系列操作是不可中断的。即使是在多线程的情况下，操作一旦开始，就不会被其他线程干扰。
    有序性是指对于单线程的执行代码，执行是按顺序依次进行的。
    但在多线程环境中，则可能出现乱序现象，因为在编译过程中会出现“指令重排”，重排后的指令与原指令的顺序未必一致。
指令重排：
    CPU和编译器为了提高程序执行的效率，会按照一定的规则允许进行指令优化。
    但代码逻辑之间是存在一定的先后顺序，并发执行时按照不同的执行逻辑会得到不同的结果。    
volatile不能保证原子性，它只是对单个volatile变量的读/写具有原子性，但是对于类似i++的复合操作就无法保证。
volatile实现单例模式的双重检查锁
```
### 10.synchronized和volatile的区别
```markdown
volatile本质是在告诉JVM当前变量寄存器(工作内存)中的值是不确定的，需要从主存中读取；
synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
volatile只能用于变量，而synchronized可以修饰方法和代码块。volatile性能比synchronized要好。
多线程访问volatile不会发生阻塞，而synchronized可能发生阻塞。
volatile能够保证数据的可见性，但是不能保证数据的原子性，synchronized两者都能保证。
volatile主要是解决变量在多个线程之间的可见性，synchronized解决多个线程之间访问资源的同步性。
volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化
```
### 4.sleep()和wait()的区别联系
```markdown
wait()是Object的方法，而sleep()是Thread的静态方法；
wait可以指定时间，也可以不指定；而sleep必须指定时间。
wait释放cpu资源，同时释放锁；sleep释放cpu资源，但是不释放锁，所以易死锁。
wait必须放在同步块或同步方法中，而sleep可以再任意位置
sleep()通常被用于暂停执行，而wait()通常被用于线程间交互和通信
```

## JVM
### 1.JMM与Java内存区域划分的区别与联系
```markdown
区别:两者是不同的概念层次。
    JMM是抽象的，他是用来描述⼀组规则，通过这个规则来控制各个变量的访问方式，围绕原子性、有序性、可见性等展开的。
    而Java运行时内存的划分是具体的，是JVM运行Java程序时，必要的内存划分。
联系
    都存在私有数据区域和共享数据区域。⼀般来说，JMM中的主内存属于共享数据区域，他是包含了堆和方法区；
    同样，JMM中的本地内存属于私有数据区域，包含了程序计数器、本地方法栈、虚拟机栈。
```
### 2.JVM内存模型
>>[一份热乎乎的腾讯后端面试真题](https://www.cnblogs.com/jay-huaxiao/p/12776714.html)
### 3.cms和g1有没有了解过，它们有什么区别
>>[一份热乎乎的腾讯后端面试真题](https://www.cnblogs.com/jay-huaxiao/p/12776714.html)
```markdown
CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收集器一起使用；
G1收集器收集范围是老年代和新生代，不需要结合其他收集器使用；
CMS收集器以最小的停顿时间为目标的收集器；
G1收集器可预测垃圾回收的停顿时间
CMS收集器是使用“标记-清除”算法进行的垃圾回收，容易产生内存碎片
G1收集器使用的是“标记-整理”算法，进行了空间整合，降低了内存空间碎片。
```
###4.谈谈你对垃圾回收的了解，什么时候发生垃圾回收，回收过程
>>[一份热乎乎的腾讯后端面试真题](https://www.cnblogs.com/jay-huaxiao/p/12776714.html)
```markdown
可以讲JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代，
如Minor GC，Major GC，full GC这几个讲清楚，还有对象存活判断方法，还有垃圾回收算法，复制算法等等
```
### [2.关于强引用、软引用、弱引用、幻象引用，你该如何回答？](https://www.cnblogs.com/cxuanBlog/p/12774370.html)|
```markdown
1. 强引用:被强引用关联的对象不会被回收。使用new一个新对象的方式来创建强引用。
        Object obj = new Object();
2. 软引用:被软引用关联的对象只有在内存不够的情况下才会被回收。使用SoftReference类来创建软引用。
        Object obj = new Object();
        SoftReference<Object> sf = new SoftReference<Object>(obj);
        obj = null; // 使对象只被软引用关联
3. 弱引用:被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。使用WeakReference类来创建弱引用。
        Object obj = new Object();
        WeakReference<Object> wf = new WeakReference<Object>(obj);
        obj = null;
4. 虚引用:又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。
       为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。使用PhantomReference来创建虚引用。
       Object obj = new Object();
       PhantomReference<Object> pf = new PhantomReference<Object>(obj, null);
       obj = null;
```
### 
## Java容器集合
### 1.ArrayList不是线程安全的
[浅析CopyOnWriteArrayList](https://www.cnblogs.com/zengcongcong/p/12754067.html)
```markdown
由于fail-fast机制的存在，抛出了modcount修改异常的错误(modcount是ArrayList源码中的一个变量，
用来表示修改的次数，因为ArrayList不是为并发情况而设计的集合类）
解决办法：1.可以使用Vector集合，Vector集合是线程安全版的ArrayList，其方法都上了一层synchronized进行修饰，
采取jvm内置锁来保证其并发情况下的原子性、可见性、有序性。但同时也带来了性能问题，因为synchronized一旦膨胀到重量级锁，
存在用户态到和心态的一个转变，多线程的上下文切换会带来开销。另一个问题是Vector集合的扩容没有ArrayList的策略好
2.使用Collections.synchronizedList
3.采用JUC提供的并发容器，CopyOnWriteArrayList
和ArrayList一样，其底层数据结构也是数组，加上transient不让其被序列化，加上volatile修饰来保证多线程下的其可见性和有序性
CopyOnWriteArrayList适合于多线程场景下使用，其采用读写分离的思想，读操作不上锁，写操作上锁，且写操作效率较低
CopyOnWriteArrayList基于fail-safe机制，每次修改都会在原先基础上复制一份，修改完毕后在进行替换
CopyOnWriteArrayList采用的是ReentrantLock进行上锁。
```

## 
>> 一文摸透从输入URL到页面渲染的过程
[一文摸透从输入URL到页面渲染的过程](https://www.cnblogs.com/AhuntSun-blog/p/12641050.html)



[Java面试后端经验分享（不是面经的面经）:题目整合](https://www.nowcoder.com/discuss/421353?type=5)

[阿里java面经（供后人查看）](https://www.nowcoder.com/discuss/420953?type=2)
[https://www.nowcoder.com/discuss/420929?type=2]
