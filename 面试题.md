# 面试题总结

[TOC]


## 一、Java基础
### 1.Java中==与equals区别比较
```markdown
[听说你还搞不定java中的==和equals？](https://www.cnblogs.com/yichunguo/p/12383853.html)
==的作用是判断两个对象的值是否相等，即判断两个对象是不是同一个对象。
基础对象类型==比较的是值，引用数据类型==比较的是内存地址。
equals():的作用也是判断两个对象是否相等，但是一般有两种情况：
    情况1：类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于==。
    情况2：类覆盖了equals()方法，用来比较对象的内容是否相等。
```
```java
public class test1 {
    public static void main(String[] args) {
        String a = new String("ab"); // a 为⼀个引⽤
        String b = new String("ab"); // b为另⼀个引⽤,对象的内容⼀样
        String aa = "ab"; // 放在常量池中
        String bb = "ab"; // 从常量池中查找
        if (aa == bb) // true
        System.out.println("aa==bb");
        if (a == b) // false，⾮同⼀对象
        System.out.println("a==b");
        if (a.equals(b)) // true
        System.out.println("aEQb");
        if (42 == 42.0) { // true
            System.out.println("true");
        }
    }
}
```
#### 1.1 所有整型包装类对象之间值的比较，全部使用equals方法比较。【阿里巴巴Java开发手册】
```markdown
在-128至127之间的赋值,Integer对象是在IntegerCache.cache产生，会复用已有对象，这个区间内的Integer值可以直接使用==进行判断，
但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用 equals 方法进行判断。
```
#### 1.2 浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用equals来判断。
### 2.equals()和hashCode()
```markdown
[HashCode()与equals()深入理解](https://www.cnblogs.com/moershiwei/p/12643626.html)
[听说你还搞不定java中的==和equals？](https://www.cnblogs.com/yichunguo/p/12383853.html)
1、如果两个对象equals为true ，他们的hashcode一定相等。
2、如果两个对象equals为false，他们的hashcode有可能相等。
3、如果两个对象hashcode相等，equals不一定为true。
4、如果两个对象hashcode不相等，equals一定为false。
```
### 3.拆箱和装箱分别是什么？分别应用在什么场景？
```markdown
拆箱和装箱：拆箱是把包装类型变成基本类型；装箱是把基本类型变成包装类型。
自动装箱都是通过包装类的valueOf()方法来实现的;自动拆箱都是通过包装类对象的xxxValue()来实现的（如booleanValue()、longValue()等）。
应用场景：当==两边是基本类型和包装类型的时候，包装类型会拆箱，然后==会比较基本类型的两个值；
当equals方法的参数是基本类型的时候，基本类型会装箱，然后equals方法会先比较两个包装类型的类型，在比较值。

```
#### 在使用三目运算符的过程中，可能会进行自动拆箱而导致NPE问题。【Java开发手册】
```markdown
 boolean flag = true;
 boolean simpleBoolean = false;
 Boolean nullBoolean = null;
 boolean x = flag ? nullBoolean.booleanValue() : simpleBoolean;
反编译后的代码的最后一行，编译器帮我们做了一次自动拆箱，而就是因为这次自动拆箱，导致代码出现对于一个null对象（nullBoolean.booleanValue()）的调用，导致了NPE。
三目运算符当第二位和第三位操作数的类型相同时，则三目运算符表达式的结果和这两位操作数的类型相同。
当第二，第三位操作数分别为基本类型和该基本类型对应的包装类型时，那么该表达式的结果的类型要求是基本类型。
所以，Java开发手册中提到要高度注意第二位和第三位表达式的类型对齐过程中由于自动拆箱发生的 NPE 问题，
其实还需要注意使用三目运算符表达式给变量赋值的时候由于自动拆箱导致的NPE问题。
Boolean b = Boolean.valueOf(maps == null ? false : ((Boolean)maps.get("Hollis")).booleanValue());
```
### 4.String str="abc" 与 String str=new String (“abc”) 一样吗？为什么？
```markdown
1.使用String直接赋值：String str= “abc”：可能创建一个或者不创建对象。如果”abc”在字符串池中不存在，会在java字符串池中创建一个String对象（”abc”），
然后str指向这个内存地址，无论以后用这种方式创建多少个值为”abc” 的字符串对象，始终只有一个内存地址被分配；如果 “abc” 在字符串池中存在，str直接指向这个内存地址。
2.使用new String创建字符串：String str = new String(“abc”)：至少会创建一个对象，也有可能创建两个。因为用到 new 关键字，肯定会在堆中创建一个 String 对象，如
果字符池中已经存在”abc”, 则不会在字符串池中创建一个 String 对象，如果不存在，则会在字符串常量池中也创建一个对象。注意，此时二者地址不相同。
3.String拼接字符串：字符串拼接又分为变量拼接和已知字符串拼接。只要拼接内容存在变量，那么该拼接后的新变量就是在堆内存中新建的一个对象实体。但是不会在字符常量池中创建新对象。
4.String.intern()：当调用intern方法时，如果常量池已经包含一个等于此String对象的字符串（用equals(Object)方法确定），则返回池中的字符串。否则，将此String对象添加到常量池中，并返回此String对象的引用。
String str=“abc” 和 String str=new String(“abc”); 产生几个对象？String str = new String("hello")+new String("123");产生了几个对象？
前者 1 或 0， 后者 2 或 1，最后一个是 3 或 4 或 5
先看字符串常量池，如果字符串常量池中没有，都在常量池中创建一个，如果有，前者直接引用，后者在堆内存中还需创建一个 “abc” 实例对象。
字符常量池的位置？字符常量池存储的内容？
字符串常量池的位置，jdk1.7 从方法区移至堆中。
字符串常量池存储的是字符串字面量（注意，这里的字面量指的就是String的对象，因为String本身是一个类，而字符常量池在jdk1.8的时候放在堆中，所以存储的内容全都是对象）
```
### 5.给定三个变量：i1、i2、i3。Integer i1= 120；Integer i2=120；int i3=120；i1和i2一样吗？i1和i3 呢？为什么？如果把120换成130呢，i1,12,i3的关系又如何，为什么？
```markdown
integer包装类和其他包装类不同之处，对于范围在-128到127之间的整数，integer创建对象的时候是直接从缓存读取的，这个时候直接从缓存得的的内容地址是保持一致的，
所以两个integer对象地址是相同的，但是不在这个范围的时候，地址就不在相同的。
对于integer变量和int变量，通过==比较，符合拆箱应用场景，integer会直接拆箱，所以无论什么范围，integer和int，都是直接比较值的。
```
### 6.throw 和 throws 的区别？
```markdown
throws 声明：
如果一个方法内部的代码会抛出检查异常（checked exception），而方法自己又没有完全处理掉，则javac保证你必须在方法的签名上使用throws关键字声明这些可能抛出的异常，否则编译不通过。
throws是另一种处理异常的方式，它不同于 try…catch…finally，throws 仅仅是将函数中可能出现的异常向调用者声明，而自己则不具体处理。
throw异常抛出语句：
程序员也可以通过throw语句手动显式的抛出一个异常。throw语句的后面必须是一个异常对象。
throw语句必须写在函数中，执行throw语句的地方就是一个异常抛出点，它和由 JRE自动形成的异常抛出点没有任何差别。
在异常处理中，try语句要捕获的是一个异常对象，那么此异常对象也可以自己抛出。
try-catch-finally 中哪个部分可以省略？finally 可以省略，其他都不可以省略
try-catch-finally中，如果catch中return了，finally 还会执行吗？
在try块中即便有 return，break，continue等改变执行流的语句，finally也会执行。try…catch…finally中的return只要能执行，就都执行了，他们共同向同一个内存地址
（假设地址是 0×80）写入返回值，后执行的将覆盖先执行的数据，而真正被调用者取的返回值就是最后一次写入的。finally中的return会覆盖try或者catch中的返回值。
finally中的return和方法的return不能共存，因为finally是异常处理的最后执行的部分，finally必定执行，内部的return跟方法最后的return存在冲突。
```
### 7.常见的异常类有哪些？java异常的执行流程？
```markdown
error 错误类：StackOverFlowError、OutOfMemoryError
exception 类：IOException（FileNotFindException）、RuntimeException（NullPointException）
在Java应用程序中，异常处理机制为：抛出异常，捕捉异常。
抛出异常：当一个方法出现错误引发异常时，方法创建异常对象并交付运行时系统，异常对象中包含了异常类型和异常出现时的程序状态等异常信息。
运行时系统负责寻找处置异常的代码并执行。
捕捉异常：在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器（exceptionhandler）。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。
当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适的异常处理器。运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常
处理器的方法并执行。当运行时系统遍历调用栈而未找到合适的异常处理器，则运行时系统终止。同时，意味着Java程序的终止。
```
### 8.NoClassDefFoundError 和 ClassNotFoundException 区别
[聊聊面试-NoClassDefFoundError 和 ClassNotFoundException 区别](https://www.cnblogs.com/xiao2shiqi/p/11740563.html)
```markdown
NoClassDefFoundError 是一种 Error，Error 在大多数情况下代表无法从程序中恢复的致命错误，产生的原因在于 JVM 或者 ClassLoader
在运行时类加载器在 classpath 下找不到需要的类定义（编译期是可以正常找到的，所以和 ClassNotFoundException 不同的是这是
一个运行期的 Error），这个时候虚拟机就会抛出 NoClassDefFoundError，通常造成该 ERROR 的原因是打包过程中漏掉了部分类，
或者 jar 包出现损坏或篡改，对应的 Class 在 classpath 中不可用等等原因。
ClassNotFoundException 是属于 Exception 的运行时异常，大多是可以从代码中恢复的异常类型，导致该异常的原因大多是因为使用 
Class.forName() 方法动态的加载类信息，但是这个类在类路径中并没有被找到，那么就会在运行时抛出 ClassNotFoundException
以上是大致的 NoClassDefFoundError 和 ClassNotFoundException 的区别，
那么延伸一下可以探讨 Java 类型体系中的 Error 和 Exception
```
### 9.Error 和 Exception 的区别
```markdown
Error和Exception都是继承 Throwable 类，它们体现 Java 设计者在对异常的不同情况所进行的分类处理，在Java中只有 Throwable类的
实例才能被 try/catch 捕获或者声明抛出。Error 在大多数情况下代表程序出现了致命并且不可恢复的错误，它们大多都是不可预测的错误，
不需要也不能捕获和抛出，例如常见的 OutOfMemeryError，StackOverFlowError，还有本文提到的 NoClassDefFoundError，
他们都是 Error 的子类。Exception 属于程序错误，大多是人为编码所导致的，它们大多都可以预测，也可以通过程序处理让程序正常流程，
所以是需要进行捕获（try/catch）或者声明抛出（throw）的，Exception 还分两种情况，可检查异常 checked exception（编译期异常），
非检查异常 unchecked exception（运行期异常）
```
### 10.设计模式
#### 1.熟悉的设计模式
>> 单例模式，工厂模式，代理模式
#### 2.单例模式
#### 3.代理模式有什么用？应用场景是什么？
```markdown
代理（Proxy）模式是结构型的设计模式之一，它可以为其他对象提供一种代理（Proxy）以控制对这个对象的访问。
所谓代理，是指具有与被代理的对象具有相同的接口的类，客户端必须通过代理与被代理的目标类交互。
应用场景：
 需要控制对目标对象的访问。
 需要对目标对象进行方法增强。如：添加日志记录，计算耗时等。
 需要延迟加载目标对象。
实现动态代理的两种方式：JDK动态代理和Gglib动态代理
 JDK动态代理是实现了被代理对象的接口，Cglib是继承了被代理对象。
 JDK和Cglib都是在运行期生成字节码，JDK是直接写Class字节码，Cglib使用ASM框架写Class字节码，Cglib代理实现更复杂，生成代理类比JDK效率低。
 JDK调用代理方法，是通过反射机制调用，Cglib是通过FastClass机制直接调用方法，Cglib执行效率更高。
动态代理是什么？与静态代理的区别在于？
Java中的静态代理要求代理主题 (ProxySubject)和真实主题(RealSubject)都实现同一个接口(Subject)。静态代理中代理类在编译期就已经确定，
而动态代理则是JVM运行时动态生成，静态代理的效率相对动态代理来说相对高一些，但是静态代理代码冗余大，一但需要修改接口，代理类和委托类都需要修改。
```
#### 4.简单工厂和抽象工厂有什么区别？
```markdown
工厂模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类
抽象工厂模式：为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类
```
#### 5.装饰者模式和适配器模式以及代理模式的区别？
```markdown
装饰者和代理模式的区别
 装饰者模式关注的是对象的动态添加功能。代理模式关注的是对对象的控制访问，对它的用户隐藏对象的具体信息。
装饰者模式和适配器模式
 装饰者模式和被装饰的类要实现同一个接口，或者装饰类是被装饰的类的子类。适配器模式和被适配的类具有不同的接口。
 适配器模式被用于桥接两个接口，而装饰模式的目的是在不修改类的情况下给类增加新的功能。
```
#### 6.JDK 库中使用的设计模式？
```markdown
装饰器设计模式（Decorator design pattern）被用于多个Java IO类中。
单例模式（Singleton pattern）用于Runtime，Calendar 和其他的一些类中。
工厂模式（Factory pattern）被用于各种不可变的类如Boolean，像Boolean.valueOf，
观察者模式（Observer pattern）被用于Swing和很多的事件监听中。
```
### 11.jdk1.8新增的变化
```markdown
新特性：
    接口增强，使用default与static在接口中定义方法
    lambda表达式
    方法引用
    内建函数式接口
方法函数变化：    
    Hashmap 红黑树，扩容
    concurrentHashmap 红黑树，进一步减少锁的粒度
    Jvm常量池的变化，字符常量池在jdk1.7从方法区脱离放入堆中，方法区则在jdk1.8中变成元空间。
```

## 二、多线程并发
### 1.进程和线程的区别与联系
```markdown
进程是⼀个独立的运行环境，而线程是在进程中执行的⼀个任务。一个进程在其执行过程中可以产生多个线程。
两个本质的区别是是否单独占有内存地址空间及其它系统资源（比如I/O）
进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位，即CPU分配时间的单位。
```
### 2.[多线程的四种实现方式](https://www.cnblogs.com/xpybsh/p/12818796.html)
#### 2.1 继承Thread类重写run()方法：
```markdown
  1. 创建一个继承于Thread类的子类
  2. 重写Thread类的run() --> 将此线程执行的操作声明在run()中
  3. 创建Thread类的子类的对象
  4. 通过此对象调用start()
```
#### 2.2 实现Runnable接口：
```markdown
  1. 创建一个实现Runnable接口的类
  2. 实现Runnable中的run()方法
  3. 创建实现类的对象
  4. 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象
  5. 通过Thread类的对象调用start()
```
#### 2.3 实现Callable接口
```markdown
 1.创建Callable的实现类
 2.实现call方法，将此线程需要执行的操作声明在call()中
 3.创建Callable接口实现类的对象
 4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象
 5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()
 6.获取Callable中call方法的返回值
```
#### 2.4线程池
```markdown
 1. 提供指定线程数量的线程池
 2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象
 3.关闭连接池
```
[参考资料：并发编程相关面试题四](https://www.cnblogs.com/Zzzzn/p/12586656.html)
[参考资料：Java 并发进阶常见面试题总结](https://www.cnblogs.com/wuwuyong/p/12169102.html)
### 3.CAS无锁机制
```markdown
CAS：Compare and Swap，即比较交换；
　　jdk1.5增加了并发包java.util.concurrent.*，其下面的类使用CAS算法实现了区别于synchronized同步锁的一种乐观锁。jdk1.5之前java是靠synchronized关键字保证同步的，是一种独占锁，也是悲观锁；
　　本身无锁，采用乐观锁的思想，在数据操作时对比数据是否一致，如果一致代表之前没有线程操作该数据，那么就会更新数据，如果不一致代表有县城更新则重试；
　　CAS当中包含三个参数CAS(V,E,N)，V标识要更新的变量，E标识预期值，N标识新值　　
　　运行过程：
　　　　1.线程访问时，先会将主内存中的数据同步到线程的工作内存当中；
　　　　2.假设线程A和线程B都有对数据进行更改，那么假如线程A先获取到执行权限；
　　　　3.线程A先会对比工作内存当中的数据和主内存当中的数据是否一致，如果一致（V==E）则进行更新，不一致则刷新数据，重新循环判断；
　　　　4.这时更新完毕后，线程B也要进行数据更新，主内存数据和工作内存数据做对比，如果一致则进行更新，不一致则将主内存数据重新更新到工作内存，然后循环再次对比两个内存中的数据，直到一致为止；　
　　CAS无锁机制存在一个问题
　　　　ABA问题，如果将原来A的值改为了B，然后又改回了A，虽然最终结果没有发生改变，但是在过程中是对该数据进行了修改操作
　　　　解决该问题：在Java中并发包下有一个原子类：AtomicStampedReference，在该类当中通过版本控制判断值到底是否被修改
　　　　解释：如果对值进行了更改则版本号+1，那么在CAS当中不仅仅对比变量的值，还要对比版本号，如果值和版本号都相等则代表没有被修改，如果有一方不相等代表进行过更改
　　　　那么就从主内存中重新刷新数据到工作内存然后循环对比，直到成功为止~
```
### 4. AQS
```markdown
AQS:全称AbstractQueueSynchronizer，抽象队列同步器，这个类在java.util.concurrent.locks包下
它是一个底层同步工具类，比如CountDownLatch,Sammphore，ReentrantLock,ReentrantReadWriteLock等等都是基于AQS底层三个内容：
　　　　　　1.state（用于计数器）
　　　　　　2.线程标记（哪一个线程加的锁）
　　　　　　3.阻塞队列（用于存放阻塞线程）
AQS提供了一种实现阻塞锁和一系列依赖FIFO等待队列的同步器的框架，如下图所示。AQS为一系列同步器依赖于一个单独的原子变量（state）
的同步器提供了一个非常有用的基础。子类们必须定义改变state变量的protected方法，这些方法定义了state是如何被获取或释放的。
```
### 5. ReentrantLock底层实现
```markdown
ReentrantLock是基于AQS的，AQS是Java并发包中众多同步组件的构建基础，它通过一个int类型的状态变量state和一个FIFO队列来完成共享资源的获取，
线程的排队等待等。AQS是个底层框架，采用模板方法模式，它定义了通用的较为复杂的逻辑骨架，比如线程的排队，阻塞，唤醒等，将这些复杂但实质通用的部分抽取出来，
这些都是需要构建同步组件的使用者无需关心的，使用者仅需重写一些简单的指定的方法即可（其实就是对于共享变量state的一些简单的获取释放的操作）。
synchronized是ReentrantLock内部实现的一个同步组件，它是Reentrantlock的一个静态内部类，继承于AQS；
```
### 6.Java开发中用过哪些锁
```markdown
1、乐观锁
　　乐观锁顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。
    乐观锁适用于多读的应用类型，这样可以提高吞吐量，在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS(Compare and Swap 比较并交换)实现的
　　乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升；　　
　　乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。
2、悲观锁
　　悲观锁总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。
    比如Java里面的同步原语synchronized关键字的实现就是悲观锁。
　　悲观锁适合写操作非常多的场景；悲观锁在Java中的使用，就是利用各种锁；
3、独享锁
　　独享锁是指该锁一次只能被一个线程所持有。
　　独享锁通过AQS来实现的，通过实现不同的方法，来实现独享锁。对于Synchronized而言，当然是独享锁。
4、共享锁
　　共享锁是指该锁可被多个线程所持有。
　　读锁的共享锁可保证并发读是非常高效的，读写，写读，写写的过程是互斥的。
　　共享锁也是通过AQS来实现的，通过实现不同的方法，来实现共享锁。
5、互斥锁
　　互斥锁在Java中的具体实现就是ReentrantLock。
6、读写锁
　　读写锁在Java中的具体实现就是ReadWriteLock。
7、可重入锁　　　　
　　重入锁也叫作递归锁，指的是同一个线程外层函数获取到一把锁后，内层函数同样具有这把锁的控制权限；
　　synchronized和ReentrantLock就是重入锁对应的实现；
　　synchronized重量级的锁 ；ReentrantLock轻量级的锁；
8、公平锁
　　公平锁是指多个线程按照申请锁的顺序来获取锁。
　　对于Java ReetrantLock而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。
9、非公平锁
　　非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。　　
　　对于Synchronized而言，也是一种非公平锁。由于其并不像ReentrantLock是通过AQS的来实现线程调度，所以并没有任何办法使其变成公平锁。
10、分段锁
　　分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。
　　我们以ConcurrentHashMap来说一下分段锁的含义以及设计思想，ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap（JDK7和JDK8中HashMap的实现）的结构，
    即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock）。
　　当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在哪一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。
　　但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计。
　　分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。
11、偏向锁　　
　　偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。
12、轻量级锁
　　轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。
13、重量级锁
　　重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让他申请的线程进入阻塞，性能降低。
14、自旋锁
　　在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。
```
### 7.synchronized关键字理解
```markdown
使用了synchronized关键字可以轻松地解决多线程共享数据同步问题。
　　synchronized关键字修饰实例方法，修饰静态方法，修饰代码块
    synchronized可作用于instance变量、object reference（对象引用）、static函数和class literals(类名称字面常量)身上。 
　　synchronized取得的锁都是对象；每个对象只有一个锁（lock）与之相关联；实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。
　　synchronized的4种用法：
　　　　1. 方法声明时使用,线程获得的是成员锁；
　　　　2. 对某一代码块使用,synchronized后跟括号,括号里是变量,线程获得的是成员锁；
　　　　3. synchronized后面括号里是一对象,此时,线程获得的是对象锁；
　　　　4. synchronized后面括号里是类,此时,线程获得的是对象锁；
庆幸的是在Java 6之后Java官方对从JVM层面对synchronized较大优化，所以现在的synchronized锁效率也优化得很不错了。
JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。
synchronized的不足之处:
    1.如果临界区是只读操作，其实可以多线程一起执行，但是使用synchronized的话，同一时间只能有一个线程执行。
    2.synchronized无法知道线程有没有成功获取到锁。
    3.使用synchronized，如果临界区因为IO或者sleep方法等原因阻塞了，而当前线程没有释放锁，就会导致所有线程等待
```
### 8.ReentrantLock和synchronized之间的区别
```markdown
两者都是可重入锁：
synchronized加锁和解锁自动进行，不必担心最后是否释放锁；ReentrantLock加锁和解锁需要手动进行，且次数需一样，否则其他线程无法获得锁。
1.synchronized是JVM层面实现的；ReentrantLock是JDK代码层面实现。说白了就是，是操作系统来实现，还是用户自己敲代码实现。
2.synchronized竞争锁时会一直等待；ReentrantLock可以尝试获取锁，并得到获取结果。
3.synchronized获取锁无法设置超时；ReentrantLock可以设置获取锁的超时时间。
4.synchronized只能是非公平锁，无法实现公平锁；ReentrantLock可以满足公平锁，即先等待先获取到锁,也可以满足非公平锁，默认非公平锁。
5.synchronized控制等待和唤醒需要结合加锁对象的wait()和notify()、notifyAll()；ReentrantLock控制等待和唤醒需要结合Condition的await()和signal()、signalAll()方法
6.synchronized在加锁代码块执行完或者出现异常，自动释放锁；ReentrantLock不会自动释放锁，需要在finally{}代码块显示释放。
ReentrantLock锁的细粒度和灵活度，都明显优于synchronized。
```
### 9.volatile特性和[面试中的volatile关键字](https://www.cnblogs.com/ArvinYL/p/12827641.html)
```markdown
被volatile修饰的共享变量，就具有了以下两点特性：
    保证了不同线程对该变量操作的**内存可见性**
    禁止指令重排序(有序性)
内存可见性:
    可见性是指一个线程修改了共享变量的值，其他线程能够立即得知这个修改。
    volatile变量保证新值能够立马同步到主内存，使用时也立即从主内存中刷新，保证了多线程操作时变量的可见性。
JMM的特性：原子性，有序性，可见性。
    原子性即一个操作或一系列操作是不可中断的。即使是在多线程的情况下，操作一旦开始，就不会被其他线程干扰。
    有序性是指对于单线程的执行代码，执行是按顺序依次进行的。
    但在多线程环境中，则可能出现乱序现象，因为在编译过程中会出现“指令重排”，重排后的指令与原指令的顺序未必一致。
指令重排：
    CPU和编译器为了提高程序执行的效率，会按照一定的规则允许进行指令优化。
    但代码逻辑之间是存在一定的先后顺序，并发执行时按照不同的执行逻辑会得到不同的结果。    
volatile不能保证原子性，它只是对单个volatile变量的读/写具有原子性，但是对于类似i++的复合操作就无法保证。
volatile+synchronized实现单例模式的双重检查锁
```
### 10.synchronized和volatile的区别
```markdown
volatile本质是在告诉JVM当前变量寄存器(工作内存)中的值是不确定的，需要从主存中读取；
synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
volatile只能用于变量，而synchronized可以修饰方法和代码块。volatile关键字是线程同步的轻量级实现，性能比synchronized要好。
多线程访问volatile不会发生阻塞，而synchronized可能发生阻塞。
volatile能够保证数据的可见性，但是不能保证数据的原子性，synchronized两者都能保证。
volatile主要是解决变量在多个线程之间的可见性，synchronized解决多个线程之间访问资源的同步性。
volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化
```
### 11.sleep()和wait()的区别联系
```markdown
wait()是Object的方法，而sleep()是Thread的静态方法；
wait可以指定时间，也可以不指定；而sleep必须指定时间。
wait释放cpu资源，同时释放锁；sleep释放cpu资源，但是不释放锁，所以易死锁。
wait必须放在同步块或同步方法中，而sleep可以再任意位置
sleep()通常被用于暂停执行，而wait()通常被用于线程间交互和通信
```
### 12.notify()和notifyAll()有什么区别？
```markdown
notify:方法唤醒，正在等待调用对象的锁的阻塞线程，如果有多个这样的线程，就会随机唤醒。
notifyall:唤醒所有，正在等待调用对象的锁的阻塞线程。
```

## 三、JVM
### 1.JVM的主要组成部分及其作用
```markdown
Class Loader类加载器：类加载器的作用是加载类文件到内存，比如编写一个HelloWord.java程序，然后通过javac编译成class文件。
Class Loader承担加载到内存中被执行的责任，当然，不可能随便建立一个.class文件就能被加载的，Class Loader加载的class文件是有格式要求。
 Execution Engine执行引擎：Class Loader只管加载，只要符合文件结构就加载，至于说能不能运行，则不是它负责的，
那是由Execution Engine负责的。执行引擎也叫做解释器 (Interpreter)，负责解释命令，提交操作系统执行。
 Native Interface本地接口：本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序，Java诞生的时候是C/C++横行的时候，
要想立足，必须有一个聪明的、睿智的调用C/C++程序，于是就在内存中专门开辟了一块区域处理标记为native的代码。
 Runtime data area运行数据区：运行数据区是整个JVM的重点。
```
### 2.JVM内存模型和Java运行时内存数据区
>>[一份热乎乎的腾讯后端面试真题](https://www.cnblogs.com/jay-huaxiao/p/12776714.html)
#### 1.Java运行时内存数据区
![](https://user-gold-cdn.xitu.io/2020/4/26/171b3b57de3b838c?w=727&h=478&f=png&s=203974)
```markdown
堆：线程公有，存放对象。
栈：线程私有，由栈帧组成，保存函数的一些信息。
PC计数器：代码指令行号计数器,线程私有
方法区（持久代、元数据区）,线程公有
堆：Java内存管理中最大的一块，用来存储对象实例和数组，线程共享。
栈：分为虚拟机栈和本地方法栈，这里主要指的是虚拟机栈。
虚拟机栈由一个个栈帧组成，每一个栈帧又由局部变量表、动态链接（对象引用）、方法出口等信息组成，线程私有。
```
#### 2.Java中成员变量、局部变量、静态变量、常量分别存储在那些内存区域中？
```markdown
 成员变量：堆
 局部变量：
     局部变量是基本类型（8 种基本类型）：栈
     局部变量是对象：对象实例存储在堆中，对象引用存储在栈中
 静态变量（static 修饰）：方法区（元数据区）
 常量（final 修饰）：方法区（元数据区）
```
#### 3.JVM内存模型(JMM)
![](https://user-gold-cdn.xitu.io/2020/4/26/171b3a11106f2cad?w=823&h=759&f=png&s=231498)
### 3.JMM与Java运行时内存区域划分的区别与联系
```markdown
区别:两者是不同的概念层次。
    JMM是抽象的，他是用来描述⼀组规则，通过这个规则来控制各个变量的访问方式，围绕原子性、有序性、可见性等展开的。
    而Java运行时内存的划分是具体的，是JVM运行Java程序时，必要的内存划分。
联系
    都存在私有数据区域和共享数据区域。⼀般来说，JMM中的主内存属于共享数据区域，他是包含了堆和方法区；
    同样，JMM中的本地内存属于私有数据区域，包含了程序计数器、本地方法栈、虚拟机栈。
```
### 3.cms和g1有没有了解过，它们有什么区别
>>[一份热乎乎的腾讯后端面试真题](https://www.cnblogs.com/jay-huaxiao/p/12776714.html)
```markdown
CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收集器一起使用；
G1收集器收集范围是老年代和新生代，不需要结合其他收集器使用；
CMS收集器以最小的停顿时间为目标的收集器；
G1收集器可预测垃圾回收的停顿时间
CMS收集器是使用“标记-清除”算法进行的垃圾回收，容易产生内存碎片
G1收集器使用的是“标记-整理”算法，进行了空间整合，降低了内存空间碎片。
```
### 4.谈谈你对垃圾回收的了解，什么时候发生垃圾回收，回收过程
>>[一份热乎乎的腾讯后端面试真题](https://www.cnblogs.com/jay-huaxiao/p/12776714.html)
```markdown
可以讲JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代，
如Minor GC，Major GC，full GC这几个讲清楚，还有对象存活判断方法，还有垃圾回收算法，复制算法等等
```
### [5.关于强引用、软引用、弱引用、幻象引用，你该如何回答？](https://www.cnblogs.com/cxuanBlog/p/12774370.html)|
```markdown
1. 强引用:被强引用关联的对象不会被回收。使用new一个新对象的方式来创建强引用。
        Object obj = new Object();
new语句产生的都是强引用，虚拟机不会主动去回收，即便内存溢出，也是会抛出异常而不是回收强引用。可以将对象=null，从而在垃圾回收器在下一次回收。
2. 软引用:被软引用关联的对象在内存足够时，不会回收,在内存不够的情况下才会被回收。使用SoftReference类来创建软引用。常用于缓存技术。
        Object obj = new Object();
        SoftReference<Object> sf = new SoftReference<Object>(obj);
        obj = null; // 使对象只被软引用关联
3. 弱引用:被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。使用WeakReference类来创建弱引用。
        Object obj = new Object();
        WeakReference<Object> wf = new WeakReference<Object>(obj);
        obj = null;
4. 虚引用:最弱的引用，在对象被 JVM 回收之后收到一个系统通知，用于追踪垃圾回收过程，必须与应用队列一起使用。
        一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。
       为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。使用PhantomReference来创建虚引用。
       Object obj = new Object();
       PhantomReference<Object> pf = new PhantomReference<Object>(obj, null);
       obj = null;
```
### 6.对象创建的过程
```markdown
1.类加载检查：在执行到new命令时，查看new后面的参数是否正确定位到常量池中的符号引用，并且该符号引用是否被正确的加载、连接和初始化。
2.内存分配：为对象分配内存，有指针碰撞和空闲列表两种方式。
     指针碰撞：适用于内存完整，无碎片。内存使用和未使用中间由指针隔开，分配的时候指针移动相应的位置。
     空闲列表：适用于内存不完整，有碎片。维护一个列表，列表记录可用的内存，使用时分配给对象一个足够的内存空间并更新列表
3.初始化零值：将对象分配到的空间初始化零值（不包括对象头）
4.设置对象头：对象头信息包括哈希码、GC 分代信息、元数据信息、对象是哪个类的示例等
5.执行 init 方法：给对象设置程序值，执行构造方法。
```
### 7.对象有哪几部分构成？虚拟机如何访问对象
```markdown
对象在内存中的组成部分（对象在内存的划分、对象的内存布局）:
     对象头：
         第一：元数据、GC 分代、哈希值等自身运行信息；
         第二：类型指针，确定属于哪个类的实例
     实例数据：对象真正存储的有效信息，定义的各种字段的值。
     对齐填充：没有实际意义，JVM 内存地址需要 8 字节的整数倍
虚拟机如何访问对象
     句柄：堆中专门划分一个区域作为句柄池，虚拟机栈存储是堆中句柄的地址，句柄存储的是对象的实例数据和类型数据的地址
     直接指针：栈中的引用直接指向的就是对象的实例数据和类型数据的地址。
     对比：直接指针避免二次寻址；使用句柄，在对象移动时，只修改句柄地址而不用改变引用的地址。
```
### 8.内存泄露和内存溢出分别是什么？什么原因造成？如何避免？
```markdown
内存泄露：本应被回收的对象因为其他对象的引用而不能被回收，从而在堆中寄存，造成内存泄露，长周期对象持有短周期对象的引用会造成。
 内存溢出：无法为对象分配足够的内存，对象申请过多
避免：
 不要在循环中创建对象
 不要一次调用过多数据
 大量字符串使用 StringBuffer 或者 StringBuilder
 方法区很少进行垃圾回收，尽量避免申请常量和静态变量
```
### 9.给对象分配内存如何保证线程安全？
```markdown
CAS+失败重试：CAS是乐观锁，每次都假设成功，在执行，失败就重试，找到成功。保证更新的原子性
TLAB：为每一个线程，预先在Eden区域分配一块内存，对象先分配到这里，当该区域内存不足或用完之后，使用CAS+失败重试机制
```
### 10.常量池都包括哪些内容？常量池的位置？
```markdown
Java 中有三个常量池：字符串常量池、运行时常量池、class常量池
 字符常量池：全局字符串池里的内容是在类加载完成，经过验证，准备阶段之后在堆中生成字符串对象实例，也就是编译期间字符常量池已经创建完成。
 class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池(constant pool table)——注意这里的class常量池是存放在class文件中，而不是
在jvm中，用于存放编译器生成的各种字面量(Literal)和符号引用(SymbolicReferences)。字面量就是我们所说的常量概念，符号引用就是在类加载阶段的解析阶段，把符号引用替换成直接引用。
 jvm在执行某个类的时候，必须经过加载、连接、初始化，而连接又包括验证、准备、
解析三个阶段。而当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中，运行时常量池也是每个类都有一个。
 关于class常量池和运行时常量池可以这么理解：在java文件编译时，类的字面量和符
号引用，会存放在class类常量池，但是当类文件加载到jvm之后，class常量池的内容就被会加载到运行时常量池。
常量池的位置
 在JDK1.7之前运行时常量池逻辑包含字符串常量池存放在方法区，此时hotspot虚拟机对方法区的实现为永久代。
 在JDK1.7字符串常量池被从方法区拿到了堆中，这里没有提到运行时常量池，也就是
说字符串常量池被单独拿到堆，运行时常量池剩下的东西还在方法区 , 也就是hotspot中的永久代。
 在JDK1.8hotspot移除了永久代用元空间(Metaspace)取而代之，这时候 字符串常量
池还在堆,运行时常量池还在方法区,只不过方法区的实现从永久代变成了元空间(Metaspace)。
```
## 四、Java容器集合
### 1.ArrayList不是线程安全的和CopyOnWriteArrayList解决
[浅析CopyOnWriteArrayList](https://www.cnblogs.com/zengcongcong/p/12754067.html)
```markdown
1.为什么ArrayList不是线程安全的？
    所有的java.util包中的集合类都被设计为fail-fast，由于fail-fast机制的存在，抛出了modcount修改异常的错误ConcurrentModificationException 
    (modcount是ArrayList源码中的一个变量，用来表示修改的次数，因为ArrayList不是为并发情况而设计的集合类）
2.解决办法：
    1.可以使用Vector集合，Vector集合是线程安全版的ArrayList，其方法都上了一层synchronized进行修饰，
    采取jvm内置锁来保证其并发情况下的原子性、可见性、有序性。但同时也带来了性能问题，因为synchronized一旦膨胀到重量级锁，
    存在用户态到和心态的一个转变，多线程的上下文切换会带来开销。另一个问题是Vector集合的扩容没有ArrayList的策略好
    2.使用Collections.synchronizedList，在更新操作中使用了同步锁。
    3.采用JUC提供的并发容器，CopyOnWriteArrayList
3.CopyOnWriteArrayList
    和ArrayList一样，其底层数据结构也是数组，加上transient不让其被序列化，加上volatile修饰来保证多线程下的其可见性和有序性。
    CopyOnWriteArrayList在更新操作中不仅使用了可重入锁，而且还需要进行数组的复制。
    CopyOnWriteArrayList适合于多线程场景下使用，其采用读写分离的思想，读操作不上锁，写操作上锁，且写操作效率较低
    CopyOnWriteArrayList基于fail-safe机制，每次修改都会在原先基础上复制一份，修改完毕后在进行替换
    CopyOnWriteArrayList采用的是ReentrantLock进行上锁。
```
### 2.[不可错过的java面试博客之java集合篇](https://www.cnblogs.com/jichi/p/12834238.html)
#### 2.1 List及ArrayList、Vector、LinkedList
```markdown
1.List是无序的Collection，List一共三个实现类：分别是 ArrayList、Vector和LinkedList
    1.1：ArrayList通过数组实现的，允许对元素进行快速随机访问。缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，
        就要将已经有数组的数据复制到新的存储空间中。当从中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。
        适合随机查找和遍历，不适合插入和删除。排列有序，可重复，容量不够的时候，当前容量*1.5+1。
    1.2：Vector与ArrayList 一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，
        避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问ArrayList慢。默认扩展一倍容量。
    1.3：LinkedList是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。还提供了List接口中没有定义的方法，
        专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。底层使用双向循环链表数据结构。线程不安全。
        将LinkedList替换成ConcurrentLinkedQueue实现线程安全。
```
#### 2.2 Set
```markdown
1.Set是存储有序(存入和取出的顺序不一定相同)元素，值不能重复。
    1.1：HashSet（Hash 表）没有key值的HashMap
    1.2:TreeSet（二叉树） 有序 每增加一个对象都会进行排序
    1.3:LinkHashSet（HashSet+LinkedHashMap）
```
#### 2.3 Map
```markdown
1.Map
    1.1：HashMap（数组+链表+红黑树）根据键的hashCode值存储数据,大多数情况下可以直接定位到它的值，具有很快的访问速度，但遍历顺序却是不确定的。
          HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全。  
          可以用Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。
    1.2：ConcurrentHashMap和HashMap思路是差不多的，但是因为它支持并发操作，线程安全。分段锁Segment 继承 ReentrantLock 加锁
    ConcurrentHashMap是多个Segment数组，Segment通过继承ReentrantLock来进行加锁，所以每次需要加锁的操作锁住的是一个segment，
    这样只要保证每个Segment是线程安全的，也就实现了全局的线程安全。默认是 16，
    1.3：HashTable（线程安全）是遗留类，并发性不如ConcurrentHashMap
    1.4：TreeMap（可排序）实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序
    1.5：LinkHashMap（记录插入顺序）是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历
         LinkedHashMap如何保证有序性:继承自HashMap，内部增加了head tail 和access order。
```
#### 2.4 HashMap扩容机制算法
```markdown
默认情况下HashMap的容量是16，但是，如果用户通过构造函数指定了一个数字作为容量，那么Hash会选择大于该数字的第一个2的幂作为容量。
HashMap有扩容机制，就是当达到扩容条件时会进行扩容。HashMap的扩容条件就是当HashMap中的元素个数（size）超过临界值（threshold）时就会自动扩容。
在HashMap中，threshold = loadFactor * capacity。非常影响性能的。
在Jdk1.7和Jdk1.8中，HashMap初始化这个容量的时机不同。jdk1.8中，在调用HashMap的构造函数定义HashMap的时候，就会进行容量的设定。
而在Jdk1.7中，要等到第一次put操作时才进行这一操作。
```
####2.5 hashmap的工作原理
```markdown
HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，
我们先对键调用hashCode()方法，计算并返回的hashCode是用于找到Map数组的bucket位置来储存Node 对象。这里关键点在于指出，HashMap是在bucket中储存键对象和值对象，作为Map.Node 。
以下是具体的put过程（JDK1.8版）
1.对Key求Hash值，然后再计算下标
2.如果没有碰撞，直接放入桶中（碰撞的意思是计算得到的Hash值相同，需要放到同一个bucket中）
3.如果碰撞了，则调用equals() 比较value，相同则替换旧值，不同则以链表的方式链接到后面
4.如果链表长度超过阀值( TREEIFY THRESHOLD==8)，就把链表转成红黑树，链表长度低于6，就把红黑树转回链表
5.如果桶满了(容量16*加载因子0.75)，就需要 resize（扩容2倍后重排）
以下是具体get过程(考虑特殊情况如果两个键的hashcode相同，你如何获取值对象？)
当我们调用get()方法，HashMap会使用键对象的hashcode找到bucket位置，找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。
```
#### 2.6 拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？
```markdown
选择红黑树是为了解决二叉查找树的缺陷，二叉查找树在特殊情况下会变成一条线性结构遍历查找会非常慢。
而红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，引入红黑树就是为了查找数据快，解决链表查询深度的问题，
红黑树属于平衡二叉树，为了保持“平衡”是需要付出代价的，但是该代价所损耗的资源要比遍历线性链表要少，
所以当长度大于8的时候，会使用红黑树，如果链表长度很短的话，根本不需要引入红黑树，引入反而会慢。
```
#### 2.7 解决hash碰撞还有那些办法？
```markdown
开放定址法
    当冲突发生时，使用某种探查技术在散列表中形成一个探查(测)序列。沿此序列逐个单元地查找，直到找到给定的地址。
    按照形成探查序列的方法不同，可将开放定址法区分为线性探查法、二次探查法、双重散列法等。
再哈希法
    Hi = RHi（key），i=1,2,...k,RHi均是不同的哈希函数，即在同义词产生地址冲突时计算另一个哈希函数地址，直到不发生冲突为止。
    这种方法不易产生聚集，但是增加了计算时间。
    缺点：增加了计算时间。
建立一个公共溢出区
    假设哈希函数的值域为[0,m-1]，则设向量HashTable[0...m-1]为基本表，每个分量存放一个记录，另设立向量OverTable[0....v]为溢出表。
    所有关键字和基本表中关键字为同义词的记录，不管他们由哈希函数得到的哈希地址是什么，一旦发生冲突，都填入溢出表。
    简单地说就是搞个新表存冲突的元素。
链地址法（拉链法）
    将所有关键字为同义词的记录存储在同一线性链表中，也就是把冲突位置的元素构造成链表。
```
#### 2.8 Comparable 和 Comparator 的区别?
```markdown
如果在定义类时，就实现了Comparable接口，直接在里面重写compareTo()方法，如果没实现，后面在业务开发中需要有比较排序的功能，
就再单独写一个类实现Comparator接口，在里面重写compare()方法，然后这个类需要作为参数传入到工具类Collections.sort和Arrays.sort方法中。
最主要的区别就是一个一开始就实现，一个是后期实现。
```
### 3.怎么确保一个集合不能被修改？
```markdown
方式一：final：
    final 修饰的类不能被继承，
    final 修饰的方法不能被重写，
    final 修饰的变量不能修改
   这里需要特别注意，变量是基本类型的时候，值不可修改，变量是对象的时候，引用不可修改。
   集合的值是可以不断添加，但是当引用改变的时候就会报错，所以使用final只能让集合的引用不可修改，而值还是可以修改和添加。
方式二：使用Collections.unmodifiableCollection(Collection c)方法来创建一个只读集合，
    这样改变集合的任何操作都会抛出Java.lang.UnsupportedOperationException异常。
```
## 五、计算机网络和操作系统
### 1. 在地址栏键入URL后，网络世界发生了什么？
[一文摸透从输入URL到页面渲染的过程](https://www.cnblogs.com/AhuntSun-blog/p/12641050.html)
```markdown
1.在键入URL之前，刚开完机的时候，需要联网，然后才能上网。这个阶段包括了获取本机IP地址，获取DNS服务器IP地址，获得网关路由器IP和MAC地址等操作。
--获取本机IP地址，DNS服务器地址，网关路由器地址
--1.获取域名的IP地址 --DNS域名解析:获取域名对应IP
--2.三次握手建立TCP连接
--3.建立连接后进行数据交互 发送HTTP请求  服务器处理请求并返回HTTP报文 请求结束关闭TCP连接
--4.浏览器解析渲染页面 构建DOM树 样式计算 页面布局 生成分层树 栅格化 显示
--5.合成与显示
```

[Java面试后端经验分享（不是面经的面经）:题目整合](https://www.nowcoder.com/discuss/421353?type=5)

[阿里java面经（供后人查看）](https://www.nowcoder.com/discuss/420953?type=2)
[https://www.nowcoder.com/discuss/420929?type=2]计算机
## 六、数据库和Redis
### 1.MySQL
#### 存储过程和函数的区别？
```markdown
 存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。
    函数每次执行都需要编译一次。
 存储过程中可以使用try-catch块和事务，而函数中不可以
 函数有且只有一个输入参数和一个返回值，而存储过程没有这个限制
 函数可以被存储过程调用而存储过程不可以被函数调用
```
#### 视图的操作会对基本表产生影响吗？
```markdown
 视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，视图通常是有一个表或者多个表的行或列的子集。
对视图的修改会影响基本表。它使得我们获取数据更容易，相比多表查询。
 当用户试图修改视图的某些信息时，数据库必须把它转化为对基本表的某些信息的修改，对于简单的视图来说，这是很方便的，
但是，对于比较复杂的试图，可能是不可修改的。
```

