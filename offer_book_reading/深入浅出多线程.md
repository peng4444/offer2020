# 阅读深入浅出多线程

**项目地址链接**  [**深入浅出多线程**](https://github.com/RedSpider1/concurrent) **欢迎为作者们点赞star**。

可以gitbook或者下载PDF阅读哦！[**gitbook地址**](https://redspider.gitbook.io/concurrent) ---- 

[参考视频：尚硅谷Java大厂面试题第二季(java面试必学，周阳主讲)](https://www.bilibili.com/video/BV18b411M7xz?p=35)

//[参考视频：黑马-全面深入学习java并发编程，中级程序员进阶必会](https://www.bilibili.com/video/BV16J411h7Rd)

[TOC]


## 第一章：进程和线程的基本概念
### 1.1进程和线程
>> 进程：是系统运行程序的基本单位，是程序的一次执行过程，各个进程之间互不干扰。同时进程保存着程序每⼀个时刻运行的状态。

>> 线程：一个进程执行可以产生多个线程，让一个线程执行一个子任务，每个线程负责⼀个单独的⼦任务。
        多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈。
### 1.1.1进程和线程的区别与联系
```markdown
对于操作系统而言，一个任务就是一个进程；进程是系统中程序执行和资源分配的基本单元，每个进程都有自己的数据段、代码段、堆栈段。
两个本质的区别是是否单独占有内存地址空间及其它系统资源（比如I/O）。
进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位，即CPU分配时间的单位。
```
### 1.2上下文切换
```markdown
上下文切换（有时也称做进程切换或任务切换）是指CPU从一个进程（或线程）切换到另一个进程（或线程）。
上下文是指某一时间点CPU寄存器和程序计数器的内容。频繁地上下文线程切换会影响性能。
```
### 1.3 并行和并发
```markdown
并发（concurrent）是同一时间应对（dealing with）多件事情的能力。
并行（parallel）是同一时间动手做（doing）多件事情的能力。
```
### 1.4 同步和异步
```markdown
需要等待结果返回，才能继续运行就是同步。（synchronous）同步在多线程中还有另外一层意思，是让多个线程步调一致。
不需要等待结果返回，就能继续运行就是异步。(asynchronous)
```
### 多线程的应用
```markdown
异步调用，提升效率。
```
## 第二章：Java多线程入门类和接口
[参考资料Java多线程:进程和线程的概念和创建线程的三种方式](https://www.cnblogs.com/wmqBlog/p/9956235.html)
### 2.1 Thread类和Runnable接口
[当阿里面试官问我：Java创建线程有几种方式？我就知道问题没那么简单](https://www.cnblogs.com/eson15/p/12666341.html)

[多线程的四种实现方式](https://www.cnblogs.com/xpybsh/p/12818796.html)
>> 继承Thread类 
>> 实现Runnable接口 调用Thread类启动
>> 实现Callable接口 使用FutureTask对返回值进行封装，调用Thread类启动
>> 提供指定线程数量的线程池,执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象
### 2.1.1 Thread类和Runnable接口的比较
```markdown
由于Java“单继承，多实现”的特性，Runnable接口使用起来比Thread更灵活。Runnable接口出现更符合面向对象，将线程单独进行对象的封装。
Runnable接口出现，降低了线程对象和线程任务的耦合性。如果使用线程时不需要使用Thread类的诸多方法，显然使用Runnable接口更为轻量。
Runnable接口和Thread类创建线程的run方法没有返回值，Callable接口和Future类可以实现。
```
### 2.2 Callable,Future和 FutureTask
[参考资料：java中Future与FutureTask使用与分析](https://www.cnblogs.com/dafanjoy/p/9778271.html)
### 2.2.1 Future和FutureTask的区别联系
```markdown
FutureTask是实现的RunnableFuture接口的，而RunnableFuture接口同时继承了Runnable接口和Future接口：
FutureTask可用于异步获取执行结果或取消执行任务的场景。当一个计算任务需要执行很长时间，那么就可以用FutureTask来封装这个任务，主线程在完成自己的任务之后再去获取结果。
在很多高并发的环境下，有可能Callable和FutureTask会创建多次。FutureTask能够在高并发环境下确保任务只执行一次。
```
### 2.3 线程运行原理
#### 2.3.1 栈和栈帧
```markdown
JVM中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？其实就是线程，每个线程启动后，虚拟机就会为其分配一块栈内存。
每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存。每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法
```
## 第三章：线程组和线程优先级
>> 线程组
>> 线程优先级
```markdown
Java程序中对线程所设置的优先级只是给操作系统⼀个建议，操作系统不⼀定会采纳。而真正的调用顺序，是由操作系统的线程调度算法决定的。
线程优先级和线程组优先级
    如果某个线程优先级大于线程所在线程组的最大优先级，那么该线程的优先级将会失效，取而代之的是线程组的最大优先级。
总结：线程组是⼀个树状的结构，每个线程组下面可以有多个线程或者线程组。线程组可以起到统一控制线程的优先级和检查线程的权限的作用。
```
## 第四章：Java线程的状态及主要转化⽅法
[深入理解Java线程状态转移](https://www.cnblogs.com/darope/p/12748184.html)
![线程状态转换https://www.cnblogs.com/darope/p/12748184.html](https://images.cnblogs.com/cnblogs_com/darope/1747012/o_200421111345%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB.png)
```markdown
NEW RUNNABLE(runnable&Running) BLOCKED WATTING TIMED_WAITING TERMINATED
1. 新建态(NEW)：一个线程被创建出来时候所处的状态 ；
2. 就绪态(runnable)：线程调用start()方法后，便处于可以被操作系统调度的状态，即就绪态。
            就绪状态可以由三处转化而来，新建态执行了start、线程阻塞结束、锁池等待队列中的线程获得了锁。
3. 运行态(RUNNing)：表示当前线程被操作系统调度，分配了时间片，执行线程中的run方法时的状态。
            运行态只可以由就绪态的线程转化而来，如果多个线程都处在就绪态，就等待操作系统分配。
4. 阻塞态(BLOCKED):表示当前线程被由于某种原因，被挂起，也就是被阻塞，正在运行的线程被阻塞后，
            即使结束阻塞状态也回不去运行态，只能回到就绪态，等待os分配cpu资源去调度。
5. 无限期等待（Waiting）：等待其它线程显式地唤醒，否则不会被分配 CPU 时间片。
            进入方法：                                       退出方法：
            没有设置Timeout参数的Object.wait()方法       Object.notify() / Object.notifyAll()
            没有设置Timeout参数的Thread.join()方法       被调用的线程执行完毕
            LockSupport.park()方法                      LockSupport.unpark(Thread)
6. 限期等待（Timed Waiting）：无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。
            调用Thread.sleep()方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。
            调用Object.wait()方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。
            睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。
            阻塞和等待的区别在于，阻塞是被动的，它是在等待获取一个排它锁。而等待是主动的，通过调用Thread.sleep()和Object.wait()等方法进入。
              进入方法                                       退出方法
            Thread.sleep() 方法                              时间结束
            设置了Timeout参数的Object.wait()方法       时间结束/Object.notify()/Object.notifyAll()
            设置了Timeout参数的Thread.join()方法       时间结束/被调用的线程执行完毕
            LockSupport.parkNanos()方法               LockSupport.unpark(Thread)
            LockSupport.parkUntil()方法               LockSupport.unpark(Thread)
7. 结束（Terminated）：可以是线程结束任务之后自己结束，或者产生了异常而结束。
```
### 线程start()的两个问题
```markdown
1. 反复调用同一个线程的start()方法是否可行？ 不可行，在第一次调用之后ThreadStatus的值改变，反复调用会报异常。
2. 假如一个线程执行完毕（此时处于TERMINATED状态），再次调用这个线程的start()方法是否可行？
```
[Java—线程的生命周期及线程控制方法详解](https://www.cnblogs.com/Andya/p/12919381.html)
### 线程start(),run(),sleep(),yield(),
```markdown
start()实际上通过本地方法start0()启动线程，会新运行一个线程，新线程会调用run()方法。
run()方法：target是Runnable对象，run()直接调用Thread线程的Runnable成员的run()方法，并不会新建一个线程。
sleep()示例://让当前线程睡眠1000毫秒，即暂定1s,Thread.sleep(1000);
yield()方法介绍：
yield()方法让当前正在执行的线程暂停，但不会阻塞线程，只是让线程转入就绪状态。
yield()方法让当前线程暂停，让系统的线程调度重新调度一次，所以会出现当某个线程调用了yield()方法后，线程调度器又重新将它调度出来执行。
yield()方法让当前线程暂停后，只有优先级>=当前线程的处于就绪状态的线程才能获取CPU执行权限。
yield()方法重载：public static native void yield();：静态方法。
yield()示例：//让当前线程暂停Thread.yield();
join()方法：
1.Thread类提供join()方法让一个线程等待另一个线程完成的方法；就是将指定的线程加入到当前线程，这样两个交替执行的线程就变成了
顺序执行的线程，如线程A调用了线程B的join()方法，则线程A会等待线程B执行完毕后才会继续执行自己。
2.join()方法由使用线程的程序调用，调用线程调用线程t的t.join()方法后将会被阻塞，直到线程t执行完毕，调用线程才能继续执行。
一般就是用于主线程内，等待其他线程执行完毕后，再继续执行main()函数。
join()方法重载方式
public final void join() throws InterruptedException：等待被join的线程执行完毕。
public final synchronized void join(long millis) throws InterruptedException：等待被join的线程的超时时间为millis毫秒。
如果在millis毫秒内被join的线程还未结束执行流程，则调用线程不再等待。
public final synchronized void join(long millis, int nanos) throws InterruptedException：等待被join的线程的时间最长为millis毫秒+nanos毫微秒。（很少用）
```
### sleep()和yield()方法的区别
```markdown
1.- 依赖线程优先级：sleep()方法暂停当前线程后，会给其他线程执行机会，而不在乎其他线程的优先级；
    yield()方法暂停当前线程后，只会给优先级相同或更高的线程执行机会。
2.- 线程转入状态：sleep()方法将线程转入阻塞状态，知道经过阻塞时间才会转入就绪状态；
    yield()方法不会将线程转入阻塞状态，而是将线程转入就绪状态。
3.- 异常声明：sleep()方法声明抛出了InterruptedException异常；yield()方法未声明抛出异常。
4.- 可移植性： sleep()方法的移植性比yield()方法好，所以一般使用sleep()方法控制并发编程。
```
## 第五章：Java线程之间的通信
[多线程通讯(wait、notify、Lock、ThreadLocal)](https://www.cnblogs.com/javatalk/p/9924531.html)
>> 线程锁与同步，wait(),notify(),notifyAll(),信号量，管道，Join,ThreadLocal
### [全面理解线程间的通信方式](https://www.cnblogs.com/yzjbk/p/12853063.html)
### 使用对象的wait()/notify()/notifyAll()所要注意的点
```markdown
调用wait()/notify()/notifyAll()方法的线程必须是持有该对象的锁的线程
调用wait()方法后线程由RUNNING状态变为WAITING状态，并将当前线程放置在该对象的等待队列中，同时释放拥有的锁
调用notify()和notifyAll()之后线程并不会立即从wait()方法处返回，而是需要等待调用notify()/notifyAll()的线程释放锁之后才会返回。
notify()将等待队列中的线程移动到同步队列中去，notifyAll()将等待队列中所有的线程移动到同步队列中去,此时被移动的线程状态由WAITING转为BLOCKED
```
```markdown
1：为什么操作wait()、notify()、notifyAll()需要事先获取锁？
主要是为了防止死锁了永久等待的发生，以上面的例子说明，收件人线程执行if(CABINET.size()==0)的时候满足条件由于没有synchronize加持，
所以该线程并不一定会执行CABINET.wait()可能被CPU切走了，线程进入了BLOCKED状态。
此时快递小哥线程获取到了执行权，判断if(CABINET.size==10)不满足条件，然后执行CABINET.add(包裹操作)执行notify()因为收件人线程并没有执行wait()，
所以就可能处于一直等待中。就如同你给我打电话 我还没有拿到电话你就已经打过了 此时我再拿到电话也不会收到你的电话了。
Wait()放到synchronize 中执行就是为了保证线程安全，如果一个线程想要从wait()处返回也需要获取到该对象的锁否则会出现IllegalMonitorStateException异常。
2：为什么线程通信的方法wait()notify()notifyAll()是定义在Object中而sleep()定义在线程类中？
主要因为java中的wait()notify()notifyAll()都是锁级别的操作，操作这几个方法的线程必须持有该对象的锁，而锁又是属于对象的。
每一个对象的对象头中有几位是标识锁的状态的，所以实际上锁是属于对象的并不是属于线程的。如果这几个方法定义在线程中会造成极大的不便，
在实际的操作中我们会遇到一个线程获取几把锁的情况，如果将锁定义在线程中时间这种情况就不是那么的方便了。
3：wait()方法是属于对象的，那调用Thread.wait()会怎样？
调用Thread.wait()也就是说将Thread 当做锁对象，持有Thread对象的锁的线程在执行结束后会自动调用notify(),所以我们应该避免使用线程对象来作为锁对象。
4：notifyAll()会唤醒所有的线程同时去争夺这把锁，如果没有获取到锁的对象该怎么办？
没有抢到锁的线程会再次进入WAITING状态，进入对象的等待队列中去，直至有其他线程再次调用notify()或者notifyAll()或者调用该线程的中断方法。
```
## 第六章：Java内存模型基础知识
![Java内存模型图](https://user-gold-cdn.xitu.io/2020/5/1/171cef6637426e1e?w=823&h=759&f=png&s=251488)
### 6.1 Java内存模型
```markdown
Java内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。
处理器上的寄存器的读写的速度比内存快几个数量级，为了解决这种速度矛盾，在它们之间加入了高速缓存。
加入高速缓存带来了一个新的问题：缓存一致性。如果多个缓存共享同一块主内存区域，那么多个缓存的数据可能会不一致，需要一些协议来解决这个问题。
所有的变量都存储在主内存中，每个线程还有自己的工作内存，工作内存存储在高速缓存或者寄存器中，保存了该线程使用的变量的主内存副本拷贝。
线程只能直接操作工作内存中的变量，不同线程之间的变量值传递需要通过主内存来完成。
```
### 6.2 并发编程的两个关键问题
```markdown
线程间如何通信？即：线程之间以何种机制来交换信息               
线程间如何同步？即：线程以何种机制来控制不同线程间操作发生的相对顺序
两种并发模型可以解决这两个问题：
    消息传递并发模型
    共享内存并发模型；在Java中，使用的是共享内存并发模型。
```
## 第七章：重排序与happens-before
>> 重排序：计算机在执⾏程序时，为了提⾼性能，编译器和处理器常常会对指令做重排。
```markdown
源代码 -> 编译器优化的重排 -> 指令并行的重排 -> 内存系统的重排 -> 最终执行的指令。
编译器优化重排:编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
指令并行重排:
内存系统重排：
```
>> happens-before规则
```markdown
是一个给程序员使用的规则，只要程序员在写代码的时候遵循happens-before规则，JVM就能保证指令在多线程之间的顺序性符合程序员的预期。
```
## 第八章: volatile和原子性、有序性、可见性
[从多线程的三个特性理解多线程开发](https://www.cnblogs.com/dafanjoy/p/10020225.html)
```markdown
原子性：指一个操作或者一系列操作要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。
有序性：本义是指程序在执行的时候，程序的代码执行顺序和语句的顺序是一致的。
可见性：指的是线程之间的可见性，当⼀个线程修改了共享变量时，另⼀个线程可以读取到这个修改后的值。
volatile能够保证数据的可见性，但是不能保证数据的原子性，synchronized两者都能保证。i++的运行结果无法保证原子性，
使用synchronized、volatile，加锁lock等方式一般及可以保证线程的可见性与有序性。
volatile:禁止volatile变量与普通变量重排序。
```
[Java内存可见性volatile](https://www.cnblogs.com/junejs/p/12686902.html)
```markdown
内存可见性:指的是当一个线程对volatile修饰的变量进行写操作时，JMM会立即把该线程对应的本地内存中的共享变量的值刷新到主内存；
当⼀个线程对volatile修饰的变量进行读操作时，JMM会把立即该线程对应的本地内存置为无效，从主内存中读取共享变量的值。
```
>> volatile的三大特性。1：保证可见性 2：不保证原子性 3：保证顺序。
[【漫画】JAVA并发编程三大Bug源头(可见性、原子性、有序性)](https://www.cnblogs.com/liuyanling/p/12845755.html)
## 第九章：synchronized与锁
### synchronized
```markdown
synchronized修饰的方法或代码块相当于并发中的临界区，即在同一时刻jvm只允许一个线程进入执行。
synchronized是通过锁机制实现同一时刻只允许一个线程来访问共享资源的。
另外synchronized锁机制还可以保证线程并发运行的原子性，有序性，可见性。
所谓“临界区”，指的是某一块代码区域，它同一时刻只能由一个线程执行。
[synchronized使用及原理解析](https://www.cnblogs.com/little-sheep/p/9909111.html)
Synchronized修饰静态方法，对类对象进行加锁，是类锁。
Synchronized修饰实例方法，对方法所属对象进行加锁，是对象锁。
Synchronized修饰代码块时，对一段代码块进行加锁，是对象锁。
```
[Synchronized实现原理深入解析](https://www.cnblogs.com/wyc1994666/p/11748212.html)
### Java对象内存结构
![Java对象内存结构](https://img2020.cnblogs.com/blog/1216484/202005/1216484-20200510184617454-1254111974.png)
```markdown
对象在内存中存储的结构由三部分组成：对象头，主要是一些标记信息MarkWord，比如hashcode，锁状态这些；实例数据，就是真实的数据；
对齐填充，要求对象大小8字节的整数倍，如果不是就填充补齐。
我们以Hotspot虚拟机为例，Hopspot对象头主要包括两部分数据：Mark Word（标记字段）Klass Pointer（类型指针）。
Mark Word：默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构
以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。
Klass Point：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。
在上面中我们知道了synchronized用的锁是存在Java对象头里的，那么具体是存在对象头哪里呢？
答案是：存在锁对象的对象头的Mark Word中，那么MarkWord在对象头中到底长什么样，它到底存储了什么呢？
```
>>  MarkWord：锁状态标记就在这里面，以32位jvm为例，64位也是这些东西，只是占的大小不一样
![32位虚拟机](https://img-blog.csdnimg.cn/20200606113736103.png)
```markdown
无锁：对象头开辟25bit的空间用来存储对象的hashcode,4bit用于存放对象分代年龄,1bit用来存放是否偏向锁的标识位,2bit用来存放锁标识位为01。
偏向锁：在偏向锁中划分更细，还是开辟25bit的空间，其中23bit用来存放线程ID，2bit用来存放Epoch，4bit存放对象分代年龄，
    1bit存放是否偏向锁标识， 0表示无锁，1表示偏向锁，锁的标识位还是01。
轻量级锁：在轻量级锁中直接开辟30bit的空间存放指向栈中锁记录的指针，2bit存放锁的标志位，其标志位为00。
重量级锁： 在重量级锁中和轻量级锁一样，30bit的空间用来存放指向重量级锁的指针，2bit存放锁的标识位，为11。
GC标记： 开辟30bit的内存空间却没有占用，2bit空间存放锁标志位为11。
其中无锁和偏向锁的锁标志位都是01，只是在前面的1bit区分了这是无锁状态还是偏向锁状态。
```
### synchronized底层实现原理
[Synchronized加锁、锁升级和java对象内存结构](https://www.cnblogs.com/nijunyang/p/12864548.html)
```markdown
synchronized是jvm内置的同步锁，它是隐式锁，不需要我们自己手动释放锁。每一个java对象中都有一个内部对象Monitor。
synchronized就是通过内部对象Monitor(监视器锁)实现，基于进入与退出Monitor对象实现方法与代码块同步，
监视器锁的实现依赖底层操作系统的Mutex lock（互斥锁）实现，它是一个重量级锁性能较低（jdk1.6之后进行了优化）。                                          
当我们在代码中使用了synchronized之后，可以在字节码文件看到MONITORENTER和MONITOREXIT。
```
```markdown
synchronized是由一对monitorenter/monitorexit指令实现的，monitor对象是同步的基本实现单元。在JVM处理字节码会出现相关指令。
 代码块的同步：利用monitorenter和monitorexit这两个字节码指令。它们分别位于同步代码块的开始和结束位置。
当jvm执行到monitorenter指令时，当前线程试图获取monitor对象的所有权，如果未加锁或者已经被当前线程所持有，就把锁的计数器+1；
当执行monitorexit指令时，锁计数器-1；当锁计数器为0时，该锁就被释放了。如果获取monitor对象失败，该线程会进入阻塞状态，直到其他线程释放锁。
 方法级的同步：是隐式的，即无需通过字节码指令来控制的，它实现在方法调用和返回操作之中。JVM可以从方法常量池中的方法表结构(method_info Structure)中的
ACC_SYNCHRONIZED访问标志区分一个方法是否同步方法。当方法调用时，调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，
执行线程将先持有monitor(虚拟机规范中用的是管程)，然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时释放monitor。
```
[synchronized实现原理及其优化-（自旋锁，偏向锁，轻量锁，重量锁）](https://www.cnblogs.com/ljl150/p/12514198.html)
```markdown
在jdk1.5之前，只有synchronized重量级锁，实现需要借助操作系统，是比较消耗性能的操作，在1.6之中为了提高性能，
便对synchronized锁进行了优化，实现了各种锁优化技术，如：适应性自旋，锁消除，锁粗化，轻量级锁，偏向锁。
1. 无锁状态 unlocked
2. 偏向锁状态 biasble 
3. 轻量级锁状态 lightweight locked
4. 重量级锁状态 inflated
```
### [4种常用Java线程锁的状态的特点、性能比较、使用场景](https://blog.csdn.net/bingdianone/article/details/84639128)
[关于锁的四种状态与锁升级过程图文详解](https://www.cnblogs.com/mingyueyy/p/13054296.html)
>> 锁的状态总共有四种，级别由低到高依次为：无锁、偏向锁、轻量级锁、重量级锁。
>>并且四种状态会随着竞争的情况逐渐升级，而且是不可逆的过程，目的是为了提高获得锁和释放锁的效率。
#### 偏向锁
```markdown
Java偏向锁是在jdk1.6中引入的，它的目的是消除数据无竞争情况下的同步原语，进一步提高程序的运行性能。
如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除连CAS都不做。
偏向锁使用了一种等到竞争出现才释放锁的机制 所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。
```
#### 轻量级锁
```markdown
轻量级锁是jdk1.6中加入的新型锁机制，它名字中的“轻量级”是相对于使用操作系统互斥量来实现的重量级锁而言的。
首先需要强调的是，轻量级锁并不是来代替重量级锁的，本意是在没有多线程竞争的前提下，减少传统重量级锁使用操作系统互斥量产生的性能消耗。
需明白一点，轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁。
```
#### 自旋锁  
```markdown
自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么等待竞争锁的线程就不需要做内核态和用户态之间的切换进入
阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。
JDK6出现自适应自旋锁：自旋的次数不再确定；由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。
```
#### 重量级锁
>> 线程竞争不使用自旋，不会消耗CPU。线程阻塞，响应时间缓慢，在多线程下，频繁的获取释放锁会带来巨大的性能消耗。
### 重量级锁、轻量级锁和偏向锁之间转换
>> 偏向锁升级成轻量级锁
```markdown
偏向锁升级成轻量级锁时，会暂停拥有偏向锁的线程，重置偏向锁标识，这个过程看起来容易，实则开销还是很大的，大概的过程如下：
1. 在一个安全点（在这个时间点上没有字节码正在执行）停止拥有锁的线程。
2. 遍历线程栈，如果存在锁记录的话，需要修复锁记录和Mark Word，使其变成无锁状态。
3. 唤醒被停止的线程，将当前锁升级成轻量级锁。
```
>> 线程获取锁时发生其他锁已经获取，就自旋获取锁 失败就锁膨胀修改为重量级锁。
### 锁的升级流程
![锁状态](https://img-blog.csdnimg.cn/20200603161323889.png)
```markdown
每一个线程在准备获取共享资源时：第一步，检查MarkWord里面是不是放的自己的ThreadId ,如果是，表示当前线程是处于 “偏向锁” 。
第二步，如果MarkWord不是自己的ThreadId，锁升级，这时候，用CAS来执行切换，新的线程根据MarkWord里面现有的ThreadId，
通知之前线程暂停，之前线程将Markword的内容置为空。
第三步，两个线程都把锁对象的HashCode复制到自己新建的用于存储锁的记录空间，接着开始通过CAS操作， 
把锁对象的MarKword的内容修改为自己新建的记录空间的地址的方式竞争MarkWord。
第四步，第三步中成功执行CAS的获得资源，失败的则进入自旋。
第五步，自旋的线程在自旋过程中，成功获得资源(即之前获的资源的线程执行完成并释放了共享资源)，则整个状态依然处于轻量级锁的状态。
第六步，如果自旋失败，进入重量级锁的状态，这个时候，自旋的线程进行阻塞，等待之前线程执行完成并唤醒自己。
```
### 各种锁的优缺点及使用场景
```markdown
偏向锁：通常只有一个线程访问临界区。
轻量级锁：可以有多个线程交替进入临界区，在竞争不激烈的时候，稍微自旋就能获得锁。
重量级锁：线程间出现了激烈的竞争就需要使用重量级锁，此时未获取到锁的线程会进入阻塞队列，需要操作系统介入。
jvm设置偏向锁和轻量级锁，就是为了避免阻塞，避免操作系统的介入。
```
```markdown
锁的状态总共有四种，无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁。
锁                  优点                          缺点                         适用场景

偏向锁    加锁和解锁不需要额外的消耗，         如果线程间存在锁竞争，          适用于只有一个线程访问同步块场景。
        和执行非同步方法比仅存在纳秒级的差距。 会带来额外的锁撤销的消耗。

轻量级锁       竞争的线程不会阻塞，        如果始终得不到锁竞争               追求响应时间。同步块执行速度非常快。
            提高了程序的响应速度。         的线程使用自旋会消耗CPU。

重量级锁  线程竞争不使用自旋，不会消耗CPU。  线程阻塞，响应时间缓慢。          追求吞吐量。同步块执行速度较长。
```
## 第十章：乐观锁和悲观锁及CAS与Atomic
### 乐观锁和悲观锁
[乐观锁和悲观锁](https://www.cnblogs.com/ljl150/p/12506034.html)
```markdown
乐观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，
只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。
乐观锁：偏向锁、轻量级锁、自旋锁
 乐观锁的主要思想是：CAS（compare and swap:比较与交换）
CAS是一种思想，并不是一种锁，它是一种原子操作，通过比较传入的值来判断是否更新，一样则更新，不一样则失败。
 悲观锁：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；
上锁期间其他人不能修改数据。
```
### CAS:Compare and Swap(比较与交换)
```markdown
用于在硬件层面上提供原子性操作，它是一条CPU并发原语。是一种原子操作，也是一种乐观锁的实现思想。
CAS算法涉及到三个操作数：需要读写的内存值V、进行比较的值A、拟写入的新值B。
当且仅当V的值等于A时,CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。
一般情况下是一个自旋操作，即不断的重试。(自旋锁)+unsafe类
注意Unsafe类中的所有的方法都是native修饰的，也就是说Unsafe类中的方法都直接调用操作系统底层资源执行相应任务。
```
[JUC整理笔记一之细说Unsafe](https://www.cnblogs.com/jfound/p/12941947.html)
```markdown
Unsafe在sun.misc下，顾名思义，这是一个不安全的类，因为Unsafe类所操作的并不属于Java标准，Java的一系列内存操作都是交给jvm的，
而Unsafe类却能有像C语言的指针一样直接操作内存的能力，同时也会带来了指针的问题。过度使用Unsafe类的话，会使出错率变得更大，
因此官方才命名为Unsafe，并且不建议使用，连注释的没有。
在java9之后，又出现了一个jdk.internal.misc.Unsafe类，其功能与sun.misc.Unsafe类是一样的，唯一不一样的是在 getSafe() 的时候，
jdk.internal.misc.Unsafe是没有做校验的，但是jdk包下的代码，应用开发时是不能直接调用的，而且在java9之后，两个Unsafe类都有充足的注释。
Unsafe类的功能主要分为内存操作、CAS、Class相关、对象操作、数组相关、内存屏障、系统相关、线程调度等功能。
```
[锁开销优化以及CAS简单说明](https://www.cnblogs.com/cposture/p/10761396.html)
### CAS实现原子操作的三大问题
```markdown
1.ABA问题：就是⼀个值原来是A，变成了B，又变回了A。这个时候使用CAS是检查不出变化的，但实际上却被更新了两次。
解决思路是在变量前面追加上版本号或者时间戳,原子类之AtomicStampedReference可以解决ABA问题。
2.循环时间长开销大：CAS多与自旋结合。如果自旋CAS长时间不成功，会占用大量的CPU资源。
CAS是基于乐观锁的思想实现的，当频繁出现当前值与所旧预期值不相等的情况，会导致频繁的自旋而使得浪费CPU资源。
解决思路是让JVM支持处理器提供的pause指令。
3.只能保证一个共享变量的原子操作：
单纯对共享变量进行CAS操作，只能保证单个，无法使多个共享变量同时进行原子操作。
```
[浅析CAS与AtomicInteger原子类](https://www.cnblogs.com/zengcongcong/p/12751761.html)
>> AtomicInteger类主要利用CAS+volatile和native方法来保证原子操作，从而避免synchronized的高开销，执行效率大大提升。
### atomic的原理
[像宝石一样的Java原子类](https://www.cnblogs.com/upnote/p/12972751.html)
```markdown
 Atomic包中的类基本的特性就是在多线程环境下，当有多个线程同时对单个（包括基本类型及引用类型）变量进行操作时，具有排他性，
即当多个线程同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以向自旋锁一样，继续尝试，一直等到执行成功。
 Atomic系列的类中的核心方法都会调用unsafe类中的几个本地方法。因此atomic证原子性就是通过:自旋+CAS（乐观锁）
 Lock类和Atomic包底层实现都是通过CAS+自旋的方式解决多线程同步问题。Atomic在竞争激烈时能维持常态，比lock性能好，但是只能同步一个变量。
```
### [比AtomicLong更优秀的LongAdder确定不来了解一下吗？](https://www.cnblogs.com/wang-meng/p/12892695.html)
```markdown
count++操作，使用AtomicInteger count = new AtomicInteger();count.addAndGet(1);
如果是JDK8，推荐使用LongAdder对象，比AtomicLong性能更好（减少乐观锁的重试次数）。
AtomicLong：能保证并发情况下计数的准确性，其内部通过CAS来解决并发安全性的问题。
在使用CAS+自旋的过程中，在高并发环境下，N个线程同时进行自旋操作，会出现大量失败并不断自旋的情况，此时AtomicLong的自旋会成为瓶颈。
随着并发的增加，AtomicLong性能是急剧下降的，耗时是LongAdder的数倍。
1、设计思想上，LongAdder采用"分段"的方式降低CAS失败的频次。
2、使用Contended注解来消除伪共享
3、惰性求值
看场景来使用，如果是并发不太高的系统，使用AtomicLong可能会更好一些，而且内存需求也会小一些。
而在高并发统计计数的场景下，才更适合使用LongAdder。
```
## 第十一章：AQS及ReentrantLock
[看看AQS阻塞队列和条件队列](https://www.cnblogs.com/wyq1995/p/12253792.html)
[Java多线程——AQS框架源码阅读](https://www.cnblogs.com/zackku/p/9984887.html)
[java之AQS和显式锁](https://www.cnblogs.com/hongshaodian/p/12452136.html)
>> AQS是AbstractQueuedSynchronizer的简称，即抽象队列同步器
```markdown
AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的同步器，比如我们提到的ReentrantLock，Semaphore，
ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。
```
[ReentrantLock是如何基于AQS实现的](https://www.cnblogs.com/liyus/p/10760411.html)
[多线程高并发编程(3) -- ReentrantLock源码分析AQS](https://www.cnblogs.com/huangrenhui/p/12712475.html)
```markdown
ReentrantLock是一个可重入的互斥锁，因此也可以保证原子性。可重入顾名思义，指的是线程可以重复获取同一把锁。
基于AQS实现，它具有与使用synchronized方法和语句相同的一些基本行为和语义，但功能更强大。
ReentantLock同步方式是独占模式，资源是独占的，一次只能一个线程获取。
```
[JUC之ReentrantLock源码分析](https://www.cnblogs.com/zzw-blog/p/12870196.html)

[ReentrantLock解析及源码分析](https://www.cnblogs.com/bmilk/p/12988395.html)
```markdown
公平竞争：遵从先来后到的规则，先到先得。
非公平竞争：正常情况下是先到先得，但是允许见缝插针。即持有锁的线程刚释放锁，等待队列中的线程刚准备获取锁时，
    突然半路杀出个程咬金，抢到了锁，等待队列中等待获取锁的线程只能干瞪眼，接着等抢到锁的线程释放锁。
非公平锁加锁流程：
　　1.不管线程有没有被持有，先尝试获取锁
　　2.锁未被持有，直接获取锁。
        2.1获取锁成功，结束；
        2.2获取锁失败，封装成CLH队列的Node节点，并进行线程阻塞
　　3.锁被持有。
        3.1线程重入加锁，进行state累加，等待释放锁时进行减除；
        3.2封装成CLH队列的Node节点，并进行线程阻塞
公平锁加锁的流程：
　　1.锁未被持有，尝试直接获取锁。
        2.1获取锁成功，结束；
        2.2获取锁失败，封装成CLH队列的Node节点，并进行线程阻塞
　　     2.锁被持有。
            2.1线程重入加锁，进行state累加，等待释放锁时进行减除；
            2.2封装成CLH队列的Node节点，并进行线程阻塞
锁释放过程：
　　1.先判断当前线程是否可以进行锁释放
　　2.state减除，如果减除后的state为0，就将锁的持有者设为空，并解除下一个等待节点的线程阻塞状态
```
[【漫画】互斥锁ReentrantLock不好用？试试读写锁ReadWriteLock](https://www.cnblogs.com/liuyanling/p/12897748.html)
```markdown
ReentrantLock完美实现了互斥，完美解决了并发问题。但是却意外发现它对于读多写少的场景效率实在不行。
此时ReentrantReadWriteLock来救场了！一种适用于读多写少场景的锁，可以大幅度提升并发效率。是可重用的读写锁。
读写锁最大的特征是允许多个线程同时读共享变量。但是只允许一个线程写共享变量，且如果一个写线程正在执行写操作，此时禁止读线程读共享变量。
```
[【漫画】读写锁ReadWriteLock还是不够快?再试试StampedLock！](https://www.cnblogs.com/liuyanling/p/12905454.html)
```markdown
ReadWriteLock 支持两种模式：一种是读锁，一种是写锁。而StampedLock支持三种模式，分别是：写锁、悲观读锁和乐观读。
```
## 第十二章：线程池和ThreadLocal原理
[学会Java中的线程池，这一篇也许就够了！](https://www.cnblogs.com/wang-meng/p/12945703.html)

[线程池源码探究](https://www.cnblogs.com/NaLanZiYi-LinEr/p/12714607.html)
### 1.为什么要使用线程池，线程池的优势？
```markdown
1. 创建/销毁线程需要消耗系统资源，线程池可以复用已创建的线程。
2. 控制并发的数量。并发数量过多，可能会导致资源消耗过多，从而造成服务器崩溃。（主要原因）
3. 提高线程的统一管理性，可以对线程做统一管理。
```
### 2.线程池都有哪些状态
![线程池状态的变化流转：](https://img2020.cnblogs.com/other/799093/202005/799093-20200524074816572-2061701085.png)
```markdown
 RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务。
    线程池的初始化状态是RUNNING。线程池被一旦被创建，就处于RUNNING状态，并且线程池中的任务数为0。
 SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。
    调用线程池的shutdown()方法时，线程池由RUNNING->SHUTDOWN。
 STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。
    调用线程池的shutdownNow()方法时，线程池由(RUNNING or SHUTDOWN) -> STOP。
 TIDYING：所有的任务都销毁了，workCount为0，线程池的状态在转换为TIDYING状态时，会执行钩子方法terminated()。
因为terminated()在ThreadPoolExecutor类中是空的，所以用户想在线程池变为TIDYING时进行相应的处理；可以通过重载terminated()函数来实现。
 TERMINATED：线程池处在TIDYING状态时，执行完terminated()之后，就会由TIDYING->TERMINATED。
    当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由SHUTDOWN->TIDYING。
    当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP->TIDYING。
```
### 3.线程池中submit()和execute()方法有什么区别
[线程池续：你必须要知道的线程池submit()实现原理之FutureTask！](https://www.cnblogs.com/wang-meng/p/13023710.html)
```markdown
 execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。
    execute()方法输入的任务是一个Runnable类的实例。
 submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，
    并且可以通过future的get()方法来获取返回值，submit()方法输入的任务是一个Callable类的实例。
```
### 4.创建线程池有哪几种方式？
>> Exector——>ExectorService-->AbstractExectorService——>ThreadPoolExecutor——>ScheduledThreadPoolExecutor
>>                         ——>ScheduledExecutorService-->ScheduledThreadPoolExecutor
>> Exectors 
```markdown
快捷创建线程池很简单，只需要调用Executors中相应的静态工厂方法即可
    Executors.newFixedThreadPoll(int);执行一个长期的任务，性能好很多。返回一个固定线程数量的线程池。线程池中的线程数量始终不变。
        当有新的任务提交时，有空闲线程则立即执行否则任务被缓存在一个任务队列中，待有空闲线程时处理。
    Executors.newSingleThreadExecutor();一个任务一个线程执行的任务场景。返回只有一个线程的线程池。
        若多余任务提交到线程池，任务会被保存到任务队列中，待线程空闲，按先入先出的顺序执行。
    Executors.newCacheThreadPool();适用：执行短期异步的小程序或者负载轻的服务器。返回可根据实际情况调整的线程数量的线程池。
    Java8 Executors.newWorkStealingPool(int);java8新增，使用目前机器上可以的处理器作为他的并行级别。
    1）FixedThreadPool和SingleThreadPool：允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。
    2）CachedThreadPool：允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。
    所以阿里巴巴也建议我们要自定义线程池核心线程数以及阻塞队列的长度。
使用ThreadPoolExecutor自定义创建线程池：
阿里巴巴Java开发手册：
    【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。
    【强制】线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor自定义的方式，
        这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。
```
### 5.线程池处理原理和流程
[java线程池原理解析](https://www.cnblogs.com/floor/p/12853748.html)
![](https://img2020.cnblogs.com/blog/1128201/202005/1128201-20200508232041775-1049844965.png)
```markdown
1.在创建了线程池后，等待提交过来的任务请求。
2.当调用execute()方法添加一个请求任务时，线程池会如下判断：
    2.1 如果正在运行的线程数量小于corePoolSize,那么马上创建线程运行这个任务。
    2.2 如果正在运行的线程数数量大于或等于corePoolSize，那么将这个任务放入队列。
    2.3 如果这个时候队列满了且正在运行的线程数量还小于maximumPoolSize,那么还是要创建非核心线程立刻运行这个任务。
    2.4 如果队列满了且正在运行的线程数量大于或等于maximumPoolSize,那么线程池会启动和拒绝策略来执行。
3.当一个线程完成任务时，它会从队列中去下一个任务来执行。
4.当一个线程无事可做超过一定的时间(KeepAliveTime)时，线程池会判断：
    如果当前运行的线程数大于corePoolSize,那么这个线程就被停掉。
    所以线程池的所有任务完成之后它最终会收缩到corePoolSize的大小。
```
### 6.ThreadLocal源码和原理
[并发——深入分析ThreadLocal的实现原理](https://www.cnblogs.com/tuyang1129/p/12713815.html)

[面试官：小伙子，听说你看过ThreadLocal源码？（万字图文深度解析ThreadLocal）](https://www.cnblogs.com/wang-meng/p/12856648.html)
```markdown
ThreadLocal被称作线程局部变量，当我们定义了一个ThreadLocal变量，所有的线程共同使用这个变量，但是对于每一个线程来说，
实际操作的值是互相独立的。简单来说就是，ThreadLocal能让线程拥有自己内部独享的变量。
```
#### TheadLocal原理
```markdown
每一个线程都有一个对应的Thread对象，而Thread类有一个成员变量，它是一个Map集合，这个Map集合的key就是ThreadLocal的引用，
而value就是当前线程在key所对应的ThreadLocal中存储的值。当某个线程需要获取存储在ThreadLocal变量中的值时，
ThreadLocal底层会获取当前线程的Thread对象中的Map集合，然后以ThreadLocal作为key，从Map集合中查找value值。
这就是ThreadLocal实现线程独立的原理。也就是说，ThreadLocal能够做到线程独立，是因为值并不存在ThreadLocal中，而是存储在线程对象中。
ThreadLocal中的get方法：get方法的作用非常简单，就是线程向ThreadLocal中取值。
ThreadLocal的set方法的实现，set方法用来使线程向ThreadLocal中存放值（实际上是存放在线程自己的Map中）。
```
#### ThreadLocalMap数据结构
```markdown
线程向ThreadLocal中存放的值，最后都放入了线程自己的ThreadLocalMap中，而这个map的key就是当前ThreadLocal的引用。
ThreadLocalMap的实现其实就是一个比较普通的Map集合，它的实现和HashMap类似:
    key值虽然使用的弱引用，但是value使用的却是强引用。
    这会造成key被JVM回收，但是value却无法被收，key对应的ThreadLocal被回收后，key变为了null，但是value却还是原来的value，
    因为被ThreadLocalMap所引用，将无法被JVM回收。若value所占内存较大，线程较多的情况下，将持续占用大量内存，甚至造成内存溢出。
    ThreadLocal实现线程独立的方式是直接将值存放在Thread对象的ThreadLocalMap中，Map的key就是ThreadLocal的引用，
    且为了有助于JVM进行垃圾回收，key使用的是弱引用。在使用ThreadLocal后，一定要记得调用remove方法，有助于JVM对value的回收。
```
[java线程池原理及源码分析](https://www.cnblogs.com/nijunyang/p/12941653.html)
### 7.[Java并发编程：线程池ThreadPoolExecutor](https://www.cnblogs.com/lbhym/p/12919352.html)
```markdown
//创建一个大小为10的固定线程池
ExecutorService threadpool= Executors.newScheduledThreadPool(10);
下面简单介绍一下这些工厂方法：
newFixedThreadPool()方法：固定线程数量线程池。传入的数字就是线程的数量，如果有空闲线程就去执行任务，如果没有空闲线程就会把任务放到一个任务队列，等到有线程空闲时便去处理队列中的任务。
newSingleThreadExecutor()方法：只有一个线程的线程池。同样，超出的任务会被放到任务队列，等这个线程空闲时就会去按顺序处理。
newCachedThreadPool()方法：可以根据实际情况拓展的线程池。当没有空闲线程去执行新任务时，就会再创建新的线程去执行任务，执行完后新建的线程也会返回线程池进行复用。
newSingleThreadScheduledExecutor()方法：返回的是ScheduledExecutorService对象。ScheduledExecutorService是继承于ExecutorService的，
    有一些拓展方法，如指定执行时间。这个线程池大小为1，在指定时间执行任务。关于指定时间的几个方法：schedule()是在指定时间后执行一次任务。
scheduleAtFixedRate()和方法scheduleWithFixedDelay()方法，两者都是周期性的执行任务，但是前者是以上一次任务开始为周期起点，后者是以上一次任务结束为周期起点。
newScheduledThreadPool()方法：和上面一个方法一样，但是可以指定线程池大小，其实上面那个方法也是调用这个方法的，只是传入的参数是1。
```
#### 线程池ThreadPoolExecutor方法参数介绍
```markdown
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler)
        参数从上到下，作用依次为：
        　　1.corePoolSize:指定线程池种线程的数量。
        　　2.maximumPoolSize:线程池种最大的线程数量，也就是最大能拓展到多少。
        　　3.keepAliveTime:当线程数量超过corePoolSize，多余的空闲线程多久会被销毁。
        　　4.unit:keepAliveTime的单位。
        　　5.workQueue:任务队列(阻塞队列)，当空闲线程不够，也不能再新建线程时，新提交的任务就会被放到任务阻塞队列中。
        　　6.threadFactory:线程工厂，用于创建线程，默认的即可。
        　　7.handler:拒绝策略。当任务太多，达到最大线程数量、任务队列也满了，该如何拒绝新提交的任务。
```
#### 任务队列
```markdown
任务队列是一个BlockingQueue(阻塞队列)接口，在ThreadPoolExecutor一共有如下几种实现类实现了BlockingQueue接口。
1.SynchronousQueue：直接提交队列。这种队列其实不会真正的去保存任务，每提交一个任务就直接让空闲线程执行，如果没有空闲线程就去新建，
当达到最大线程数时，就会执行拒绝策略。所以使用这种任务队列时，一般会设置很大的maximumPoolSize，不然很容易就执行了拒绝策略。
newCachedThreadPool线程池的corePoolSize为0，maximumPoolSize无限大，它用的就是直接提交队列。
2.ArrayBlockingQueue：有界任务队列，其构造函数必须带一个容量参数，表示任务队列的大小。当线程数量小于corePoolSize时，有任务进来优先创建线程。
当线程数等于corePoolSize时，新任务就会进入任务队列，当任务队列满了，才会创建新线程，线程数达到maximumPoolSize时执行拒绝策略。
3.LinkedBlockingQueue：无界任务队列，通过它的名字也应该知道了，它是个链表，除非没有空间了，不然不会出现任务队列满了的情况，但是非常耗费系统资源。
和有界任务队列一样，线程数若小于corePoolSize，新任务进来时没有空闲线程的话就会创建新线程，当达到corePoolSize时，就会进入任务队列。
会发现没有maximumPoolSize什么事，newFixedThreadPool固定大小线程池就是用的这个任务队列，它的corePoolSize和maximumPoolSize相等。
4.PriorityBlockingQueue：优先任务队列，它是一个特殊的无界队列，因为它总能保证高优先级的任务先执行。
```
#### 拒绝策略
```markdown
拒绝策略:当任务太多，达到最大线程数量、任务队列也满了，该如何拒绝新提交的任务。
JDK提供了四种拒绝策略。
　　1.AbortPolicy：直接抛出异常，阻止系统正常工作。
　　2.CallerRunsPolicy：如果线程池未关闭，则在调用者线程里面执行被丢弃的任务，这个策略不是真正的拒绝任务。
        比如我们在T1线程中提交的任务，那么该拒绝策略就会把多余的任务放到T1线程执行，会影响到提交者线程的性能。
　　3.DiscardOldestPolicy：该策略会丢弃一个最老的任务，也就是即将被执行的任务，然后再次尝试提交该任务。
　　4.DiscardPolicy：直接丢弃多余的任务，不做任何处理，如果允许丢弃任务，这个策略是最好的。
以上内置的拒绝策略都实现了RejectedExecutionHandler接口，所以当上面的拒绝策略无法满足你的要求，
    可以自定义一个：继承RejectedExecutionHandler并实现rejectedExecution方法。
```
#### ThreadPoolExecutor核心线程池中线程预热功能？
```markdown
在创建线程池后，可以使用prestartAllCoreThreads()来预热核心线程池。
public int prestartAllCoreThreads() {
    int n = 0;
    while (addWorker(null, true))
        ++n;
    return n;
}
```
#### ThreadPoolExecutor中创建的线程如何被复用的？
```markdown
这个主要是看runWorker()和getTask()两个方法的执行流程，当执行任务时调用runWorker()方法，执行完成后会继续从
workQueue中获取任务继续执行，已达到线程复用的效果，当然这里还有一些细节，可以回头看看上面的源码解析。
```
#### ThreadPoolExecutor中关闭线程池的方法shutdown与shutdownNow的区别？
```markdown
* shutdown()会将线程池状态变为SHUTDOWN，此时新任务不能被提交，workQueue中还存有的任务可以继续执行，同时会像线程池中空闲的状态发出中断信号。
* shutdownNow()方法是将线程池的状态设置为STOP，此时新任务不能被提交，线程池中所有线程都会收到中断的信号。
    如果线程处于wait状态，那么中断状态会被清除，同时抛出InterruptedException。
```
#### ThreadPoolExecutor中存在的一些扩展点？
```markdown
钩子方法：
1）beforeExecute()/afterExecute()：runWorker()中线程执行前和执行后会调用的钩子方法
2）terminated：线程池的状态从TIDYING状态流转为TERMINATED状态时terminated方法会被调用的钩子方法。
3）onShutdown：当我们执行shutdown()方法时预留的钩子方法。
```
#### ThreadPoolExecutor支持动态调整核心线程数、最大线程数、队列长度等一些列参数吗？怎么操作？
```markdown
运行期间可动态调整参数的方法：
1）setCorePoolSize()：动态调整线程池核心线程数
2）setMaximumPoolSize()：动态调整线程池最大线程数
3）setKeepAliveTime(): 空闲线程存活时间，如果设置了allowsCoreThreadTimeOut=true，核心线程也会被回收，默认只回收非核心线程
4）allowsCoreThreadTimeOut()：是否允许回收核心线程，如果是true，在getTask()方法中，获取workQueue就采用workQueue.poll(keepAliveTime)，如果超过等待时间就会被回收。
```
## 第十三章：阻塞队列
[【高并发】不废话，言简意赅介绍BlockingQueue](https://www.cnblogs.com/binghe001/p/12723469.html)

[Java中常用七个阻塞队列的总结](https://www.cnblogs.com/kaigejava/p/12825493.html)
```markdown
队列的分类，可以分为两类，即阻塞队列和非阻塞队列。
    - 常用的三个非阻塞队列：LinkedList、PriorityQueue和ConcurrentLinkedQueue.
    - 队列是Collection的子类 Collection->Queue->BlockingQueue-->七个BlockingQueue
* 阻塞队列有存在的意义。
* 不得不阻塞，如何管理。
为什么需要阻塞队列。
    好处是我们不需要关心什么时候需要阻塞队列，什么时候需要唤醒线程，因此这一切BlockingQueue都包办了。
阻塞队列的使用场景
    - 生产者消费者模式
    - 线程池
    - 消息中间件
```
### BlockingQueue的实现类
```markdown
java.util.concurrent.BlockingQueue 接口有以下阻塞队列的实现：阻塞队列，是线程安全的。主要在生产者和消费者场景。
    - ArrayBlockingQueue 由数组结构组成的有界阻塞队列。内部结构是数组，故具有数组的特性。 有界
    [Java经典面试题：聊一聊JUC下的LinkedBlockingQueue](https://www.cnblogs.com/jamaler/p/12849927.html)
    - LinkedBlockingQueue 由链表结构组成的有界阻塞队列。内部结构是链表，具有链表的特性。 有界(Integer.MAX_VALUE)
    - DelayQueue 该队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素，支持延时优先级。 数组 无界
    - PriorityBlockingQueue 基于优先级的无界阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定）。数组 无界
    - SynchronousQueue队列比较特殊，没有任何内部容量，甚至连一个队列的容量都没有。并且每个put必须等待一个take，反之亦然。链表，不存放元素
    - LinkedTransferQueue 链表 无界 链表的无界阻塞队列。
    - LinkedBlockingDeque 链表 无界 双端数组队列。
```
[30分钟带你了解阻塞队列所有内容，再也不怕面试官刁难你了！(上)](https://www.cnblogs.com/lewisyoung/p/12981102.html)
## 第十四章 锁接口与类
### 锁的分类：
```markdown
可重入锁(递归锁)和非可重入锁：
    就是支持重新进入的锁，也就是说这个锁支持一个线程对资源重复加锁。线程可以进入任何一个它拥有的锁所同步着的代码块。
    ReentrantLock、synchronized是可重入锁。可重入锁的最大优点是避免死锁。
公平锁与非公平锁：
    如果对一个锁来说，先对锁获取请求的线程一定会先被满足，后对锁获取请求的线程后被满足，那这个锁就是公平的。
    公平锁先到先得；非公平锁一上来就尝试获取锁，非公平锁的有点在于吞吐量比公平锁大。
    对于synchronized而言，也是一种非公平锁。ReentrantLock默认是非公平锁，可以通过构造方法设置。
读写锁/独占锁共享锁和排它锁/互斥锁：
    读写锁可以在同一时刻允许多个读线程访问，排它锁在同一时刻只允许一个线程进行访问。
    ReentrantReadWriteLock其读锁时共享锁，其写锁是独占锁。
自旋锁：
    自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁。
    这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。
```
>> 抽象类AQS/AQLS/AOS
>> 接口Condition/Lock/ReadWriteLock
## 第十五章 并发集合容器
>> Vector和HashTable是线程安全的容器类，
>> 但是这些容器实现同步的方式是通过对方法加锁(sychronized)方式实现的，这样读写均需要锁操作，导致性能低下。
[ConcurrentHashMap实现原理及源码分析](https://www.cnblogs.com/chengxiao/p/6842045.html)
### 并发Map
```markdown
ConcurrentMap接口:继承了Map接口，在Map接口的基础上又定义了四个方法：
putIfAbsent：与原有put方法不同的是，putIfAbsent方法中如果插入的key相同，则不替换原有的value值；
remove：与原有remove方法不同的是，新remove方法中增加了对value的判断，如果要删除的key-value不能与Map中原有的key-value对应上，则不会删除该元素;
replace(K,V,V)：增加了对value值的判断，如果key-oldValue能与Map中原有的key-value对应上，才进行替换操作；
replace(K,V)：与上面的replace不同的是，此replace不会对Map中原有的key-value进行比较，如果key存在则直接替换；

ConcurrentHashMap类
ConcurrentHashMap同HashMap一样也是基于散列表的map，但是它提供了一种与HashTable完全不同的加锁策略提供更高效的并发性和伸缩性。
ConcurrentHashMap提供了一种粒度更细的加锁机制来实现在多线程下更高的性能，这种机制叫分段锁(Lock Striping)。
提供的优点是：在并发环境下将实现更高的吞吐量，而在单线程环境下只损失非常小的性能。
可以这样理解分段锁，就是将数据分段，对每一段数据分配一把锁。当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。
```
### 并发Queue
>> ConcurrentLinkedDeque和ConcurrentLinkedQueue。
### 并发Set
>> ConcurrentSkipListSet
## 第十六章 CopyOnWrite容器
```markdown
写入时复制思想:就是当有多个调用者同时去请求一个资源数据的时候，有一个调用者出于某些原因需要对当前的数据源进行修改，
这个时候系统将会复制一个当前数据源的副本给调用者修改。
```
>>CopyOnWrite容器即写时复制的容器,当我们往一个容器中添加元素的时候，不直接往容器中添加，而是将当前容器进行copy，
>>复制出来一个新的容器，然后向新容器中添加我们需要的元素，最后将原容器的引用指向新容器。

>> CopyOnWriteArrayList
[浅析CopyOnWriteArrayList](https://www.cnblogs.com/zengcongcong/p/12754067.html)
[Java经典面试题：聊一聊JUC下的 CopyOnWriteArrayList](https://www.cnblogs.com/jamaler/p/12843126.html)
## 第十七章 通信工具类及并发工具类CountDownLatch等等
[java线程并发工具类](https://www.cnblogs.com/hongshaodian/p/12452105.html)
```markdown
主要讲Fork-Join、CountDownLatch、CyclicBarrier以及Callable、Future和FutureTask，最后再手写一个自己的FutureTask。
```
### 同步工具类 —— CountDownLatch
>> CountDownLatch 线程等待直到计数器减为0时开始工作
[同步工具类—— CountDownLatch](https://www.cnblogs.com/54chensongxia/p/12721925.html)
[CountDownLatch是个啥？](https://www.cnblogs.com/zhangweicheng/p/12679116.html)
[并发——深入分析CountDownLatch的实现原理](https://www.cnblogs.com/tuyang1129/p/12692423.html)
```markdown
CountDownLatch是JDK并发包中提供的一个同步工具类,主要功能是让一个或者多个线程等待其他线程线程执行完成之后才继续执行。
CountDownLatch重要的API
    - getCount()：获取当前count的值。
    - wait()：让当前线程在此CountDownLatch对象上等待，可以中断。与notify()、notifyAll()方法对应。
    - await()：让当前线程等待此CountDownLatch对象的count变为0，可以中断。
    - await(timeout,TimeUnit)：让当前线程等待此CountDownLatch对象的count变为0，可以超时、可以中断。
    - countDown()：使此CountDownLatch对象的count值减1(无论执行多少次，count最小值为0)。
使用场景
    场景一：将任务分割成多个子任务，每个子任务由单个线程去完成，等所有线程完成后再将结果汇总。
    （MapReduce）这种场景下，CountDoenLatch作为一个完成信号来使用。
    场景二：多个线程等到，一直等到某个条件发生。比如多个赛跑运动员都做好了准备，就等待裁判手中的发令枪响。
    这种场景下，就可以将CountdownLatch的初始值设置成1。
CountDownLatch的实现原理
    CountDownLatch的实现原理主要是通过内部类Sync来实现的，内部类Sync是AQS的子类，主要是通过重写AQS的共享式获取和释放同步状态方法来实现的。
    1、初始化CountDownLatch实际就是设置了AQS的state为计数的值
    2、调用CountDownLatch的countDown方法时实际就是调用AQS的释放同步状态的方法，每调用一次就自减一次state值
    3、调用await方法实际就调用AQS的共享式获取同步状态的方法acquireSharedInterruptibly(1)，这个方法的实现逻辑就调用子类Sync的tryAcquireShared方法，
    只有当子类Sync的tryAcquireShared方法返回大于0的值时才算获取同步状态成功，否则就会一直在死循环中不断重试，直到tryAcquireShared方法返回大于等于0的值，
    而Sync的tryAcquireShared方法只有当AQS中的state值为0时才会返回1，否则都返回-1，也就相当于只有当AQS的state值为0时，await方法才会执行成功，否则就会一直处于死循环中不断重试。
CountDownLatch总结
    CountDownLatch的初始值不能重置，只能减少不能增加，最多减少到0；后续再执行countDown方法的效果就无效了。
    当CountDownLatch计数值没减少到0之前，调用await方法可能会让调用线程进组一个阻塞队列，等待计数值减小到0；
    调用countDown方法会让计数值每次都减小1，但是最多减少到0。当CountDownLatch的计数值减少到0的时候，会唤醒所有在阻塞队列中的线程。
    CountDownLatch实际完全依靠AQS的共享式获取和释放同步状态来实现，初始化时定义AQS的state值，每调用countDown实际就是释放一次AQS的共享式同步状态，
    await方法实际就是尝试获取AQS的同步状态，只有当同步状态值为0时才能获取成功。
```
[多线程高并发编程(5) -- CountDownLatch、CyclicBarrier源码分析](https://www.cnblogs.com/huangrenhui/p/12744230.html)
### CyclicBarrier 作用跟CountDownLatch类似，但是可以重复使用
[并发工具——CyclicBarrier](https://www.cnblogs.com/54chensongxia/p/12752749.html)
```markdown
CyclicBarrier拥有CountDownLatch的所有功能，还可以使用reset()方法重置屏障。用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。
CyclicBarrier的主要功能是一组线程互相等待，线程全部到达同步点后这些线程才继续往下工作。
实现的原理是：先到达的线程调用Condition的await方法，进入waiting状态。最后一个到达的线程会调用signalAll方法唤醒所有线程继续往下工作。
前面我们介绍了CyclicBarrier，可以发现它在构造方法里传入“任务总量”parties之后，就不能修改这个值了，
并且每次调用await()方法也只能消耗一个parties计数。但Phaser可以动态地调整任务总量！
CyclicBarrier有两个构造函数，其中parties指示计数器的初始值，barrierAction在所有线程都到达屏障的时候会执行一次。
```
[Java并发包5--同步工具CountDownLatch、CyclicBarrier、Semaphore的实现原理解析](https://www.cnblogs.com/jackion5/p/12932343.html)
### CyclicBarrier和CountDownLatch的区别
```markdown
CountDownLatch和CyclicBarrier实现的效果看似都是某个线程等待一组线程达到条件之后才可继续执行，但是实际上两者存在很多区别。
区别一：强调的重点不一样
    CountDownLatch更加强调一组线程等待另外一组线程。--
    CyclicBarrier更加强调一组线程之间的互相等待。++
区别二：可重用性不一样  
    CountDownLatch计数归零后就不能重复利用了，但是CyclicBarrier可以reset进行重复利用。
1、CountDownLatch阻塞的是调用await()的线程，不会阻塞达到条件的线程；CyclicBarrier阻塞的是达到同步屏障的所有线程
2、CountDownLatch采用倒数计数，定义数量之后，每当一个线程达到要求之后就减一；CyclicBarrier是正数计数，当数量达到定义的数量之后就打开同步屏障
3、CountDownLatch仅单次有效，不可重复使用；CyclicBarrir可以循环重复使用
4、CountDownLatch定义的数量和实际线程数无关，可以有一个线程执行多次countDown()；CyclicBarrier定义的数量和实际线程数一致，
    必须由多个线程都达到要求执行才行(线程调用await()方法之后就会被阻塞，想调用多次也不行的)
5、CountDownLatch是通过内部类Sync继承AQS来实现的；CyclicBarrier是通过重入锁ReentrantLock来实现的
6、CountDownLatch不可重置；CyclicBarrier可以调用reset方法进行重置
```
### Semaphore限制线程的数量
#### [并发工具类——Semaphore](https://www.cnblogs.com/54chensongxia/p/12871187.html)
```markdown
Semaphore字面意思是信号量，实际可以看作是一个限流器，初始化Semaphore时就定义好了最大通行证数量，每次调用时调用方法来消耗，
    业务执行完毕则释放通行证，如果通行证消耗完，再获取通行证时就需要阻塞线程直到有通行证可以获取。
信号量的主要目的是：一个是用于多个共享资源的互斥使用，另一个是用于并发线程数的控制。
    * Semaphore只能用来做线程同步——控制线程的执行顺序，但是并不能保证线程安全；Semaphore并不能保证共享变量的可见性。
    * Semaphore主要用来控制线程的并发数量，通常用在限流组件中。
    * Semaphore基于AQS机制实现。
内部有一个继承了AQS的同步器Sync，重写了tryAcquireShared方法。在方法里，会去尝试获取资源。
如果获取失败（想要的资源数量小于目前已有的资源数量），就会返回一个负数（代表尝试获取资源失败）。然后当前线程就会进入AQS的等待队列。
Semaphore的实现全部是通过其内部类Sync来实现了，Sync也是AQS的子类，Semaphore的实现方式基本上和ReentrantLock的实现原理如出一辙。
```
#### [Semaphore面试](https://www.cnblogs.com/heihaozi/p/13063895.html)
```markdown
Semaphore是JDK提供的一个同步工具，它通过维护若干个许可证来控制线程对共享资源的访问。如果许可证剩余数量大于零时，线程则允许访问该共享资源；
如果许可证剩余数量为零时，则拒绝线程访问该共享资源。Semaphore所维护的许可证数量就是允许访问共享资源的最大线程数量。
所以，线程想要访问共享资源必须从Semaphore中获取到许可证。
Semaphore常用的方法:有acquire方法和release方法。当调用acquire方法时线程就会被阻塞，直到Semaphore中可以获得到许可证为止，然后线程再获取这个许可证。
当调用release方法时将向Semaphore中添加一个许可证，如果有线程因为获取许可证被阻塞时，它将获取到许可证并被释放；如果没有获取许可证的线程，Semaphore只是记录许可证的可用数量。
```
### Exchanger两个线程交换数据
```markdown
Exchanger类用于两个线程交换数据。它支持泛型，也就是说你可以在两个线程之间传送任何数据。
```
## 第十八章 Fork/Join框架
```markdown
Fork/Join框架是一个实现了ExecutorService接口的多线程处理器，为那些可以通过递归分解成更细小的任务而设计，最大化的利用多核处理器来提高应用程序的性能。
与其他ExecutorService相关的实现相同的是，Fork/Join框架会将任务分配给线程池中的线程。Fork/Join框架在执行任务时使用了工作窃取算法。
工作窃取算法指的是在多线程执行不同任务队列的过程中，某个线程执行完自己队列的任务后从其他线程的任务队列里窃取任务来执行。
```
## 第十九章 Java8 Stream并行计算原理
### [Java8中创建Stream流有哪几种方式？](https://www.cnblogs.com/binghe001/p/12961977.html)
```markdown
Stream是Java8中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。
使用Stream API对集合数据进行操作，类似于使用SQL执行的数据库查询。也可以使用Stream API来并行执行操作。简言之，Stream API提供了一种高效且易于使用的处理数据的方式。
流：流就是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。“集合讲的是数据，流讲的是计算！ ”
注意：
    ①Stream 自己不会存储元素。
    ②Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。
    ③Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。
如何创建Stream流？
    （1）通过Collection系列集合提供的stream()方法或者parallelStream()方法来创建Stream。
    （2）通过Arrays中的静态方法stream()获取数组流。
    （3）通过Stream类的静态方法of()获取数组流。
    （4）创建无限流:可以使用静态方法 Stream.iterate() 和Stream.generate(), 创建无限流。
    （5）创建空流
Stream API 可以声明性地通过 parallel() 与sequential() 在并行流与串行流之间进行切换 。
```
### [Stream API有哪些中间操作](https://www.cnblogs.com/binghe001/p/12969825.html)
```markdown
Stream的中间操作:整体上可以分为：筛选与切片、映射、排序。
筛选与切片API:    
    filter()方法主要是用于接收Lambda表达式，从流中排除某些元素。
    limit()方法主要作用为：截断流，使其元素不超过给定数量。
    skip()方法跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素 不足 n 个，则返回一个空流。与 limit(n) 互补。
    distinct()方法筛选，通过流所生成元素的hashCode()和equals()去除重复元素。distinct需要实体中重写hashCode()和equals()方法才可以使用。
映射:
    map()方法接收一个函数作为参数，该函数会被应用到每个元 素上，并将其映射成一个新的元素。
    flatMap()接收一个函数作为参数，将流中的每个值都换成另 一个流，然后把所有流连接成一个流。
排序:
    sorted有两种方法，一种是不传任何参数，叫自然排序，还有一种需要传Comparator接口参数，叫做定制排序。
```
### [谈谈Java8中的Stream API有哪些终止操作？](https://www.cnblogs.com/binghe001/p/12984967.html)
```markdown
在Java8中，Stream的终止操作可以分为：查找与匹配、规约和收集。
查找与匹配:
    1.allMatch()方法表示检查是否匹配所有元素。注意：使用allMatch()方法时，只有所有的元素都匹配条件时，allMatch()方法才会返回true。
    2.anyMatch()方法表示检查是否至少匹配一个元素。注意：使用anyMatch()方法时，只要有任意一个元素符合条件，anyMatch()方法就会返回true。
    3.noneMatch()方法表示检查是否没有匹配所有元素。注意：使用noneMatch()方法时，只有所有的元素都不符合条件时，noneMatch()方法才会返回true。
    4.findFirst()方法表示返回第一个元素。
    5.findAny()方法表示返回当前流中的任意元素。
    6.count()方法表示返回流中元素总数。
    7.max()方法表示返回流中最大值。
    8.min()方法表示返回流中最小值。
    9.forEach()方法表示内部迭代(使用Collection接口需要用户去做迭代，称为外部迭代。
规约:
    reduce(T iden, BinaryOperator b)	可以将流中元素反复结合起来，得到一个值。 返回 T
    reduce(BinaryOperator b)	可以将流中元素反复结合起来，得到一个值。 返回 Optional
收集:    
    collect(Collector c)	将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法
```
### [Stream 源码分析](https://www.cnblogs.com/zhuxudong/p/10152663.html)
```markdown
Stream
支持顺序和并行聚合操作的一组元素序列。
    1）operations：支持在单个元素上执行的操作，流操作分为中间操作和终止操作
    1-1）中间操作：
        1-1-1）无状态：unordered()、filter()、map()、mapToInt()、mapToLong()、mapToDouble、
                      flatMap()、flatMapToInt()、flatMapToLong()、flatMapToDouble()、
                      peek()
        1-1-2）有状态：distinct()、sorted()、limit()、skip()
    1-2）终止操作：
        1-2-1）非短路操作：forEach()、forEachOrdered()、toArray()、min()、max()、count()、
                      collect()、reduce()
        1-2-2）短路操作： findFirst()、findAny()、anyMatch()、noneMatch()、allMatch()
    2）stream pipeline：将多个流操作串联的流管道
流是延迟处理的，直到遇到一个终止操作时，才会触发流管道计算。
已经执行终止操作的流不能再次触发计算。
```
## 第二十章 计划任务
```markdown
自JDK 1.5 开始，JDK提供了ScheduledThreadPoolExecutor类用于计划任务（又称定时任务）
```

## 基础线程机制 -- cyc2018
```markdown
Executor:    
    Executor管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。
    主要有三种 Executor：
        CachedThreadPool：一个任务创建一个线程；
        FixedThreadPool：所有任务只能使用固定大小的线程；
        SingleThreadExecutor：相当于大小为 1 的 FixedThreadPool。
Daemon:
    守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。
    当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。
    main() 属于非守护线程。使用 setDaemon() 方法将一个线程设置为守护线程。
sleep():
    Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。
    sleep()可能会抛出InterruptedException，因为异常不能跨线程传播回main()中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。
yield():    
    对静态方法Thread.yield()的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。
    该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。
```

## 准备阅读
[参考博客：随笔分类 - Java多线程](https://www.cnblogs.com/ljl150/category/1657632.html)
[参考博客：随笔分类 - Java Concurrency](https://www.cnblogs.com/zzq6032010/category/1466867.html)
[随笔分类 - 多线程、并发](https://www.cnblogs.com/longfurcat/category/1273128.html)
[随笔分类 - 02. 多线程与Java](https://www.cnblogs.com/noteless/category/1394612.html)
[随笔分类 - JUC](https://www.cnblogs.com/pony1223/category/1241236.html)

[【深入AQS原理】我画了35张图就是为了让你深入 AQS](https://www.cnblogs.com/wang-meng/p/12816829.html )
[一篇博客带你轻松应对java面试中的多线程与高并发](https://www.cnblogs.com/jichi/p/12854685.html)
[由浅入深的介绍实现高并发的各个细节](https://www.cnblogs.com/binghe001/category/1648522.html)
[Java的每个Thread都希望拥有自己的名称](https://www.cnblogs.com/-beyond/p/12943023.html#top)
### [Java并发编程：线程和锁的使用与解析](https://www.cnblogs.com/lbhym/p/12913280.html)

### [朴实的聊聊很多人会误解/不懂的Java并发中断机制](https://www.cnblogs.com/FraserYu/p/12921773.html)
```markdown
中断机制是 AQS API实现的一部分，更贯穿于整个并发编程内容中。
中断是一种【协同】机制。
interrupt() VS isInterrupted() VS interrupted()。
中断机制的使用场景
通常，中断的使用场景有以下几个
    点击某个桌面应用中的关闭按钮时（比如你关闭 IDEA，不保存数据直接中断好吗？）；
    某个操作超过了一定的执行时间限制需要中止时；
    多个线程做相同的事情，只要一个线程成功其它线程都可以取消时；
    一组线程中的一个或多个出现错误导致整组都无法继续时；
因为中断是一种协同机制，提供了更优雅中断方式，也提供了更多的灵活性，所以当遇到如上场景等，我们就可以考虑使用中断机制了
JDK 中有哪些使用中断机制的地方呢？
    1).ThreadPoolExecutor中的 shutdownNow 方法会遍历线程池中的工作线程并调用线程的 interrupt 方法来中断线程
    2).FutureTask 中的 cancel 方法，如果传入的参数为 true，它将会在正在运行异步任务的线程上调用 interrupt 方法，
    如果正在执行的异步任务中的代码没有对中断做出响应，那么 cancel 方法中的参数将不会起到什么效果
```
## 并发源码解析
[java juc包概述](https://blog.csdn.net/h2604396739/article/details/102576408?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159152131119725247642595%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=159152131119725247642595&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v25-16-102576408.nonecase&utm_term=java+JUC)

[透彻理解Java并发编程系列](https://segmentfault.com/a/1190000015558984)

[随笔分类 - 并发编程源码分析](https://www.cnblogs.com/java-chen-hao/category/1342902.html)
### 
[ReentrantReadWriteLock源码分析及理解](https://www.cnblogs.com/bmilk/p/13044892.html)

[Java多线程——ReentrantReadWriteLock源码阅读](https://www.cnblogs.com/zackku/p/9993126.html)
```markdown

```
[深入学习ThreadLocal原理源码](https://www.cnblogs.com/volcano-liu/p/10712524.html)

## 并发面试题
### [阿里一道Java并发面试题 (详细分析篇)](https://www.cnblogs.com/jiangxinlingdu/p/10842321.html)
>> 多线程并发的同时进行set、get操作，A线程调用set方法，B线程并不一定能对这个改变可见！！！
>> synchronized对需要同步的代码加锁，使得每一次只有一个线程可以进入同步块（其实是一种悲观策略）从而保证线程之间得安全性。
>> Java 内存模型 happens-before原则:如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。
>> volatile 禁止内存重排序并且保证了多线程下的可见性。
>> synchronized关键字可以去掉，仅仅用volatile即可。
```java
public class ThreadSafeCache{
    int result;
    
    public int getResult(){
        return result;
    }
    
    public synchronized void setResult(int result){
        this.result = result;
    }    
    
    public static void main(String[] args) {
            ThreadSafeCache threadSafeCache = new ThreadSafeCache();
    
            for (int i = 0; i < 8; i++) {
                new Thread(() -> {
                    int x = 0;
                    while (threadSafeCache.getResult() < 100) {
                        x++;
                    }
                    System.out.println(x);
                }).start();
            }
    
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
    
            threadSafeCache.setResult(200);
        }
}
```
### [获得多个子线程的结果，面试和工作中你会遇到的多线程问题](https://www.cnblogs.com/haly/p/10732332.html)
```markdown
主线程必须要等2个子线程执行完，拿到子线程的结果进行相加，得到最终结果。
方案一： 使用thread.join()实现
    java中的join方法可以控制线程的执行顺序，这个方案主要是考察线程的join方法原理，以及thread的实现方式。
    如果在主线程mian()中调用子线程的join()方法，就会阻塞主线程，直到子线程执行完，在唤起主线程继续执行。
 方案一注意：
1. join()一定要在start()方法之后调用。所以如果多个子线程执行，要先循环执行完子线程的start()方法，再循环执行join()方法，这样才能变成并行执行。
如果执行一个子线程的start()方法后，就直接执行这个子线程的join()方法，由于主线程阻塞主了，所以需要等这个线程执行完，后面的线程才能执行，就变成串行的了。
2. 每个子线程计算的返回值，我们目前是用子线程里的变量保存实现的，我们也可以用主线程的引用类型当作共享变量实现（这个要考虑并发下，线程安全问题）。
方案二：使用Future和Callable实现
    Future是可以保存返回值的，Future封装了多个方法，可以很好的获取线程执行状态，以及异常处理
方案二注意：
1. Future接口调用get()方法取得处理的结果值时是阻塞性的，如果调用Future对象的get()方法时，任务尚未执行完成，则调用get()方法时一直阻塞到此任务完成为止。
如果这样，则前面先执行的任务一旦耗时很多，后面的任务调用get()方法就呈阻塞状态，也就是排队进行等待。
主线程并不能保证首先获得结果的是最先完成任务线程的返回值，大大影响运行效率。那么使用多线程就没什么意义了。
幸运的是JDK并发包也提供了CompletionService接口可以解决这个问题，它的take()方法哪个线程先完成就先获取谁的Futrue对象。
方案三：使用CountDownLatch实现
    CountDownLatch是通过一个计数器来实现的，计数器的初始值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就会减1。
    当计数器值到达0时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。
方案三注意:
1. CountDownLatch的缺点是CountDownLatch是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当CountDownLatch使用完毕后，它不能再次被使用。
2.countDownLatch.countDown()最好在finally块中执行，防止子线程没有执行完，就自减1了，导致主线程没有等到所有子线程执行完，便执行了。
```

## 并发工作使用 
### [多线程注意事项和获取子线程何时都执行完毕](https://www.cnblogs.com/Simple-Object/p/10740790.html)
```markdown
实现Runnable接口类需要注意事项
    1.事务失效:在Runnable实现类里，是不支持事务的。就新写了一个类，把主要的业务方法全放到那个类里，再测试，发现事务可以正常回滚。
    2.注解无效:实现Runnable接口的类不受spring监管，所以spring的一些注解就不能使用了。
    解决办法：
    1.可以参考下面这样写，可以获得你想要用的类。
        ApplicationContext ctx = new ApplicationContext();
        ctx.getBean(你想要获取的类名.class);
    2.那就是在调用多线程实现类之前，在其他类里用spring的一些注解，获得你想要的类，然后通过参数方式，传到多线程实现类里面。
如何知道多个线程都执行完毕了呢？
//线程池
private ExecutorService threadPool;
//分配线程任务
for (int i=0; i<5; i++) {
     threadPool.execute(new RunHandler());
}
//关闭线程池，此时执行的线程不会立刻关闭，而是线程池不再接受新的线程请求了，线程执行完会被回收掉。
threadPool.shutdown();
while(true){
    if(threadPool.isTerminated()) {//判断线程是否执行完毕，不是就休眠主线程。
        //如果子线程们都执行完毕，就会进这个判断，然后会跳出这个循环。这样就达到了主线程等待子线程们
        //都执行完了，才去执行其他的代码。
        break;
    }
    Thread.sleep(1000);//主线程睡眠1秒
}
//这里写执行完毕的日志或者最后的“收尾”功能。
```
### [管程(Monitor)概念及Java的实现原理](https://www.cnblogs.com/upnote/p/13030741.html)
