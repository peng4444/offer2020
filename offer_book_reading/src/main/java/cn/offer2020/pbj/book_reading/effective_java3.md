# Effective Java 3
>> [Effective Java Third Edition](https://www.cnblogs.com/IcanFixIt/tag/Effective%20Java%20Third%20Edition/)

[TOC]


## 第一章 引言
```markdown
    代码应该被重用，而不是被拷贝。组件之间的依赖性应该尽可能地降到最小。
    Java 语言支持四种类型：接口 包括注释）、类（包括 enum ）、数组和基本类型。前三种种类型通常被称为引用类型（ reference type ），
    类实例和数组是对象（ object ），而基本类型的值则不是对象， 类的成员（ member ）由它的域(field ）、方法（ method 成员类
     member class ）和成员接口（ member interface ）组成。方法的签名（ signature 由它的名称和所有 数类型组成； 签名不包括方法的返回类型
```
## 第二章 创建和销毁对象
```markdown
    本章的主题是创建和销毁对象：何时以及如何创建对象，何时以及如何避免创建对象，如何确保它们能够适时地销毁，以及如何管理对象销毁之前必须进行的各种清理动作
```
### 第1条：用静态工厂方法代替构造器
```markdown
    *详情见代码*
    注意：静态工厂方法与设计模式中的工厂方法模式不同[Gamma95]。
        本条目中描述的静态工厂方法并不直接对应于设计模式中的工作方法。
    1.静态工厂方法与构造器相比的优势在于：
        1).静态工厂方法有名称
        2).静态工厂方法不必每次调用都创建新的对象  (静态工厂方法能够为重复的调用返回相同对象)
        3).可以返回原返回类型的如何子类的对象
        4).所返回的对象的类可以随着每次调用而发生变化，这取决于静态工厂方法的参数值
        5).方法返回的对象所属的类，在编写包含该静态工厂方法的类可以不存在
    
    2.静态工厂方法与构造器相比的劣势在于：
        1).类如果实现静态的工厂方法，而不含有公有的或者受保护的构造器，就不能够被实例化。
            这也鼓励我们多使用复合(composition) 而不是继承
        2).程序员很难发现使用了静态工厂方法
        
    静态工厂方法的一些惯用名称
        form -- 类型转换方法，它只要单个参数，返回该类型的一个相对应的实例，
            例如：Date d = Date.form(instance);
        
        of -- 聚合方法，带有多个参数，返回该类型的一个实例，把它们何必起来
            例如： Set<Rank> faceCards = EmumSet.of(Jack,Queen,King);
            
        valueOf -- 这个方法返回的实例与它的参数具有相同的值，这样的静态工厂方法实际上是用来做类型转换的。
            例如：BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);    
        
        instance或者getInstance -- 返回的实例是通过方法的参数来描述的，但是不能够说与参数具有相同的值。
        对于Singleton来说这个方法没有参数，并返回唯一的实例.
            例如：StackWalker luke = StackWalker.getInstance(options);
            
        create 或 newInstance——与instance 或 getInstance类似，除了该方法保证每个调用返回一个新的实例，
            例如：Object newArray = Array.newInstance(classObject, arrayLen);
            
        getType——与getInstance类似，但是如果在工厂方法中不同的类中使用。Type是工厂方法返回的对象类型，
            例如：FileStore fs = Files.getFileStore(path);
            
        newType——与newInstance类似，但是如果在工厂方法中不同的类中使用。Type是工厂方法返回的对象类型，
            例如：BufferedReader br = Files.newBufferedReader(path);
            
        type—— getType 和 newType简洁的替代方式，
            例如：List<Complaint> litany = Collections.list(legacyLitany);
```
####总结
```markdown
    静态工厂方法和公有构造器是各有用处的，但是我们需要理解他们的长处。静态工厂方法通常更加的合适，
    希望我们以后第一时间不是考虑构造器，而是想想静态工厂方法是否更合适。 
```
        
    
   
### 第2条： 当遇到多个构造器参数时要考虑使用builder模式 [构建器]
```markdown
    *详情见代码* 
        与重叠构造器，JavaBean模式相比建造者模式是不是更好。
        1).重叠构造器，可行，但是当参数太多时，难以编写和阅读 
        2).弥补重叠构造器的不足，但是JavaBeans模式有严重的不足：
                     在构造过程中JavaBean可能处于不一致的状态。
                     JavaBean模式使得把类变成可变的了。  
        3).建造者模式  
                    代码很容易编写，更重要的是易于阅读
                    Builder模式非常适合类层次结构
```
   ####总结
```markdown
    当设计类的构造方法或静态工厂的参数超过几个时，Builder模式是一个不错的选择，特别是如果许多参数是可选的或相同类型的。
    客户端代码比使用构造方法（telescoping constructors）更容易读写，并且builder比JavaBeans更安全。
        
```
### 第3条： 使用私有构造器或枚举类型强化Singleton属性
```markdown
或者参考我的设计模式代码：[单例设计模式代码](https://github.com/peng4444/DesignPattern/blob/master/src/cn/pbj/createmodles/singletion/Singleton.java)
    *详情见代码*
         什么是单例模式
         保证一个系统中的某个类只有一个实例而且该实例易于外界访问。例如Windows界面的任务管理器就可以看做是一个单例。
         单例模式的使用场景
         在程序中比较常用的是数据库连接池、线程池、日志对象等等。
         单例模式使用
         最早我们在学习单例模式的时候，基本都会接触这两种模式：饿汉式和饱汉式(懒汉式)。
        实现单例设计模式（singleton）的两种常见方法
        1.共有静态成员是一个final域  --  (饿汉式)
        2.共有的成员是个静态工厂方法  -- 饱汉式(懒汉式)
            饿汉式      如何防止反射和反序列化
            定义一个私有的构造方法，并将自身的实例对象设置为一个私有属性,并加上static和final修饰符，
            然后通过公共的静态方法调用返回实例。
            优点：写起来很简单，并且不会因为不加synchronized关键字而造成的线程不安全问题。
            类初始化时立即加载，无法延迟加载,天然线程安全
            方法没有同步，调用效率高
            缺点：当该类被加载的时候，会初始化该实例和静态变量并被创建并分配内存空间，并且会一直占用内存。
            
            饱汉式
            定义一个私有的构造方法，定义一个该类静态私有的变量，然后定义一个公共的静态方法，对该类的值进行空判断，
            不为空直接返回，否则重新构建一个。
            延迟加载
            优点：写起来很简单，在第一次调用的时候才会初始化，节省了内存。
            缺点：线程不安全，多个线程调用可能会出现多个实例。
            总结：书写简单，线程不安全，效率还行。
            
            JDK1.5之后出现了枚举，并且完美支持单例模式，并且线程安全、效率高！但是这些不是最重要的，
            最重要的是书写超级简单！
```
#### 总结
```markdown
             单例模式的几种使用就到这了，那么我们来总结下使用单例模式需要注意什么(不包括枚举)。
             构造方法私有化（private）;
             定义一个私有(private)静态(static)实例化对象;
             对外提供一个公共(public)静态(static)的方法得到该实例;
```
### 第4条：使用私有构造方法强化不可实例化的能力
```markdown
        1). 试图通过创建抽象类来强制执行非实例化是行不通的。该类可以被子类化，并且该子类也可以被实例化
```
#### 总结
```markdown
        让一个类包含一个私有构造器，它就不能被实例化
        由于显式的构造器是私有的，所以不可以在该类的外部访问它。这种习惯用法也有副作用，它使得 个类不能被子类化。
```
        
### 第5条：优先考虑使用依赖注入来引入资源
```markdown
        静态实用类和单例对于那些行为被底层资源参数化的类来说是不合适的。
        依赖注入也同样适用于构造器、静态工厂和构建器
        依赖注入是最简单的模式。
```
####总结
```markdown
        不要使用单例或静态的实用类来实现一个类，该类依赖于一个或多个底层资源，这些资源的行为会影响类的行为，
        虽然String.matches方法最易于查看一个字符串是否与正则表达式相匹配，但并不适合在注重性能的情形中重复使用
        并且不让类直接创建这些资源。相反，将资源或工厂传递给构造方法(或静态工厂或builder模式)。
        这种称为依赖注入的实践将极大地增强类的灵活性、可重用性和可测试性。  
```
### 第6条：避免创建不必要的对象
```markdown
        构造器在每次被调用的时候都会创建一个新的对象，而静态工厂方法 从来不要求这样做，实际上也不会这样做 除了重用不可变的对象之外，也可以重用那些已知不会被修改的可变对象
        一个适配器是一个对象，它委托一个支持对象（backing object），提供一个可替代的接口。
        由于适配器没有超出其支持对象的状态，因此不需要为给定对象创建多个给定适配器的实例。
        另一种创建多余对象的方法，称作自动装箱。自动装箱使得基本类型和装箱基本类型之间的差别变得模糊起来，但是并没有完全消除。
        优先使用基本类型而不是装箱的基本类型，也要注意无意识的自动装箱。
```
### 第7条：消除过期的对象引用     
```markdown
        如果一个栈先是增长，然后再收缩。那么，从栈中弹出来的对象将不会被当作垃圾回收，即使使用校的程序不再引用这些对象，它们也不会被回收
        是因为栈内部维护着对这些对象的过期引用
        这类问题的修复方法很简单 一旦对象引用已经过期，只需清空这些引用即可 对于上述例子中的 Stack 类而言，只要一个单元被弹出拢，指向它的引用就过期了
        只要类是自己管理内存，程序员就应该 惕内存泄漏问题。
        内存泄漏的可能：1.过期引用没有清空
                       2.缓存
                       3.监听器和其他回调
```
### 第8条： 避免使用Finalizer终结方法和Cleaner清空机制
```markdown
            永远不要依赖终结方法和清空方法来更新重要的持久状态【注重时间的任务】
            及时地执行终结方法和清除方法正是垃圾回收算法的一个主要功能，
            使用终结方法和清除方法有一个非常严重的性能损失。
            Java9垃圾回收机制：java.lang.ref.Cleaner和java.lang.ref.PhantomReference提供更灵活和有效的方式，
            在对象无法再访问时释放资源。
```
#### 总结
```markdown
     总而言之，除非是作为安全网，或者是为了终止非关键的本地资源，否则请不要使用清除方法，对于在 Java9之前的发行版本，则尽量不要使用终结方法 使用了终结方法或者清除方法，则要注意它的不确定性和性能后果   
```
  ### 第9条： 使用try-with-resources语句替代try-finally语句
```markdown
        Java7引入try-with-resources语句，自动关闭资源链接
```
#### 总结
```markdown
    结论很明显,在处理必须关闭的资源时，始终要优先考虑用 try-with-resources,而不是try-finally.这样得到的代码将更加简洁、清晰，
    产生的异常也更有价值.有了try-with resources 语句，在使用必须关闭的资源时，就能更轻松地正确编写代码了 实践证明，这个用 try-finally 是不可能做到的
```
## Effective Java 第三章：对于所有的对象都通用的方法
### 第10条：重写equals方法时遵守通用约定
```markdown
    类的每个实例本质上都是唯一的
    类没有必要提供“逻辑相等”（ logical equality ）的测试功能
    超类已经覆盖 equals 超类的行为对于这个类也是合适的。
    类是私有的，或者是包级私有的 可以确定它的 equals 方法永远不会 调用
```
### 第 11 条：覆盖 equals 时总要覆盖 hashCode
```markdown
    在每个覆盖了 equals 方法的类中， 都必须覆盖 hashCode 方法
    因没有覆盖 hashCode 而违反的关键约定是第二条：相等的对象必须具有相等的散到码（ hash code)
    每当覆盖 equals 方法时都必须覆盖 hashCode ，否则程序将无法正确运行
```
### 第 12 条：始终要覆盖 toString
```markdown
    
```
### 第 13 条：谨慎的覆盖 clone
