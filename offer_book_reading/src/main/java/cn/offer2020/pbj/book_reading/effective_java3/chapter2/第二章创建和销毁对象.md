## Effective Java 第二章：创建和销毁对象
  ###第1条：用静态工厂方法代替构造器
    *详情见代码*
    注意：静态工厂方法与设计模式中的工厂方法模式不同[Gamma95]。
        本条目中描述的静态工厂方法并不直接对应于设计模式中的工作方法。
    1.静态工厂方法与构造器相比的优势在于：
        1).静态工厂方法有名称
        2).静态工厂方法不必每次调用都创建新的对象
        3).可以返回原返回类型的如何子类的对象
        4).所返回的对象的类可以随着每次调用而发生变化，这取决于静态工厂方法的参数值
        5).方法返回的对象所属的类，在编写包含该静态工厂方法的类可以不存在
    
    2.静态工厂方法与构造器相比的劣势在于：
        1).类如果实现静态的工厂方法，而不含有公有的或者受保护的构造器，就不能够被实例化。
            这也鼓励我们多使用复合(composition) 而不是继承
        2).程序员很难发现使用了静态工厂方法
        
    静态工厂方法的一些惯用名称
        form -- 类型转换方法，它只要单个参数，返回该类型的一个相对应的实例，
            例如：Date d = Date.form(instance);
        
        of -- 聚合方法，带有多个参数，返回该类型的一个实例，把它们何必起来
            例如： Set<Rank> faceCards = EmumSet.of(Jack,Queen,King);
            
        valueOf -- 这个方法返回的实例与它的参数具有相同的值，这样的静态工厂方法实际上是用来做类型转换的。
            例如：BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);    
        
        instance或者getInstance -- 返回的实例是通过方法的参数来描述的，但是不能够说与参数具有相同的值。
        对于Singleton来说这个方法没有参数，并返回唯一的实例.
            例如：StackWalker luke = StackWalker.getInstance(options);
            
        create 或 newInstance——与instance 或 getInstance类似，除了该方法保证每个调用返回一个新的实例，
            例如：Object newArray = Array.newInstance(classObject, arrayLen);
            
        getType——与getInstance类似，但是如果在工厂方法中不同的类中使用。Type是工厂方法返回的对象类型，
            例如：FileStore fs = Files.getFileStore(path);
            
        newType——与newInstance类似，但是如果在工厂方法中不同的类中使用。Type是工厂方法返回的对象类型，
            例如：BufferedReader br = Files.newBufferedReader(path);
            
        type—— getType 和 newType简洁的替代方式，
            例如：List<Complaint> litany = Collections.list(legacyLitany);
    ####总结
        静态工厂方法和公有构造器是各有用处的，但是我们需要理解他们的长处。静态工厂方法通常更加的合适，
        希望我们以后第一时间不是考虑构造器，而是想想静态工厂方法是否更合适。 
   
  ### 第2条： 当遇到多个构造器参数时要考虑使用builder模式 
    *详情见代码* 
                
        与重叠构造器，JavaBean模式相比建造者模式是不是更好。
        
        1).重叠构造器，可行，但是当参数太多时，难以编写和阅读 
        2).弥补重叠构造器的不足，但是JavaBeans模式有严重的不足：
                     在构造过程中JavaBean可能处于不一致的状态。
                     JavaBean模式使得把类变成可变的了。  
        3).建造者模式  
                    代码很容易编写，更重要的是易于阅读
                    Builder模式非常适合类层次结构
    
   ####总结
        当设计类的构造方法或静态工厂的参数超过几个时，Builder模式是一个不错的选择，特别是如果许多参数是可选的或相同类型的。
        客户端代码比使用构造方法（telescoping constructors）更容易读写，并且builder比JavaBeans更安全。
        
  ### 第3条： 使用私有构造器或枚举类型强化Singleton属性
   或者参考我的设计模式代码：[单例设计模式代码](https://github.com/peng4444/DesignPattern/blob/master/src/cn/pbj/createmodles/singletion/Singleton.java)
    *详情见代码*
    
        **
         什么是单例模式
         保证一个系统中的某个类只有一个实例而且该实例易于外界访问。例如Windows界面的任务管理器就可以看做是一个单例。
         单例模式的使用场景
         在程序中比较常用的是数据库连接池、线程池、日志对象等等。
         单例模式使用
         最早我们在学习单例模式的时候，基本都会接触这两种模式：饿汉式和饱汉式(懒汉式)。
        **
        实现单例设计模式（singleton）的两种常见方法
        1.共有静态成员是一个final域  --  (饿汉式)
        2.共有的成员是个静态工厂方法  -- 饱汉式(懒汉式)
        *
            饿汉式      如何防止反射和反序列化
            定义一个私有的构造方法，并将自身的实例对象设置为一个私有属性,并加上static和final修饰符，
            然后通过公共的静态方法调用返回实例。
            优点：写起来很简单，并且不会因为不加synchronized关键字而造成的线程不安全问题。
            类初始化时立即加载，无法延迟加载,天然线程安全
            方法没有同步，调用效率高
            缺点：当该类被加载的时候，会初始化该实例和静态变量并被创建并分配内存空间，并且会一直占用内存。
        *
        *
            饱汉式
            定义一个私有的构造方法，定义一个该类静态私有的变量，然后定义一个公共的静态方法，对该类的值进行空判断，
            不为空直接返回，否则重新构建一个。
            延迟加载
            优点：写起来很简单，在第一次调用的时候才会初始化，节省了内存。
            缺点：线程不安全，多个线程调用可能会出现多个实例。
            总结：书写简单，线程不安全，效率还行。
        *
        *
            JDK1.5之后出现了枚举，并且完美支持单例模式，并且线程安全、效率高！但是这些不是最重要的，
            最重要的是书写超级简单！究竟有多简单，看示例应该就可以了解
        *
   #### 总结
             单例模式的几种使用就到这了，那么我们来总结下使用单例模式需要注意什么(不包括枚举)。
             构造方法私有化（private）;
             定义一个私有(private)静态(static)实例化对象;
             对外提供一个公共(public)静态(static)的方法得到该实例;
       
   
  ### 第4条：使用私有构造方法强化不可实例化的能力
        1). 试图通过创建抽象类来强制执行非实例化是行不通的
     
   #### 总结
        让一个类包含一个私有构造器，它就不能被实例化
        
  ### 第5条：优先考虑使用依赖注入来引入资源
        静态实用类和单例对于那些行为被底层资源参数化的类来说是不合适的。
        依赖注入是最简单的模式。
    ####总结
        不要使用单例或静态的实用类来实现一个类，该类依赖于一个或多个底层资源，这些资源的行为会影响类的行为，
        并且不让类直接创建这些资源。相反，将资源或工厂传递给构造方法(或静态工厂或builder模式)。
        这种称为依赖注入的实践将极大地增强类的灵活性、可重用性和可测试性。   
         
  ### 第6条：避免创建不必要的对象
        一个适配器是一个对象，它委托一个支持对象（backing object），提供一个可替代的接口。
        由于适配器没有超出其支持对象的状态，因此不需要为给定对象创建多个给定适配器的实例。
        优先使用基本类型而不是装箱的基本类型，也要注意无意识的自动装箱。
        
  ### 第7条：消除过期的对象引用     
        内存泄漏的可能：1.过期引用没有清空
                       2.缓存
                       3.监听器和其他回调
  
  ### 第8条： 避免使用Finalizer终结方法和Cleaner清空机制
        永远不要依赖终结方法和清空方法来更新重要的持久状态
        Java9垃圾回收机制：java.lang.ref.Cleaner和java.lang.ref.PhantomReference提供更灵活和有效的方式，
        在对象无法再访问时释放资源。
        
  ### 第9条： 使用try-with-resources语句替代try-finally语句
        Java7引入try-with-resources语句，自动关闭资源链接