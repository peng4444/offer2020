 # 漫画算法阅读总结和代码

[TOC]


## chapter1 算法概述
```markdown
    1:算法与数据结构  数据结构：算法+程序 
        数据结构是数据的组织、管理和存储格式，其使用目的是为了高效地访问和修改数据。
    2:时间复杂度
        时间复杂度是对一个算法运行时间长短的量度，用大O表示
    3:空间复杂度
        空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度，用大O表示，记作S(n)=O(f(n))
```
## chapter2 数据结构基础
```markdown
    1:数组 顺序存储  查找O(1) 更新O(1) 插入O(n) 删除O(n) 数组所适合的是读操作多、写操作少的场景
    2:链表 双向链表 查找O(n) 更新O(1) 插入O(1) 删除O(1) 能够灵活地进行插入和删除操作
    3:栈和队列  O(1) 栈和队列。这两者都属于逻辑结构，它们的物理实现既可以利用数组，也可以利用链表来完成。
        栈：先入后出 入栈，出栈操作 队列：先入先出 入队，出队操作
        循环队列，双端队列，优先队列
        应用：栈：递归的实现
    4:散列表(哈希表) 散列表也叫哈希表，是存储Key-Value映射的集合。对于某一个Key，散列表可以在接近O(1)的时间内进行读写操作
        哈希函数  哈希冲突解决办法：开放地址法(ThreadLocal)和链表法(HashMap)  在Java中，ThreadLocal所使用的就是开放寻址法。
        链表法被应用在了Java的集合类HashMap当中。JDK8的hashmap的散列表转换为红黑树
        关于HashMap的实现，JDK 8和以前的版本有着很大的不同。当多个Entry被Hash到同一个数组下标位置时，
        为了提升插入和查找的效率，HashMap会把Entry的链表转化为红黑树这种数据结构。
        建议读者把两个版本的实现都认真地看一看，这会让你受益匪浅。
    5:高级数据结构：优先队列，图，前缀树，线段树，树状数组。
```
## chapter3 树
[替罪羊树 —— 暴力也是种优雅](https://www.cnblogs.com/peihuan/p/11523351.html)
```markdown
    1:树
    2:二叉树  (满二叉树，完全二叉树)
        二叉树：属于逻辑结构，它们的物理实现既可以利用数组，也可以利用链表来完成。进行查找操作和维持相对顺序
        用数组存储二叉树，父节点的下标是parent，那么它的左孩子节点下标是2*parent+1，右孩子节点下标为2*parent+2。
        二叉搜索树：（Binary Search tree 类似二分查找） = 二叉排序树
        左子树上的所有的节点的值均小于它的根节点的值，右子树上的所有的节点的值均大于它的根节点的值，同时它的左右子树也是二叉搜索树。
        二叉树遍历：
            深度优先遍历：前序(根左右)，中序(左根右)，后序遍历(左右根)
            广度优先遍历：层次遍历
    3:二叉堆：
        最大堆的任何一个父节点的值，都大于或等于它左、右孩子节点的值。
        最小堆的任何一个父节点的值，都小于或等于它左、右孩子节点的值。
        最大堆和最小堆的特点决定了：最大堆的堆顶是整个堆中的最大元素；最小堆的堆顶是整个堆中的最小元素。
        二叉堆的所有节点都存储在数组中。二叉堆虽然是一个完全二叉树，但它的存储方式并不是链式存储，而是顺序存储
        当二叉堆插入节点时，插入位置是完全二叉树的最后一个位置。
        二叉堆删除节点的过程和插入节点的过程正好相反，所删除的是处于堆顶的节点。
    4:优先队列：
        最大优先队列，无论入队顺序如何，都是当前最大的元素优先出队
        最小优先队列，无论入队顺序如何，都是当前最小的元素优先出队
        可以用二叉堆最大堆来实现最大优先队列，每一次入队操作就是堆的插入操作，每一次出队操作就是删除堆顶节点。
```
## chapter4 查找排序算法 
```markdown
二分查找： 迭代，递归实现
```
[参考博客>>八大经典排序算法入门](https://www.cnblogs.com/PJQOOO/p/11669493.html)

[参考博客>>排序算法进阶--排序算法优化](https://www.cnblogs.com/PJQOOO/p/11675335.html)

[参考博客>>数据结构之——八大排序算法](https://www.cnblogs.com/vfdxvffd/p/11731219.html)

[参考博客>>八大排序算法详解（动图演示 思路分析 实例代码java 复杂度分析 适用场景）](cnblogs.com/l199616j/p/10742603.html)
```markdown
时间复杂度为O(n^2)的排序算法
        冒泡排序
        选择排序 
        插入排序
        希尔排序（希尔排序比较特殊，它的性能略优于O(n2)，但又比不上O(nlogn)，姑且把它归入本类）
时间复杂度为O(nlogn)的排序算法
        快速排序
        归并排序  [快速排序和归并排序的时间复杂度分析](https://www.cnblogs.com/tuyang1129/p/12857821.html)
        堆排序
时间复杂度为线性的排序算法
        计数排序
        桶排序
        基数排序
如果值相同的元素在排序后仍然保持着排序前的顺序，则这样的排序算法是稳定排序；
如果值相同的元素在排序后打乱了排序前的顺序，则这样的排序算法是不稳定排序。
    1.冒泡排序及其优化    稳定排序  平均时间复杂度是O(n^2)
        冒泡排序：把相邻的元素两两比较，当一个元素大于右侧相邻元素时，交换它们的位置；当一个元素小于或等于右侧相邻元素时，位置不变。
            > 优化1：提前有序终止排序
            > 优化2：有序区【最后面几个有序】不再排序
            > 鸡尾酒排序：有序区【最后面几个或者最前面几个有序】不再排序，元素比较和交换过程是双向的
    2.快速排序   分治法 平均时间复杂度是O(nlogn) 基准元素为最大或者最小元素，在这种极端情况下，快速排序需要进行n轮，时间复杂度退化成了O(n2)。
        快速排序思想：选一个数作为基数（这里我选的是第一个数），大于这个基数的放到右边，小于这个基数的放到左边，等于这个基数的数可以放到左边或右边，看自己习惯，这里我是放到了左边，
        一趟结束后，将基数放到中间分隔的位置，第二趟将数组从基数的位置分成两半，分割后的两个的数组继续重复以上步骤，选基数，将小数放在基数左边，将大数放到基数的右边，在分割数组，，，直到数组不能再分为止，排序结束。
        单边循环法和双边循环法 以及非递归实现【栈实现】
    3.堆排序   二叉堆 时间复杂度是O(nlogn) 不稳定排序
        把无序数组构建成二叉堆。需要从小到大排序，则构建成最大堆；需要从大到小排序，则构建成最小堆。
        循环删除堆顶元素，替换到二叉堆的末尾，调整堆产生新的堆顶。
    4.计数排序和桶排序
          以计数排序来说，这种排序算法是利用数组下标来确定元素的正确位置的。
          计数排序优化：很简单，只要不再以输入数列的最大值+1作为统计数组的长度，而是以数列最大值-最小值+1作为统计数组的长度即可。
          同时，数列的最小值作为一个偏移量，用于计算整数在统计数组中的下标。 
```
## chapter5 面试中的算法
####判断链表有环,环的入口，环的长度
####最小栈的实现
####如何求最大公约数
####判断一个数是否为2的整数幂
####无序数组排序后的最大相邻差 
#### 如何用栈实现队列
#### 寻找全排列的下一个数
#### 删去k个数字后的最小值
#### 如何实现大整数相加
#### 如何求解金矿问题
[漫画：去掉一个数，如何让剩余的数乘积最大？](https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&mid=2653200288&idx=1&sn=dbf1199e9633e19e903b6c938ce5bbc9&chksm=8c99ed7abbee646c667c6b04001f626b7b26783ccdb201707371b4bc539cf1fef55ba56b84d6&mpshare=1&scene=23&srcid=&sharer_sharetime=1572229211679&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
## chapter6 算法的实际应用
### BitMap
### LRU
### [赫(哈)夫曼树及java代码实现](https://www.cnblogs.com/nijunyang/p/12798951.html)



[阿里面试官让我实现一个线程安全并且可以设置过期时间的LRU缓存，我蒙了！](https://www.cnblogs.com/javaguide/p/12751779.html)
[树，二叉树，线索二叉树，霍夫曼树](https://www.cnblogs.com/Joey777210/p/11985685.html)
[平衡树详解和运用](https://www.cnblogs.com/ac-evil/p/11755354.html)
[关于KMP算法你不知道的事](https://www.cnblogs.com/Unicron/p/11746306.html)
