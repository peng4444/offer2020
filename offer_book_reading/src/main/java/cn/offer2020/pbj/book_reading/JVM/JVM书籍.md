# JVM书籍
## 参考书籍
**深入了解Java虚拟机**
## 参考博客
[从多线程的三个特性理解多线程开发](https://www.cnblogs.com/dafanjoy/p/10020225.html)
>> 1.共享变量
```markdown
从JVM内存模型的角度上讲，存储在堆内存上数据都是线程共享的，如实例化的对象、全局变量、数组等。
存储在线程栈上的数据是线程独享的，如局部变量、操作栈、动态链接、方法出口等信息。
```
>> 2.原子性操作
```markdown
i++:不是原子性操作，虽然读取i和i=i+1都是原子性操作，两个合并就不是原子性操作，可能出现线程不安全。
```
[JVM中的五大内存区域划分详解及快速扫盲](https://www.cnblogs.com/chaogu94/p/12529692.html)
[JVM-内存模型](https://www.cnblogs.com/ljl150/p/12535658.html)

[大厂面试经：高频率JVM面试问题整理！](https://www.cnblogs.com/xwgblog/p/11842394.html)


[垃圾回收与内存分配策略](https://www.cnblogs.com/CodeMLB/p/12113279.html)

[Java垃圾收集算法](https://www.cnblogs.com/rainple/p/10793500.html)
[JVM垃圾回收算法详解](https://www.cnblogs.com/xwgblog/p/11703104.html)
```markdown
在JVM内存模型中会将堆内存划分新生代、老年代两个区域，两块区域的主要区别在于新生代存放存活时间较短的对象，
老年代存放存活时间较久的对象，除了存活时间不同外，还有垃圾回收策略的不同，在JVM中中有以下回收算法：
>> 标记清除：标记阶段是从根集合（GC Root)开始扫描，每到达一个对象就会标记该对象为存活状态，清除阶段在扫描完成之后将没有标记的对象给清除掉。
>> 标记整理：从根集合（GC Root)开始扫描进行标记然后清除无用的对象，清除完成后它会整理内存。没有内存碎片的问题
>> 复制算法：复制算法会将JVM推分成二等分，给对象分配内存的时候总是使用其中的一块来分配，分配满了以后，GC就会进行标记，然后将存活
的对象移动到另外一块空白的区域，然后清除掉所有没有存活的对象，这样重复的处理，始终就会有一块空白的区域没有被合理的利用到。
>> 分代收集算法：分代收集算法将heap区域划分为新生代和老年代，新生代的空间比老年代的空间要小。新生代又分为了Eden和两个survivor空间，
它们的比例为8：1：1。对象被创建时，内存的分配是在新生代的Eden区发生的，大对象直接在老年代分配内存，IBM的研究表明，Eden区98%的对象都是很快消亡的。
```
>> JVM是如果确定对象是垃圾对象的呢？JVM判断对象是否存活算法：
>>  引用计数
>> 可达性分析

### 垃圾回收器
[一文了解JVM全部垃圾回收器，从Serial到ZGC](https://www.cnblogs.com/zackku/p/10056865.html)
>> Serial收集器 是单线程执行垃圾回收的。当需要执行垃圾回收时，程序会暂停一切手上的工作，然后单线程执行垃圾回收。
>> ParNew收集器 ParNew同样用于新生代，是Serial的多线程版本，并且在参数、算法（同样是复制算法）上也完全和Serial相同。
>> Parallel Scavenge收集器 新生代的收集器，同样用的是复制算法，也是并行多线程收集。与ParNew最大的不同，它关注的是垃圾回收的吞吐量。
>> Serial Old收集器 老年代的收集器，与Serial一样是单线程，不同的是算法用的是标记-整理（Mark-Compact）。
>> Parallel Old收集器 老年代的收集器，是Parallel Scavenge老年代的版本。其中的算法替换成Mark-Compact。
>> CMS收集器 同样是老年代的收集器。它关注的是垃圾回收最短的停顿时间（低停顿），在老年代并不频繁GC的场景下，是比较适用的。
>> G1收集器 G1可以说是CMS的终极改进版，解决了CMS内存碎片、更多的内存空间登问题。虽然流程与CMS比较相似，但底层的原理已是完全不同。
>> ZGC 

