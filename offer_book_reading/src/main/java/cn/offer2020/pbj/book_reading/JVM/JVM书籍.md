# JVM书籍

[TOC]


>> **深入了解Java虚拟机第二版，第三版**

>> [参考博客：随笔分类 - Java虚拟机](https://www.cnblogs.com/ysocean/category/1151281.html)

>> [ JVM 底层原理知识总结](https://doocs.github.io/jvm)
## 基础知识整理
>> 参考：cyc2018大佬

>> 参考：[Java程序员必备基础结构图](https://www.cnblogs.com/jay-huaxiao/p/12819379.html)

>> 参考：[一文带你学会java的jvm精华知识点](https://www.cnblogs.com/jichi/p/12827921.html)
### 1.运行时数据区域
![运行时数据区域](https://user-gold-cdn.xitu.io/2020/4/29/171c6a4017b17e4a?w=906&h=699&f=png&s=69259)
```markdown
程序计数器(线程私有):记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。
Java虚拟机栈(线程私有):每个Java方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。
            从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。
本地方法栈(线程私有):本地方法栈与Java虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。

堆(线程共享):所有对象都在这里分配内存，是垃圾收集的主要区域（"GC堆"）。
    堆的默认分配图：![](https://user-gold-cdn.xitu.io/2020/4/30/171c6b5bddadd635?w=955&h=353&f=png&s=30398)
        1.Java堆 = 老年代 + 新生代
        2.新生代 = Eden + S0 + S1
        3.新生代与老年代默认比例的值为 1:2 ，可以通过参数 –XX:NewRatio 配置。
        4.默认的，Eden : from : to = 8 : 1 : 1 ，可以通过参数–XX:SurvivorRatio来设定
    Java对象在堆内存中包括对象头、实例数据和补齐填充3个部分：
        1.对象头包括Mark Word（存储哈希码，GC分代年龄等）和类型指针（对象指向它的类型元数据的指针）,如果是数组对象，还有一个保存数组长度的空间
        2.实例数据是对象真正存储的有效信息，包括了对象的所有成员变量，其大小由各个成员变量的大小共同决定。
        3.对齐填充不是必然存在的，仅仅起占位符的作用。
方法区(线程共享):用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
        运行时常量池:运行时常量池是方法区的一部分。
```
### 2.Java类实例化时，JVM执行顺序？
```markdown
1.父类静态代码块
2.父类静态变量
3.子类静态代码块
3.子类静态变量
4.父类成员变量赋值
5.父类构造方式开始执行
6.子类成员变量赋值
7.子类构造方式开始执行
需要注意的地方是静态变量和静态代码块谁在前面谁先执行。
```
### 3.JVM虚拟机何时结束生命周期
```markdown
执行了System.exit()方法；
程序正常执行结束；
程序在执行过程中遇到了异常或错误而异常终止；
由于操作系统出现错误而导致Java虚拟机进程；
```
### 4.JVM是如果确定对象是垃圾对象的呢？JVM判断对象是否存活算法：
```markdown
垃圾收集主要是针对堆和方法区进行。
程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。
引用计数算法：为对象添加一个引用计数器，当对象增加一个引用时计数器加1，引用失效时计数器减1。引用计数为0的对象可被回收。
    在两个对象出现循环引用的情况下，此时引用计数器永远不为0，导致无法对它们进行回收。正是因为循环引用的存在，因此Java虚拟机不使用引用计数算法。
可达性分析算法:
    以GC Roots为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。
    Java虚拟机使用该算法来判断对象是否可被回收，GC Roots一般包含以下内容：
        虚拟机栈中局部变量表中引用的对象
        本地方法栈中JNI中引用的对象
        方法区中类静态属性引用的对象
        方法区中的常量引用的对象
方法区的回收:因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。
       主要是对常量池的回收和对类的卸载。
       为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。
       类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载：
            该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。
            加载该类的 ClassLoader 已经被回收。
            该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。
finalize():当一个对象可被回收时，如果需要执行该对象的finalize()方法，那么就有可能在该方法中让对象重新被引用，
            从而实现自救。自救只能进行一次，如果回收的对象之前调用了finalize()方法自救，后面回收时不会再调用该方法。
```
### 5.JVM垃圾回收算法
[Java垃圾收集算法](https://www.cnblogs.com/rainple/p/10793500.html)
[JVM垃圾回收算法详解](https://www.cnblogs.com/xwgblog/p/11703104.html)
```markdown
在JVM内存模型中会将堆内存划分新生代、老年代两个区域，两块区域的主要区别在于新生代存放存活时间较短的对象，
老年代存放存活时间较久的对象，除了存活时间不同外，还有垃圾回收策略的不同，在JVM中中有以下回收算法：
标记-清除：标记阶段是从根集合(GCRoot)开始扫描，每到达一个对象就会标记该对象为存活状态，清除阶段在扫描完成之后将没有标记的对象给清除掉。
        标记和清除过程效率都不高；
        会产生大量不连续的内存碎片，导致无法给大对象分配内存。
标记-整理：从根集合(GCRoot)开始扫描进行标记然后清除无用的对象，清除完成后它会整理内存。没有内存碎片的问题。
        优点:不会产生内存碎片
        不足:需要移动大量对象，处理效率比较低。
标记-复制算法：复制算法会将JVM推分成二等分，给对象分配内存的时候总是使用其中的一块来分配，分配满了以后，GC就会进行标记，然后将存活
的对象移动到另外一块空白的区域，然后清除掉所有没有存活的对象，这样重复的处理，始终就会有一块空白的区域没有被合理的利用到。
        
分代收集算法：分代收集算法将heap区域划分为新生代和老年代，新生代的空间比老年代的空间要小。新生代又分为了Eden和两个survivor空间，它们的比例为8:1:1。
对象被创建时，内存的分配是在新生代的Eden区发生的，大对象直接在老年代分配内存，IBM的研究表明，Eden区98%的对象都是很快消亡的。
        新生代使用：复制算法
        老年代使用：标记 - 清除 或者 标记 - 整理 算法
```
### 6.垃圾回收器
[一文了解JVM全部垃圾回收器，从Serial到ZGC](https://www.cnblogs.com/zackku/p/10056865.html)
```markdown
Serial收集器:(新生代收集器)
    是单线程执行垃圾回收的。当需要执行垃圾回收时，程序会暂停一切手上的工作，然后单线程执行垃圾回收。
ParNew收集器:(新生代收集器)
    ParNew同样用于新生代，是Serial的多线程版本，并且在参数、算法（同样是复制算法）上也完全和Serial相同。
Parallel Scavenge收集器:(新生代收集器)
    新生代的收集器，同样用的是复制算法，也是并行多线程收集。与ParNew最大的不同，它关注的是垃圾回收的吞吐量。
Serial Old收集器:(老年代收集器)
    是 Serial 收集器的老年代版本，与Serial一样是单线程，不同的是算法用的是标记-整理（Mark-Compact）。
Parallel Old收集器:(老年代收集器)
    是Parallel Scavenge收集器的老年代版本，是Parallel Scavenge老年代的版本。其中的算法替换成Mark-Compact。
CMS收集器:(老年代收集器)
    同样是老年代的收集器。它关注的是垃圾回收最短的停顿时间（低停顿），在老年代并不频繁GC的场景下，是比较适用的。
    分为以下四个流程：
    初始标记：仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，需要停顿。
    并发标记：进行GC Roots Tracing的过程，它在整个回收过程中耗时最长，不需要停顿。
    重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。
    并发清除：不需要停顿。
    缺点:1.吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。
         2.无法处理浮动垃圾，可能出现Concurrent Mode Failure。
        浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次GC时才能进行回收。
        由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。
        如果预留的内存不够存放浮动垃圾，就会出现Concurrent Mode Failure，这时虚拟机将临时启用Serial Old来替代CMS。
         3.标记-清除算法导致的空间碎片往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。。
G1收集器:(混合收集器)
    G1可以说是CMS的终极改进版，解决了CMS内存碎片、更多的内存空间登问题。虽然流程与CMS比较相似，但底层的原理已是完全不同。
    G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多CPU和大内存的场景下有很好的性能。HotSpot开发团队赋予它的使命是未来可以替换掉CMS收集器。
    堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而G1可以直接对新生代和老年代一起回收。
    G1 收集器的运作大致可划分为以下几个步骤：
        1.初始标记
        2.并发标记
        3.最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的
        Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中。这阶段需要停顿线程，但是可并行执行。
        4.筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计
        划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，
        而且停顿用户线程将大幅度提高收集效率。
ZGC(Z Garbage Collector): 
    在JDK 11中新加入的具有实验性质的低延迟垃圾收集器，
jdk1.7 默认垃圾收集器Parallel Scavenge（新生代）+Parallel Old（老年代）
jdk1.8 默认垃圾收集器Parallel Scavenge（新生代）+Parallel Old（老年代）
jdk1.9 默认垃圾收集器G1
 -XX:+PrintCommandLineFlagsjvm参数可查看默认设置收集器类型
 -XX:+PrintGCDetails亦可通过打印的GC日志的新生代、老年代名称判断   
```
### 7.内存分配与回收策略
[垃圾回收与内存分配策略](https://www.cnblogs.com/CodeMLB/p/12113279.html)
#### Minor GC 和 Full GC
```markdown
Minor GC：回收新生代，因为新生代对象存活时间很短，因此Minor GC会频繁执行，执行的速度一般也会比较快。
Full GC：回收老年代和新生代，老年代对象其存活时间长，因此Full GC很少执行，执行速度会比Minor GC慢很多。
```
#### 内存分配策略
![对象内存分配流程图](https://user-gold-cdn.xitu.io/2020/5/1/171d05dec9c7bbfd?w=972&h=943&f=png&s=115538)
```markdown
1. 对象优先在Eden分配:大多数情况下，对象在新生代Eden上分配，当Eden空间不够时，发起Minor GC。
2. 大对象直接进入老年代:
        大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。
        经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。
        -XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在Eden和Survivor之间的大量内存复制。
3. 长期存活的对象进入老年代
        为对象定义年龄计数器，对象在Eden出生并经过Minor GC依然存活，将移动到Survivor中，年龄就增加1岁，增加到一定年龄则移动到老年代中。
        -XX:MaxTenuringThreshold用来定义年龄的阈值。
4. 动态对象年龄判定
        虚拟机并不是永远要求对象的年龄必须达到MaxTenuringThreshold才能晋升老年代，如果在Survivor中相同年龄
        所有对象大小的总和大于Survivor空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到MaxTenuringThreshold中要求的年龄。
5. 空间分配担保
        在发生Minor GC之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么Minor GC可以确认是安全的。
        如果不成立的话虚拟机会查看HandlePromotionFailure的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否
        大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC；如果小于，或者HandlePromotionFailure的值不允许冒险，那么就要进行一次Full GC。
```
#### Full GC 的触发条件
```markdown
对于 Minor GC，其触发条件非常简单，当Eden空间满时，就将触发一次Minor GC。而Full GC则相对复杂，有以下条件：
    1. 调用System.gc():建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。
    2. 老年代空间不足:老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。
    3.空间分配担保失败:使用复制算法的Minor GC需要老年代的内存空间作担保，如果担保失败会执行一次Full GC。
    4.JDK 1.7 及以前的永久代空间不足:
        在JDK 1.7及以前，HotSpot虚拟机中的方法区是用永久代实现的，永久代中存放的为一些Class的信息、常量、静态变量等数据。
    5. Concurrent Mode Failure:执行CMS GC的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是GC过程中浮动垃圾过多导致暂时
        性的空间不足），便会报Concurrent Mode Failure错误，并触发Full GC。
```
### 8.类的生命周期、初始化时机和加载机制
#### 1.类的生命周期
![类的生命周期图](https://user-gold-cdn.xitu.io/2020/4/30/171c843fe9b784cb?w=1364&h=707&f=png&s=67514)
```markdown
类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类。因为如果一次性加载，那么会占用很多的内存。
        加载（Loading）
        验证（Verification）
        准备（Preparation）
        解析（Resolution）
        初始化（Initialization）
        使用（Using）
        卸载（Unloading）
类加载过程：包含了加载、验证、准备、解析和初始化这 5 个阶段。
    1. 加载
        加载过程完成以下三件事：
        1.通过类的完全限定名称获取定义该类的二进制字节流。
        2.将该字节流表示的静态存储结构转换为方法区的运行时存储结构。
        3.在内存中生成一个代表该类的Class对象，作为方法区中该类各种数据的访问入口。
    2. 验证
        验证的目的是确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
        验证阶段有：文件格式校验、元数据校验、字节码校验、符号引用校验。
    3. 准备
        准备阶段是正式为类中定义的变量（静态变量）分配内存并设置类变量初始值的阶段。
        类变量是被static修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。
        实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。
        应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。
    4.解析
        解析阶段是虚拟机将常量池的符号引用替换为直接引用的过程。
        其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持Java的动态绑定。
    5. 初始化
        初始化阶段才真正开始执行类中定义的Java程序代码。初始化阶段是虚拟机执行类构造器<clinit>()方法的过程。
        在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。 
```
#### 2.类初始化时机
```markdown
1. 主动引用
2. 被动引用
    1.通过子类引用父类的静态字段，不会导致子类初始化。
        System.out.println(SubClass.value); // value 字段在 SuperClass 中定义
    2.通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动
      生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。SuperClass[] sca = new SuperClass[10];
    3.常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。
        System.out.println(ConstClass.HELLOWORLD);
```
#### 3.类加载器分类
```markdown
从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器：
    启动类加载器（Bootstrap ClassLoader），使用 C++ 实现，是虚拟机自身的一部分；
    所有其它类的加载器，使用 Java 实现，独立于虚拟机，继承自抽象类 java.lang.ClassLoader。
从 Java 开发人员的角度看，类加载器可以划分得更细致一些：
    启动类加载器（Bootstrap ClassLoader）
    扩展类加载器（Extension ClassLoader）
    应用程序类加载器（Application ClassLoader）
```
#### 4.双亲委派模型
![双亲委派模型](https://user-gold-cdn.xitu.io/2020/4/30/171c84d6f56e220d?w=880&h=857&f=png&s=70024)
```markdown
双亲委派模型构成
    启动类加载器，扩展类加载器，应用程序类加载器，自定义类加载器
双亲委派模型工作过程是
    如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个类加载器都是如此，
    只有当父加载器在自己的搜索范围内找不到指定的类时（即ClassNotFoundException），子加载器才会尝试自己去加载。
为什么需要双亲委派模型？
    如果没有双亲委派，那么用户是不是可以自己定义一个java.lang.Object的同名类，java.lang.String的同名类，并把它放到ClassPath中,
    那么类之间的比较结果及类的唯一性将无法保证，因此，双亲委派模型可以防止内存中出现多份同样的字节码。
```
#### 5.自定义类加载器实现
```markdown
自定义类加载器必须继承classloader。需要实现里面的findClass方法。
我们可以传入路径，通过二进制输出流，将路径内容读取为二进制数组。通过调用defineClass方法定义class。
```
### 9.栈帧概念结构图
![栈帧概念结构图](https://user-gold-cdn.xitu.io/2020/5/1/171d0288ac431ad3?w=709&h=814&f=png&s=64282)
```markdown
栈帧是用于支持虚拟机进行方法调用和方法执行背后的数据结构。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址信息。
局部变量表
    是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。
    局部变量表的容量以变量槽(Variable Slot)为最小单位。
操作数栈
    操作数栈，也称操作栈，是一个后入先出栈。
    当一个方法刚刚开始执行的时候, 该方法的操作数栈也是空的, 在方法的执行过程中, 会有各种字节码指令往操作数栈中写入和提取内容, 也就是出栈与入栈操作。
动态连接
    每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用, 持有引用是为了支持方法调用过程中的动态连接(Dynamic Linking)。
方法返回地址
    当一个方法开始执行时, 只有两种方式退出这个方法 。一种是执行引擎遇到任意一个方法返回的字节码指令。另外一种退出方式是在方法执行过程中遇到了异常。
```
### 10.Java内存模型图
![Java内存模型图](https://user-gold-cdn.xitu.io/2020/5/1/171cef6637426e1e?w=823&h=759&f=png&s=251488)
```markdown
Java内存模型规定了所有的变量都存储在主内存中
每条线程还有自己的工作内存
线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝
线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。
不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。
```
### 11.JVM参数思维导图
![](https://user-gold-cdn.xitu.io/2020/5/1/171cfb2cb8a29672?w=1479&h=945&f=png&s=154318)
### 12.JVM触发full gc的几种情况？
```markdown
System.gc()方法的调用:建议JVM进行Full GC,只是建议而非一定,但很多情况下它会触发Full GC,从而增加Full GC的频率,也即增加了间歇性停顿的次数。
    强烈影响系建议能不使用此方法就别使用，让虚拟机自己去管理它的内存，可通过通过-XX:+ DisableExplicitGC来禁止RMI调用System.gc。
老年代空间不足:老年代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出如下错误：
    java.lang.OutOfMemoryError: Java heap space为避免以上两种状况引起的Full GC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。
永生区空间不足:JVM规范中运行时数据区域中的方法区，在HotSpot虚拟机中又被习惯称为永生代或者永生区，Permanet Generation中存放的为一些class的信息、常量、静态变量等数据，
    当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下也会执行Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出如下错误信息：
    java.lang.OutOfMemoryError: PermGen space为避免Perm Gen占满造成Full GC现象，可采用的方法为增大Perm Gen空间或转为使用CMS GC。
CMS GC时出现promotion failed和concurrent mode failure
```
## 相关博客文章
### [1.从多线程的三个特性理解多线程开发](https://www.cnblogs.com/dafanjoy/p/10020225.html)
>> 1.共享变量
```markdown
从JVM内存模型的角度上讲，存储在堆内存上数据都是线程共享的，如实例化的对象、全局变量、数组等。
存储在线程栈上的数据是线程独享的，如局部变量、操作栈、动态链接、方法出口等信息。
```
>> 2.原子性操作
```markdown
i++:不是原子性操作，虽然读取i和i=i+1都是原子性操作，两个合并就不是原子性操作，可能出现线程不安全。
```
### [2.关于强引用、软引用、弱引用、幻象引用，你该如何回答？](https://www.cnblogs.com/cxuanBlog/p/12774370.html)|
```markdown
1. 强引用:被强引用关联的对象不会被回收。使用new一个新对象的方式来创建强引用。
    Object obj = new Object();
    平时使用的new就是强引用，把一个对象赋给一个引用变量。它处于可达状态的时候，是不会被垃圾回收的。强引用是造成内存泄漏的主要原因。
2. 软引用:被软引用关联的对象只有在内存不够的情况下才会被回收。使用SoftReference类来创建软引用。
    Object obj = new Object();
    SoftReference<Object> sf = new SoftReference<Object>(obj);
    obj = null; // 使对象只被软引用关联
    软引用配合softreference使用，当系统中有足够的内存的时候，不会被回收，当系统中内存空间不足的时候会被回收，软引用存在于对内存敏感的程序中。
3. 弱引用:被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。使用WeakReference类来创建弱引用。
    Object obj = new Object();
    WeakReference<Object> wf = new WeakReference<Object>(obj);
    obj = null;
    弱引用配合weakreference类来实现。比软引用的生存期更短，对于弱引用对象来说，只要垃圾回收机制一回收，不管内存空间是否充足就直接回收掉。
4. 虚引用:又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。
    为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。使用PhantomReference来创建虚引用。
    Object obj = new Object();
    PhantomReference<Object> pf = new PhantomReference<Object>(obj, null);
    obj = null;
    虚引用需要phantomreference来实现，不能单独使用，必须配合引用队列。虚引用主要作用是跟踪对象的被垃圾回收的状态。
5.引用队列
使用软引用，弱引用和虚引用的时候都可以关联这个引用队列。程序通过判断引用队列里面是不是有这个对象来判断，对象是否已经被回收了。
软引用，弱引用和虚引用用来解决oom问题，用来保存图片的路径。主要用于缓存。
```

###
[JVM中的五大内存区域划分详解及快速扫盲](https://www.cnblogs.com/chaogu94/p/12529692.html)

[JVM-内存模型](https://www.cnblogs.com/ljl150/p/12535658.html)

[大厂面试经：高频率JVM面试问题整理！](https://www.cnblogs.com/xwgblog/p/11842394.html)

