# JVM书籍
### 参考书籍
**深入了解Java虚拟机**
[参考博客：随笔分类 - Java虚拟机](https://www.cnblogs.com/ysocean/category/1151281.html)
[ JVM 底层原理知识总结](https://doocs.github.io/jvm)
### 相关博客
[从多线程的三个特性理解多线程开发](https://www.cnblogs.com/dafanjoy/p/10020225.html)
>> 1.共享变量
```markdown
从JVM内存模型的角度上讲，存储在堆内存上数据都是线程共享的，如实例化的对象、全局变量、数组等。
存储在线程栈上的数据是线程独享的，如局部变量、操作栈、动态链接、方法出口等信息。
```
>> 2.原子性操作
```markdown
i++:不是原子性操作，虽然读取i和i=i+1都是原子性操作，两个合并就不是原子性操作，可能出现线程不安全。
```
[JVM中的五大内存区域划分详解及快速扫盲](https://www.cnblogs.com/chaogu94/p/12529692.html)
[JVM-内存模型](https://www.cnblogs.com/ljl150/p/12535658.html)

[垃圾回收与内存分配策略](https://www.cnblogs.com/CodeMLB/p/12113279.html)

### 运行时数据区域
```markdown
程序计数器:记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。
Java虚拟机栈:每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。
            从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。
本地方法栈:本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。
堆:所有对象都在这里分配内存，是垃圾收集的主要区域（"GC堆"）。
方法区:用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
运行时常量池:运行时常量池是方法区的一部分。
```
### JVM是如果确定对象是垃圾对象的呢？JVM判断对象是否存活算法：
```markdown
垃圾收集主要是针对堆和方法区进行。
程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。
引用计数算法：为对象添加一个引用计数器，当对象增加一个引用时计数器加1，引用失效时计数器减1。引用计数为0的对象可被回收。
    在两个对象出现循环引用的情况下，此时引用计数器永远不为0，导致无法对它们进行回收。正是因为循环引用的存在，因此Java虚拟机不使用引用计数算法。
可达性分析算法:
    以 GC Roots为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。
    Java虚拟机使用该算法来判断对象是否可被回收，GC Roots一般包含以下内容：
        虚拟机栈中局部变量表中引用的对象
        本地方法栈中JNI中引用的对象
        方法区中类静态属性引用的对象
        方法区中的常量引用的对象
方法区的回收:因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。
       主要是对常量池的回收和对类的卸载。
       为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。
       类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载：
            该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。
            加载该类的 ClassLoader 已经被回收。
            该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。
finalize():当一个对象可被回收时，如果需要执行该对象的finalize()方法，那么就有可能在该方法中让对象重新被引用，
            从而实现自救。自救只能进行一次，如果回收的对象之前调用了finalize()方法自救，后面回收时不会再调用该方法。
```
[关于强引用、软引用、弱引用、幻象引用，你该如何回答？](https://www.cnblogs.com/cxuanBlog/p/12774370.html)|
```markdown
1. 强引用:被强引用关联的对象不会被回收。使用new一个新对象的方式来创建强引用。
        Object obj = new Object();
2. 软引用:被软引用关联的对象只有在内存不够的情况下才会被回收。使用SoftReference类来创建软引用。
        Object obj = new Object();
        SoftReference<Object> sf = new SoftReference<Object>(obj);
        obj = null; // 使对象只被软引用关联
3. 弱引用:被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。使用WeakReference类来创建弱引用。
        Object obj = new Object();
        WeakReference<Object> wf = new WeakReference<Object>(obj);
        obj = null;
4. 虚引用:又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。
       为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。使用PhantomReference来创建虚引用。
       Object obj = new Object();
       PhantomReference<Object> pf = new PhantomReference<Object>(obj, null);
       obj = null;
```
[Java垃圾收集算法](https://www.cnblogs.com/rainple/p/10793500.html)
[JVM垃圾回收算法详解](https://www.cnblogs.com/xwgblog/p/11703104.html)
```markdown
在JVM内存模型中会将堆内存划分新生代、老年代两个区域，两块区域的主要区别在于新生代存放存活时间较短的对象，
老年代存放存活时间较久的对象，除了存活时间不同外，还有垃圾回收策略的不同，在JVM中中有以下回收算法：
标记-清除：标记阶段是从根集合(GCRoot)开始扫描，每到达一个对象就会标记该对象为存活状态，清除阶段在扫描完成之后将没有标记的对象给清除掉。
        标记和清除过程效率都不高；
        会产生大量不连续的内存碎片，导致无法给大对象分配内存。
标记-整理：从根集合(GCRoot)开始扫描进行标记然后清除无用的对象，清除完成后它会整理内存。没有内存碎片的问题。
        优点:不会产生内存碎片
        不足:需要移动大量对象，处理效率比较低。
标记-复制算法：复制算法会将JVM推分成二等分，给对象分配内存的时候总是使用其中的一块来分配，分配满了以后，GC就会进行标记，然后将存活
的对象移动到另外一块空白的区域，然后清除掉所有没有存活的对象，这样重复的处理，始终就会有一块空白的区域没有被合理的利用到。
        
分代收集算法：分代收集算法将heap区域划分为新生代和老年代，新生代的空间比老年代的空间要小。新生代又分为了Eden和两个survivor空间，它们的比例为8:1:1。
对象被创建时，内存的分配是在新生代的Eden区发生的，大对象直接在老年代分配内存，IBM的研究表明，Eden区98%的对象都是很快消亡的。
        新生代使用：复制算法
        老年代使用：标记 - 清除 或者 标记 - 整理 算法
```
### 垃圾回收器
[一文了解JVM全部垃圾回收器，从Serial到ZGC](https://www.cnblogs.com/zackku/p/10056865.html)
```markdown
Serial收集器:
    是单线程执行垃圾回收的。当需要执行垃圾回收时，程序会暂停一切手上的工作，然后单线程执行垃圾回收。
ParNew收集器:
    ParNew同样用于新生代，是Serial的多线程版本，并且在参数、算法（同样是复制算法）上也完全和Serial相同。
Parallel Scavenge收集器:
    新生代的收集器，同样用的是复制算法，也是并行多线程收集。与ParNew最大的不同，它关注的是垃圾回收的吞吐量。
Serial Old收集器:
    是 Serial 收集器的老年代版本，与Serial一样是单线程，不同的是算法用的是标记-整理（Mark-Compact）。
Parallel Old收集器:
    是Parallel Scavenge收集器的老年代版本，是Parallel Scavenge老年代的版本。其中的算法替换成Mark-Compact。
CMS收集器:
    同样是老年代的收集器。它关注的是垃圾回收最短的停顿时间（低停顿），在老年代并不频繁GC的场景下，是比较适用的。
    分为以下四个流程：
    初始标记：仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，需要停顿。
    并发标记：进行GC Roots Tracing的过程，它在整个回收过程中耗时最长，不需要停顿。
    重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。
    并发清除：不需要停顿。
    缺点:1.吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。
         2.无法处理浮动垃圾，可能出现Concurrent Mode Failure。
        浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次GC时才能进行回收。
        由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。
        如果预留的内存不够存放浮动垃圾，就会出现Concurrent Mode Failure，这时虚拟机将临时启用Serial Old来替代CMS。
         3.标记-清除算法导致的空间碎片往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。。
G1收集器:
    G1可以说是CMS的终极改进版，解决了CMS内存碎片、更多的内存空间登问题。虽然流程与CMS比较相似，但底层的原理已是完全不同。
    G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多CPU和大内存的场景下有很好的性能。HotSpot开发团队赋予它的使命是未来可以替换掉CMS收集器。
    堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而G1可以直接对新生代和老年代一起回收。
    G1 收集器的运作大致可划分为以下几个步骤：
        1.初始标记
        2.并发标记
        3.最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的
        Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中。这阶段需要停顿线程，但是可并行执行。
        4.筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计
        划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，
        而且停顿用户线程将大幅度提高收集效率。
ZGC(Z Garbage Collector): 
    在JDK 11中新加入的具有实验性质的低延迟垃圾收集器，
    
```


  
### 内存分配与回收策略
#### Minor GC 和 Full GC
```markdown
Minor GC：回收新生代，因为新生代对象存活时间很短，因此Minor GC会频繁执行，执行的速度一般也会比较快。
Full GC：回收老年代和新生代，老年代对象其存活时间长，因此Full GC很少执行，执行速度会比Minor GC慢很多。
```
#### 内存分配策略
```markdown
1. 对象优先在Eden分配:大多数情况下，对象在新生代Eden上分配，当Eden空间不够时，发起Minor GC。
2. 大对象直接进入老年代:
        大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。
        经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。
        -XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在Eden和Survivor之间的大量内存复制。
3. 长期存活的对象进入老年代
        为对象定义年龄计数器，对象在Eden出生并经过Minor GC依然存活，将移动到Survivor中，年龄就增加1岁，增加到一定年龄则移动到老年代中。
        -XX:MaxTenuringThreshold用来定义年龄的阈值。
4. 动态对象年龄判定
        虚拟机并不是永远要求对象的年龄必须达到MaxTenuringThreshold才能晋升老年代，如果在Survivor中相同年龄
        所有对象大小的总和大于Survivor空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到MaxTenuringThreshold中要求的年龄。
5. 空间分配担保
        在发生Minor GC之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么Minor GC可以确认是安全的。
        如果不成立的话虚拟机会查看HandlePromotionFailure的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否
        大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC；如果小于，或者HandlePromotionFailure的值不允许冒险，那么就要进行一次Full GC。
```
#### Full GC 的触发条件
```markdown
对于 Minor GC，其触发条件非常简单，当Eden空间满时，就将触发一次Minor GC。而Full GC则相对复杂，有以下条件：
    1. 调用System.gc():建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。
    2. 老年代空间不足:老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。
    3.空间分配担保失败:使用复制算法的Minor GC需要老年代的内存空间作担保，如果担保失败会执行一次Full GC。
    4.JDK 1.7 及以前的永久代空间不足:
        在JDK 1.7及以前，HotSpot虚拟机中的方法区是用永久代实现的，永久代中存放的为一些Class的信息、常量、静态变量等数据。
    5. Concurrent Mode Failure:执行CMS GC的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是GC过程中浮动垃圾过多导致暂时
        性的空间不足），便会报Concurrent Mode Failure错误，并触发Full GC。
```
### 类加载机制
```markdown
类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类。因为如果一次性加载，那么会占用很多的内存。
类的生命周期   【图】
        加载（Loading）
        验证（Verification）
        准备（Preparation）
        解析（Resolution）
        初始化（Initialization）
        使用（Using）
        卸载（Unloading）
类加载过程：包含了加载、验证、准备、解析和初始化这 5 个阶段。
    1. 加载
        加载过程完成以下三件事：
        1.通过类的完全限定名称获取定义该类的二进制字节流。
        2.将该字节流表示的静态存储结构转换为方法区的运行时存储结构。
        3.在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。
    2. 验证
        确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
    3. 准备
        类变量是被static修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。
        实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。
        应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。
    4.解析
        将常量池的符号引用替换为直接引用的过程。
        其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。
    5. 初始化
        初始化阶段才真正开始执行类中定义的Java程序代码。初始化阶段是虚拟机执行类构造器<clinit>()方法的过程。
        在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。 
```
#### 类初始化时机
```markdown
1. 主动引用
2. 被动引用
    1.通过子类引用父类的静态字段，不会导致子类初始化。
        System.out.println(SubClass.value); // value 字段在 SuperClass 中定义
    2.通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动
      生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。SuperClass[] sca = new SuperClass[10];
    3.常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。
        System.out.println(ConstClass.HELLOWORLD);
```
#### 类加载器分类
```markdown
从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器：
    启动类加载器（Bootstrap ClassLoader），使用 C++ 实现，是虚拟机自身的一部分；
    所有其它类的加载器，使用 Java 实现，独立于虚拟机，继承自抽象类 java.lang.ClassLoader。
从 Java 开发人员的角度看，类加载器可以划分得更细致一些：
    启动类加载器（Bootstrap ClassLoader）
    扩展类加载器（Extension ClassLoader）
    应用程序类加载器（Application ClassLoader）
```
#### 双亲委派模型
#### 自定义类加载器实现


[大厂面试经：高频率JVM面试问题整理！](https://www.cnblogs.com/xwgblog/p/11842394.html)

