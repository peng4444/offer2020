# 阅读深入浅出多线程
**项目地址链接**  [深入浅出多线程](https://github.com/RedSpider1/concurrent) **欢迎为作者们点赞star**，可以gitbook或者下载PDF阅读哦！
## 第一章：进程和线程的基本概念
### 1.1进程和线程
>> 进程：是应用程序在内存中分配的空间，也就是正在运行的程序，各个进程之间互不干扰。同时进程保存着程序每⼀个时刻运行的状态。

>> 线程：让一个线程执行一个子任务，这样⼀个进程就包含了多个线程，每个线程负责⼀个单独的⼦任务
### 1.1.1进程和线程的区别与联系
```markdown
对于操作系统而言，一个任务就是一个进程；进程是系统中程序执行和资源分配的基本单元，每个进程都有自己的数据段、代码段、堆栈段。
两个本质的区别是是否单独占有内存地址空间及其它系统资源（⽐如I/O）。
进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位，即CPU分配时间的单位。
```
### 1.2上下文切换
```markdown
上下文切换（有时也称做进程切换或任务切换）是指 CPU 从⼀个进程（或线程）切换到另⼀个进程（或线程）。
上下文是指某⼀时间点 CPU 寄存器和程序计数器的内容。
```
## 第二章：Java多线程入门类和接口
[参考资料Java多线程:进程和线程的概念和创建线程的三种方式](https://www.cnblogs.com/wmqBlog/p/9956235.html)
### 2.1 Thread类和Runnable接口
[当阿里面试官问我：Java创建线程有几种方式？我就知道问题没那么简单](https://www.cnblogs.com/eson15/p/12666341.html)
>> 继承Thread类 
>> 实现Runnable接口
>> 实现Callable接口
### 2.1.1 Thread类和Runnable接口的比较
```markdown
由于Java“单继承，多实现”的特性，Runnable接口使用起来比Thread更灵活。Runnable接口出现更符合面向对象，将线程单独进行对象的封装。
Runnable接口出现，降低了线程对象和线程任务的耦合性。如果使用线程时不需要使⽤Thread类的诸多⽅法，显然使用Runnable接口更为轻量。
Runnable接口和Thread类创建线程的run方法没有返回值，Callable接口和Future类可以实现。
```
### 2.2 Callable,Future和FutureTask
[参考资料：java中Future与FutureTask使用与分析](https://www.cnblogs.com/dafanjoy/p/9778271.html)
>> Future和FutureTask的区别联系
```markdown
FutureTask是实现的RunnableFuture接口的，而RunnableFuture接口同时继承了Runnable接口和Future接口：
使用FutureTask直接取get取值，而上面的Demo是通过submit方法返回的Future去取值。
在很多高并发的环境下，有可能Callable和FutureTask会创建多次。FutureTask能够在高并发环境下确保任务只执行一次。
```
## 第三章：线程组和线程优先级
>> 线程组
>> 线程优先级
```markdown
Java程序中对线程所设置的优先级只是给操作系统⼀个建议，操作系统不⼀定会采纳。而真正的调⽤顺序，是由操作系统的线程调度算法决定的。
线程优先级和线程组优先级
如果某个线程优先级大于线程所在线程组的最大优先级，那么该线程的优先级将会失效，取而代之的是线程组的最大优先级。
总结：线程组是⼀个树状的结构，每个线程组下面可以有多个线程或者线程组。线程组可以起到统⼀控制线程的优先级和检查线程的权限的作用。
```
## 第四章 Java线程的状态及主要转化⽅法
>> NEW RUNNABLE BLOCKED WATTING TIMED_WAITING TERMINATED
### 线程start()的两个问题
```markdown
1. 反复调⽤同⼀个线程的start()方法是否可行？ 不可行，在第一次调用之后ThreadStatus的值改变，反复调用会报异常。
2. 假如⼀个线程执行完毕（此时处于TERMINATED状态），再次调用这个线程的start()⽅法是否可行？
```


[从多线程的三个特性理解多线程开发](https://www.cnblogs.com/dafanjoy/p/10020225.html)
