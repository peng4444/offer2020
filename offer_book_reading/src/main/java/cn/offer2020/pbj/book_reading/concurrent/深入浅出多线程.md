# 阅读深入浅出多线程
**项目地址链接**  [深入浅出多线程](https://github.com/RedSpider1/concurrent) **欢迎为作者们点赞star**，可以gitbook或者下载PDF阅读哦！
## 第一章：进程和线程的基本概念
### 1.1进程和线程
>> 进程：是应用程序在内存中分配的空间，也就是正在运行的程序，各个进程之间互不干扰。同时进程保存着程序每⼀个时刻运行的状态。

>> 线程：让一个线程执行一个子任务，这样⼀个进程就包含了多个线程，每个线程负责⼀个单独的⼦任务
### 1.1.1进程和线程的区别与联系
```markdown
对于操作系统而言，一个任务就是一个进程；进程是系统中程序执行和资源分配的基本单元，每个进程都有自己的数据段、代码段、堆栈段。
两个本质的区别是是否单独占有内存地址空间及其它系统资源（⽐如I/O）。
进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位，即CPU分配时间的单位。
```
### 1.2上下文切换
```markdown
上下文切换（有时也称做进程切换或任务切换）是指 CPU 从⼀个进程（或线程）切换到另⼀个进程（或线程）。
上下文是指某⼀时间点 CPU 寄存器和程序计数器的内容。
```
## 第二章：Java多线程入门类和接口
[参考资料Java多线程:进程和线程的概念和创建线程的三种方式](https://www.cnblogs.com/wmqBlog/p/9956235.html)
### 2.1 Thread类和Runnable接口
[当阿里面试官问我：Java创建线程有几种方式？我就知道问题没那么简单](https://www.cnblogs.com/eson15/p/12666341.html)
>> 继承Thread类 
>> 实现Runnable接口
>> 实现Callable接口
### 2.1.1 Thread类和Runnable接口的比较
```markdown
由于Java“单继承，多实现”的特性，Runnable接口使用起来比Thread更灵活。Runnable接口出现更符合面向对象，将线程单独进行对象的封装。
Runnable接口出现，降低了线程对象和线程任务的耦合性。如果使用线程时不需要使⽤Thread类的诸多⽅法，显然使用Runnable接口更为轻量。
Runnable接口和Thread类创建线程的run方法没有返回值，Callable接口和Future类可以实现。
```
### 2.2 Callable,Future和FutureTask
[参考资料：java中Future与FutureTask使用与分析](https://www.cnblogs.com/dafanjoy/p/9778271.html)
>> Future和FutureTask的区别联系
```markdown
FutureTask是实现的RunnableFuture接口的，而RunnableFuture接口同时继承了Runnable接口和Future接口：
使用FutureTask直接取get取值，而上面的Demo是通过submit方法返回的Future去取值。
在很多高并发的环境下，有可能Callable和FutureTask会创建多次。FutureTask能够在高并发环境下确保任务只执行一次。
```
## 第三章：线程组和线程优先级
>> 线程组
>> 线程优先级
```markdown
Java程序中对线程所设置的优先级只是给操作系统⼀个建议，操作系统不⼀定会采纳。而真正的调⽤顺序，是由操作系统的线程调度算法决定的。
线程优先级和线程组优先级
如果某个线程优先级大于线程所在线程组的最大优先级，那么该线程的优先级将会失效，取而代之的是线程组的最大优先级。
总结：线程组是⼀个树状的结构，每个线程组下面可以有多个线程或者线程组。线程组可以起到统⼀控制线程的优先级和检查线程的权限的作用。
```
## 第四章 Java线程的状态及主要转化⽅法
>> NEW RUNNABLE BLOCKED WATTING TIMED_WAITING TERMINATED
### 线程start()的两个问题
```markdown
1. 反复调用同⼀个线程的start()方法是否可行？ 不可行，在第一次调用之后ThreadStatus的值改变，反复调用会报异常。
2. 假如⼀个线程执行完毕（此时处于TERMINATED状态），再次调用这个线程的start()方法是否可行？
```



[从多线程的三个特性理解多线程开发](https://www.cnblogs.com/dafanjoy/p/10020225.html)
>> 原子性，有序性，可见性
```markdown
原子性是指一个操作或者一系列操作要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。
有序性的本义是指程序在执行的时候，程序的代码执行顺序和语句的顺序是一致的。
volatile能够保证数据的可见性，但是不能保证数据的原子性，synchronized两者都能保证。
使用synchronized、volatile，加锁lock等方式一般及可以保证线程的可见性与有序性。
```
[Java并发编程之验证volatile不能保证原子性](https://www.cnblogs.com/kaigejava/p/12544060.html)
>> volatile的三大特性。1：保证可见性 2：不保证原子性 3：保证顺序。
```markdown
i++的运行结果无法保证原子性，
```
## 第九章 synchronized与锁
```markdown
synchronized修饰的方法或代码块相当于并发中的临界区，即在同一时刻jvm只允许一个线程进入执行。synchronized是通过锁机制实现
同一时刻只允许一个线程来访问共享资源的。另外synchronized锁机制还可以保证线程并发运行的原子性，有序性，可见性。
```
[Synchronized实现原理深入解析](https://www.cnblogs.com/wyc1994666/p/11748212.html)
[synchronized实现原理及其优化-（自旋锁，偏向锁，轻量锁，重量锁）](https://www.cnblogs.com/ljl150/p/12514198.html)
```markdown
在jdk1.5之前，只有synchronized重量级锁，实现需要借助操作系统，是比较消耗性能的操作，在1.6之中为了提高性能，
便对synchronized锁进行了优化，实现了各种锁优化技术，如：适应性自旋，锁消除，锁粗化，轻量级锁，偏向锁。
```
### 轻量级锁
```markdown
轻量级锁是jdk1.6中加入的新型锁机制，它名字中的“轻量级”是相对于使用操作系统互斥量来实现的重量级锁而言的。首先需要强调的是，
轻量级锁并不是来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统重量级锁使用操作系统互斥量产生的性能消耗。
在解释轻量级锁的执行过程之前，先明白一点，轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，
就会导致轻量级锁膨胀为重量级锁。
```
### 偏向锁
```markdown
Java偏向锁是在jdk1.6中引入的，它的目的是消除数据无竞争情况下的同步原语，进一步提高程序的运行性能。如果说轻量级锁是
在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除连CAS都不做。
```
### 自旋锁
```markdown
自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入
阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗
```
### 重量级锁、轻量级锁和偏向锁之间转换
### 各种锁的使用场景
```markdown
偏向锁：通常只有一个线程访问临界区。
轻量级锁：可以有多个线程交替进入临界区，在竞争不激烈的时候，稍微自旋就能获得锁。
重量级锁：线程间出现了激烈的竞争就需要使用重量级锁，此时未获取到锁的线程会进入阻塞队列，需要操作系统介入。
jvm设置偏向锁和轻量级锁，就是为了避免阻塞，避免操作系统的介入。
```
```markdown
锁的状态总共有四种，无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁。
锁                  优点                          缺点                         适用场景

偏向锁   加锁和解锁不需要额外的消耗，         如果线程间存在锁竞争，          适用于只有一个线程访问同步块场景。
        和执行非同步方法比仅存在纳秒级的差距。 会带来额外的锁撤销的消耗。

轻量级锁       竞争的线程不会阻塞，        如果始终得不到锁竞争               追求响应时间。同步块执行速度非常快。
            提高了程序的响应速度。         的线程使用自旋会消耗CPU。

重量级锁  线程竞争不使用自旋，不会消耗CPU。  线程阻塞，响应时间缓慢。          追求吞吐量。同步块执行速度较长。
```

## 第十二章 线程池
[线程池原理初探](https://www.cnblogs.com/volcano-liu/p/10783008.html)
