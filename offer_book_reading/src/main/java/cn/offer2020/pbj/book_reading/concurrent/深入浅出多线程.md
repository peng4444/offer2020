# 阅读深入浅出多线程
**项目地址链接**  [深入浅出多线程](https://github.com/RedSpider1/concurrent) **欢迎为作者们点赞star**，可以gitbook或者下载PDF阅读哦！
[参考博客：随笔分类 - Java多线程](https://www.cnblogs.com/ljl150/category/1657632.html)
## 第一章：进程和线程的基本概念
### 1.1进程和线程
>> 进程：是应用程序在内存中分配的空间，也就是正在运行的程序，各个进程之间互不干扰。同时进程保存着程序每⼀个时刻运行的状态。

>> 线程：让一个线程执行一个子任务，这样⼀个进程就包含了多个线程，每个线程负责⼀个单独的⼦任务
### 1.1.1进程和线程的区别与联系
```markdown
对于操作系统而言，一个任务就是一个进程；进程是系统中程序执行和资源分配的基本单元，每个进程都有自己的数据段、代码段、堆栈段。
两个本质的区别是是否单独占有内存地址空间及其它系统资源（⽐如I/O）。
进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位，即CPU分配时间的单位。
```
### 1.2上下文切换
```markdown
上下文切换（有时也称做进程切换或任务切换）是指 CPU 从⼀个进程（或线程）切换到另⼀个进程（或线程）。
上下文是指某⼀时间点 CPU 寄存器和程序计数器的内容。
```
## 第二章：Java多线程入门类和接口
[参考资料Java多线程:进程和线程的概念和创建线程的三种方式](https://www.cnblogs.com/wmqBlog/p/9956235.html)
### 2.1 Thread类和Runnable接口
[当阿里面试官问我：Java创建线程有几种方式？我就知道问题没那么简单](https://www.cnblogs.com/eson15/p/12666341.html)
>> 继承Thread类 
>> 实现Runnable接口
>> 实现Callable接口
### 2.1.1 Thread类和Runnable接口的比较
```markdown
由于Java“单继承，多实现”的特性，Runnable接口使用起来比Thread更灵活。Runnable接口出现更符合面向对象，将线程单独进行对象的封装。
Runnable接口出现，降低了线程对象和线程任务的耦合性。如果使用线程时不需要使⽤Thread类的诸多⽅法，显然使用Runnable接口更为轻量。
Runnable接口和Thread类创建线程的run方法没有返回值，Callable接口和Future类可以实现。
```
### 2.2 Callable,Future和FutureTask
[参考资料：java中Future与FutureTask使用与分析](https://www.cnblogs.com/dafanjoy/p/9778271.html)
>> Future和FutureTask的区别联系
```markdown
FutureTask是实现的RunnableFuture接口的，而RunnableFuture接口同时继承了Runnable接口和Future接口：
使用FutureTask直接取get取值，而上面的Demo是通过submit方法返回的Future去取值。
在很多高并发的环境下，有可能Callable和FutureTask会创建多次。FutureTask能够在高并发环境下确保任务只执行一次。
```
## 第三章：线程组和线程优先级
>> 线程组
>> 线程优先级
```markdown
Java程序中对线程所设置的优先级只是给操作系统⼀个建议，操作系统不⼀定会采纳。而真正的调⽤顺序，是由操作系统的线程调度算法决定的。
线程优先级和线程组优先级
如果某个线程优先级大于线程所在线程组的最大优先级，那么该线程的优先级将会失效，取而代之的是线程组的最大优先级。
总结：线程组是⼀个树状的结构，每个线程组下面可以有多个线程或者线程组。线程组可以起到统⼀控制线程的优先级和检查线程的权限的作用。
```
## 第四章 Java线程的状态及主要转化⽅法
>> NEW RUNNABLE BLOCKED WATTING TIMED_WAITING TERMINATED
### 线程start()的两个问题
```markdown
1. 反复调用同⼀个线程的start()方法是否可行？ 不可行，在第一次调用之后ThreadStatus的值改变，反复调用会报异常。
2. 假如⼀个线程执行完毕（此时处于TERMINATED状态），再次调用这个线程的start()方法是否可行？
```
## 第五章 Java线程之间的通信
[多线程通讯(wait、notify、Lock、ThreadLocal)](https://www.cnblogs.com/javatalk/p/9924531.html)
```markdown
线程锁与同步，wait(),notify(),notifyAll(),信号量，管道，Join,ThreadLocal
```
## 第六章 Java内存模型基础知识
### 并发编程的两个关键问题
```markdown
线程间如何通信？即：线程之间以何种机制来交换信息               
线程间如何同步？即：线程以何种机制来控制不同线程间操作发生的相对顺序
两种并发模型可以解决这两个问题：
消息传递并发模型
共享内存并发模型  在Java中，使用的是共享内存并发模型。
```
## 第七章  重排序与happens-before
>> 重排序：计算机在执⾏程序时，为了提⾼性能，编译器和处理器常常会对指令做重排。
```markdown
编译器优化重排:编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
指令并行重排:
内存系统重排：
```
>> happens-before规则
```markdown
是⼀个给程序员使用的规则，只要程序员在写代码的时候遵循happens-before规则
则，JVM就能保证指令在多线程之间的顺序性符合程序员的预期。
```
## 第八章 volatile
[从多线程的三个特性理解多线程开发](https://www.cnblogs.com/dafanjoy/p/10020225.html)
>> 原子性，有序性，可见性
```markdown
原子性：指一个操作或者一系列操作要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。
有序性：本义是指程序在执行的时候，程序的代码执行顺序和语句的顺序是一致的。
内存可见性：指的是线程之间的可见性，当⼀个线程修改了共享变量时，另⼀个线程可以读取到这个修改后的值。
volatile能够保证数据的可见性，但是不能保证数据的原子性，synchronized两者都能保证。i++的运行结果无法保证原子性，
使用synchronized、volatile，加锁lock等方式一般及可以保证线程的可见性与有序性。
volatile:禁止volatile变量与普通变量重排序
```
[Java内存可见性volatile](https://www.cnblogs.com/junejs/p/12686902.html)
>> 所谓内存可⻅性:指的是当⼀个线程对 volatile 修饰的变量进⾏写操作时，JMM会⽴即把该线程对应的本地内存中的共享变量的值刷新到
主内存；当⼀个线程对 volatile 修饰的变量进⾏读操作时，JMM会把⽴即该线程对应的本地内存置为⽆效，从主内存中读取共享变量的值。
[Java并发编程之验证volatile不能保证原子性](https://www.cnblogs.com/kaigejava/p/12544060.html)
>> volatile的三大特性。1：保证可见性 2：不保证原子性 3：保证顺序。
## 第九章 synchronized与锁
```markdown
synchronized修饰的方法或代码块相当于并发中的临界区，即在同一时刻jvm只允许一个线程进入执行。synchronized是通过锁机制实现
同一时刻只允许一个线程来访问共享资源的。另外synchronized锁机制还可以保证线程并发运行的原子性，有序性，可见性。
所谓“临界区”，指的是某⼀块代码区域，它同⼀时刻只能由⼀个线程执行。
```
[Synchronized实现原理深入解析](https://www.cnblogs.com/wyc1994666/p/11748212.html)
[synchronized实现原理及其优化-（自旋锁，偏向锁，轻量锁，重量锁）](https://www.cnblogs.com/ljl150/p/12514198.html)
```markdown
在jdk1.5之前，只有synchronized重量级锁，实现需要借助操作系统，是比较消耗性能的操作，在1.6之中为了提高性能，
便对synchronized锁进行了优化，实现了各种锁优化技术，如：适应性自旋，锁消除，锁粗化，轻量级锁，偏向锁。
1. 无锁状态
2. 偏向锁状态  
3. 轻量级锁状态
4. 重量级锁状态
```
### 偏向锁
```markdown
Java偏向锁是在jdk1.6中引入的，它的目的是消除数据无竞争情况下的同步原语，进一步提高程序的运行性能。如果说轻量级锁是
在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除连CAS都不做。
偏向锁使用了⼀种等到竞争出现才释放锁的机制 所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。
```
### 轻量级锁
```markdown
轻量级锁是jdk1.6中加入的新型锁机制，它名字中的“轻量级”是相对于使用操作系统互斥量来实现的重量级锁而言的。首先需要强调的是，
轻量级锁并不是来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统重量级锁使用操作系统互斥量产生的性能消耗。
在解释轻量级锁的执行过程之前，先明白一点，轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，
就会导致轻量级锁膨胀为重量级锁。
```
### 自旋锁  
```markdown
自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入
阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗
```
### 重量级锁
### 重量级锁、轻量级锁和偏向锁之间转换
>> 偏向锁升级成轻量级锁
```markdown
偏向锁升级成轻量级锁时，会暂停拥有偏向锁的线程，重置偏向锁标识，这个过程看起来容易，实则开销还是很大的，大概的过程如下：
1. 在⼀个安全点（在这个时间点上没有字节码正在执行）停止拥有锁的线程。
2. 遍历线程栈，如果存在锁记录的话，需要修复锁记录和Mark Word，使其变成无锁状态。
3. 唤醒被停止的线程，将当前锁升级成轻量级锁。
```
>> 线程获取锁时发生其他锁已经获取，就自旋获取锁 失败就锁膨胀修改为重量级锁。
### 锁的升级流程
```markdown
每一个线程在准备获取共享资源时： 第⼀步，检查MarkWord里面是不是放的自己的ThreadId ,如果是，表示当前线程是处于 “偏向锁” 。
第二步，如果MarkWord不是自己的ThreadId，锁升级，这时候，用CAS来执行切换，新的线程根据MarkWord里面现有的ThreadId，
通知之前线程暂停，之前线程将Markword的内容置为空。
第三步，两个线程都把锁对象的HashCode复制到自己新建的用于存储锁的记录空间，接着开始通过CAS操作， 
把锁对象的MarKword的内容修改为自己新建的记录空间的地址的方式竞争MarkWord。
第四步，第三步中成功执行CAS的获得资源，失败的则进⼊自旋 。
第五步，自旋的线程在自旋过程中，成功获得资源(即之前获的资源的线程执行完成并释放了共享资源)，则整个状态依然处于轻量级锁的状态，如果⾃旋失败 。
第六步，进⼊重量级锁的状态，这个时候，自旋的线程进行阻塞，等待之前线程执行完成并唤醒自己。
```
### 各种锁的使用场景
```markdown
偏向锁：通常只有一个线程访问临界区。
轻量级锁：可以有多个线程交替进入临界区，在竞争不激烈的时候，稍微自旋就能获得锁。
重量级锁：线程间出现了激烈的竞争就需要使用重量级锁，此时未获取到锁的线程会进入阻塞队列，需要操作系统介入。
jvm设置偏向锁和轻量级锁，就是为了避免阻塞，避免操作系统的介入。
```
```markdown
锁的状态总共有四种，无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁。
锁                  优点                          缺点                         适用场景

偏向锁   加锁和解锁不需要额外的消耗，         如果线程间存在锁竞争，          适用于只有一个线程访问同步块场景。
        和执行非同步方法比仅存在纳秒级的差距。 会带来额外的锁撤销的消耗。

轻量级锁       竞争的线程不会阻塞，        如果始终得不到锁竞争               追求响应时间。同步块执行速度非常快。
            提高了程序的响应速度。         的线程使用自旋会消耗CPU。

重量级锁  线程竞争不使用自旋，不会消耗CPU。  线程阻塞，响应时间缓慢。          追求吞吐量。同步块执行速度较长。
```
## 第十章 乐观锁和悲观锁
[乐观锁和悲观锁](https://www.cnblogs.com/ljl150/p/12506034.html)
```markdown
乐观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，
只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。
悲观锁：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；
上锁期间其他人不能修改数据。
```
### CAS实现原子操作的三大问题
```markdown
ABA问题：就是⼀个值原来是A，变成了B，又变回了A。这个时候使用CAS是检查不出变化的，但实际上却被更新了两次。
解决思路是在变量前⾯追加上版本号或者时间戳
循环时间长开销大：CAS多与自旋结合。如果自旋CAS长时间不成功，会占用⼤量的CPU资源。
解决思路是让JVM支持处理器提供的pause指令。
只能保证一个共享变量的原子操作：
```
## 第十一章 AQS
[看看AQS阻塞队列和条件队列](https://www.cnblogs.com/wyq1995/p/12253792.html)
[Java多线程——AQS框架源码阅读](https://www.cnblogs.com/zackku/p/9984887.html)
[java之AQS和显式锁](https://www.cnblogs.com/hongshaodian/p/12452136.html)
>> AQS是 AbstractQueuedSynchronizer 的简称，即抽象队列同步器
```markdown
AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的同步器，比如我们提到的ReentrantLock，Semaphore，
ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。
```
[ReentrantLock是如何基于AQS实现的](https://www.cnblogs.com/liyus/p/10760411.html)
```markdown
ReentrantLock是一个可重入的互斥锁，基于AQS实现，它具有与使用 synchronized 方法和语句相同的一些基本行为和语义，但功能更强大。
ReentantLock同步方式是独占模式，资源是独占的，一次只能一个线程获取。
```
## 第十二章 线程池
[线程池原理初探](https://www.cnblogs.com/volcano-liu/p/10783008.html)
[线程池源码探究](https://www.cnblogs.com/NaLanZiYi-LinEr/p/12714607.html)
[Java 8 ThreadLocal 源码解析](https://www.cnblogs.com/Finley/p/10162144.html)
[如何设置线程池参数？美团给出了一个让面试官虎躯一震的回答。](https://www.cnblogs.com/thisiswhy/p/12690630.html)
### 为什么要使用线程池
```markdown
1. 创建/销毁线程需要消耗系统资源，线程池可以复用已创建的线程
2. 控制并发的数量。并发数量过多，可能会导致资源消耗过多，从而造成服务器崩溃。（主要原因）
3. 可以对线程做统一管理。
```
## 第十三章 阻塞队列

## 第十五章 并发集合容器
[ConcurrentHashMap实现原理及源码分析](https://www.cnblogs.com/chengxiao/p/6842045.html)



>> CAS:Compare and Swap ⽐较并设置。⽤于在硬件层⾯上提供原⼦性操作。
[锁开销优化以及 CAS 简单说明](https://www.cnblogs.com/cposture/p/10761396.html)


[CountDownLatch是个啥？](https://www.cnblogs.com/zhangweicheng/p/12679116.html)
[并发——深入分析CountDownLatch的实现原理](https://www.cnblogs.com/tuyang1129/p/12692423.html)


[并发——深入分析ThreadLocal的实现原理](https://www.cnblogs.com/tuyang1129/p/12713815.html)
