# 阅读深入浅出多线程

**项目地址链接**  [**深入浅出多线程**](https://github.com/RedSpider1/concurrent) **欢迎为作者们点赞star**。

可以gitbook或者下载PDF阅读哦！[**gitbook地址**](https://redspider.gitbook.io/concurrent) ---- 

[参考视频：黑马-全面深入学习java并发编程，中级程序员进阶必会](https://www.bilibili.com/video/BV16J411h7Rd)

[TOC]


## 第一章：进程和线程的基本概念
### 1.1进程和线程
>> 进程：是应用程序在内存中分配的空间，也就是正在运行的程序，各个进程之间互不干扰。同时进程保存着程序每⼀个时刻运行的状态。

>> 线程：让一个线程执行一个子任务，这样⼀个进程就包含了多个线程，每个线程负责⼀个单独的⼦任务。
### 1.1.1进程和线程的区别与联系
```markdown
对于操作系统而言，一个任务就是一个进程；进程是系统中程序执行和资源分配的基本单元，每个进程都有自己的数据段、代码段、堆栈段。
两个本质的区别是是否单独占有内存地址空间及其它系统资源（⽐如I/O）。
进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位，即CPU分配时间的单位。
```
### 1.2上下文切换
```markdown
上下文切换（有时也称做进程切换或任务切换）是指CPU从一个进程（或线程）切换到另一个进程（或线程）。
上下文是指某一时间点CPU寄存器和程序计数器的内容。频繁地上下文线程切换会影响性能。
```
### 1.3 并行和并发
```markdown
并发（concurrent）是同一时间应对（dealing with）多件事情的能力。
并行（parallel）是同一时间动手做（doing）多件事情的能力。
```
### 1.4 同步和异步
```markdown
需要等待结果返回，才能继续运行就是同步。（synchronous）同步在多线程中还有另外一层意思，是让多个线程步调一致。
不需要等待结果返回，就能继续运行就是异步。(asynchronous)
```
### 多线程的应用
```markdown
异步调用，提升效率，
```
## 第二章：Java多线程入门类和接口
[参考资料Java多线程:进程和线程的概念和创建线程的三种方式](https://www.cnblogs.com/wmqBlog/p/9956235.html)
### 2.1 Thread类和Runnable接口
[当阿里面试官问我：Java创建线程有几种方式？我就知道问题没那么简单](https://www.cnblogs.com/eson15/p/12666341.html)

[多线程的四种实现方式](https://www.cnblogs.com/xpybsh/p/12818796.html)
>> 继承Thread类 
>> 实现Runnable接口 调用Thread类启动
>> 实现Callable接口 使用FutureTask对返回值进行封装，调用Thread类启动
>> 提供指定线程数量的线程池,执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象
### 2.1.1 Thread类和Runnable接口的比较
```markdown
由于Java“单继承，多实现”的特性，Runnable接口使用起来比Thread更灵活。Runnable接口出现更符合面向对象，将线程单独进行对象的封装。
Runnable接口出现，降低了线程对象和线程任务的耦合性。如果使用线程时不需要使用Thread类的诸多方法，显然使用Runnable接口更为轻量。
Runnable接口和Thread类创建线程的run方法没有返回值，Callable接口和Future类可以实现。
```
### 2.2 Callable,Future和 FutureTask
[参考资料：java中Future与FutureTask使用与分析](https://www.cnblogs.com/dafanjoy/p/9778271.html)
### 2.2.1 Future和FutureTask的区别联系
```markdown
FutureTask是实现的RunnableFuture接口的，而RunnableFuture接口同时继承了Runnable接口和Future接口：
FutureTask可用于异步获取执行结果或取消执行任务的场景。当一个计算任务需要执行很长时间，那么就可以用FutureTask来封装这个任务，主线程在完成自己的任务之后再去获取结果。
在很多高并发的环境下，有可能Callable和FutureTask会创建多次。FutureTask能够在高并发环境下确保任务只执行一次。
```
### 2.3 线程运行原理
#### 2.3.1 栈和栈帧
```markdown
JVM中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？其实就是线程，每个线程启动后，虚拟机就会为其分配一块栈内存。
每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存。每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法
```
## 第三章：线程组和线程优先级
>> 线程组
>> 线程优先级
```markdown
Java程序中对线程所设置的优先级只是给操作系统⼀个建议，操作系统不⼀定会采纳。而真正的调用顺序，是由操作系统的线程调度算法决定的。
线程优先级和线程组优先级
如果某个线程优先级大于线程所在线程组的最大优先级，那么该线程的优先级将会失效，取而代之的是线程组的最大优先级。
总结：线程组是⼀个树状的结构，每个线程组下面可以有多个线程或者线程组。线程组可以起到统一控制线程的优先级和检查线程的权限的作用。
```
## 第四章 Java线程的状态及主要转化⽅法
[深入理解Java线程状态转移](https://www.cnblogs.com/darope/p/12748184.html)
![线程状态转换https://www.cnblogs.com/darope/p/12748184.html](https://images.cnblogs.com/cnblogs_com/darope/1747012/o_200421111345%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB.png)
```markdown
NEW RUNNABLE BLOCKED WATTING TIMED_WAITING TERMINATED
1. 新建态(NEW)：一个线程被创建出来时候所处的状态 ；
2. 就绪态：线程调用start()方法后，便处于可以被操作系统调度的状态，即就绪态。
            就绪状态可以由三处转化而来，新建态执行了start、线程阻塞结束、锁池等待队列中的线程获得了锁。
3. 运行态(RUNNABLE)：表示当前线程被操作系统调度，分配了时间片，执行线程中的run方法时的状态。
            运行态只可以由就绪态的线程转化而来，如果多个线程都处在就绪态，就等待操作系统分配
4. 阻塞态(BLOCKED):表示当前线程被由于某种原因，被挂起，也就是被阻塞，正在运行的线程被阻塞后，
            即使结束阻塞状态也回不去运行态，只能回到就绪态，等待os分配cpu资源去调度。
5. 无限期等待（Waiting）：等待其它线程显式地唤醒，否则不会被分配 CPU 时间片。
            进入方法：                                       退出方法：
            没有设置Timeout参数的Object.wait()方法       Object.notify() / Object.notifyAll()
            没有设置Timeout参数的Thread.join()方法       被调用的线程执行完毕
            LockSupport.park()方法                      LockSupport.unpark(Thread)
6. 限期等待（Timed Waiting）：无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。
            调用Thread.sleep()方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。
            调用Object.wait()方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。
            睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。
            阻塞和等待的区别在于，阻塞是被动的，它是在等待获取一个排它锁。而等待是主动的，通过调用Thread.sleep()和Object.wait()等方法进入。
              进入方法                                       退出方法
            Thread.sleep() 方法                              时间结束
            设置了Timeout参数的Object.wait()方法       时间结束/Object.notify()/Object.notifyAll()
            设置了Timeout参数的Thread.join()方法       时间结束/被调用的线程执行完毕
            LockSupport.parkNanos()方法               LockSupport.unpark(Thread)
            LockSupport.parkUntil()方法               LockSupport.unpark(Thread)
7. 结束（Terminated）：可以是线程结束任务之后自己结束，或者产生了异常而结束。
```
### 线程start()的两个问题
```markdown
1. 反复调用同一个线程的start()方法是否可行？ 不可行，在第一次调用之后ThreadStatus的值改变，反复调用会报异常。
2. 假如一个线程执行完毕（此时处于TERMINATED状态），再次调用这个线程的start()方法是否可行？
```
## 第五章 Java线程之间的通信
[多线程通讯(wait、notify、Lock、ThreadLocal)](https://www.cnblogs.com/javatalk/p/9924531.html)
```markdown
线程锁与同步，wait(),notify(),notifyAll(),信号量，管道，Join,ThreadLocal
```
## 第六章 Java内存模型基础知识
![Java内存模型图](https://user-gold-cdn.xitu.io/2020/5/1/171cef6637426e1e?w=823&h=759&f=png&s=251488)
### 6.1 Java内存模型
```markdown
Java内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。
处理器上的寄存器的读写的速度比内存快几个数量级，为了解决这种速度矛盾，在它们之间加入了高速缓存。
加入高速缓存带来了一个新的问题：缓存一致性。如果多个缓存共享同一块主内存区域，那么多个缓存的数据可能会不一致，需要一些协议来解决这个问题。
所有的变量都存储在主内存中，每个线程还有自己的工作内存，工作内存存储在高速缓存或者寄存器中，保存了该线程使用的变量的主内存副本拷贝。
线程只能直接操作工作内存中的变量，不同线程之间的变量值传递需要通过主内存来完成。
```
### 6.2 并发编程的两个关键问题
```markdown
线程间如何通信？即：线程之间以何种机制来交换信息               
线程间如何同步？即：线程以何种机制来控制不同线程间操作发生的相对顺序
两种并发模型可以解决这两个问题：
消息传递并发模型
共享内存并发模型  在Java中，使用的是共享内存并发模型。
```
## 第七章  重排序与happens-before
>> 重排序：计算机在执⾏程序时，为了提⾼性能，编译器和处理器常常会对指令做重排。
```markdown
编译器优化重排:编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
指令并行重排:
内存系统重排：
```
>> happens-before规则
```markdown
是一个给程序员使用的规则，只要程序员在写代码的时候遵循happens-before规则，JVM就能保证指令在多线程之间的顺序性符合程序员的预期。
```
## 第八章 volatile
[从多线程的三个特性理解多线程开发](https://www.cnblogs.com/dafanjoy/p/10020225.html)
>> 原子性，有序性，可见性
```markdown
原子性：指一个操作或者一系列操作要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。
有序性：本义是指程序在执行的时候，程序的代码执行顺序和语句的顺序是一致的。
内存可见性：指的是线程之间的可见性，当⼀个线程修改了共享变量时，另⼀个线程可以读取到这个修改后的值。
volatile能够保证数据的可见性，但是不能保证数据的原子性，synchronized两者都能保证。i++的运行结果无法保证原子性，
使用synchronized、volatile，加锁lock等方式一般及可以保证线程的可见性与有序性。
volatile:禁止volatile变量与普通变量重排序
```
[Java内存可见性volatile](https://www.cnblogs.com/junejs/p/12686902.html)
>> 所谓内存可⻅性:指的是当⼀个线程对 volatile 修饰的变量进⾏写操作时，JMM会⽴即把该线程对应的本地内存中的共享变量的值刷新到
主内存；当⼀个线程对 volatile 修饰的变量进⾏读操作时，JMM会把⽴即该线程对应的本地内存置为⽆效，从主内存中读取共享变量的值。
[Java并发编程之验证volatile不能保证原子性](https://www.cnblogs.com/kaigejava/p/12544060.html)
>> volatile的三大特性。1：保证可见性 2：不保证原子性 3：保证顺序。
## 第九章 synchronized与锁
```markdown
synchronized修饰的方法或代码块相当于并发中的临界区，即在同一时刻jvm只允许一个线程进入执行。synchronized是通过锁机制实现
同一时刻只允许一个线程来访问共享资源的。另外synchronized锁机制还可以保证线程并发运行的原子性，有序性，可见性。
所谓“临界区”，指的是某⼀块代码区域，它同⼀时刻只能由⼀个线程执行。
```
[Synchronized实现原理深入解析](https://www.cnblogs.com/wyc1994666/p/11748212.html)
[synchronized实现原理及其优化-（自旋锁，偏向锁，轻量锁，重量锁）](https://www.cnblogs.com/ljl150/p/12514198.html)
```markdown
在jdk1.5之前，只有synchronized重量级锁，实现需要借助操作系统，是比较消耗性能的操作，在1.6之中为了提高性能，
便对synchronized锁进行了优化，实现了各种锁优化技术，如：适应性自旋，锁消除，锁粗化，轻量级锁，偏向锁。
1. 无锁状态 unlocked
2. 偏向锁状态 biasble 
3. 轻量级锁状态 lightweight locked
4. 重量级锁状态 inflated
```
### 偏向锁
```markdown
Java偏向锁是在jdk1.6中引入的，它的目的是消除数据无竞争情况下的同步原语，进一步提高程序的运行性能。如果说轻量级锁是
在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除连CAS都不做。
偏向锁使用了⼀种等到竞争出现才释放锁的机制 所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。
```
### 轻量级锁
```markdown
轻量级锁是jdk1.6中加入的新型锁机制，它名字中的“轻量级”是相对于使用操作系统互斥量来实现的重量级锁而言的。首先需要强调的是，
轻量级锁并不是来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统重量级锁使用操作系统互斥量产生的性能消耗。
在解释轻量级锁的执行过程之前，先明白一点，轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，
就会导致轻量级锁膨胀为重量级锁。
```
### 自旋锁  
```markdown
自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入
阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗
```
### 重量级锁
### 重量级锁、轻量级锁和偏向锁之间转换
>> 偏向锁升级成轻量级锁
```markdown
偏向锁升级成轻量级锁时，会暂停拥有偏向锁的线程，重置偏向锁标识，这个过程看起来容易，实则开销还是很大的，大概的过程如下：
1. 在⼀个安全点（在这个时间点上没有字节码正在执行）停止拥有锁的线程。
2. 遍历线程栈，如果存在锁记录的话，需要修复锁记录和Mark Word，使其变成无锁状态。
3. 唤醒被停止的线程，将当前锁升级成轻量级锁。
```
>> 线程获取锁时发生其他锁已经获取，就自旋获取锁 失败就锁膨胀修改为重量级锁。
### 锁的升级流程
```markdown
每一个线程在准备获取共享资源时： 第⼀步，检查MarkWord里面是不是放的自己的ThreadId ,如果是，表示当前线程是处于 “偏向锁” 。
第二步，如果MarkWord不是自己的ThreadId，锁升级，这时候，用CAS来执行切换，新的线程根据MarkWord里面现有的ThreadId，
通知之前线程暂停，之前线程将Markword的内容置为空。
第三步，两个线程都把锁对象的HashCode复制到自己新建的用于存储锁的记录空间，接着开始通过CAS操作， 
把锁对象的MarKword的内容修改为自己新建的记录空间的地址的方式竞争MarkWord。
第四步，第三步中成功执行CAS的获得资源，失败的则进⼊自旋 。
第五步，自旋的线程在自旋过程中，成功获得资源(即之前获的资源的线程执行完成并释放了共享资源)，则整个状态依然处于轻量级锁的状态，如果⾃旋失败 。
第六步，进⼊重量级锁的状态，这个时候，自旋的线程进行阻塞，等待之前线程执行完成并唤醒自己。
```
### 各种锁的使用场景
```markdown
偏向锁：通常只有一个线程访问临界区。
轻量级锁：可以有多个线程交替进入临界区，在竞争不激烈的时候，稍微自旋就能获得锁。
重量级锁：线程间出现了激烈的竞争就需要使用重量级锁，此时未获取到锁的线程会进入阻塞队列，需要操作系统介入。
jvm设置偏向锁和轻量级锁，就是为了避免阻塞，避免操作系统的介入。
```
```markdown
锁的状态总共有四种，无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁。
锁                  优点                          缺点                         适用场景

偏向锁   加锁和解锁不需要额外的消耗，         如果线程间存在锁竞争，          适用于只有一个线程访问同步块场景。
        和执行非同步方法比仅存在纳秒级的差距。 会带来额外的锁撤销的消耗。

轻量级锁       竞争的线程不会阻塞，        如果始终得不到锁竞争               追求响应时间。同步块执行速度非常快。
            提高了程序的响应速度。         的线程使用自旋会消耗CPU。

重量级锁  线程竞争不使用自旋，不会消耗CPU。  线程阻塞，响应时间缓慢。          追求吞吐量。同步块执行速度较长。
```
## 第十章 乐观锁和悲观锁
[乐观锁和悲观锁](https://www.cnblogs.com/ljl150/p/12506034.html)
```markdown
乐观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，
只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。
悲观锁：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；
上锁期间其他人不能修改数据。
```
[浅析CAS与AtomicInteger原子类](https://www.cnblogs.com/zengcongcong/p/12751761.html)
### CAS实现原子操作的三大问题
```markdown
1.ABA问题：就是⼀个值原来是A，变成了B，又变回了A。这个时候使用CAS是检查不出变化的，但实际上却被更新了两次。
解决思路是在变量前面追加上版本号或者时间戳
2.循环时间长开销大：CAS多与自旋结合。如果自旋CAS长时间不成功，会占用大量的CPU资源。
CAS是基于乐观锁的思想实现的，当频繁出现当前值与所旧预期值不相等的情况，会导致频繁的自旋而使得浪费CPU资源。
解决思路是让JVM支持处理器提供的pause指令。
3.只能保证一个共享变量的原子操作：
单纯对共享变量进行CAS操作，只能保证单个，无法使多个共享变量同时进行原子操作。
```
#### CAS:Compare and Swap 比较并设置。用于在硬件层面上提供原子性操作。
[锁开销优化以及 CAS 简单说明](https://www.cnblogs.com/cposture/p/10761396.html)
## 第十一章 AQS
[看看AQS阻塞队列和条件队列](https://www.cnblogs.com/wyq1995/p/12253792.html)
[Java多线程——AQS框架源码阅读](https://www.cnblogs.com/zackku/p/9984887.html)
[java之AQS和显式锁](https://www.cnblogs.com/hongshaodian/p/12452136.html)
>> AQS是AbstractQueuedSynchronizer的简称，即抽象队列同步器
```markdown
AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的同步器，比如我们提到的ReentrantLock，Semaphore，
ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。
```
[ReentrantLock是如何基于AQS实现的](https://www.cnblogs.com/liyus/p/10760411.html)
[多线程高并发编程(3) -- ReentrantLock源码分析AQS](https://www.cnblogs.com/huangrenhui/p/12712475.html)
```markdown
ReentrantLock是一个可重入的互斥锁，基于AQS实现，它具有与使用 synchronized 方法和语句相同的一些基本行为和语义，但功能更强大。
ReentantLock同步方式是独占模式，资源是独占的，一次只能一个线程获取。
```
## 第十二章 线程池
[线程池原理初探](https://www.cnblogs.com/volcano-liu/p/10783008.html)
[线程池源码探究](https://www.cnblogs.com/NaLanZiYi-LinEr/p/12714607.html)
[Java 8 ThreadLocal 源码解析](https://www.cnblogs.com/Finley/p/10162144.html)
[如何设置线程池参数？美团给出了一个让面试官虎躯一震的回答。](https://www.cnblogs.com/thisiswhy/p/12690630.html)
[并发——深入分析ThreadLocal的实现原理](https://www.cnblogs.com/tuyang1129/p/12713815.html)
### 为什么要使用线程池
```markdown
1. 创建/销毁线程需要消耗系统资源，线程池可以复用已创建的线程
2. 控制并发的数量。并发数量过多，可能会导致资源消耗过多，从而造成服务器崩溃。（主要原因）
3. 可以对线程做统一管理。
```
## 第十三章 阻塞队列
[【高并发】不废话，言简意赅介绍BlockingQueue](https://www.cnblogs.com/binghe001/p/12723469.html)

[Java中常用七个阻塞队列的总结](https://www.cnblogs.com/kaigejava/p/12825493.html)
```markdown
队列的分类，可以分为两类，即阻塞队列和非阻塞队列。
    常用的三个非阻塞队列：LinkedList、PriorityQueue和ConcurrentLinkedQueue.
    队列是Collection的子类 Collection->Queue->BlockingQueue-->七个BlockingQueue
```
### BlockingQueue的实现类
```markdown
java.util.concurrent.BlockingQueue 接口有以下阻塞队列的实现：阻塞队列，是线程安全的。主要在生产者和消费者场景。
    ArrayBlockingQueue 由数组结构组成的有界阻塞队列。内部结构是数组，故具有数组的特性。 有界
    LinkedBlockingQueue 由链表结构组成的有界阻塞队列。内部结构是链表，具有链表的特性。 有界
    DelayQueue 该队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素，支持延时优先级。 数组 无界
    PriorityBlockingQueue 基于优先级的无界阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定）。数组 无界
    SynchronousQueue队列比较特殊，没有任何内部容量，甚至连一个队列的容量都没有。并且每个put必须等待一个take，反之亦然。链表，不存放元素
    LinkedTransferQueue 链表 无界 链表的无界阻塞队列
    LinkedBlockingDeque 链表 无界 双端数组队列
```
## 第十四章 锁接口与类
>> 锁的分类
```markdown
可重入锁和非可重入锁：就是支持重新进入的锁，也就是说这个锁支持一个线程对资源重复加锁。
公平锁与非公平锁：如果对一个锁来说，先对锁获取请求的线程一定会先被满足，后对锁获取请求的线程后被满足，那这个锁就是公平的。
读写锁和排它锁：读写锁可以在同一时刻允许多个读线程访问，排它锁在同一时刻只允许一个线程进行访问。
```
>> 抽象类AQS/AQLS/AOS
>> 接口Condition/Lock/ReadWriteLock
## 第十五章 并发集合容器
>> Vector和HashTable是线程安全的容器类，
>> 但是这些容器实现同步的方式是通过对方法加锁(sychronized)方式实现的，这样读写均需要锁操作，导致性能低下。
[ConcurrentHashMap实现原理及源码分析](https://www.cnblogs.com/chengxiao/p/6842045.html)
### 并发Map
```markdown
ConcurrentMap接口:继承了Map接口，在Map接口的基础上又定义了四个方法：
putIfAbsent：与原有put方法不同的是，putIfAbsent方法中如果插入的key相同，则不替换原有的value值；
remove：与原有remove方法不同的是，新remove方法中增加了对value的判断，如果要删除的key-value不能与Map中原有的key-value对应上，则不会删除该元素;
replace(K,V,V)：增加了对value值的判断，如果key-oldValue能与Map中原有的key-value对应上，才进行替换操作；
replace(K,V)：与上面的replace不同的是，此replace不会对Map中原有的key-value进行比较，如果key存在则直接替换；

ConcurrentHashMap类
ConcurrentHashMap同HashMap一样也是基于散列表的map，但是它提供了一种与HashTable完全不同的加锁策略提供更高效的并发性和伸缩性。
ConcurrentHashMap提供了一种粒度更细的加锁机制来实现在多线程下更高的性能，这种机制叫分段锁(Lock Striping)。
提供的优点是：在并发环境下将实现更高的吞吐量，而在单线程环境下只损失非常小的性能。
可以这样理解分段锁，就是将数据分段，对每一段数据分配一把锁。当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。
```
### 并发Queue
>> ConcurrentLinkedDeque和ConcurrentLinkedQueue。
### 并发Set
>> ConcurrentSkipListSet
## 第十六章 CopyOnWrite容器
```markdown
写入时复制思想:就是当有多个调用者同时去请求一个资源数据的时候，有一个调用者出于某些原因需要对当前的数据源进行修改，
这个时候系统将会复制一个当前数据源的副本给调用者修改。
```
>>CopyOnWrite容器即写时复制的容器,当我们往一个容器中添加元素的时候，不直接往容器中添加，而是将当前容器进行copy，
>>复制出来一个新的容器，然后向新容器中添加我们需要的元素，最后将原容器的引用指向新容器。

>> CopyOnWriteArrayList
[浅析CopyOnWriteArrayList](https://www.cnblogs.com/zengcongcong/p/12754067.html)
## 第十七章 通信工具类
>> Semaphore 限制线程的数量
```markdown
Semaphore内部有一个继承了AQS的同步器Sync，重写了tryAcquireShared方法。在这个方法里，会去尝试获取资源。
如果获取失败（想要的资源数量小于目前已有的资源数量），就会返回一个负数（代表尝试获取资源失败）。
然后当前线程就会进入AQS的等待队列。
```
>> Exchanger 两个线程交换数据
```markdown
Exchanger类用于两个线程交换数据。它支持泛型，也就是说你可以在两个线程之间传送任何数据。
```
>> CountDownLatch 线程等待直到计数器减为0时开始工作
### 同步工具类 —— CountDownLatch
[同步工具类—— CountDownLatch](https://www.cnblogs.com/54chensongxia/p/12721925.html)
[CountDownLatch是个啥？](https://www.cnblogs.com/zhangweicheng/p/12679116.html)
[并发——深入分析CountDownLatch的实现原理](https://www.cnblogs.com/tuyang1129/p/12692423.html)
```markdown
CountDownLatch是JDK并发包中提供的一个同步工具类,主要功能是让一个或者多个线程等待直到一组在其他线程中执行的操作完成。
```
>> CountDownLatch重要的API
```markdown
- getCount()：获取当前count的值。
- wait()：让当前线程在此CountDownLatch对象上等待，可以中断。与notify()、notifyAll()方法对应。
- await()：让当前线程等待此CountDownLatch对象的count变为0，可以中断。
- await(timeout,TimeUnit)：让当前线程等待此CountDownLatch对象的count变为0，可以超时、可以中断。
- countDown()：使此CountDownLatch对象的count值减1(无论执行多少次，count最小值为0)。
```
#### 使用场景
```markdown
场景一：将任务分割成多个子任务，每个子任务由单个线程去完成，等所有线程完成后再将结果汇总。
（MapReduce）这种场景下，CountDoenLatch作为一个完成信号来使用。
场景二：多个线程等到，一直等到某个条件发生。比如多个赛跑运动员都做好了准备，就等待裁判手中的发令枪响。
 这种场景下，就可以将CountdownLatch的初始值设置成1。
```
#### CountDownLatch总结
```markdown
CountDownLatch的初始值不能重置，只能减少不能增加，最多减少到0；
当CountDownLatch计数值没减少到0之前，调用await方法可能会让调用线程进组一个阻塞队列，等待计数值减小到0；
调用countDown方法会让计数值每次都减小1，但是最多减少到0。当CountDownLatch的计数值减少到0的时候，会唤醒所有在阻塞队列中的线程。
```
[多线程高并发编程(5) -- CountDownLatch、CyclicBarrier源码分析](https://www.cnblogs.com/huangrenhui/p/12744230.html)
#### CyclicBarrier 作用跟CountDownLatch类似，但是可以重复使用
[并发工具——CyclicBarrier](https://www.cnblogs.com/54chensongxia/p/12752749.html)
```markdown
CyclicBarrier拥有CountDownLatch的所有功能，还可以使用reset()方法重置屏障。
用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。
```
#### Phaser 增强的CyclicBarrier
```markdown
前面我们介绍了CyclicBarrier，可以发现它在构造方法里传入“任务总量”parties之后，就不能修改这个值了，
并且每次调用await()方法也只能消耗一个parties计数。但Phaser可以动态地调整任务总量！
CyclicBarrier有两个构造函数，其中parties指示计数器的初始值，barrierAction在所有线程都到达屏障的时候会执行一次。
```
## 第十八章 Fork/Join框架
```markdown
Fork/Join框架是一个实现了ExecutorService接口的多线程处理器，它专为那些可以通过递归分解成更细小的任务而设计，
最大化的利用多核处理器来提高应用程序的性能。与其他ExecutorService相关的实现相同的是，Fork/Join框架会将任务分配给线程池中的线程。
而与之不同的是，Fork/Join框架在执行任务时使用了工作窃取算法。
工作窃取算法指的是在多线程执行不同任务队列的过程中，某个线程执行完自己队列的任务后从其他线程的任务队列里窃取任务来执行。
```
## 第十九章 Java 8 Stream并行计算原理
```markdown

```
## 第二十章 计划任务
```markdown
自JDK 1.5 开始，JDK提供了ScheduledThreadPoolExecutor类用于计划任务（又称定时任务）
```

## 基础线程机制 -- cyc2018
```markdown
Executor:    
    Executor管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。
    主要有三种 Executor：
        CachedThreadPool：一个任务创建一个线程；
        FixedThreadPool：所有任务只能使用固定大小的线程；
        SingleThreadExecutor：相当于大小为 1 的 FixedThreadPool。
Daemon:
    守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。
    当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。
    main() 属于非守护线程。使用 setDaemon() 方法将一个线程设置为守护线程。
sleep():
    Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。
    sleep()可能会抛出InterruptedException，因为异常不能跨线程传播回main()中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。
yield():    
    对静态方法Thread.yield()的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。
    该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。
```


## 准备阅读
[参考博客：随笔分类 - Java多线程](https://www.cnblogs.com/ljl150/category/1657632.html)
[由浅入深的介绍实现高并发的各个细节](https://www.cnblogs.com/binghe001/category/1648522.html)
[参考博客：随笔分类 - Java Concurrency](https://www.cnblogs.com/zzq6032010/category/1466867.html)
[随笔分类 - 多线程、并发](https://www.cnblogs.com/longfurcat/category/1273128.html)
