# Java多线程与并发面试题
[参考资料：并发编程相关面试题四](https://www.cnblogs.com/Zzzzn/p/12586656.html)
[参考资料：Java 并发进阶常见面试题总结](https://www.cnblogs.com/wuwuyong/p/12169102.html)
[Java 多线程并发编程](https://www.cnblogs.com/chenyanbin/p/13629067.html)

[TOC]

### 0.多线程基础概念
```markdown
使用多线程的场景
    web服务器
    异步处理
    大量复杂计算（JVM垃圾回收）
线程安全：指某个函数、函数库在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成。
JMM的特性：原子性，有序性，可见性。
    原子性:一个操作或一系列操作是不可中断的。即使是在多线程的情况下，操作一旦开始，就不会被其他线程干扰。
    有序性:指对于单线程的执行代码，执行是按顺序依次进行的。
        但在多线程环境中，则可能出现乱序现象，因为在编译过程中会出现“指令重排”，重排后的指令与原指令的顺序未必一致。
    可见性:可见性就是指当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改。（volatile保证了多线程的可见性）
```
### 1.进程和线程的区别与联系【10+】
```markdown
​1.进程：是资源分配的最小单位，是程序的执行过程，一个进程可以有多个线程，多个线程共享进程的堆和方法区资源，
    但每个线程又有属于自己的本地方法栈、虚拟机栈、程序计数器。
  ​线程：是任务调度和执行的最小单位，线程间可能存在相互影响，执行开销较小，不利于资源的管理和保护，线程间是共享进程中的资源的。
2、程序运行先创建进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段。
    线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多
3、线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以管道pipe或者消息队列进行。
4、多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。
```
### 2.创建线程的四种实现方式【10+】
[多线程的四种实现方式](https://www.cnblogs.com/xpybsh/p/12818796.html)
[java的线程、创建线程的 3 种方式、静态代理模式、Lambda表达式简化线程](https://www.cnblogs.com/lifegoeson/p/13491735.html)
#### 2.1 继承Thread类重写run()方法，调用start()：
```markdown
  1. 创建一个继承于Thread类的子类
  2. 重写Thread类的run() --> 将此线程执行的操作声明在run()中
  3. 创建Thread类的子类的对象
  4. 通过此对象调用start()
// 1、 创建一个继承于Thread类的子类
 class Test1 extends Thread { 
     // 2、 重写Thread类的run()
     @Override
     public void run() {
         //Thread.currentThread().getName()：获取当前线程的名字
         System.out.println("线程需要执行的代码" + "->"
                 + Thread.currentThread().getName());
     } 
 } 
 public class ThreadTest1 {
     public static void main(String[] args) {
         // 3、 创建Thread类的子类的对象
         Test1 test1 = new Test1();
         //多线程当然可以创建多个对象来开启多个线程
         Test1 test2 = new Test1();
         // 4、通过此对象调用start()方法启动线程
         //start()方法的作用：1）启动当前线程  2）调用当前线程的run()方法
         test1.start();
         test2.start();
     }
 }

```
#### 2.2 实现Runnable接口,实现run()方法，new Thread对象调用Thread的start()
```markdown
  1. 创建一个实现Runnable接口的类
  2. 实现Runnable中的run()方法
  3. 创建实现类的对象
  4. 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象
  5. 通过Thread类的对象调用start()
/*
    创建方式2：实现Runnable + 重写run
    启动方式：创建实现类对象 + 借助thread代理类 + start
*/
//1. 创建一个实现Runnable接口的类
 class Test2 implements Runnable {
     // 2. 实现Runnable中的run()方法
     @Override
      public void run() {
          System.out.println("线程需要执行的代码" + "->"
                  + Thread.currentThread().getName());
     }
  }
 public class ThreadTest2 {
     public static void main(String[] args) {
         // 3. 创建实现类的对象
         Test2 test = new Test2();
         // 4. 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象
         Thread t1 = new Thread(test);
         Thread t2 = new Thread(test);
         // 5. 通过Thread类的对象调用start()
         t1.start();
         t2.start();
     }
}
```
#### 2.3 实现Callable接口,实现call()方法，new FutureTask().start() ,或者new Thread(task).start()
```markdown
 1.创建Callable的实现类
 2.实现call方法，将此线程需要执行的操作声明在call()中
 3.创建Callable接口实现类的对象
 4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象
 5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()
 6.获取Callable中call方法的返回值
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;
 //1.创建Callable的实现类
class Test3 implements Callable<Object>{
  //2.实现call方法，将此线程需要执行的操作声明在call()中
  @Override
  public Object call() throws Exception {
      int sum = 0;
      for (int i = 1; i <= 100; i++) {
          if(i % 2 == 0){
              System.out.println(i);
               sum += i;
          }
      }
       return sum;
      //如果不需要方法返回值
      //return null;
  }
}  
public class ThreadTest3 {
   public static void main(String[] args) {
       //3.创建Callable接口实现类的对象
       Test3 numThread = new Test3();
       //4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象
       FutureTask futureTask = new FutureTask(numThread);
       //5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()
       new Thread(futureTask).start();//用了匿名内部类
　　　　/*可以和上面一样写成（相当于）：
      Thread thread = new Thread(futureTask);
      thread.start();
 　　　　*/
       try {
           //6.获取Callable中call方法的返回值
          //get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。
           Object sum = futureTask.get();
           System.out.println("总和为：" + sum);
       } catch (InterruptedException e) {
           e.printStackTrace();
       } catch (ExecutionException e) {
           e.printStackTrace();
       }
   }
}
```
#### 2.4 线程池
```markdown
 1. 提供指定线程数量的线程池
 2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象
 3.关闭连接池
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
/**
* 这里可以用实现Runnable的方式 也可以用实现Callable的方式
* 
*/
class Test4 implements Runnable {
     @Override
     public void run() {
         System.out.println("代码");
     }
} 
public class ThreadTest4 {
     public static void main(String[] args) {
         // 1. 提供指定线程数量的线程池  这里设置为10
         ExecutorService service = Executors.newFixedThreadPool(10); 
         // 2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象
         service.execute(new Test4());// 适合适用于Runnable
         // service.submit(Callable callable);//适合使用于Callable
         // 3.关闭连接池
         service.shutdown();
     }
}
```
#### 2.5 Thread类和Runnable接口及Callable接口的比较
```markdown
由于Java“单继承，多实现”的特性，Runnable接口使用起来比Thread更灵活。
    Runnable接口出现更符合面向对象，将线程单独进行对象的封装。
    Runnable接口出现，降低了线程对象和线程任务的耦合性。如果使用线程时不需要使用Thread类的诸多方法，显然使用Runnable接口更为轻量。
    Runnable接口和Thread类创建线程的run方法没有返回值，Callable接口和Future类可以实现。
    Runnable没有返回值，Callable可以拿到返回值，Callable可以看作Runnable的补充。
    ?? Runnable接口的线程可以重复调用，而Thread接口不能??
```
#### 2.6 如何实现处理线程的返回值
```markdown
1.主线程等待法
2.使用Thread类的join()阻塞当前线程以等待子线程处理完毕
3.通过Callable接口实现：通过FutureTask或者线程池获取
```
### 3.Java线程的状态及主要转化⽅法(线程的生命周期？)【10+】
[深入理解Java线程状态转移](https://www.cnblogs.com/darope/p/12748184.html)
![线程状态转换https://www.cnblogs.com/darope/p/12748184.html](https://images.cnblogs.com/cnblogs_com/darope/1747012/o_200421111345%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB.png)
```markdown
NEW RUNNABLE(runnable&Running) BLOCKED WATTING TIMED_WAITING TERMINATED
1. 新建态(NEW)：一个线程被创建出来时候所处的状态 ；
2. 就绪态(runnable)：线程调用start()方法后，便处于可以被操作系统调度的状态，即就绪态。
            就绪状态可以由三处转化而来，新建态执行了start、线程阻塞结束、锁池等待队列中的线程获得了锁。
3. 运行态(RUNNing)：表示当前线程被操作系统调度，分配了时间片，执行线程中的run方法时的状态。
            运行态只可以由就绪态的线程转化而来，如果多个线程都处在就绪态，就等待操作系统分配。
4. 阻塞态(BLOCKED):表示当前线程被由于某种原因，被挂起，也就是被阻塞，正在运行的线程被阻塞后，
            即使结束阻塞状态也回不去运行态，只能回到就绪态，等待os分配cpu资源去调度。
5. 无限期等待（Waiting）：等待其它线程显式地唤醒，否则不会被分配 CPU 时间片。
            进入方法：                                       退出方法：
            没有设置Timeout参数的Object.wait()方法       Object.notify() / Object.notifyAll()
            没有设置Timeout参数的Thread.join()方法       被调用的线程执行完毕
            LockSupport.park()方法                      LockSupport.unpark(Thread)
6. 限期等待（Timed Waiting）：无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。
            调用Thread.sleep()方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。
            调用Object.wait()方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。
            睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。
            阻塞和等待的区别在于，阻塞是被动的，它是在等待获取一个排它锁。而等待是主动的，通过调用Thread.sleep()和Object.wait()等方法进入。
              进入方法                                       退出方法
            Thread.sleep() 方法                              时间结束
            设置了Timeout参数的Object.wait()方法       时间结束/Object.notify()/Object.notifyAll()
            设置了Timeout参数的Thread.join()方法       时间结束/被调用的线程执行完毕
            LockSupport.parkNanos()方法               LockSupport.unpark(Thread)
            LockSupport.parkUntil()方法               LockSupport.unpark(Thread)
7. 结束（Terminated）：可以是线程结束任务之后自己结束，或者产生了异常而结束。
```
### 4.线程start()的两个问题【2+】
```markdown
1. 反复调用同一个线程的start()方法是否可行？不可行，在第一次调用之后ThreadStatus的值改变，反复调用会报异常。
    Java的线程是不允许启动两次的，第二次调用必然会抛出IllegalThreadStateException，这是一种运行时异常。
2. 假如一个线程执行完毕（此时处于TERMINATED状态），再次调用这个线程的start()方法是否可行？
```
### 5.多线程start()和run()方法的区别，sleep()和yield()方法的区别【5+】
```markdown
多线程start()和run()方法的区别
    1.start()实际上通过本地方法start0()启动线程，会新运行一个线程，新线程会调用run()方法。
    2.run()方法：run()直接调用Thread线程的Runnable成员的run()方法，用于执行线程的运行时代码，并不会新建一个线程。
    3.start()只能调用一次，run()可以调用多次。
sleep()和yield()方法的区别
    1.- 依赖线程优先级：sleep()方法暂停当前线程后，会给其他线程执行机会，而不在乎其他线程的优先级；
        yield()方法暂停当前线程后，只会给优先级相同或更高的线程执行机会。
    2.- 线程转入状态：sleep()方法将线程转入阻塞状态，知道经过阻塞时间才会转入就绪状态；
        yield()方法不会将线程转入阻塞状态，而是将线程转入就绪状态。
    3.- 异常声明：sleep()方法声明抛出了InterruptedException异常；yield()方法未声明抛出异常。
    4.- 可移植性：sleep()方法的移植性比yield()方法好，所以一般使用sleep()方法控制并发编程。
Sleep、Wait、Yield、Suspend、join
    1.Sleep()线程进入**阻塞状态**，不能得到CPU执行时间，只有等待时间够长之后才会使线程重新进入可执行状态。
        **如果有同步锁则sleep不会释放锁即其他线程无法获得同步锁**。
    2.wait()需和notify配合使用，线程调用wait后进入**阻塞状态**。wait有两只形式，一种是包含固定时长参数，另一种不包含固定时长参数。
        包含固定时长参数时在等待时长超出或者调用notify都会使线程重新进入可执行状态；而不包含固定时长参数的只有调用notify才会重新进入可执行状态。
        wait和notify需要使用在synchronized函数或块中，当进入wait时，同步块中的同步数据可以被其他线程使用。
        **必须放在循环体和同步代码块中，执行该方法的线程会释放锁，进入线程等待池中等待被再次唤醒即放入锁池中竞争同步锁**。
    3.Yeild()只会使当前线程结束执行状态，功能相当于提前让线程的CPU时间使用完毕。**线程进入就绪状态**。
        当前的线程继续进入可执行队列中，所以有可能当前的线程会投入可执行队列后会立即进行执行。
        Wait可以使低优先级的线程得到执行时间，yield()只能使同优先级或更高优先级的线程有执行的机会。不推荐使用。
    4.Suspend()需和resume配套使用。Suspend使当前线程**阻塞状态**，且不会自动恢复。只有调用resume才会使当前的线程恢复可执行状态。
    5.join()，一种特殊的wait，当前运行线程调用另一个线程的join方法，当前线程进入**阻塞状态**直到另一个线程运行结束。
```
### 6.CAS无锁机制-乐观锁【5+】
[面试：为了进阿里，又把并发CAS（Compare and Swap）实现重新精读一遍](https://www.cnblogs.com/Ccwwlx/p/13621012.html)
```markdown
CAS：Compare and Swap，即比较交换；
　　jdk1.5增加了并发包java.util.concurrent.*，其下面的类使用CAS算法实现了区别于synchronized同步锁的一种乐观锁。
    jdk1.5之前java是靠synchronized关键字保证同步的，是一种独占锁，也是悲观锁；
CAS本身无锁，采用乐观锁的思想，在数据操作时对比数据是否一致，如果一致代表之前没有线程操作该数据，那么就会更新数据，如果不一致代表有县城更新则重试；
　　CAS当中包含三个参数CAS(V,E,N)，V标识要更新的变量，E标识预期值，N标识新值　　
　　运行过程：
　　　　1.线程访问时，先会将主内存中的数据同步到线程的工作内存当中；
　　　　2.假设线程A和线程B都有对数据进行更改，那么假如线程A先获取到执行权限；
　　　　3.线程A先会对比工作内存当中的数据和主内存当中的数据是否一致，如果一致（V==E）则进行更新，不一致则刷新数据，重新循环判断；
　　　　4.这时更新完毕后，线程B也要进行数据更新，主内存数据和工作内存数据做对比，如果一致则进行更新，
        不一致则将主内存数据重新更新到工作内存，然后循环再次对比两个内存中的数据，直到一致为止；　
（1）CAS存在ABA问题
　　ABA问题，如果将原来A的值改为了B，然后又改回了A，虽然最终结果没有发生改变，但是在过程中是对该数据进行了修改操作
　　解决方法：加版本号，在Java中并发包下有一个原子类：AtomicStampedReference，在该类当中通过版本控制判断值到底是否被修改
             加时间戳
　　解释：如果对值进行了更改则版本号+1，那么在CAS当中不仅仅对比变量的值，还要对比版本号，如果值和版本号都相等则代表没有被修改，
        如果有一方不相等代表进行过更改，那么就从主内存中重新刷新数据到工作内存然后循环对比，直到成功为止。
（2）循环开销大
    CAS是乐观锁，如果线程比较多，资源抢占激烈，命中率低的情况下，不断的循环会不断的消耗资源。自旋CAS。 
    实际上，可以设置最大循环数，达到最大循环数还没有占有资源就自动放弃，避免无限的循环。
    解决方法：
        1.限制自旋次数，防止进入死循环
        2.JVM能支持处理器提供的pause指令那么效率会有一定的提升，
（3）只能保证一个共享变量的原子操作。
    当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性。
    解决方法：
        1.如果需要对多个共享变量进行操作，可以使用加锁方式(悲观锁)保证原子性，
        2.可以把多个共享变量合并成一个共享变量进行CAS操作。
```
### 7.AQS思想原理【5+】
[JUC同步器框架AbstractQueuedSynchronizer源码图文分析](http://www.throwable.club/2019/04/07/java-juc-aqs-source-code/)
[AQS源码分析](https://www.cnblogs.com/funyoung/p/13619854.html)
[AQS是什么吧？都是怎么用的？](https://www.cnblogs.com/jimoer/p/13747291.html)
[一文搞懂AQS及其组件的核心原理](https://www.cnblogs.com/yewy/p/13773799.html)
```markdown
AQS:全称AbstractQueueSynchronizer，抽象队列同步器，这个类在java.util.concurrent.locks包下
    它是一个底层同步工具类，比如CountDownLatch,Semaphore，ReentrantLock,ReentrantReadWriteLock等等都是基于AQS底层三个内容：
    AQS定义了两种资源共享模式：
        独占式：每次只能有一个线程持有锁，例如ReentrantLock实现的就是独占式的锁资源。独占模式通过acquire和release方法获取和释放锁。
        共享式：允许多个线程同时获取锁，并发访问共享资源，ReentrantWriteLock和CountDownLatch等就是实现的这种模式。
            共享模式通过acquireShared和releaseShared方法获取和释放锁。
    AQS维护了一个volatile的state变量和一个FIFO（先进先出）的队列。其中state变量代表的是竞争资源标识，而队列代表的是竞争资源失败的线程排队时存放的容器。
    AQS使用一个volatile int state变量作为共享资源，如果线程获取资源失败，则进入同步队列等待；如果获取成功就执行临界区代码，释放资源时会通知同步队列中的等待线程。
    **AQS其实就是基于volatile+CAS实现的锁模板；如果需要线程阻塞等待，唤醒机制，则使用LockSupport挂起、唤醒线程。**
AQS是JUC包中用于构建锁或者其他同步组件(信号量、事件等)的基础框架类。AQS从它的实现上看主要提供了下面的功能：
    1.同步状态的原子性管理。state（用于计数器）
    2.线程的阻塞和解除阻塞。线程标记（哪一个线程加的锁）
    3.提供阻塞线程的存储队列。阻塞队列（用于存放阻塞线程）
基于这三大功能，衍生出下面的附加功能：
    通过中断实现的任务取消，基于线程中断实现。
    可选的超时设置，也就是调用者可以选择放弃等待。
    定义了Condition接口，用于支持管程形式的await/signal/signalAll操作，代替了Object类基于JNI提供的wait/notify/notifyAll。
AQS提供了一种实现阻塞锁和一系列依赖FIFO等待队列的同步器的框架，AQS为一系列同步器依赖于一个单独的原子变量（state）
    的同步器提供了一个非常有用的基础。子类们必须定义改变state变量的protected方法，这些方法定义了state是如何被获取或释放的。
AQS核⼼思想：如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的⼯作线程，并且将共享资源设置为锁定状态。
    如果被请求的共享资源被占⽤，那么就需要⼀套线程阻塞等待以及被唤醒时锁分配的机制，
    这个机制AQS是⽤CLH（虚拟的双向队列）队列锁实现的，即将暂时获取不到锁的线程加⼊到队列中。
lock：是一种可重入锁，除了能完成synchronized所能完成的所有工作外，还提供了诸如可响应中断锁、可轮询锁请求、定时锁等避免多线程死锁的方法。
    默认为非公平锁，但可以初始化为公平锁；通过方法lock()与unlock()来进行加锁与解锁操作；
```
### 8.Lock接口有哪些实现类，使用场景是什么 Lock和synchronized的区别
```markdown
Lock和synchronized的区别
1.Lock需要手动获取锁和释放锁。就好比自动挡和手动挡的区别
1.Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现。
2.synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；
    而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁。
3.Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断。
4.通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。
5.Lock可以通过实现读写锁提高多个线程进行读操作的效率。
```
### 9. ReentrantLock底层实现原理【10+】
>> ReenTrantLock中的condition有什么作用？condition的await和signal和Object的wait和notify有什么区别？
[ReentrantLock源码分析](https://www.cnblogs.com/funyoung/p/13623109.html)
```markdown
ReentrantLock是独享锁，同时是基于AQS实现的，因此它内部肯定是通过自定义AQS独占模式下的同步器来实现独享锁，
    该同步器需要重写AQS提供的tryAcquire()和tryRelease()方法，告诉AQS是否尝试获取同步资源和释放同步资源成功。
    通过一个int类型的状态变量state和一个FIFO队列来完成共享资源的获取，线程的排队等待等。
    AQS是个底层框架，采用模板方法模式，它定义了通用的较为复杂的逻辑骨架，比如线程的排队，阻塞，唤醒等，将这些复杂但实质通用的部分抽取出来。
    synchronized是ReentrantLock内部实现的一个同步组件，它是Reentrantlock的一个静态内部类，继承于AQS。
    AQS子类需要定义以及维护同步状态的值，在ReentrantLock中使用state为0表示锁没有被线程所持有，使用state不为0表示锁经被线程所持有。
    ReentrantLock有公平和非公平两种模式，公平模式即多线程按照申请锁的顺序来获取锁，非公平模式即多线程并非按照申请锁的顺序来获取锁。
关于ReentrantLock的tryLock()方法
    ReentrantLock的tryLock()方法是非公平的，因为无论在什么模式下，该方法都会调用抽象同步器的nonfairTryAcquire()方法，
    因此当线程释放锁时，需要唤醒离头节点最近的同时等待状态不为CANCELLED的后继节点，然后在该节点尝试获取锁之前，被其他线程直接调用了tryLock()方法获取了锁，
    那么被唤醒的这个线程又只能再进入阻塞状态，这就是非公平的体现。
关于获取了锁的线程能否再进行加锁?
    是可以的，因为无论在非公平还是公平模式下，tryAcquire()方法中都会有这么一个判断，如果同步状态的值不为0，表示锁已经被线程所持有，
    同时当前线程就是拥有锁的线程，它还进行加锁，那么累加同步状态的值，这种情况方法也会返回true，同时在抽象同步器的tryRelease()方法中，
    如果线程释放锁后，同步状态的值为0，则返回true，否则说明线程加了不止一把锁，然后它又没有释放全，这种情况会更新同步状态的值，然后返回false，只有当线程把它加的锁都释放后，tryRelease()方法才会返回true。
非公平锁是如何实现非公平的？
    主要体现在非公平同步器的lock()方法，当线程要进行加锁时，并没有直接调用同步器的acquire()方法（虽然acquire也会调用tryAcquire），
    而是先通过CAS尝试获取锁，因此当线程释放锁时，需要唤醒离头节点最近的同时等待状态不为CANCELLED的后继节点，然后在该节点尝试获取锁之前，
    被其他线程直接调用了lock()方法获取了锁，那么被唤醒的这个线程又只能再进入阻塞状态，这就是非公平的体现。
公平锁是如何实现公平的?
    主要体现在公平同步器的lock()和tryAcquire()方法，首先lock()方法直接调用同步器的acquire()方法，并没有像非公平同步器的lock()方法一样，先通过CAS尝试获取锁，
    然后在tryAcquire()方法中，只有当同步状态的值为0，同时等待队列中的头节点的后继节点封装的线程是当前线程时，才会通过CAS尝试获取锁，
    因此当线程释放锁时，需要唤醒离头节点最近的同时等待状态不为CANCELLED的后继节点，然后在该节点尝试获取锁之前，被其他线程调用了lock()方法进行加锁，
    由于lock()方法直接调用同步器的acquire()方法，然后acquire()方法又调用公平同步器的tryAcquire()方法，虽然此时同步状态的值为0，
    但是当前线程并不是等待队列中头节点的后继节点封装的线程，因此该线程也只能封装成Node节点，然后加入到等待队列当中。
```
### 10.synchronized理解及底层实现【10+】
[synchronized底层是怎么实现的？](https://www.cnblogs.com/jimoer/p/13664252.html)
#### 1.synchronized理解与使用
```markdown
使用了synchronized关键字可以轻松地解决多线程共享数据同步问题。
　　synchronized**修饰实例方法，修饰静态方法，修饰代码块**（synchronized关键字加在静态方法和非静态方法上有何区别？）
   synchronized可作用于instance变量、object reference（对象引用）、static函数和class literals(类名称字面常量)身上。 
　　synchronized取得的锁都是对象；每个对象只有一个锁（lock）与之相关联；实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。
　　synchronized的4种用法：
　　　　1. synchronized修饰实例方法时,线程获得的是成员锁。（锁住实例方法对象）
            public class SynchronizedTest {
                /**
                 * synchronized 使用在实例方法上
                 * @return
                 */
                public synchronized String syncOnMethod(){
                    return "a developer name Jimoer";
                }
            }
       2. synchronized修饰静态方法，线程获取的是对象锁。（锁住类对象）
            public class SynchronizedTest {
                   /**
                    * synchronized 使用在静态方法上
                    */
                   public static synchronized void test1(){
                       System.out.println("I am test1 method");
                   }
               }         
　　　　3. 对某一代码块使用,synchronized后跟括号,括号里是变量,线程获得的是成员锁；（锁住实例对象）
            public class SynchronizedTest {
                private String name;
                public String getName() {
                    return name;
                }
                public void setName(String name) {
                    this.name = name;
                }
                /**
                 * 带姓氏的名称
                 * @param firstName 姓氏
                 */
                public void buildName(String firstName){
                    synchronized(this){
                        this.setName(firstName+this.getName());
                    }
                }
            }
　　　　4. synchronized后面括号里是类,此时,线程获得的是对象锁；（锁住类对象）
            public class SynchronizedTest {
                private static String myName = "Jimoer";
                /**
                 * 带姓氏的名称
                 * @param firstName 姓氏
                 */
                public static void buildName(String firstName){
                    synchronized(SynchronizedTest.class){
                        System.out.println(firstName+myName);
                    }
                }
            }
　　　　5. synchronized后面括号里是一对象,此时,线程获得的是对象锁；（锁住类对象）
            public class SynchronizedTest {
                private String lastName;
                public String getLastName() {
                    return lastName;
                }
                public void setLastName(String lastName) {
                    this.lastName = lastName;
                }
                /**
                 * 带姓氏的名称
                 * @param firstName 姓氏
                 */
                public void buildName(String firstName){
                    synchronized(lastName){
                        System.out.println(firstName+lastName);
                    }
                }
            }
```
#### 2.synchronized底层原理
```markdown
下面一段代码，包含一个synchronized代码块和一个synchronized的同步方法。
    public class SynchronizedTest {
        private static String myName = "Jimoer";
        public static void main(String[] args) {
            synchronized (myName){
                System.out.println(myName);
            }
        }
        /**
         * synchronized 使用在静态方法上
         */
        public static synchronized void test1(){
            System.out.println("I am test1 method");
        }
    }
在编译完成后生成了class文件，我将class文件反编译出来，看看生成的class文件的内容。
    javap -p -v -c SynchronizedTest.class 查看编译之后的代码
ACC_SYNCHRONIZED标志。代表的是当线程执行到方法后会检查是否有这个标志，如果有的话就会隐式的去调用monitor enter和monitor exit两个命令来将方法锁住。
synchronized底层实现：是由一对monitorenter/monitorexit指令实现的，monitor对象是同步的基本实现单元。在JVM处理字节码会出现相关指令。
 代码块的同步：利用monitorenter和monitorexit这两个字节码指令。它们分别位于同步代码块的开始和结束位置。
    当JVM执行到monitorenter指令时，当前线程试图获取对象锁，如果未加锁或者已经被当前线程所持有，就把锁的计数器+1；
    当执行monitorexit指令时，锁计数器-1；当锁计数器为0时，该锁就被释放了。如果获取monitor对象失败，该线程会进入阻塞状态，直到其他线程释放锁。
 方法级的同步：是隐式的，即无需通过字节码指令来控制的，它实现在方法调用和返回操作之中。JVM可以从方法常量池中的方法表结构(method_info Structure)中的
    ACC_SYNCHRONIZED访问标志区分一个方法是否同步方法。当方法调用时，调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，
    执行线程将先持有monitor(虚拟机规范中用的是管程)，然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时释放monitor。
不公平的原因
    所有收到锁请求的线程首先自旋，如果通过自旋也没有获取锁将被放入ContentionList，该做法对于已经进入队列的线程不公平。
    为了防止ContentionList尾部的元素被大量线程进行CAS访问影响性能，Owner线程会在释放锁时将ContentionList的部分线程移动到EntryList并指定某个线程为OnDeck线程，该行为叫做竞争切换，牺牲了公平性但提高了性能。
```
#### 3.synchronized优化与不足
```markdown
庆幸的是在Java6之后Java官方对从JVM层面对synchronized较大优化，所以现在的synchronized锁效率也优化得很不错了。
JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。
锁主要存在的四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。
synchronized的不足之处:
    1.如果临界区是只读操作，其实可以多线程一起执行，但是使用synchronized的话，同一时间只能有一个线程执行。
    2.synchronized无法知道线程有没有成功获取到锁。
    3.使用synchronized如果临界区因为IO或者sleep方法等原因阻塞了，而当前线程没有释放锁，就会导致所有线程等待。
```
#### 4.synchronized锁的升级流程【10+】
![锁状态](https://img-blog.csdnimg.cn/20200603161323889.png)
![](https://img-blog.csdnimg.cn/20200913223743191.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_60,color_c8cae6,t_70#pic_center)
```markdown
当一个线程在准备获取共享资源时：无锁->偏向锁->轻量级锁->重量级锁，锁升级的过程是不可逆的。
在锁对象的对象头中有一个Threadid字段，第一次访问的时候为空，JVM让其持有偏向锁，并将Threadid设置为线程id
第一步，检查MarkWord里面是不是放的自己的ThreadId ,如果是，表示当前线程是处于**偏向锁**。
第二步，如果MarkWord不是自己的ThreadId，锁升级，这时候，用CAS来执行切换，新的线程根据MarkWord里面现有的ThreadId，
    通知之前线程暂停，之前线程将Markword的内容置为空。如果是自己的可以直接使用此对象资源。
第三步，两个线程都把锁对象的HashCode复制到自己新建的用于存储锁的记录空间，接着开始通过CAS操作， 
    把锁对象的MarKword的内容修改为自己新建的记录空间的地址的方式竞争MarkWord。
第四步，第三步中成功执行CAS的获得资源，失败的则进入**自旋**。
第五步，自旋的线程在自旋过程中，成功获得资源(即之前获的资源的线程执行完成并释放了共享资源)，则整个状态依然处于**轻量级锁**的状态。
    轻量级锁则是会在线程中创建一个Lock Record，然后将锁对象的MarkWord和创建的Lock Record的MarkWord进行交换，
    然后Lock Record的Object reference将指向锁对象，每次需要获取锁时就去看看锁对象的MarkWord，看是否是自己的。
第六步，如果自旋失败，进入重量级锁的状态，这个时候，自旋的线程进行阻塞，等待之前线程执行完成并唤醒自己。
    会向操作系统申请资源，线程挂起，进入到操作系统内核态的等待队列中，等待操作系统调度，然后映射回用户态。
    在重量级锁中，由于需要做内核态到用户态的转换，而这个过程中需要消耗较多时间，也就是"重"的原因之一。
    锁升级为重量级锁，请求一个Monitor，然后将Object的MarkWord指向重量级锁，重量级锁的Owner是当前使用锁的线程，竞争的线程加入到EntryList阻塞队列。
锁升级的目的：为了减低锁带来的性能消耗，锁可以升级但不能降级，这种只能升级不能降级的锁策略是为了提高锁获得和释放的效率。

锁	        优点	                                                      缺点	                                 适用场景
偏向锁	加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。	如果线程间存在锁竞争，会带来额外的锁撤销的消耗。	适用于只有一个线程访问同步块场景。
轻量级锁	竞争的线程不会阻塞，提高了程序的响应速度。	如果始终得不到锁竞争的线程使用自旋会消耗CPU。	   追求响应时间。同步块执行速度非常快。
重量级锁	线程竞争不使用自旋，不会消耗CPU。	线程阻塞，响应时间缓慢。	           追求吞吐量。同步块执行速度较长。
```
#### 5.偏向锁，轻量级锁，重要级锁的解锁过程
```markdown
偏向锁没有解锁，就算使用完了，锁对象的MarkWord上仍然是偏向锁的线程ID
轻量级锁则是将Lock Record中交换的MarkWord还回去
synchronized则是将Owner设置为null，然后唤醒EntryList中的线程
```
#### 6.Java对象头的组成
```markdown
在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。
    1.实例数据里面存储的是对象的真正有效数据，里面包含各种类型的字段内容，无论是自身的还是从父类继承来的。
    2.对齐填充这部分并不是必然存在的，只是为了占位。虚拟机自动管理内存系统要求对象的大小必须是8字节的整数倍，当整个对象的大小不是8字节的整数倍时，用来对齐填充补全。
    3.对象头部分包含两类信息。
        1、第一类是自身运行时数据，如何哈希码（hashcode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID等，这部分数据官方称它为“Mark Word”。
        2、第二类是类型指针，即对象指向它的类型元数据的指针，虚拟机通过它来确定对象是哪个类型的实例。
    锁存在于Java对象头里，对象头的组成部分：
        Mark Word：存储对象的hashCode或锁信息等。
        Class Metadata Address：存储到对象类型数据的指针。
        Array length：数组的长度（如果当前对象是数组）
    Java对象头的MardWord中记录了对象和锁的相关信息，无锁状态下，Java对象头里的Mark Word里默认存储对象的HashCode、分代年龄和锁标记位。在64位的JVM中，Mark Word为64bit。
    在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。锁升级的功能也主要靠MarkWord中锁标志位和是否偏向锁标志完成。
```
![](https://img2020.cnblogs.com/blog/1771072/202009/1771072-20200921000025902-374721258.png)
### 11.ReentrantLock和synchronized之间的区别【10+】
[Java中提供了synchronized，为什么还要提供Lock呢？](https://www.cnblogs.com/binghe001/p/13676545.html)
```markdown
两者都是可重入锁：
原始构成：synchronized是JVM层面实现的；ReentrantLock是JDK API层面实现。（说白了就是是操作系统来实现，还是用户自己敲代码实现。）
两者区别：
    1.synchronized加锁和解锁自动进行，不必担心最后是否释放锁；ReentrantLock加锁和解锁需要手动进行，且次数需一样，否则其他线程无法获得锁。
    2.synchronized竞争锁失败时会一直处于阻塞状态资源不会释放；ReentrantLock可以尝试获取锁，并得到获取结果，获取锁失败直接返回。
    3.synchronized不可中断，获取锁无法设置超时；ReentrantLock可以响应中断，可以设置获取锁的超时时间。
    4.synchronized只能是非公平锁，无法实现公平锁；ReentrantLock可以满足公平锁，即先等待先获取到锁,也可以满足非公平锁，默认非公平锁。
    5.synchronized控制等待和唤醒需要结合加锁对象的wait()和notify(),notifyAll()随机唤醒或者全部唤醒；
        ReentrantLock控制等待和唤醒需要结合Condition的await()和signal()、signalAll()方法，可以实现分组精确唤醒线程。
    6.synchronized在加锁代码块执行完或者出现异常，自动释放锁；ReentrantLock不会自动释放锁，需要在finally{}代码块显示释放。
        ReentrantLock锁的细粒度和灵活度，都明显优于synchronized。
    7.底层实现不一样，synchronized是同步阻塞，使用的是悲观并发策略，lock是同步非阻塞，采用的是乐观并发策略
**synchronized关键是是无法破坏“不可剥夺”这个死锁的条件的**。这是因为synchronized申请资源的时候，如果申请不到，线程直接进入阻塞状态了，
    而线程进入阻塞状态，啥都干不了，也释放不了线程已经占有的资源。
Lock的优点：
    1）能够响应中断 void lockInterruptibly() throws InterruptedException;
    2）支持超时 boolean tryLock(long time,TimeUnit unit) throws InterruptedException;
    3）非阻塞地获取锁 boolean tryLock()
```
### 12.Java开发中用过哪些锁【10+】
#### 1.介绍一下Java有哪些锁(synchronized、juc提供的锁如ReentrantLock、CountDownLatch、CyclicBarrier、Semaphore等)
[5000字|24张图带你彻底理解21种并发锁](https://www.cnblogs.com/jackson0714/p/lock.html)
[谈谈Java中的那些“琐”事](https://www.cnblogs.com/songjilong/p/13710455.html)
```markdown
1、乐观锁
    乐观锁顾名思义每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。
    乐观锁适用于多读的应用类型，这样可以提高吞吐量，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升；　
        在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS(Compare and Swap 比较并交换)实现的
        乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。
    版本号控制：一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。
    当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。
2、悲观锁
　　悲观锁总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。
        比如Java里面的同步原语synchronized关键字的实现就是悲观锁。
        传统的关系型数据库使用这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁；
　　乐观锁适用于读多写少的情况下（多读场景），悲观锁比较适用于写多读少场景。
3、独占锁(也可称为写锁，只能被一个线程持有，synchronized和ReentrantLock都是独占锁)
　　独享锁是指该锁一次只能被一个线程所持有。和悲观锁、互斥锁同义。
　　独享锁通过AQS来实现的，通过实现不同的方法，来实现独享锁。对于Synchronized,ReentrantLock而言，当然是独享锁。
4、共享锁(也可称为读锁，可被多个线程持有) 
　　共享锁是指该锁可被多个线程所持有。读锁的共享锁可保证并发读是非常高效的，读写，写读，写写的过程是互斥的。
　　共享锁也是通过AQS来实现的，通过实现不同的方法，来实现共享锁。
    ReentrantReadWriteLock中的读锁是共享锁、写锁是独占锁
5、互斥锁
　　互斥锁与悲观锁、独占锁同义，表示某个资源只能被一个线程访问，其他线程不能访问。互斥锁在Java中的具体实现就是ReentrantLock。
6、读写锁
    Java提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如果没有写锁的情况下，读是无阻塞的，在一定程度上提高了程序的执行效率。 
    读写锁分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由jvm自己控制的。读锁：允许多个线程获取读锁，同时访问同一个资源。写锁：只允许一个线程获取写锁，不允许同时访问同一个资源。
　　 读写锁在Java中的具体实现就是ReadWriteLock,ReentrantReadWriteLock。
    /**
    * 创建一个读写锁
    * 它是一个读写融为一体的锁，在使用的时候，需要转换
    */
    private ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();
    // 获取读锁
    rwLock.readLock().lock();
    // 释放读锁
    rwLock.readLock().unlock();
    // 创建一个写锁
    rwLock.writeLock().lock();
    // 写锁 释放
    rwLock.writeLock().unlock();
7、可重入锁 （synchronized和ReentrantLock都是典型的可重入锁）　　　
　　**重入锁也叫作递归锁，任意线程在获取到锁之后能够再次获取该锁而不会被锁所阻塞。**可重入锁的原理：通过组合自定义同步器来实现锁的获取与释放。
　　synchronized和ReentrantLock就是重入锁对应的实现；可重入锁的作用：避免死锁。
　　synchronized重量级的锁 ；ReentrantLock轻量级的锁；
8、公平锁 （ReentrantLock 既可以是公平锁也可以是非公平锁）
　　公平锁是指多个线程按照申请锁的顺序来获取锁。在并发环境中，每个线程会先查看此锁维护的等待队列，如果当前等待队列为空，则占有锁，
        如果等待队列不为空，则加入到等待队列的末尾，按照FIFO的原则从队列中拿到线程，然后占有锁。
　　对于Java ReetrantLock而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。
    优：线程按照顺序获取锁，不会出现饿死现象（注：饿死现象是指一个线程的CPU执行时间都被其他线程占用，导致得不到CPU执行）。
    缺：整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU 唤醒线程的开销比非公平锁要大。
9、非公平锁（synchronized）
　　非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。　　
　　对于Synchronized而言，也是一种非公平锁。由于其并不像ReentrantLock是通过AQS的来实现线程调度，所以并没有任何办法使其变成公平锁。
    优点：非公平锁的性能高于公平锁，减少上下文切换，吞吐量高。缺点：有可能造成线程饥饿（某个线程很长一段时间获取不到锁）
10、分段锁
　　分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。
　　我们以ConcurrentHashMap来说一下分段锁的含义以及设计思想，ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap（JDK7和JDK8中HashMap的实现）的结构，
    即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock）。
　　当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在哪一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。
　　但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计。
　　分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。
11、偏向锁　　
　　偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。
    优点： 把整个同步都消除掉，连CAS操作都不去做了，优于轻量级锁。
    缺点： 如果程序中大多数的锁都总是被多个不同的线程访问，那偏向锁就是多余的。
12、轻量级锁
　　轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。
    优点： 如果没有竞争，通过CAS操作成功避免了使用互斥量的开销。
    缺点： 如果存在竞争，除了互斥量本身的开销外，还额外产生了CAS操作的开销，因此在有竞争的情况下，轻量级锁比传统的重量级锁更慢。
13、重量级锁
　　 synchronized是通过对象内部的一个叫做监视器锁（monitor）来实现的，监视器锁本身依赖底层的操作系统的 Mutex Lock来实现。
    操作系统实现线程的切换需要从用户态切换到核心态，成本非常高。这种依赖于操作系统 Mutex Lock来实现的锁称为重量级锁。
    为了优化synchonized，引入了轻量级锁，偏向锁。重量级锁会让他申请的线程进入阻塞，性能降低。Java中的重量级锁： synchronized
14、自旋锁 (CAS：CompareAndSwap，比较并交换，它是一种乐观锁。)
　　在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，优点：是减少线程上下文切换的消耗，缺点是循环会消耗CPU。
    缺点：如果锁被其他线程长时间占用，一直不释放CPU，会带来许多的性能开销；自旋次数默认值是10
15.自适应自旋锁：
    对上面自旋锁优化方式的进一步优化，它的自旋的次数不再固定，其自旋的次数由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定，这就解决了自旋锁带来的缺点。
16.锁粗化是一种优化技术：如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作都是出现在循环体体之中，就算真的没有线程竞争，
    频繁地进行互斥同步操作将会导致不必要的性能损耗，所以就采取了一种方案：把加锁的范围扩展（粗化）到整个操作序列的外部，这样加锁解锁的频率就会大大降低，从而减少了性能损耗。
17.锁消除是一种优化技术：就是把锁干掉。当Java虚拟机运行时发现有些共享数据不会被线程竞争时就可以进行锁消除。
    那如何判断共享数据不会被线程竞争？
    利用逃逸分析技术：分析对象的作用域，如果对象在A方法中定义后，被作为参数传递到B方法中，则称为方法逃逸；如果被其他线程访问，则称为线程逃逸。
    在堆上的某个数据不会逃逸出去被其他线程访问到，就可以把它当作栈上数据对待，认为它是线程私有的，同步加锁就不需要了。
```
#### 2.公平锁和非公平锁区别？为什么公平锁效率低？【2+】
```markdown
公平锁：
​   公平锁自然是遵循FIFO（先进先出）原则的，先到的线程会优先获取资源，后到的会进行排队等待
​   优点：所有的线程都能得到资源，不会饿死在队列中。
​   缺点：吞吐量会下降，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销大
非公平锁：
​   多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。
​   优点：可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。
​   缺点：你们可能也发现了，这样可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁
公平锁效率低原因：
​   公平锁要维护一个队列，后来的线程要加锁，即使锁空闲，也要先检查有没有其他线程在wait，如果有自己要挂起，加到队列后面，然后唤醒队列最前面线程。
这种情况下相比较非公平锁多了一次挂起和唤醒。线程切换的开销，其实就是非公平锁效率高于公平锁的原因，因为非公平锁减少了线程挂起的几率，后来的线程有一定几率逃离被挂起的开销
```
#### 3.锁优化
```markdown
【1】减少锁的时间：
​     不需要同步执行的代码，能不放在同步快里面执行就不要放在同步快内，可以让锁尽快释放；
​【2】减少锁的粒度：
    ​ 它的思想是将物理上的一个锁，拆成逻辑上的多个锁，增加并行度，从而降低锁竞争。它的思想也是用空间来换时间；java中很多数据结构都是采用这种方法提高并发操作的效率，比如：
    ConcurrentHashMap：
​    java中的ConcurrentHashMap在jdk1.8之前的版本，使用一个Segment 数组：Segment<K,V>[] segments
​    Segment继承自ReenTrantLock，所以每个Segment是个可重入锁，每个Segment有一个HashEntry<K,V>数组用来存放数据，put操作时，先确定往哪个Segment放数据，
    只需要锁定这个Segment，执行put，其它的Segment不会被锁定；所以数组中有多少个Segment就允许同一时刻多少个线程存放数据，这样增加了并发能力。
​【3】锁粗化：
​   大部分情况下我们是要让锁的粒度最小化，锁的粗化则是要增大锁的粒度;
​   在以下场景下需要粗化锁的粒度：
​   假如有一个循环，循环内的操作需要加锁，我们应该把锁放到循环外面，否则每次进出循环，都进出一次临界区，效率是非常差的；
​【4】使用读写锁：
​   ReentrantReadWriteLock 是一个读写锁，读操作加读锁，可并发读，写操作使用写锁，只能单线程写；
​【5】使用CAS：
​    如果需要同步的操作执行速度非常快，并且线程竞争并不激烈，这时候使用cas效率会更高，因为加锁会导致线程的上下文切换，
    如果上下文切换的耗时比同步操作本身更耗时，且线程对资源的竞争不激烈，使用volatiled+cas操作会是非常高效的选择；
```
### 13.volatile原理和特性【10+】
>> volatile作用？底层实现？禁止重排序的场景？单例模式中volatile的作用？
[面试中的volatile关键字](https://www.cnblogs.com/ArvinYL/p/12827641.html)
[Java程序员面试必备：Volatile全方位解析](https://www.cnblogs.com/jay-huaxiao/p/13473197.html)
```markdown
volatile关键字是Java虚拟机提供的的「最轻量级的同步机制」，它作为一个修饰符出现，用来「修饰变量」，但是这里不包括局部变量哦。
被volatile修饰的共享变量，就具有了以下几点特性：
    1.保证了不同线程对该变量操作的**内存可见性**
    2.禁止指令重排序(有序性)
    3.不保证原子性
内存可见性:(**volatile怎么保证可见性**)
    可见性是指一个线程修改了共享变量的值，其他线程能够立即得知这个修改。
    volatile变量保证新值能够立马同步到主内存，使用时也立即从主内存中刷新，保证了多线程操作时变量的可见性。
    通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，
    并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。
    因为java虚拟机会在volatile变量写操作后插入一个StoreLoad屏障。该屏障禁止了屏障之后的任何读操作和屏障之前的任何写操作之间进行重排序。
    所以在StoreLoad屏障之前的写操作，因为StoreLoad屏障的清空写缓冲器中所有写操作的结果到高速缓存使得其他线程能得到更新后的数据。
指令重排：
    为了提高性能，编译器和处理器通常会对指令进行重排序，重排序指从源代码到指令序列的重排序，分为三种：
        ① 编译器优化的重排序，编译器在不改变单线程程序语义的前提下可以重排语句的执行顺序。
        ② 指令级并行的重排序，如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
        ③ 内存系统的重排序。
volatile如何防止指令重排？
    也是内存屏障哦，跟面试官讲下Java内存的保守策略：
        在每个volatile写操作的前面插入一个StoreStore屏障。
        在每个volatile写操作的后面插入一个StoreLoad屏障。
        在每个volatile读操作的前面插入一个LoadLoad屏障。
        在每个volatile读操作的后面插入一个LoadStore屏障。
    再讲下volatile的语义哦，重排序时不能把内存屏障后面的指令重排序到内存屏障之前的位置
内存屏障：也称内存栅栏，内存栅障，屏障指令等， 是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，
    使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作。也是一个让CPU 处理单元中的内存状态对其它处理单元可见的一项技术。
happens-before规则
    是一个给程序员使用的规则，只要程序员在写代码的时候遵循happens-before规则，
    JVM就能保证指令在多线程之间的顺序性符合程序员的预期。
volatile不能保证原子性，它只是对单个volatile变量的读/写具有原子性，但是对于类似i++的复合操作就无法保证。
volatile+synchronized实现单例模式的双重检查锁
    单例模式中volatile的作用：防止代码读取到instance不为null时，instance引用的对象有可能还没有完成初始化。
    class Singleton{
        private volatile static Singleton instance = null;   //禁止指令重排
        private Singleton() {}
        public static Singleton getInstance() {
            if(instance==null) {
                synchronized (Singleton.class) {
                    if(instance==null)
                        instance = new Singleton();
                }
            }
            return instance;
        }
    }
```
### 14.synchronized和volatile的区别
```markdown
volatile本质是在告诉JVM当前变量寄存器(工作内存)中的值是不确定的，需要从主存中读取；
synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
    1.volatile只能用于变量，而synchronized可以修饰类，方法和代码块。
    2.volatile关键字是线程同步的轻量级实现，性能比synchronized要好。
    3.多线程访问volatile不会发生阻塞，而synchronized可能发生阻塞。
    4.volatile能够保证数据的可见性，但是不能保证数据的原子性，synchronized两者都能保证。
    5.volatile主要是解决变量在多个线程之间的可见性，synchronized解决多个线程之间访问资源的同步性。
    6.volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。
```
### 15.当⼀个线程进⼊⼀个对象的⼀个synchronized⽅法后，其它线程是否可进⼊此对象的其它⽅法?
```markdown
其他⽅法前是否加了synchronized关键字，如果没加，则能。
    如果这个⽅法内部调⽤了wait，则可以进⼊其他synchronized⽅法。
    如果其他个⽅法都加了synchronized关键字，并且内部没有调⽤wait，则不能。
    如果其他⽅法是static，它⽤的同步锁是当前类的字节码，与⾮静态的⽅法不能同步，因为⾮静态的⽅法⽤的是this。
```
### 16.sleep()和wait()的区别联系【10+】
```markdown
1.wait()是Object的方法，而sleep()是Thread的静态方法。
2.wait可以指定时间，也可以不指定；而sleep必须指定时间。
3.wait释放cpu资源，同时释放锁；sleep释放cpu资源，但是不释放锁，所以易死锁。
4.wait必须放在同步块或同步方法中，而sleep可以再任意位置。
5.sleep()通常被用于暂停执行，而wait()通常被用于线程间交互和通信。
【加分项】.在调用没有指定时间wait方法之后，线程会变为WATING（无限期等待）状态，在调用指定时间的wait()方法之后线程进入TIMED_WAITING（限期等待）状态。
    而调用sleep方法之后，线程会变为TIMED_WAITING（限期等待）状态。
【加分项】.进入wait状态的线程能够被notify和notifyAll线程唤醒，而sleep状态的线程不能被notify方法唤醒。
```
[加分项>>如何证明sleep不释放锁，而wait释放锁？](https://mp.weixin.qq.com/s?__biz=MzU1NTkwODE4Mw==&mid=2247487370&idx=1&sn=90c0bd01fd490b680eae9b60515e5e5f&chksm=fbcc62b2ccbbeba43cdaa4e95a8263ac7bd9dc42bf75b9060ff0354e724e0bc2215dda232b10&mpshare=1&scene=23&srcid=0721tKj84e0eLyXf3j5gmaqW&sharer_sharetime=1595339628839&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
```markdown
wait()释放锁
    给wait()和notify()两个方法上了同一把锁（locker），但在调用完wait()方法之后locker锁就被释放了，所以程序才能正常执行notify()的代码，
    因为是同一把锁，如果不释放锁的话，是不会执行notify()的代码的，这一点也可以从打印的结果中证实（结果输出顺序），所以综合以上情况来说wait()方法是释放锁的。
sleep()不释放锁
    sleep(1000)方法（行号：11）执行之后，调用notify()方法并没有获取到locker锁，从上述执行结果中可以看出，
    而是执行完sleep(1000)方法之后才执行的notify()方法，因此可以证明调用sleep()方法并不会释放锁。
```
```java
public class WaitDemo {
    private static Object locker = new Object();

    public static void main(String[] args) throws InterruptedException {
        WaitDemo waitDemo = new WaitDemo();

        // 启动新线程，防止主线程被休眠
        new Thread(() -> {
            try {
                waitDemo.doWait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
        Thread.sleep(200); // 此行本身没有意义，是为了确保 wait() 先执行再执行 notify()
        waitDemo.doNotify();
    }

    /**
     * 执行 wait()
     */
    private void doWait() throws InterruptedException {
        synchronized (locker) {
            System.out.println("wait start.");
            locker.wait();
            System.out.println("wait end.");
        }
    }

    /**
     * 执行 notify()
     */
    private void doNotify() {
        synchronized (locker) {
            System.out.println("notify start.");
            locker.notify();
            System.out.println("notify end.");
        }
    }
}
//以上程序的执行结果为：
//  wait start. 
//  notify start. 
//  notify end. 
//  wait end.
```
```java
public class WaitDemo {
    private static Object locker = new Object();

    public static void main(String[] args) throws InterruptedException {
        WaitDemo waitDemo = new WaitDemo();
        // 启动新线程，防止主线程被休眠
        new Thread(() -> {
            synchronized (locker) {
                try {
                    System.out.println("sleep start.");
                    Thread.sleep(1000);
                    System.out.println("sleep end.");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }).start();

        Thread.sleep(200);
        waitDemo.doNotify();
    }

    /**
     * 执行 notify()
     */
    private void doNotify() {
        synchronized (locker) {
            System.out.println("notify start.");
            locker.notify();
            System.out.println("notify end.");
        }
    }
}
//以上程序的执行结果为：
//  sleep start. 
//  sleep end. 
//  notify start. 
//  notify end.
```
### 17.notify()和notifyAll()有什么区别？【5+】
```markdown
notify():方法唤醒一个正在等待池的线程进入锁池去竞争获取锁的机会，如果有多个这样的线程，就会随机唤醒。notify()方法仅通知一个线程。
notifyAll():唤醒所有正在等待池的线程全部进入锁池区竞争获取锁的机会。
    唤醒不等于就能执行，需要得到锁对象才能有权利继续执行，而锁只有一把，所以多个线程被唤醒时需要争取该锁。
notify()之后进入哪个状态？是直接进入runable吗？
    线程a先抢到了对象o的锁，然后wait，然后b抢到了o的锁，然后b中调用o.notify并释放锁，此时a是running状态还是blocked状态？？
    如果b在执行完notify()后没有释放锁则线程a是阻塞等待，
    如果线程b执行完同步代码块（释放锁）后，则线程a就是就绪态，不一定是运行态
```
### 19.线程死锁编码及定位分析【5+】
```markdown
死锁是什么：死锁是指两个或两个以上的进程在执行过程中，因为争夺资源而造成的一种互相等待的现象。
    当线程A持有独占锁a,并且尝试去获取独占锁b的同时，线程B持有独占锁b，并且尝试获取独占锁a的情况下，
    就会发生AB两个线程由于互相持有对方需要的锁，而发生的阻塞现象，称为死锁。
死锁的必要条件：
     互斥条件 (Mutual exclusion)：资源不能被共享，只能由一个进程使用。
     请求与保持条件 (Hold and wait)：已经得到资源的进程可以再次申请新的资源。
     非抢占条件 (No pre-emption)：已经分配的资源不能从相应的进程中被强制地剥夺。
     循环等待条件 (Circular wait)：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源。
发生死锁时，上面的情况必须同时会发生。如果其中任意一个条件不会成立，死锁就不会发生。可以通过破坏其中任意一个条件来破坏死锁。
死锁的处理策略：
     鸵鸟策略：忽略死锁带来的影响
     死锁检测与死锁恢复（检测死锁并回复死锁，死锁发生时对其进行检测，一旦发生死锁后，采取行动解决问题）
        从死锁中恢复：通过抢占进行恢复,通过回滚进行恢复,杀死进程恢复。
     死锁预防（通过仔细分配资源来避免死锁）
     死锁避免（通过破坏死锁产生的四个条件之一来避免死锁）
        单个资源的银行家算法，破坏死锁，破坏互斥条件，破坏保持等待的条件，破坏不可抢占条件，破坏循环等待条件。
如何防止死锁：
    1.尽量使用tryLock(long timeout,TimeUnit unit)的方法(ReentrantLock,ReentrantReadWriteLock),设置超时时间，超时可以退出防止死锁。
    2.尽量使用Java.util.concurrent并发类替代自己手写锁
    3.尽量降低锁的使用粒度，尽量不要把几个功能用同一个锁。
    4.尽量减少同步的代码块。
```
```java
class HoldLockThed implements Runnable{
    private String lockA;
    private String lockB;
    public HoldLockThread(String lockA,String lockB){
        this.lockA = lockA;
        this.lockB = lockB;
    }
    
    @Override
    public void run(){
        synchronized (lockA){
            System.out.println(Thread.currentThread().getName()+"自己持有："+lockA+"尝试获得："+lockB);
            //暂停一会线程
                            try {
                                TimeUnit.MILLISECONDS.sleep(200);
                            } catch (InterruptedException e) {
                                e.printStackTrace();
                            }
            synchronized (lockB){
                        System.out.println(Thread.currentThread().getName()+"自己持有："+lockA+"尝试获得："+lockB);
                    }
        }
    }
}
public class DeadLockDemo{
    public static void main(String[] args){
      String lockA = "lockA";
      String lockB = "lockB";
      
      new Thread(new HoldLockThread(lockA,lockB),"ThreadAAA").start();//线程持有A,想要获取B
      new Thread(new HoldLockThread(lockB,lockA),"ThreadBBB").start();//线程持有B,想要获取A
    }
}
```
### 20.ThreadLocal原理【10+】
[ThreadLocal-面试必问深度解析](https://www.jianshu.com/p/98b68c97df9b)
[【Java并发编程】面试常考的ThreadLocal，超详细源码学习](https://www.cnblogs.com/summerday152/p/13735612.html)
[用ThreadLocal来优化下代码吧](https://www.cnblogs.com/awan-note/p/13754449.html)
#### 1.ThreadLocal简介和原理
```markdown
ThreadLocal是一个本地线程副本变量工具类。主要用于一个线程内跨类、方法传递数据。特别适用于各个线程依赖不同的变量值完成操作的场景。
    提供了线程隔离的局部变量，通过get()和set()方法操作当前线程对应的变量，而且不会和其他线程冲突，实现了基于线程的数据隔离。
ThreadLocal原理：首先ThreadLocal是一个泛型类，保证可以接受任何类型的对象。因为一个线程内可以存在多个ThreadLocal对象，
    所以其实是ThreadLocal内部维护了一个Map ，这个Map不是直接使用的HashMap，而是ThreadLocal实现的一个叫做ThreadLocalMap的静态内部类。
​    最终的变量是放在了当前线程的ThreadLocalMap中，并不是存在ThreadLocal上，ThreadLocal可以理解为只是ThreadLocalMap的封装，传递了变量值。
    我们使用的get()、set()方法其实都是调用了这个ThreadLocalMap类对应的get()、set()方法。
在1.7以前Threadlocal是由ThreadLocal来管理ThreadLocalMap，Thread作为key，
在1.8以后是Thread来管理ThreadLocalMap，ThreadLocal作为key。
```
#### 2.ThreadLocal使用
```markdown
ThreadLocal API使用
    private static ThreadLocal<String> threadLocal = ThreadLocal.withInitial(()->"java金融");
    public static void main(String[] args) {
        System.out.println("获取初始值："+threadLocal.get());//获取初始值：java金融
        threadLocal.set("关注：【java金融】");
        System.out.println("获取修改后的值："+threadLocal.get());//获取修改后的值：关注：【java金融】
        threadLocal.remove();
    }
1）存储用户Session
        private static final ThreadLocal threadSession = new ThreadLocal();
        public static Session getSession() throws InfrastructureException {
            Session s = (Session) threadSession.get();
            try {
                if (s == null) {
                    s = getSessionFactory().openSession();
                    threadSession.set(s);
                }
            } catch (HibernateException ex) {
                throw new InfrastructureException(ex);
            }
            return s;
        }
2）解决线程安全的问题
        public class DateUtil {
            //SimpleDateFormat不是线程安全的，所以每个线程都要有⾃⼰独⽴的副本
            private static ThreadLocal<SimpleDateFormat> format1 = new                     ThreadLocal<SimpleDateFormat>() {
                @Override
                protected SimpleDateFormat initialValue() {
                    return new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
                }
            };
            public static String formatDate(Date date) {
                return format1.get().format(date);
            }
        }
```
#### 3.ThreadLocal源码
```markdown
//set 方法：
        public void set(T value) {
            Thread t = Thread.currentThread();//1.获取当前线程
            ThreadLocalMap map = getMap(t);//2.获取ThreadLocalMap对象
            //3.如果ThreadLocalMap对象存在，则将当前线程对象作为key，要存储的对象作为value存到map中 如果ThreadLocalMap对象不存在，就调用creatMap( )进行创建
            if (map != null)
                map.set(this, value);
            else
                createMap(t, value);
        }
//get方法,就是从map中取值的过程。
        public T get() {   
            Thread t = Thread.currentThread();   
            ThreadLocalMap map = getMap(t);   
            if (map != null)   
                return (T)map.get(this);   
            // 如果不存在，则创建它   
            T value = initialValue();   
            createMap(t, value);   
            return value;   
        }
//createMap方法,就是新建一个ThreadLocalMap对象
        void createMap(Thread t, T firstValue) {   
            t.threadLocals = new ThreadLocalMap(this, firstValue);   
        } 
//ThreadLocalMap是个静态的内部类,定义了一个Entry类作为存储值的地方,key是当前ThreadLocal对象，value是我们要存储的值（对象）。
        static class ThreadLocalMap {   
            ……  
        }  
```
#### 4.ThreadLocal弱引用和内存泄漏【5+】
[面试：为了进阿里，死磕了ThreadLocal内存泄露原因](https://www.cnblogs.com/Ccwwlx/p/13581004.html)
```markdown
**内存泄露**为程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。
**强引用**使用最普遍的引用，一个对象具有强引用，不会被垃圾回收器回收。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不回收这种对象。
    如果想取消强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样可以使JVM在合适的时间就会回收该对象。
**弱引用**JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在java中，用java.lang.ref.WeakReference类来表示。可以在缓存中使用弱引用。
实际上ThreadLocalMap中使用的key为ThreadLocal的弱引用，⽽value是强引⽤。
    弱引用的特点是如果这个对象持有弱引用，那么在下一次垃圾回收的时候必然会被清理掉。
    ThreadLocal没有被外部强引用的情况下，在垃圾回收的时候会被清理掉的，这样一来ThreadLocalMap中使用这个ThreadLocal的key也会被清理掉。
    但是，value是强引用，不会被清理，这样一来就会出现key为null的value。假如我们不做任何措施的话，value永远⽆法被GC回收，这个时候就可能会产⽣内存泄露。
ThreadLocalMap实现中已经考虑了这种情况，**在调用set()、get()、remove()方法的时候，会清理掉key为null的记录。**
   如果说会出现内存泄漏，那只有在出现了key为null的记录后，没有手动调用remove()方法，并且之后也不再调用get()、set()、remove()方法的情况下。
​   因此使⽤完ThreadLocal⽅法后，最好⼿动调⽤remove()⽅法。
HaseMap解决hash冲突是由链表和红黑树（jdk1.8）来解决的，但是这个我们看到ThreadLocalMap只有一个数组。
ThreadLocalMap中解决Hash冲突的方式并非链表的方式，而是采用**线性探测**的方式，所谓线性探测，就是根据初始key的hashcode值确定元素在table数组中的位置，
    如果发现这个位置上已经有其他key值的元素被占用，则利用固定的算法寻找一定步长的下个位置，依次判断，直至找到能够存放的位置。
            private static int nextIndex(int i, int len) {
                return ((i + 1 < len) ? i + 1 : 0);
            }
            private static int prevIndex(int i, int len) {
                return ((i - 1 >= 0) ? i - 1 : len - 1);
            }
内存泄漏代码演示：
 public static void main(String[] args) throws InterruptedException {
        ThreadLocal<Long []> threadLocal = new ThreadLocal<>();
        for (int i = 0; i < 50; i++) {
            run(threadLocal);
        }
        Thread.sleep(50000);
        // 去除强引用
        threadLocal = null;
        System.gc();
        System.runFinalization();
        System.gc();
    }
    private static void run(ThreadLocal<Long []> threadLocal) {
        new Thread(() -> {
            threadLocal.set(new Long[1024 * 1024 *10]);
            try {
                Thread.sleep(1000000000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
    }
```
### 22.线程池【15+】
[分析JUC线程池ThreadPoolExecutor的实现原理](https://www.cnblogs.com/throwable/p/13574306.html)
[线程池原理及源码分析](https://www.cnblogs.com/jajian/p/11442929.html)
>> java线程池参数描述，线程池工作原理，线程池如何调优。Java线程池原理
   线程池中的keepAliveTime参数主要是作用于哪里的，还有一些关于线程池的基本知识,自己写个线程池应该怎么写？
#### 0.为什么要使用线程池，线程池的优势？
```markdown
1. 创建/销毁线程需要消耗系统资源，线程池可以复用已创建的线程。
2. 控制并发的数量。并发数量过多，可能会导致资源消耗过多，从而造成服务器崩溃。（主要原因）
3. 提高线程的统一管理性，可以对线程做统一管理。
4. 实现任务线程队列缓冲策略和拒绝机制。实现某些与时间相关的功能，如定时执行、周期执行等。
ThreadPoolExecutor里面使用到JUC同步器框架，主要用于四个方面：
    1.全局锁mainLock成员属性，是可重入锁ReentrantLock类型，主要是用于访问工作线程Worker集合和进行数据统计记录时候的加锁操作。
    2.条件变量termination，Condition类型，主要用于线程进行等待终结awaitTermination()方法时的带期限阻塞。
    3.任务队列workQueue，BlockingQueue<Runnable>类型，任务队列，用于存放待执行的任务。
    4.工作线程，内部类Worker类型，是线程池中真正的工作线程对象。
```
#### 1.线程池构造函数7大参数
```markdown
参数	            作用
corePoolSize	核心线程池大小
maximumPoolSize	最大线程池大小
keepAliveTime	线程池中超过corePoolSize数目的空闲线程最大存活时间；可以allowCoreThreadTimeOut(true)使得核心线程有效时间
TimeUnit	    keepAliveTime时间单位
workQueue	    阻塞任务队列
threadFactory	新建线程工厂
RejectedExecutionHandler	拒绝策略。当提交任务数超过maxmumPoolSize+workQueue之和时，任务会交给RejectedExecutionHandler来处理
/**
* 线程池构造函数7大参数
*/
public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,
    TimeUnit unit,BlockingQueue<Runnable> workQueue,ThreadFactory threadFactory,
    RejectedExecutionHandler handler) {
        if (corePoolSize < 0 ||maximumPoolSize <= 0 ||maximumPoolSize < corePoolSize ||
                keepAliveTime < 0)
             throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.corePoolSize = corePoolSize;
           this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
}
```
#### 2.线程拒绝策略
```markdown
​线程池中的线程已经用完了，无法继续为新任务服务，同时，等待队列也已经排满了，再也塞不下新任务了。这时候我们就需要拒绝策略机制合理的处理这个问题。
JDK内置的拒绝策略如下：
​   AbortPolicy：直接抛出异常，阻止系统正常运行。
​   CallerRunsPolicy ：只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务。显然这样做不会真的丢弃任务，但是，任务提交线程的性能极有可能会急剧下降。
​   DiscardOldestPolicy ：丢弃最老的一个请求，也就是即将被执行的任务，并尝试再次提交当前任务。
​   DiscardPolicy ：该策略默默地丢弃无法处理的任务，不予任何处理。如果允许任务丢失，这是最好的一种方案。
```
#### 3.线程池几种工作队列
```markdown
1.ArrayBlockingQueue：底层是数组，有界队列，如果我们要使用生产者-消费者模式，这是非常好的选择。
2.LinkedBlockingQueue：底层是链表，可以当做无界和有界队列来使用，所以大家不要以为它就是无界队列。
3.SynchronousQueue：本身不带有空间来存储任何元素，使用上可以选择公平模式和非公平模式。
4.PriorityBlockingQueue：无界队列，基于数组，数据结构为二叉堆，数组第一个也是树的根节点总是最小值。
举例ArrayBlockingQueue实现并发同步的原理：原理就是读操作和写操作都需要获取到AQS独占锁才能进行操作。
    如果队列为空，这个时候读操作的线程进入到读线程队列排队，等待写线程写入新的元素，然后唤醒读线程队列的第一个等待线程。
    如果队列已满，这个时候写操作的线程进入到写线程队列排队，等待读线程将队列元素移除腾出空间，然后唤醒写线程队列的第一个等待线程。
```
#### 4.Execuors类实现的几种线程池类型【5+】
```markdown
Executors.newSingleThreadExecutor()：只有一个线程的线程池，因此所有提交的任务是顺序执行，适用于一个一个任务执行的场景
Executors.newCachedThreadPool()：线程池里有很多线程需要同时执行，老的可用线程将被新的任务触发重新执行，
    如果线程超过60秒内没执行，那么将被终止并从池中删除，适用执行很多短期异步的小程序或者负载较轻的服务
Executors.newFixedThreadPool()：拥有固定线程数的线程池，如果没有任务执行，那么线程会一直等待，适用执行长期的任务，性能好很多。
Executors.newScheduledThreadPool()：用来调度即将执行的任务的线程池
因为以上方式都存在弊端：
    ​ FixedThreadPool和SingleThreadExecutor：允许请求的队列⻓度为Integer.MAX_VALUE，可能堆积⼤量的请求，从⽽导致OOM。
​     CachedThreadPool和ScheduledThreadPool：允许创建的线程数量为Integer.MAX_VALUE，可能会创建⼤量线程，从⽽导致OOM。
```
#### 5.线程池的工作流程
![](https://img2018.cnblogs.com/blog/1162587/201909/1162587-20190902171916863-1777758429.png)
```markdown
1.当线程池小于corePoolSize，新提交任务将创建一个新线程执行任务，即使此时线程池中存在空闲线程。
2.当线程池达到corePoolSize时，新提交任务将被放入workQueue中，等待线程池中任务调度执行。
3.当workQueue已满，且maximumPoolSize大于corePoolSize时，新提交任务会创建新线程执行任务。
4.当提交任务数超过maximumPoolSize时，新提交任务由RejectedExecutionHandler(拒绝策略)处理。
5.当线程池中超过corePoolSize线程，空闲时间达到keepAliveTime(空闲线程最大存活时间)时，关闭空闲线程。
```
#### 6.线程池大小如何设置？
```markdown
CPU 密集型
    CPU密集的意思是该任务需要大量的运算，而没有阻塞，CPU一直全速运行。
    CPU密集型任务尽可能的少的线程数量，一般为CPU核数+1个线程的线程池。
IO 密集型
    由于IO 集型任务线程并不是一直在执行任务，可以多分配一点线程数，如CPU * 2
    也可以使用公式：CPU核数/(1-阻塞系数)；其中阻塞系数在0.8 ～ 0.9之间。
在IO优化中，线程等待时间所占比例越高，需要越多线程，线程CPU时间所占比例越高，需要越少线程。
    这样的估算公式可能更适合：最佳线程数目=（（线程等待时间+线程CPU时间）/线程CPU时间 ）* CPU数目
```
#### 7.创建线程池的几种方式。
>> Exector——>ExectorService-->AbstractExectorService——>ThreadPoolExecutor——>ScheduledThreadPoolExecutor
>>                         ——>ScheduledExecutorService-->ScheduledThreadPoolExecutor
>> Exectors 
```markdown
快捷创建线程池很简单，只需要调用Executors中相应的静态工厂方法即可
    Executors.newSingleThreadExecutor();创建单线程池。返回只有一个线程的线程池。保证所有的任务都是按顺序执行的。
        最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目。
        若多余任务提交到线程池，任务会被保存到任务队列中，待线程空闲，按先入先出的顺序执行。
    Executors.newCacheThreadPool();用来处理大量短时间工作任务的线程池。返回可根据实际情况调整的线程数量的线程池。
        会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置超过60秒，则被终止并移除缓存。
        长时间闲置不会消耗什么资源，内部使用SynchronousQueue作为工作队列。
    Executors.newFixedThreadPoll(int nThread);重用指定数目(nThread)的线程，性能好很多。返回一个固定线程数量的线程池。线程池中的线程数量始终不变。
        其背后使用的是无界的工作队列，任何时候最多有nThread个工作线程是活动的。
        如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现。
        如果有工作线程退出，将会有新的工作线程被创建，以弥补指定的数目nThread.
    Executors.newSingleThreadScheduledExecutor():创建单线程池，返回ScheduledExecutorService,可以进行定时或者周期性的工作调度。
    Executors.newScheduleThreadPool(int corePoolSize):和newSingleThreadScheduledExecutor()类似，创建的是个ScheduledExecutorService
        可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程。
    Executors.newWorkStealingPool(int);java8新增，使用目前机器上可以的处理器作为他的并行级别。
        其内部会构建ForkJoinPool,利用Work-Stealing算法，并行处理任务，不保证处理顺序。
    ThreadPoolExecutor自定义创建线程池：
阿里巴巴Java开发手册：
    【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。
    【强制】线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor自定义的方式，
        这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。
    1）FixedThreadPool和SingleThreadPool：允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。
    2）CachedThreadPool：允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。
    所以阿里巴巴也建议我们要自定义线程池核心线程数以及阻塞队列的长度。
```
#### 8.线程池有哪些状态
![线程池状态的变化流转：](https://img2020.cnblogs.com/other/799093/202005/799093-20200524074816572-2061701085.png)
```markdown
 RUNNING：这是最正常的状态，接受新的任务，并且也能处理阻塞队列中的任务。
    线程池的初始化状态是RUNNING。线程池被一旦被创建，就处于RUNNING状态，并且线程池中的任务数为0。
 SHUTDOWN：不接受新的任务提交，但是却可以继续处理阻塞队列中的任务。
    调用线程池的shutdown()方法时，线程池由RUNNING->SHUTDOWN。
 STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。
    调用线程池的shutdownNow()方法时，线程池由(RUNNING or SHUTDOWN) -> STOP。
 TIDYING：所有的任务都终止了，workCount为0，线程池的状态在转换为TIDYING状态时，会执行钩子方法terminated()。
    因为terminated()在ThreadPoolExecutor类中是空的，所以用户想在线程池变为TIDYING时进行相应的处理；可以通过重载terminated()函数来实现。
 TERMINATED：线程池处在TIDYING状态时，执行完terminated()之后，就会由TIDYING->TERMINATED。
    当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由SHUTDOWN->TIDYING。
    当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP->TIDYING。
```
#### 9.线程池中submit()和execute方法的区别
[线程池续：你必须要知道的线程池submit()实现原理之FutureTask！](https://www.cnblogs.com/wang-meng/p/13023710.html)
```markdown
多线程往线程池中提交线程的时候其实有两种方法一种是execute()另外一种是submit():
 execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。
    execute()方法只能执行Runnable类的任务。
 submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，
    并且可以通过future的get()方法来获取返回值，submit()可以执行Runnable和Callable类的任务。
```
#### 10.如何关闭线程池
```markdown
可以调用shutdown或shutdownNow方法关闭线程池，
    原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法中断线程，无法响应中断的任务可能永远无法终止。
    区别是shutdownNow首先将线程池的状态设为STOP，然后尝试停止正在执行或暂停任务的线程，并返回等待执行任务的列表。
    而shutdown只是将线程池的状态设为SHUTDOWN，然后中断没有正在执行任务的线程。
通常调用shutdown来关闭线程池，如果任务不一定要执行完可调用shutdownNow。
```
#### 11.自定义一个线程池通过for循环连续创建10个任务并打印线程执行信息
```markdown
public static void main(String[] args) {
    ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(3, 6, 5L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<>(4));
    for (int i = 0; i < 10; i++) {
        threadPoolExecutor.execute(() -> {
             System.out.println("测试线程池：" + Thread.currentThread().getName() + "," + threadPoolExecutor.toString());
        });
    }
}
```
### 23.并发/同步工具类【5+】
[JUC 常用4大并发工具类](https://www.cnblogs.com/flower-dance/p/13714006.html)
>> CountDownLatch、CyclicBarrier、Semaphore介绍
#### 1.CountdownLatch
[CountDownLatch源码分析](https://www.cnblogs.com/funyoung/p/13626740.html)
```markdown
CountDowntLatch的作用是**让主线程等待所有的子线程执行完毕之后再进行执行**，同时它是基于AQS进行实现的，所以它内部肯定是通过自定义AQS共享模式下的同步器来实现的，
    该同步器需要重写AQS提供的tryAcquireShared()以及tryReleaseShared()方法，告诉AQS是否尝试获取同步资源以及释放同步资源成功。
该⼯具通常⽤来控制线程等待，它可以让某⼀个线程等待直到倒计时结束，再开始执⾏。
AQS子类需要定义以及维护同步状态的值，在CountDownLatch中，同步状态state的值为同步资源的个数。
CountDownLatch为什么不能重用？
不能重用，因此当主线程被唤醒后，然后调用tryAcquireShared()方法获取了同步资源，然后就直接返回，做自己的事情，永远都不会释放同步资源，因此不能重用。
    假设我们有这么一个场景，教室里有班长和其他6个人在教室上自习，怎么保证班长等其他6个人都走出教室在把教室门给关掉。
        public class CountDownLanchDemo {
            public static void main(String[] args) {
                for (int i = 0; i < 6; i++) {
                    new Thread(() -> {
                        System.out.println(Thread.currentThread().getName() + " 离开了教室...");
                    }, String.valueOf(i)).start();
                }
                System.out.println("班长把门给关了，离开了教室...");
            }
        }
    此时输出：
        0 离开了教室...
        1 离开了教室...
        2 离开了教室...
        3 离开了教室...
        班长把门给关了，离开了教室...
        5 离开了教室...
        4 离开了教室...
    发现班长都没有等其他人理他教室就把门给关了，此时我们就可以使用 CountDownLatch 来控制
        public class CountDownLanchDemo {
            public static void main(String[] args) throws InterruptedException {
                CountDownLatch countDownLatch = new CountDownLatch(6);
                for (int i = 0; i < 6; i++) {
                    new Thread(() -> {
                        countDownLatch.countDown();
                        System.out.println(Thread.currentThread().getName() + " 离开了教室...");
                    }, String.valueOf(i)).start();
                }
                countDownLatch.await();
                System.out.println("班长把门给关了，离开了教室...");
            }
        }
    输出：
       0 离开了教室...
       1 离开了教室...
       2 离开了教室...
       3 离开了教室...
       4 离开了教室...
       5 离开了教室...
       班长把门给关了，离开了教室...
```
#### 2.CyclicBarrier
[CyclicBarrier源码分析](https://www.cnblogs.com/funyoung/p/13633450.html)
```markdown
CyclicBarrier的作用是**让一组线程互相等待至某个状态后并行执行**（相对外部来说是并行，其实内部还是串行）。
CyclicBarrier虽然也是同步器，但是并非直接通过AQS来进行实现的，而是借助了ReentrantLock以及Condition来进行实现。
为什么说CyclicBarrier是可以复用的?
    因为当最后一个线程进入await()方法，将会调用nextGeneration()方法，该方法除了唤醒在指定Condition中等待的线程之外，还会将count的数量设置成parties，
    恢复成CyclicBarrier初始化后的状态，同时将generation引用指向一个新的Generation实例，因此CyclicBarrier是可以复用的，同时需要注意的是，
    如果CyclicBarrier已经被破坏，那么需要先调用一次reset()方法之后才能够进行复用。
直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活，线程进入屏障通过CyclicBarrier的await()方法。
    我们假设有这么一个场景，每辆车只能坐4个人，当车满了，就发车。
        public class CyclicBarrierDemo {
            public static void main(String[] args) {
                CyclicBarrier cyclicBarrier = new CyclicBarrier(4, () -> {
                    System.out.println("车满了，开始出发...");
                });
                for (int i = 0; i < 8; i++) {
                    new Thread(() -> {
                        System.out.println(Thread.currentThread().getName() + " 开始上车...");
                        try {
                            cyclicBarrier.await();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        } catch (BrokenBarrierException e) {
                            e.printStackTrace();
                        }
                    }).start();
                }
            }
        }
    输出结果：
        Thread-0 开始上车...
        Thread-1 开始上车...
        Thread-3 开始上车...
        Thread-4 开始上车...
        车满了，开始出发...
        Thread-5 开始上车...
        Thread-7 开始上车...
        Thread-2 开始上车...
        Thread-6 开始上车...
        车满了，开始出发...
```
#### 3.Semaphore
```markdown
在Java中，Semaphore（信号量）**是用来控制同时访问特定资源的线程数量**，它通过协调各个线程，以保证合理的使用公共资源。
​信号量主要用于两个目的，一个是用于多个共享资源的互斥作用，另一个用于并发线程数的控制。
    假设我们有 3 个停车位，6 辆车去抢；指定多个线程同时访问某个资源。
    public class SemaphoreDemo {
      public static void main(String[] args) {
          Semaphore semaphore = new Semaphore(3);
          for (int i = 0; i < 6; i++) {
              new Thread(() -> {
                  try {
                      semaphore.acquire(); // 获取一个许可
                      System.out.println(Thread.currentThread().getName() + " 抢到车位...");
                      Thread.sleep(3000);
                      System.out.println(Thread.currentThread().getName() + " 离开车位");
                  } catch (InterruptedException e) {
                      e.printStackTrace();
                  } finally {
                      semaphore.release(); // 释放一个许可
                  }
              }).start();
          }
      }
    }
    
    /**输出
    Thread-1 抢到车位...
    Thread-2 抢到车位...
    Thread-0 抢到车位...
    Thread-2 离开车位
    Thread-0 离开车位
    Thread-3 抢到车位...
    Thread-1 离开车位
    Thread-4 抢到车位...
    Thread-5 抢到车位...
    Thread-3 离开车位
    Thread-5 离开车位
    Thread-4 离开车位
    */
```
#### 4.Exchanger
```markdown
Exchanger是一个用于线程间协作的工具类。**Exchanger用于进行线程间的数据交换**。
它提供一个同步点，在这个同步点两个线程可以交换彼此的数据。这两个线程通过exchange方法交换数据，它提供一个同步点，在这个同步点两个线程可以交换彼此的数据。
这两个线程通过exchange方法交换数据，如果第一个线程先执行exchange方法，它会一直等待第二个线程也执行exchange，
当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。因此使用Exchanger的重点是成对的线程使用exchange()方法，
当有一对线程达到了同步点，就会进行交换数据。因此该工具类的线程对象是成对的。
public class TExchanger {
    public static void main(String[] args) {
        Exchanger exchanger = new Exchanger();
        ExchangerRunnable exchangerRunnable = new ExchangerRunnable(exchanger,"A");
        ExchangerRunnable exchangerRunnable2 = new ExchangerRunnable(exchanger,"B");
        new Thread(exchangerRunnable).start();
        new Thread(exchangerRunnable2).start();
    }
}
class ExchangerRunnable implements Runnable {
    Exchanger exchanger;
    Object object;
    public ExchangerRunnable(Exchanger exchanger,Object object){
        this.exchanger = exchanger;
        this.object = object;
    }
    @Override
    public void run() {
        Object previous = object;
        try {
            object = this.exchanger.exchange(object);
            System.out.println(
                    Thread.currentThread().getName() + "改变前是" + previous + "改变后是" + object);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```
### 24.原子类Atomic【5+】
[像宝石一样的Java原子类](https://www.cnblogs.com/upnote/p/12972751.html)
[AtomicInteger的惊天大秘密](https://www.cnblogs.com/cxuanBlog/p/13703563.html)
[一场 Atomic XXX 的魔幻之旅](https://mp.weixin.qq.com/s?__biz=MzU2NDg0OTgyMA==&mid=2247494526&idx=1&sn=071de13dff98d3daae7b189c4fa322a1&chksm=fc46168dcb319f9b7108770ac8fbb3dad9c130432f5ad5697c5e2f30aed8dbb939c65669fe0e&mpshare=1&scene=23&srcid=0929yY3T6WeQrceIUh1OyNK0&sharer_sharetime=1601374168690&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
```markdown
Atomic主要利用**CAS(Compare ans swap)和volatile和native方法**来保证原子操作，从而避免synchronized的高开销，执行效率大为提升。
JDK5提供了java.util.concurrent.atomic包，这个包中的原子操作类提供了一种用法简单、性能高效、线程安全地更新一个变量的方式。
到JDK8该包共有17个类，依据作用分为四种：原子更新基本类型类、原子更新数组类、原子更新引用类以及原子更新字段类，atomic包里的类基本都是使用Unsafe实现的包装类。
AtomicInteger 原子更新整形、 AtomicLong 原子更新长整型、AtomicBoolean 原子更新布尔类型。
 Atomic包中的类基本的特性就是在多线程环境下，当有多个线程同时对单个（包括基本类型及引用类型）变量进行操作时，具有排他性，
    即当多个线程同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以向自旋锁一样，继续尝试，一直等到执行成功。
 Atomic系列的类中的核心方法都会调用unsafe类中的几个本地方法。因此atomic证原子性就是通过:volatile+CAS（乐观锁）
 Lock类和Atomic包底层实现都是通过CAS+自旋的方式解决多线程同步问题。Atomic在竞争激烈时能维持常态，比lock性能好，但是只能同步一个变量。
AtomicInteger是JDK1.5新添加的工具类，AtomicInteger主要是依赖于sun.misc.Unsafe提供的一些native方法保证操作的原子性。
//验证是不是线程安全的，我们用下面的例子进行测试
    public class TAtomicTest implements Runnable{
        AtomicInteger atomicInteger = new AtomicInteger();
        @Override
        public void run() {
            for(int i = 0;i < 10000;i++){
                System.out.println(atomicInteger.getAndIncrement());//先取值，然后再 + 1
            }                               //incrementAndGet();//先执行+1操作，然后返回自增后的结果 
        }
        public static void main(String[] args) {
            TAtomicTest tAtomicTest = new TAtomicTest();
            Thread t1 = new Thread(tAtomicTest);
            Thread t2 = new Thread(tAtomicTest);
            t1.start();
            t2.start();
        }
    }
    //getAndDecrement : 返回当前类型的 int 值，然后对 value 的值进行自减运算。
    //decrementAndGet：同样的，decrementAndGet方法就是先执行递减操作，然后再获取value的值。
```
[比AtomicLong更优秀的LongAdder确定不来了解一下吗？](https://www.cnblogs.com/wang-meng/p/12892695.html)
```markdown
count++操作，使用AtomicInteger count = new AtomicInteger();count.addAndGet(1);
如果是JDK8，推荐使用LongAdder对象，比AtomicLong性能更好（减少乐观锁的重试次数）。
AtomicLong：能保证并发情况下计数的准确性，其内部通过CAS来解决并发安全性的问题。
在使用CAS+自旋的过程中，在高并发环境下，N个线程同时进行自旋操作，会出现大量失败并不断自旋的情况，此时AtomicLong的自旋会成为瓶颈。
随着并发的增加，AtomicLong性能是急剧下降的，耗时是LongAdder的数倍。
1、设计思想上，LongAdder采用"分段"的方式降低CAS失败的频次。
2、使用Contended注解来消除伪共享
3、惰性求值
看场景来使用，如果是并发不太高的系统，使用AtomicLong可能会更好一些，而且内存需求也会小一些。
而在高并发统计计数的场景下，才更适合使用LongAdder。
```
[阿里为什么推荐使用LongAdder，而不是volatile？](https://mp.weixin.qq.com/s?__biz=MzU1NTkwODE4Mw==&mid=2247488299&idx=1&sn=b95d80307ab34fb5a3c5b2556049fd3b&chksm=fbcc7e13ccbbf705d96a0e2983eaa70eacdbbbfe718a43d6ecf5a8f37ebb45efc3fd003d464e&mpshare=1&scene=23&srcid=0825RnF2HZd440qG7dj3BNzb&sharer_sharetime=1598317030359&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
```markdown
阿里巴巴开发手册：
    1.类似于count++这种非一写多读的场景不能使用volatile；
    2.如果是JDK8推荐使用LongAdder而非AtomicLong来替代volatile，因为LongAdder的性能更好。
volatile 线程安全测试
    public class VolatileExample {
        public static volatile int count = 0; // 计数器
        public static final int size = 100000; // 循环测试次数
        public static void main(String[] args) {
            // ++ 方式 10w 次
            Thread thread = new Thread(() -> {
                for (int i = 1; i <= size; i++) {
                    count++;
                }
            });
            thread.start();
            // -- 10w 次
            for (int i = 1; i <= size; i++) {
                count--;
            }
            // 等所有线程执行完成
            while (thread.isAlive()) {}
            System.out.println(count); // 打印结果
        }
    }
```
### 25.如何处理从线程的异常
```markdown
多线程在运行过程中抛出异常怎么捕获？ （Future或回调函数）
```
### 26.park()与unpark()
```markdown
concurrent包是基于AQS(AbstractQueuedSynchronizer)框架的，AQS框架借助于两个类：
    Unsafe（提供CAS操作）
    LockSupport（提供park/unpark操作）主要作用就是挂起线程，唤醒线程。
LockSupport.park()和LockSupport.unpark(Thread thread)调用的是Unsafe中的native代码。
park与unpark的特点
    1.park/unpark的设计原理核心是“许可”(permit)：park是等待一个许可，unpark是为某线程提供一个许可。permit不能叠加，
    也就是说permit的个数要么是0，要么是1。也就是不管连续调用多少次unpark，permit也是1个。线程调用一次park就会消耗掉permit，再一次调用park又会阻塞住。
    如果某线程A调用park，那么除非另外一个线程调用unpark(A)给A一个许可，否则线程A将阻塞在park操作上。
    2.unpark可以先于park调用。在使用park和unpark的时候可以不用担心park的时序问题造成死锁。相比之下，wait/notify存在时序问题，
    wait必须在notify调用之前调用，否则虽然另一个线程调用了notify，但是由于在wait之前调用了，wait感知不到，就造成wait永远在阻塞。
    park和unpark调用的时候不需要获取同步锁。
park与unpark的优点
    与Object类的wait/notify机制相比，park/unpark有两个优点：
    1.以thread为操作对象更符合阻塞线程的直观定义。
    2.操作更精准，可以准确地唤醒某一个线程（notify随机唤醒一个线程，notifyAll唤醒所有等待的线程），增加了灵活性。
底层实现原理
    1.在Linux系统下，是用的Posix线程库pthread中的mutex（互斥量），condition（条件变量）来实现的。
    2.mutex和condition保护了一个_counter的变量，当park时，这个变量被设置为0，当unpark时，这个变量被设置为1。
```
### 27.守护线程【3+】
```markdown
守护线程是一种支持型线程，可以通过setDaemon(true)将线程设置为守护线程，但必须在线程启动前设置。
守护线程被用于完成支持性工作，但在JVM退出时守护线程中的finally块不一定执行，因为JVM中没有非守护线程时需要立即退出，所有守护线程都将立即终止，不能靠在守护线程使用finally确保关闭资源。
    在Java中垃圾回收线程**GC线程**就是特殊的守护线程。终结器线程等
    在Java线程中可以通过setDaemon(true);在启动线程start()前使用，设置线程为守护线程，
        在线程启动后，可以使用join()合并线程。
```
### 28.在Java程序中怎么保证多线程的安全
```markdown
1.使用安全类，比如Java.util.concurrent下的类
2.使用自动锁，synchronized
3.使用手动锁，Lock
手动锁代码实现
    Lock lock = new ReentrantLock();
    lock.lock();
    try{
        System.out.println("获得锁");
    }catch(Exception e){
        // TODO : headle execption
    }finally{
        System.out.println("释放锁");
        lock.unlock();
    }
```
### 29.CopyOnWriteArrayList原理和CopyOnWriteLinkedList区别
```markdown
写入时复制思想:就是当有多个调用者同时去请求一个资源数据的时候，有一个调用者出于某些原因需要对当前的数据源进行修改，
    这个时候系统将会复制一个当前数据源的副本给调用者修改。
```
>>CopyOnWrite容器即写时复制的容器,当我们往一个容器中添加元素的时候，不直接往容器中添加，而是将当前容器进行copy，
>>复制出来一个新的容器，然后向新容器中添加我们需要的元素，最后将原容器的引用指向新容器。
>>CopyOnWriteArrayList
[浅析CopyOnWriteArrayList](https://www.cnblogs.com/zengcongcong/p/12754067.html)
[Java经典面试题：聊一聊JUC下的 CopyOnWriteArrayList](https://www.cnblogs.com/jamaler/p/12843126.html)
[CopyOnWriteArrayList源码阅读笔记](https://www.cnblogs.com/three-fighter/p/13520475.html)
### 30.线程通信的方式有哪些？
```markdown
命令式编程中线程的通信机制有两种，共享内存和消息传递。
    1.在共享内存的并发模型里线程间共享程序的公共状态，通过写-读内存中的公共状态进行隐式通信。
    2.在消息传递的并发模型里线程间没有公共状态，必须通过发送消息来显式通信。
Java并发采用共享内存模型，线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。
volatile告知程序任何对变量的读需要从主内存中获取，写必须同步刷新回主内存，保证所有线程对变量访问的可见性。
synchronized 确保多个线程在同一时刻只能有一个处于方法或同步块中，保证线程对变量访问的原子性、可见性和有序性。
等待通知机制指一个线程A调用了对象的wait方法进入等待状态，另一线程B调用了对象的notify/notifyAll方法，线程A收到通知后结束阻塞并执行后序操作。
    对象上的wait和notify/notifyAll如同开关信号，完成等待方和通知方的交互。
如果一个线程执行了某个线程的join方法，这个线程就会阻塞等待执行了join方法的线程终止，这里涉及等待/通知机制。
join底层通过wait实现，线程终止时会调用自身的notifyAll方法，通知所有等待在该线程对象上的线程。
管道IO流用于线程间数据传输，媒介为内存。PipedOutputStream和PipedWriter是输出流，相当于生产者，PipedInputStream和PipedReader是输入流，相当于消费者。
    管道流使用一个默认大小为1KB的循环缓冲数组。输入流从缓冲数组读数据，输出流往缓冲数组中写数据。当数组已满时，输出流所在线程阻塞；当数组首次为空时，输入流所在线程阻塞。
ThreadLocal是线程共享变量，但它可以为每个线程创建单独的副本，副本值是线程私有的，互相之间不影响。
```
## 多线程手写【10+】
### 多线程之间按顺序调用，实现A->B->C三个线程启动，要求如下：
[多线程交替打印ABC的多种实现方法](https://blog.csdn.net/xiaokang123456kao/article/details/77331878)
```java
//题目:多线程之间按顺序调用，实现A->B->C三个线程启动，要求如下：
//打印5次，BB打印10次，CC打印15次
//紧接着 打印5次，BB打印10次，CC打印15次 来十次
class ShareResource{
    private int number = 1;//A:1,B:2,C:3
    private Lock lock = new ReentrantLock();
    private Condition c1 = lock.newCondition();
    private Condition c2 = lock.newCondition();
    private Condition c3 = lock.newCondition();   
    public void print5(){
        lock.lock();
        try{
            //1判断
            while(number!=1){
               c1.await();
            }
            //2.干活
            for(int i = 1;i<=5;i++){
                System.out.println(Thread.currentThread().getName()+i);
            }
            //3.通知
            number = 2;
            c2.signal();
        }catch (Exception e){
            e.printStackTrace();
        }finally{
            lock.unlock();
        }
    }
    
    public void print10(){
            lock.lock();
            try{
                //1判断
                while(number!=2){
                   c2.await();
                }
                //2.干活
                for(int i = 1;i<=5;i++){
                    System.out.println(Thread.currentThread().getName()+i);
                }
                //3.通知
                number = 2;
                c3.signal();
            }catch (Exception e){
                e.printStackTrace();
            }finally{
                lock.unlock();
            }
        }
    
    public void print15(){
            lock.lock();
            try{
                //1判断
                while(number!=3){
                   c3.await();
                }
                //2.干活
                for(int i = 1;i<=5;i++){
                    System.out.println(Thread.currentThread().getName()+i);
                }
                //3.通知
                number = 1;
                c1.signal();
            }catch (Exception e){
                e.printStackTrace();
            }finally{
                lock.unlock();
            }
        }
    
}
public class Demo{
    public static void main(String[] args){
      ShareResource shareResource = new ShareResource();
      new Thread(()->{
          for(int i = 1;i<=10;i++){
              shareResource.print5();
          }
      },"A").start();
      new Thread(()->{
                for(int i = 1;i<=10;i++){
                    shareResource.print10();
                }
            },"B").start();
      new Thread(()->{
                for(int i = 1;i<=10;i++){
                    shareResource.print15();
                }
            },"C").start();
    }
}
```
### 三个线程打印1-100
### 两个线程打印1-52，A-Z,依次输出12A34B....5152Z
### 手写多线程：在主线程中新建一个子线程，子线程输出hello，主线程输出world，要求有先后顺序
### 两个线程交替打印数字，从1到20，线程一打印1,3,5,7... 线程二打印2,4,6,8... 输出结果是1 2 3 4 5 6 ... 20。(当时选择用 ReentrantLock 搭配 Condition 进行实现)
### 双线程打印1~10，一个线程打印奇数，一个线程打印偶数。用 ReentrantLock 搭配 Condition 进行实现)