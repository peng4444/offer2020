# 工具框架面试题
## 一，Spring面试题
[Spring面试题（2020最新版）](https://thinkwon.blog.csdn.net/article/details/104397516)
### 0.对Spring的理解，项目中都用什么？怎么用的？对IOC、和AOP的理解及实现原理。
```markdown
Spring是一个开源框架，处于MVC模式中的控制层，它能应对需求快速的变化，其主要原因它有一种面向切面编程（AOP）的优势，其次它提升了系统性能，
通过依赖倒置机制（IOC），系统中用到的对象不是在系统加载时就全部实例化，而是在调用到这个类时才会实例化该类的对象，从而提升了系统性能。
这两个优秀的性能使得Spring受到许多J2EE公司的青睐，如阿里中使用最多的也是Spring相关技术。
Spring的优点：(为什么要用Spring)
    1、降低了组件之间的耦合性，实现了软件各层之间的解耦。
    2、可以使用容易提供的众多服务，如事务管理，消息服务，日志记录等。
    3、容器提供了AOP技术，利用它很容易实现如权限拦截、运行期监控等功能。
    4、更方便的框架集成，Spring可以很方便的集成其他框架比如MyBatis,Hibernate。
Spring中AOP技术是设计模式中的动态代理模式。只需实现jdk提供的动态代理接口InvocationHandler，所有被代理对象的方法都由InvocationHandler接管实际的处理任务。
    面向切面编程中还要理解切入点、切面、通知、织入等概念。
Spring中IOC则利用了Java强大的反射机制来实现。所谓依赖注入即组件之间的依赖关系由容器在运行期决定。
    其中依赖注入的方法有两种，通过构造函数注入，通过set方法进行注入。
```
### 1.什么是spring?
```markdown
Spring是一个轻量级Java开发框架，最早有Rod Johnson创建，目的是为了解决企业级应用开发的业务逻辑层和其他各层的耦合问题。
它是一个分层的JavaSE/JavaEE full-stack（一站式）轻量级开源框架，为开发Java应用程序提供全面的基础架构支持。
Spring负责基础架构，因此Java开发者可以专注于应用程序的开发。
Spring最根本的使命是解决企业级应用开发的复杂性，即简化Java开发。
Spring可以做很多事情，它为企业级开发提供给了丰富的功能，但是这些功能的底层都依赖于它的两个核心特性，也就是依赖注入（DI）和面向切面编程（AOP）。
为了降低Java开发的复杂性，Spring采取了以下4种关键策略
    - 基于POJO的轻量级和最小侵入性编程；
    - 通过依赖注入和面向接口实现松耦合；
    - 基于切面和惯例进行声明式编程；
    - 通过切面和模板减少样板式代码。
```
### 2.Spring框架的设计目标，设计理念，核心，主要模块
```markdown
Spring设计目标：Spring为开发者提供一个一站式轻量级应用开发平台；
Spring设计理念：在JavaEE开发中，支持POJO和JavaBean开发方式，使应用面向接口开发，充分支持OO（面向对象）设计方法；
Spring通过IoC容器实现对象耦合关系的管理，并实现依赖反转，将对象之间的依赖关系交给IoC容器，实现解耦；
Spring框架的核心：IoC容器和AOP模块。通过IoC容器管理POJO对象以及他们之间的耦合关系；通过AOP以动态非侵入的方式增强服务。
IoC让相互协作的组件保持松散的耦合，而AOP编程允许你把遍布于应用各层的功能分离出来形成可重用的功能组件。
Spring的七大模块：
    Spring Core：框架的最基础部分，提供IoC容器，对bean进行管理。
    Spring Context：继承BeanFactory，提供上下文信息，扩展出JNDI、EJB、电子邮件、国际化等功能。
    Spring DAO：提供了JDBC的抽象层，还提供了声明性事务管理方法。
    Spring ORM：提供了JPA、JDO、Hibernate、MyBatis 等ORM映射层。
    Spring AOP：集成了所有AOP功能
    Spring Web：提供了基础的Web开发的上下文信息，现有的Web框架，如JSF、Tapestry、Structs等，提供了集成
    Spring Web MVC：提供了Web应用的Model-View-Controller全功能实现。
```
### 3.Spring的优缺点是什么？
```markdown
优点
    方便解耦，简化开发。Spring就是一个大工厂，可以将所有对象的创建和依赖关系的维护，交给Spring管理。
    AOP编程的支持。Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能。
    声明式事务的支持。只需要通过配置就可以完成对事务的管理，而无需手动编程。
    方便程序的测试。Spring对Junit4支持，可以通过注解方便的测试Spring程序。
    方便集成各种优秀框架。Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架的直接支持（如：Struts、Hibernate、MyBatis等）。
    降低JavaEE API的使用难度。Spring对JavaEE开发中非常难用的一些API（JDBC、JavaMail、远程调用等），都提供了封装，使这些API应用难度大大降低。
缺点
    - Spring明明一个很轻量级的框架，却给人感觉大而全
    - Spring依赖反射，反射影响性能
    - 使用门槛升高，入门Spring需要较长时间
```
### 4.什么是控制反转（IOC），什么是依赖注入（DI）【10+】
>>  说说IoC中的继承和Java继承的区别。
```markdown
IOC（Inverse of Control:控制反转）是一种设计思想：就是将原本在程序中手动创建对象的控制权，交由Spring框架来管理。
    IoC容器是Spring用来实现IoC的载体，IoC容器实际上就是个Map（key，value）,Map中存放的是各种对象。
    BeanFactory接口是Spring Ioc容器的核心接口。
IoC最常见以及最合理的实现方式叫做依赖注入（Dependency Injection，简称 DI）。
    将对象之间的相互依赖关系交给IO容器来管理，并由IoC容器完成对象的注入。
    这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 
    IoC容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。
    【对于Spring框架来说就是由Spring来负责控制对象的生命周期和对象间的关系。】
IOC是实现方式优点：
    1. 对象之间的耦合度或者说依赖程度降低；
    2. 资源变的容易管理；比如你用Spring容器提供的话很容易就可以实现一个单例。
DI：我们在使用Spring容器的时候，容器通过调用set方法或者是构造器来建立对象之间的依赖关系。
控制反转是目标，依赖注入是我们实现控制反转的一种手段。
Java中实现依赖注入的三种方式？
    - 1.构造器注入:IoC Service Provider会检查被注入对象的构造方法，取得它所需要的依赖对象列表，进而为其注入相应的对象。
        这种方法的优点是在对象构造完成后就处于就绪状态，可以马上使用。缺点是当依赖对象较多时，构造方法的参数列表会比较长，构造方法无法被继承，无法设置默认值。
        对于非必需的依赖处理可能需要引入多个构造方法，参数数量的变动可能会造成维护的困难。
    - 2.set方法注入:当前对象只需要为其依赖对象对应的属性添加setter方法，就可以通过setter方法将依赖对象注入到被依赖对象中。
        setter方法注入在描述性上要比构造方法注入强，并且可以被继承，允许设置默认值。缺点是无法在对象构造完成后马上进入就绪状态。
    - 3.接口注入: 必须实现某个接口，接口提供方法来为其注入依赖对象。使用少，因为它强制要求被注入对象实现不必要接口，侵入性强。
依赖注入的相关注解？
    @Autowired：自动按类型注入，如果有多个匹配则按照指定Bean的id查找，查找不到会报错。
    @Qualifier：在自动按照类型注入的基础上再按照Bean的id注入，给变量注入时必须搭配@Autowired，给方法注入时可单独使用。
    @Resource ：直接按照Bean的id注入，只能注入Bean类型。
    @Value ：用于注入基本数据类型和String类型。
依赖注入的过程？
    getBean方法获取Bean实例，该方法会调用doGetBean ，doGetBean真正实现从IoC容器获取Bean的功能，也是触发依赖注入的地方。
    具体创建Bean对象的过程由ObjectFactory的createBean完成，该方法主要通过createBeanInstance方法生成Bean包含的Java对象实例和populateBean方法对Bean属性的依赖注入进行处理。
```
### 5.SpringIoC容器初始化方式 ？
```markdown
1.基于XML文件的配置:这种配置文件的格式常用<beans>开头，然后运用一系列的bean定义和专门的应用配置选项组成。
    Spring XML配置方式是使用被Spring命名空间所支持的一些列XML的标签来实现的。
2.基于注解的配置:可以使用注解的方式来代替XML方式的bean元素的配置。这就是组件扫描，常用依赖注入的一些注解有：
@Controller @Service @Autowired @RequestMapping @RequestParam @ModelAttribute @Cacheable @CacheFlush @Resource 
@PostConstruct @PreDestroy @Repository @Scope @SessionAttributes @InitBinder @Required @Qualifier
3.组件扫描：容器会扫描base-package指定的包及其子包下面的所有类，如果该类有一些特定的注解，则纳入容器进行管理。
4.在类前面添加的一些特定的注解：@Component 通用注解 @Repository 持久层注解 @Service 业务层注解、 @Controller 控制层注解
5.基于Java的配置
```
### 6.Spring什么是三级缓存【5+】
[根据 Spring 源码写一个带有三级缓存的 IOC](https://zhuanlan.zhihu.com/p/144627581)
```markdown
1.第一级缓存：单例缓存池singletonObjects。
2.第二级缓存：早期提前暴露的对象缓存earlySingletonObjects。（属性还没有值对象也没有被初始化）
3.第三级缓存：singletonFactories单例对象工厂缓存。
```
### 7.spring如何解决循环依赖？【5+】
```markdown
什么是spring的循环依赖？
Spring使用了三级缓存解决了循环依赖的问题。
    在populateBean()给属性赋值阶段里面Spring会解析你的属性，并且赋值，当发现，A对象里面依赖了B，此时又会走getBean方法，但这个时候，你去缓存中是可以拿的到的。
    因为我们在对createBeanInstance对象创建完成以后已经放入了缓存当中，所以创建B的时候发现依赖A，直接就从缓存中去拿，此时B创建完，A也创建完，一共执行了4次。
    至此Bean的创建完成，最后将创建好的Bean放入单例缓存池中。
```
### 8.spring AOP的原理及动态代理【10+】
[静态代理和动态代理（jdk/cglib）详解](https://www.cnblogs.com/tc971121/p/13474638.html)
[Java中的静态代理和动态代理](https://www.cnblogs.com/csh24/p/13590338.html)
[关于Spring AOP，除了动态代理、CGLIB，你还知道什么？](https://mp.weixin.qq.com/s?__biz=MzU4Mjk0MjkxNA==&mid=2247487469&idx=2&sn=ef923c0ec9ad7125c8ab257a6a786e8a&chksm=fdb1e640cac66f5653ffa10a2446da2116252ee7d70ebfd68292947861db2e4274a66c01dfae&mpshare=1&scene=23&srcid=0921FWihx39xo4JGecNxDlfy&sharer_sharetime=1600649063249&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
```markdown
AOP(Aspect-Oriented Programming:⾯向切⾯编程)：能够将那些与业务⽆关，却为业务模块所共同调⽤的逻辑或责任（例如事务处理、⽇志管理、权限控制等）封装起来，
    便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。
​Spring AOP就是基于动态代理的，如果要代理的对象，实现了某个接⼝，那么Spring AOP会使⽤JDKProxy，去创建代理对象，⽽对于没有实现接⼝的对象，
    就⽆法使⽤JDK Proxy去进⾏代理了，这时候Spring AOP会使⽤Cglib，这时候Spring AOP会使⽤Cglib⽣成⼀个被代理对象的⼦类来作为代理，
AOP主要用来解决：在不改变原有业务逻辑的情况下，增强横切逻辑代码，根本上解耦合，避免横切逻辑代码重复
    切 ：指的是横切逻辑，原有业务逻辑代码不动，只能操作横切逻辑代码，所以面向横切逻辑
    面 ：横切逻辑代码往往要影响的是很多个方法，每个方法如同一个点，多个点构成一个面。这里有一个面的概念。
    Aspect：切面，一个关注点的模块化，这个关注点可能会横切多个对象。
    Joinpoint：连接点，程序执行过程中的某一行为，即业务层中的所有方法。。
    Advice：通知，指切面对于某个连接点所产生的动作，包括前置通知、后置通知、返回后通知、异常通知和环绕通知。
    Pointcut：切入点，指被拦截的连接点，切入点一定是连接点，但连接点不一定是切入点。
    Proxy：代理，Spring AOP 中有 JDK 动态代理和 CGLib 代理，目标对象实现了接口时采用 JDK 动态代理，反之采用 CGLib 代理。
    Target：代理的目标对象，指一个或多个切面所通知的对象。
    Weaving ：织入，指把增强应用到目标对象来创建代理对象的过程。
AOP相关注解：
    @JoinPoint进行织入操作的程序执行点。
    @pointcut切点注解 可以设置拦截方式
    @Advice 单一横切关注点逻辑的载体，织入到Joinpoint的横切逻辑。
    @Aspect 对横切关注点逻辑进行模块化封装的AOP概念实体，包含多个Pointcut和相关Advice的定义。
    @Before：前置通知，指在某个连接点之前执行的通知。
    @After：后置通知，指某个连接点退出时执行的通知（不论正常返回还是异常退出）。
    @AfterReturning：返回后通知，指某连接点正常完成之后执行的通知，返回值使用returning属性接收。
    @AfterThrowing：异常通知，指方法抛出异常导致退出时执行的通知，和@AfterReturning只会有一个执行，异常使用throwing属性接收。
1.JDK动态代理：利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。
2.CGlib动态代理：利用ASM（开源的Java字节码编辑库，操作字节码）开源包，将代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。
3.区别：JDK代理只能对实现接口的类生成代理；CGlib是针对类实现代理，对指定的类生成一个子类，并覆盖其中的方法，这种通过继承类的实现方式，不能代理final修饰的类。
AOP 的过程？
    Spring AOP由BeanPostProcessor后置处理器开始，这个后置处理器是一个监听器，可以监听容器触发的Bean生命周期事件，向容器注册后置处理器以后，容器中管理的Bean就具备了接收 IoC 容器回调事件的能力。
        BeanPostProcessor的调用发生在Spring IoC容器完成Bean实例对象的创建和属性的依赖注入后，为Bean对象添加后置处理器的入口是initializeBean方法。
    Spring中JDK动态代理通过JdkDynamicAopProxy调用Proxy的newInstance方法来生成代理类，JdkDynamicAopProxy也实现了InvocationHandler接口，invoke方法的具体逻辑是先获取应用到此方法上的拦截器链，
        如果有拦截器则创建MethodInvocation并调用其proceed方法，否则直接反射调用目标方法。因此Spring AOP对目标对象的增强是通过拦截器实现的。
```
### 9.Spring中Bean的生命周期和bean自动装配【5+】
```markdown
1.实例化 Instantiation
2.属性赋值 Populate
3.初始化 Initialization
4.销毁 Destruction
单例对象： singleton
    出生：当容器创建时对象出生
    活着：只要容器还在，对象一直或者
    死亡：容器销毁，对象消亡
    总结：单例对象的生命周期和容器相同
多例对象： prototype
    出生: 使用对象时spring框架为我们创建
    活着：对象只要是在使用过程中就一直活着
    死亡：当对象长时间不用且没有其它对象引用时，由java的垃圾回收机制回收
Spring自动装配bean的方式：
    no:默认值，表示没有自动装配，应使用显式bean引用进行装配。
    byName:根据bean的名称注入对象依赖项
    byType:根据类型注入对象依赖项
    构造函数：通过构造函数来注入依赖项，需要设置大量的参数
    autodetect:容器首先通过构造函数使用autowire装配，如果不能，则通过byType自动装配。
```
### 10.Bean作用域？默认什么级别？是否线程安全？Spring如何保障线程安全的?
```markdown
Bean作用域
    singleton	单例对象，默认值的作用域。SpringIOC容器中只存在一个bean实例，bean以单例模式存在。
    prototype	每次获取都会创建⼀个新的bean实例，即每次getBean()相当于执行new Bean()操作。频繁创建和销毁bean会带来很大的性能开销。
    request	    每⼀次HTTP请求都会产⽣⼀个新的bean，该bean仅在当前HTTP request内有效。
    session	    在一次HTTP session中共享一个bean实例。
    global-session	将对象存入到web项目集群的session域中,若不存在集群,则global session相当于session
默认作用域是singleton，多个线程访问同一个bean时会存在线程不安全问题
Spring中的Bean默认的单例模式，Spring框架并没有对单例bean进行多线程的封装处理，大部分的bean是无状态的，也就是说是线程安全的。
如果bean是有状态的(比如说view model对象)，那么开发者就要去保证线程安全，最简单的就是改变bean的作用域，
把“singleton”改变为“prototype”,这样请求bean相当于new Bean()了，所以就可以保证线程安全了。
    - 有状态就是有数据存储功能，无状态就是不会保存数据。
保障线程安全方法：
    1.在Bean对象中尽量避免定义可变的成员变量（不太现实）。
    2.在类中定义⼀个ThreadLocal成员变量，将需要的可变成员变量保存在ThreadLocal 中
        ThreadLocal：每个线程中都有一个自己的ThreadLocalMap类对象，可以将线程自己的对象保持到其中，各管各的，线程可以正确的访问到自己的对象。
​        将一个共用的ThreadLocal静态实例作为key，将不同对象的引用保存到不同线程的ThreadLocalMap中，
        然后在线程执行的各处通过这个静态ThreadLocal实例的get()方法取得自己线程保存的那个对象，避免了将这个对象作为参数传递的麻烦。
```
### 11.Spring事务隔离级别和事务传播属性【5+】
[【源码讲解】Spring事务是如何应用到你的业务场景中的？](https://www.cnblogs.com/winkin/p/13667568.html)
```markdown
Spring事务和MySQL事务的区别，Spring事务传播机制介绍，Spring事务失效和解决方案。
Spring事物的实现方式：
    声明式事物：声明式事物也有两种方式：1.基于xml配置文件的方式和注解方式（@Transaction）
    编码方式：提供编码的形式管理和维护事物
隔离级别：
    1) DEFAULT （默认）
    这是一个Platfrom TransactionManager默认的隔离级别，**使用数据库默认的事务隔离级别**。另外四个与JDBC的隔离级别相对应。
    2) READ_UNCOMMITTED （读未提交）
    这是事务最低的隔离级别，它允许另外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻像读。
    3) READ_COMMITTED （读已提交）
    保证一个事务修改的数据提交后才能被另外一个事务读取，另外一个事务不能读取该事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻像读。
    4) REPEATABLE_READ （可重复读）MySQL默认
    这种事务隔离级别可以防止脏读、不可重复读，但是可能出现幻像读。它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了不可重复读。
    5) SERIALIZABLE（串行化）
    这是花费最高代价但是最可靠的事务隔离级别，事务被处理为顺序执行。除了防止脏读、不可重复读外，还避免了幻像读。
Spring事务传播属性（Propagation）：
    1) REQUIRED（默认属性）
    如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。 被设置成这个级别时，会为每一个被调用的方法创建一个逻辑事务域。
    如果前面的方法已经创建了事务，那么后面的方法支持当前的事务，如果当前没有事务会重新建立事务。
    2) MANDATORY
    支持当前事务，如果当前没有事务，就抛出异常。
    3) NEVER
    以非事务方式执行，如果当前存在事务，则抛出异常。
    4) NOT_SUPPORTED
    以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
    5) REQUIRES_NEW
    新建事务，如果当前存在事务，把当前事务挂起。
    6) SUPPORTS
    支持当前事务，如果当前没有事务，就以非事务方式执行。
    7) NESTED
    支持当前事务，新增Savepoint点，与当前事务同步提交或回滚。 嵌套事务一个非常重要的概念就是内层事务依赖于外层事务。
    外层事务失败时，会回滚内层事务所做的动作。而内层事务操作失败并不会引起外层事务的回滚。
```
### 12.Spring以及Spring MVC常见注解
```markdown
Spring部分：
​ 声明bean的注解
​   @Component 通⽤的注解，可标注任意类为 Spring 组件
​   @Service 在业务逻辑层使用（service层）
​   @Repository 在数据访问层使用（dao层）
​   @Controller 在展现层使用，控制器的声明（controller层）
​ 注入bean的注解
​   @Autowired：可以对类成员变量、方法、构造方法进行标注
​   默认按照类型注入，若要按照名称注入，需要搭配@Qualifier注解一起使用
​   @Resource：默认按照名称来装配注入
@autowired和@resource的区别？
    @Autowired：可以对类成员变量、方法、构造方法进行标注。默认按照类型注入，若要按照名称注入，需要搭配@Qualifier注解一起使用
    @Resource：默认按照名称来装配注入
@Autowired的使用简化了我们的开发，其原理是使用AutowiredAnnotationBeanPostProcessor类来实现，该类实现了Spring框架的一些扩展接口，
    通过实现BeanFactoryAware接口使其内部持有了BeanFactory（可轻松的获取需要依赖的的Bean）；通过实现MergedBeanDefinitionPostProcessor扩展接口，
    在BeanFactory里面的每个Bean实例化前获取到每个Bean里面的@Autowired信息并缓存下来；通过实现Spring框架的postProcessPropertyValues扩展接口
    在BeanFactory里面的每个Bean实例后从缓存取出对应的注解信息，获取依赖对象，并通过反射设置到Bean属性里面。
Spring MVC部分：
​   @Controller 声明该类为SpringMVC中的Controller
​   @RequestMapping 用于映射Web请求
​   @ResponseBody 支持将返回值放在response内，而不是一个页面，通常用户返回json数据
​   @RequestBody 允许request的参数在request体中，而不是在直接连接在地址后面。
​   @PathVariable 用于接收路径参数，比如@RequestMapping("/hello/{name}")申明的路径，将注解放在参数中前，即可获取该值，通常作为Restful的接口实现方法。
```
### 13.BeanFactory和ApplicationContext的区别
```markdown
1.BeanFactory是Spring里面最低层的接口，提供了最简单的容器的功能，只提供了实例化对象和拿对象的功能。
2.ApplicationContext应用上下文，继承BeanFactory接口，它是Spring的一各更高级的容器，提供了更多的有用的功能。
    如国际化，访问资源，载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，消息发送、响应机制，AOP等。
3.BeanFactory在启动的时候不会去实例化Bean，中有从容器中拿Bean的时候才会去实例化。
    ApplicationContext在启动的时候就把所有的Bean全部实例化了。它还可以为Bean配置lazy-init=true来让Bean延迟实例化
```
### 14.BeanFactory和FactoryBean的区别
[一文读懂BeanFactory和FactoryBean区别](https://www.cnblogs.com/lonecloud/p/13550688.html)
```markdown
BeanFactory:是所有Spring Bean的容器根接口，给Spring的容器定义一套规范，给IOC容器提供了一套完整的规范，比如我们常用到的getBean方法等。
   1.定义方法 
        getBean(String name): Spring容器中获取对应Bean对象的方法，如存在，则返回该对象
        containsBean(String name)：Spring容器中是否存在该对象
        isSingleton(String name)：通过beanName是否为单例对象
        isPrototype(String name)：判断bean对象是否为多例对象
        isTypeMatch(String name, ResolvableType typeToMatch):判断name值获取出来的bean与typeToMath是否匹配
        getType(String name)：获取Bean的Class类型
        getAliases(String name):获取name所对应的所有的别名
   2.主要的实现类(包括抽象类)
        AbstractBeanFactory：抽象Bean工厂，绝大部分的实现类，都是继承于他
        DefaultListableBeanFactory:Spring默认的工厂类
        XmlBeanFactory：前期使用XML配置用的比较多的时候用的Bean工厂
        AbstractXmlApplicationContext:抽象应用容器上下文对象
        ClassPathXmlApplicationContext:XML解析上下文对象，用户创建Bean对象我们早期写Spring的时候用的就是他
   3.使用方式
        使用ClassPathXmlApplicationContext读取对应的xml文件实例对应上下文对象
        ApplicationContext context = new ClassPathXmlApplicationContext(new String[] {"applicationContext.xml"});
        BeanFactory factory = (BeanFactory) context;
FactoryBean:是SpringIOC容器是创建Bean的一种形式，这种方式创建Bean会有加成方式，融合了简单的工厂设计模式于装饰器模式
    FactoryBean接口，可以让用户通过实现该接口来自定义该Bean接口的实例化过程。即包装一层，将复杂的初始化过程包装，让调用者无需关系具体实现细节。
    1.方法
        T getObject()：返回实例
        Class<?> getObjectType();:返回该装饰对象的Bean的类型
        default boolean isSingleton():Bean是否为单例
    2.常用类
        ProxyFactoryBean :Aop代理Bean
        GsonFactoryBean:Gson
    3.使用
        1.Spring XML方式
两者区别：
    1.BeanFactory:负责生产和管理Bean的一个工厂接口，提供一个Spring Ioc容器规范,
    2.FactoryBean: 一种Bean创建的一种方式，对Bean的一种扩展。对于复杂的Bean对象初始化创建使用其可封装对象的创建细节。
```
### 15.Spring中用到了哪些设计模式【5+】
[面试官:“谈谈Spring中都用到了那些设计模式?”](https://github.com/Snailclimb/JavaGuide/blob/master/docs/system-design/framework/spring/Spring-Design-Patterns.md#)
```markdown
单例设计模式 : Spring 中的 Bean 默认都是单例的。提供了全局的访问点BeanFactory；
⼯⼚设计模式 : Spring使⽤⼯⼚模式通过 BeanFactory 、 ApplicationContext 创建bean 对象。
代理设计模式 : Spring AOP 功能的实现。（1、JDK动态代理。2、CGLib字节码生成技术代理。）
观察者模式： Spring 事件驱动模型就是观察者模式很经典的⼀个应⽤。spring中Observer模式常用的地方是listener的实现。如ApplicationListener。
适配器模式：Spring AOP 的增强或通知(Advice)使⽤到了适配器模式、spring MVC 中也是⽤到了适配器模式适配 Controller 。
策略模式：Bean的实例化的时候决定采用何种方式初始化bean实例（反射或者CGLIB动态字节码生成
```
### 16.Spring全局异常捕获如何编写
### 17.@Transactional及其错误使用失效场景【2+】
[一个@Transaction哪里来这么多坑？](https://mp.weixin.qq.com/s?__biz=MzU5ODg2Njk4OA==&mid=2247484779&idx=1&sn=2854d0210a65f8beb7c96ef133027632&chksm=febce828c9cb613e50dafd57ee67e5abf5aa3492f9ace748583ce02203bb86f526f69b5a9289&mpshare=1&scene=23&srcid=0829tnZEWo22Np1e0KqU4Dgw&sharer_sharetime=1598715775957&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
```markdown
1.@Transactional在private上：当标记在protected、private、package-visible方法上时，不会产生错误，
    但也不会表现出为它指定的事务配置。可以认为它作为一个普通的方法参与到一个public方法的事务中。
2.@Transactional的事务传播方式配置错误。
3.@Transactional 注解属性rollbackFor设置错误：Spring默认抛出了未检查unchecked异常（继承自 RuntimeException 的异常）或者 Error才回滚事务；其他异常不会触发回滚事务。
4.同一个类中方法调用，导致@Transactional失效：由于使用Spring AOP代理造成的，因为只有当事务方法被当前类以外的代码调用时，才会由Spring生成的代理对象来管理。
    出现了自调用：及未配置事物的方法调用了配置事物的方法，导致配置事物的方法失效。
    解决方案：
        1.自己注入自己，然后显示的调用，
        2.利用AopContext
5.异常被 catch 捕获导致@Transactional失效。
6.数据库引擎不支持事务。
7.
```
### 18.Spring的后置处理器
```markdown
1.BeanPostProcessor：Bean的后置处理器，主要在bean初始化前后工作。（before和after两个回调中间只处理了init-method）
2.InstantiationAwareBeanPostProcessor：继承于BeanPostProcessor，主要在实例化bean前后工作（TargetSource的AOP创建代理对象就是通过该接口实现）
3.BeanFactoryPostProcessor：Bean工厂的后置处理器，在bean定义(bean definitions)加载完成后，bean尚未初始化前执行。
4.BeanDefinitionRegistryPostProcessor：继承于BeanFactoryPostProcessor。
    其自定义的方法postProcessBeanDefinitionRegistry会在bean定义(bean definitions)将要加载，bean尚未初始化前真执行，
    即在BeanFactoryPostProcessor的postProcessBeanFactory方法前被调用。
```
### 19.spring中拦截器与过滤器的区别【10+】
[过滤器和拦截器有啥区别，这次会了！](https://www.cnblogs.com/summerday152/p/13658788.html)
```markdown
filter定义在web.xml中，拦截器定义在Spring.xml中；
filter必须实现javax.servlet.Filter接口，拦截器需要实现HandleInterceptor接口或者继承抽象类HandlerInterceptorAdapter；
filter只能在servlet前后起作用，拦截器能够深入到方法的前后，异常抛出前后等，更加的细致；
filter是servlet规范规定的，拦截器是Spring容器内的，是Spring框架支持的；
一、实现原理不同
    过滤器的实现基于回调函数，拦截器基于Java的反射机制【动态代理】实现。
二、使用范围不同
    过滤器是Servlet的规范，需要实现javax.servlet.Filter接口，Filter使用需要依赖于Tomcat等容器。
    拦截器是Spring组件，定义在org.springframework.web.servlet包下，由Spring容器管理【又有更加丰富的生缪那个周期处理方法，细粒度，且能够使用Spring中的资源】，不依赖Tomcat等容器。
三、触发时机不同
    过滤器：对请求在进入后Servlet之前或之后进行处理。
    拦截器：对请求在handler【Controller】前后进行处理。
四、执行顺序不同
五、控制执行顺序方式不同
控制粒度上：过滤器和拦截器都能够实现对请求的拦截功能，但是在拦截的粒度上有较大的差异，拦截器对访问控制的粒度更细。
使用场景上：拦截器往往用于权限检查、日志记录等，过滤器主要用于过滤请求中无效参数，安全校验。
依赖容器上：过滤器依赖于Servlet容器，局限于web，而拦截器依赖于Spring框架，能够使用Spring框架的资源，不仅限于web。
触发时机上：过滤器在Servlet前后执行，拦截器在handler前后执行，现在大多数web应用基于Spring，拦截器更细。    
```
### 20.@autowired 与@resource的区别【5+】
```markdown
1.二者所属包不同
    @Resource：javax.annotation.Resource j2ee
    @Autowired：org.springframework.beans.factory.annotation.Autowired Spring
2.@Autowired默认按类型装配,@Resource默认安照名称进行装配。
    @Autowired默认情况下必须要求依赖对象必须存在，如果要允许null 值，可以设置它的required属性为false。想使用名称装配，可以结合@Qualifier注解进行使用。
    @Resource的名称可以通过name属性进行指定，如果没有指定name属性，当注解写在字段上时，默认取字段名进行按照名称查找。
        如果注解写在setter方法上默认取属性名进行装配。 当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。
3.相同：@Autowired与@Resource都可以用来装配bean. 都可以写在字段上,或写在setter方法上。
实践总结：
    1.用@Resource注解在字段上，可不用写setter方法了，因为J2EE的内部注解解析器已经会自动完成setter的功能。而目前@Autowired不行。
    2.可减少与spring的耦合。
```
### 21.SpringBatch
[通过例子讲解Spring Batch入门，优秀的批处理框架](https://www.pkslow.com/archives/spring-batch-introduction)
[大量数据也不在话下，Spring Batch并行处理四种模式初探](https://www.cnblogs.com/larrydpk/p/13664256.html)
```markdown
SpringBatch是一个轻量级的、完善的批处理框架，作为Spring体系中的一员，它拥有灵活、方便、生产可用的特点。
在应对高效处理大量信息、定时处理大量数据等场景十分简便。
Spring Batch的分层架构图如下：
    Application应用层：包含了所有任务batch jobs和开发人员自定义的代码，主要是根据项目需要开发的业务流程等。
    Batch Core核心层：包含启动和管理任务的运行环境类，如JobLauncher等。
    Batch Infrastructure基础层：上面两层是建立在基础层之上的，包含基础的读入reader和写出writer、重试框架等。
```
## 二，SpringMVC面试题
[Spring MVC面试题（2020最新版）](https://blog.csdn.net/ThinkWon/article/details/104397427)
[springmvc的面试知识点总结](https://www.cnblogs.com/yunjiandubu/p/10269713.html)
#### 1.简单谈谈你对MVC的理解。
```markdown
mvc是一种设计模式（设计模式就是日常开发中编写代码的一种好的方法和经验的总结）。
模型（model）-视图（view）-控制器（controller），三层架构的设计模式。
用于实现前端页面的展现与后端业务数据处理的分离。
mvc设计模式的好处
    1.分层设计，实现了业务系统各个组件之间的解耦，有利于业务系统的可扩展性，可维护性。
    2.有利于系统的并行开发，提升开发效率。
```
#### 2.什么是 SpringMVC？SpringMVC的优点?
```markdown
SpringMVC是一个基于Java的实现了MVC设计模式的请求驱动类型的轻量级Web框架，通过把模型-视图-控制器分离，
将web层进行职责解耦，把复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合。
Spring MVC的优点
（1）可以支持各种视图技术,而不仅仅局限于JSP；
（2）与Spring框架集成（如IoC容器、AOP等）；
（3）清晰的角色分配：前端控制器(dispatcherServlet),请求到处理器映射（handlerMapping),处理器适配器（HandlerAdapter),视图解析器（ViewResolver）。
（4）支持各种请求资源的映射策略。
```
#### 3.SpringMVC的核心组件有哪些？【5+】
```markdown
（1）前端控制器 DispatcherServlet（不需要程序员开发）
    作用：接收请求、响应结果，相当于转发器，有了DispatcherServlet 就减少了其它组件之间的耦合度。
（2）处理器映射器HandlerMapping（不需要程序员开发）
    作用：根据请求的URL来查找Handler
（3）处理器适配器HandlerAdapter
    注意：在编写Handler的时候要按照HandlerAdapter要求的规则去编写，这样适配器HandlerAdapter才可以正确的去执行Handler。
（4）处理器Handler（需要程序员开发）
（5）视图解析器 ViewResolver（不需要程序员开发）
    作用：进行视图的解析，根据视图逻辑名解析成真正的视图（view）
（6）视图View（需要程序员开发jsp）
    View是一个接口，它的实现类支持不同的视图类型（jsp，freemarker，pdf等等）
```
#### 4.springmvc的工作流程?SpringMVC执行原理【5+】
![](https://img-blog.csdnimg.cn/20200208211439106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70)
[浅谈SpringMVC执行过程](https://www.cnblogs.com/wangjiming/p/10487832.html)
```markdown
（1）用户发送请求至前端控制器DispatcherServlet；
（2）DispatcherServlet收到请求后，调用HandlerMapping处理器映射器，找到处理请求的Controller；
（3）处理器映射器根据请求url找到具体的Controller，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet；
（4）DispatcherServlet调用HandlerAdapter处理器适配器；
（5）HandlerAdapter 经过适配调用 具体处理器(Handler，也叫后端控制器)；
（6）Handler执行完成返回ModelAndView；
（7）HandlerAdapter将Handler执行结果ModelAndView返回给DispatcherServlet；
（8）DispatcherServlet将ModelAndView传给ViewResolver视图解析器进行解析；
（9）ViewResolver解析后返回具体View；
（10）DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）
（11）DispatcherServlet响应用户。
```
#### 5.springmvc dispatcherservlet与handleradapter如何关联？
```markdown
DispatcherServlet拦截到请求之后,根据handlerMapping获取到handlerExecutionChain对象,然后,
在handlerExecutionChain对象不为null的情况下,根据handlerExecutionChain中的handler对象获取HandlerAdapter对象;
```
#### 6.有了springmvc的IOC容器,还需要spring的IOC容器吗?为什么?如何处理兼容问题?
```markdown
这个问题再进一步,换个方式提问即是否还需要在web.xml方法里面配置启动springIOC容器的ContextLoaderListener?
可以从正反两方面来回答,首先是需要,通常情况下,类似于数据源,事务,整合其他框架等都是放在spring的配置文件中,而不是springmvc的配置文件中, 
一般情况下,开发过程中的Service,Dao也都是放在spring的IOC容器当中;其次可以是不需要的,也可以都放在springmvc的配置文件当中,
当然需要分多个spring的配置文件,然后通过import节点导入到springmvc的配置文件当中.
几点要注意的地方:
1. springIOC容器和springmvc的IOC容器 扫描的部分有重合的地方,就会导致bean被创建2次,解决方案:使用 exclude-filter和include-filter配合
    来区分哪些bean交给springIOC容器,哪些bean交给springmvcIOC容器;
2. springmvc IOC容器里面的bean可以引用springIOC容器的bean,反之则不行,多个springIOC 容器之间可以设置为父子关系,以实现良好的解耦.
举个栗子,springIOC容器好比是全局作用域,springmvcIOC容器好比是局部作用域,局部的可以引用全局的,而全局的却不能引用局部的.
```
#### 8.SpringMVC怎么样设定重定向和转发的？
```markdown
（1）转发：在返回值前面加"forward:"，譬如"forward:user.do?name=method4"
（2）重定向：在返回值前面加"redirect:"，譬如"redirect:http://www.baidu.com"
```
#### 9.如何解决POST请求和GET请求的中文乱码问题？
```markdown
（1）解决post请求乱码问题：
在web.xml中配置一个CharacterEncodingFilter过滤器，设置成utf-8；
（2）get请求中文参数出现乱码解决方法有两个：
①修改tomcat配置文件添加编码与工程编码一致，如下：
<ConnectorURIEncoding="utf-8" connectionTimeout="20000" port="8080" protocol="HTTP/1.1" redirectPort="8443"/>
②另外一种方法对参数进行重新编码：
String userName = new String(request.getParamter(“userName”).getBytes(“ISO8859-1”),“utf-8”)
ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码。
```
#### 10. @ModelAttribute注解应该如何使用？
[@ModelAttribute注解的使用总结](https://blog.csdn.net/leo3070/article/details/81046383)
```markdown
@ModelAttribute最主要的作用是将数据添加到模型对象中，用于视图页面展示时使用。
@ModelAttribute等价于model.addAttribute("attributeName", abc);
但是根据@ModelAttribute注释的位置不同，和其他注解组合使用，致使含义有所不同。
1.@ModelAttribute注释方法 
    （1）@ModelAttribute注释void返回值的方法 
    （2）@ModelAttribute注释返回具体类的方法
    （3）@ModelAttribute(value="")注释返回具体类的方法
    （4）@ModelAttribute和@RequestMapping同时注释一个方法
2.@ModelAttribute注释一个方法的参数 
    （1）从model中获取
    （2）从Form表单或URL参数中获取（实际上，不做此注释也能拿到user对象）
3.@ModelAttribute注释一个方法的返回值
    
```
#### 11. 说说你对自定义数据类型转换器的理解？
[springmvc自定义类型转换器Converter](https://blog.csdn.net/qq_43364241/article/details/90296580)
```markdown

```
#### 12.使用Hibernate Validator注解方式校验Email数据格式应该怎么写？
[Hibernate Validator验证注解说明](https://blog.csdn.net/fighterandknight/article/details/72186260)
#### 13.Spring MVC常用注解？当接收一个对象，对某些字段加校验，非空校验，长度校验？
```markdown
@Controller：在类定义处添加，将类交给IoC容器管理。
@RequestMapping：将URL请求和业务方法映射起来，在类和方法定义上都可以添加该注解。value属性指定URL请求的实际地址，是默认值。
    method属性限制请求的方法类型，包括GET、POST、PUT、DELETE等。如果没有使用指定的请求方法请求URL，会报405 Method Not Allowed 错误。params属性限制必须提供的参数，如果没有会报错。
@RequestParam：如果Controller方法的形参和URL 参数名一致可以不添加注解，如果不一致可以使用该注解绑定。
    value属性表示HTTP请求中的参数名。required属性设置参数是否必要，默认false。defaultValue 属性指定没有给参数赋值时的默认值。
@PathVariable：Spring MVC支持RESTful风格URL，通过@PathVariable完成请求参数与形参的绑定。
```
#### 14.SpringMVC的Controller是如何将参数和前端传来的数据一一对应的。
#### 15.@RequestMapping的作用
```markdown
将HTTP请求映射到相应的类/方法上
```
#### 16.@Autowired的作用
```markdown
@Autowired可以对类成员变量，方法及构造函数进行标注，完成自动装配的工作，通过@Autowired的使用来消除set/get方法。
```

## 三，SpringBoot面试题
[Spring Boot面试题（2020最新版）](https://blog.csdn.net/ThinkWon/article/details/104397299)
[springboot2.0实战](https://blog.csdn.net/hxnlyw/category_9631147.html)
[3W 字的 Spring Boot 超详细总结](https://mp.weixin.qq.com/s?__biz=Mzg2MjEwMjI1Mg==&mid=2247502605&idx=1&sn=2aabdd1b3988f34cd8f7fd2a79eec675&chksm=ce0e7c8ef979f59856c2aa94a8954690bff691fc7332c0e1f973542baf02297f0a77fb85049c&mpshare=1&scene=23&srcid=0929SwyrW9TyXywOla4o4KCU&sharer_sharetime=1601376206141&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
#### 1.springBoot是什么?
```markdown
Spring Boot是Spring开源组织下的子项目，是Spring组件一站式解决方案，
    主要是简化了使用Spring的难度，简省了繁重的配置，提供了各种启动器，开发者能快速上手。
SpringBoot各个组件

```
#### 2.SpringBoot哪些优点【5+】
```markdown
Spring Boot 主要有如下优点：
    1.容易上手，提升开发效率，为Spring开发提供一个更快、更广泛的入门体验。
    2.开箱即用，远离繁琐的配置。
    3.提供了一系列大型项目通用的非业务性功能，例如：内嵌服务器、安全管理、运行数据监控、运行状况检查和外部化配置等。
    4.没有代码生成，也不需要XML配置。
    5.避免大量的Maven导入和各种版本冲突。
```
#### 3.SpringBoot的核心注解?【2+】
```markdown
启动类上面的注解是@SpringBootApplication，它也是SpringBoot的核心注解，主要组合包含了以下3个注解：
    @SpringBootConfiguration：组合了@Configuration注解，实现配置文件的功能。
    @EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，
        如关闭数据源自动配置功能：@SpringBootApplication(exclude={DataSourceAutoConfiguration.class})。
    @ComponentScan：Spring组件扫描。
```
#### 4.什么是JavaConfig？
```markdown
Spring JavaConfig是Spring社区的产品，它提供了配置SpringIoC容器的纯Java方法。因此它有助于避免使用XML配置。使用JavaConfig的优点在于：
（1）面向对象的配置。由于配置被定义为JavaConfig中的类，因此用户可以充分利用Java中的面向对象功能。一个配置类可以继承另一个，重写它的@Bean方法等。
（2）减少或消除XML配置。基于依赖注入原则的外化配置的好处已被证明。但是，许多开发人员不希望在XML和Java之间来回切换。
    JavaConfig为开发人员提供了一种纯Java方法来配置与XML配置概念相似的Spring容器。
    从技术角度来讲，只使用JavaConfig配置类来配置容器是可行的，但实际上很多人认为将JavaConfig与XML混合匹配是理想的。
（3）类型安全和重构友好。JavaConfig提供了一种类型安全的方法来配置Spring容器。
    由于Java 5.0对泛型的支持，现在可以按类型而不是按名称检索bean，不需要任何强制转换或基于字符串的查找。
```
#### 5.SpringBoot核心配置文件,配置文件有几种格式
```markdown
bootstrap(.yml或者.properties):bootstrap由父ApplicationContext加载的比application邮箱加载，且bootstrap里面的属性不能被覆盖。
application(.yml或者.properties):用于SpringBoot项目的自动化配置
```
#### Springboot启动流程讲讲？【5+】
[SpringBoot启动流程总结](https://blog.csdn.net/mnicsm/article/details/93893669)
```markdown
@SpringBootApplication
public class JpaApplication {
    public static void main(String[] args) {
        SpringApplication.run(JpaApplication.class, args);
    }
}
1、new了一个SpringApplication对象，使用SPI技术加载加载 ApplicationContextInitializer、ApplicationListener接口实例
2、调用SpringApplication.run()方法
3、调用createApplicationContext()方法创建上下文对象，创建上下文对象同时会注册spring的核心组件类（ConfigurationClassPostProcessor 、AutowiredAnnotationBeanPostProcessor等）。
4、调用refreshContext()方法启动Spring容器和内置的Servlet容器
加载了@SpringBootApplication注解主配置类，这个@SpringBootApplication注解主配置类里边最主要的功能就是SpringBoot开启了一个@EnableAutoConfiguration注解的自动配置功能。
    @EnableAutoConfiguration作用：
    它主要利用了一个EnableAutoConfigurationImportSelector选择器给Spring容器中来导入一些组件。
        @Import(EnableAutoConfigurationImportSelector.class)
        public @interface EnableAutoConfiguration 
@SpringBootApplication注解等同于下面三个注解：
    @SpringBootConfiguration： 底层是Configuration注解，说白了就是支持JavaConfig的方式来进行配置
    @EnableAutoConfiguration：开启自动配置功能
    @ComponentScan：就是扫描注解，默认是扫描当前类下的package
其中@EnableAutoConfiguration是关键(启用自动配置)，内部实际上就去加载META-INF/spring.factories文件的信息，然后筛选出以EnableAutoConfiguration为key的数据，加载到IOC容器中，实现自动配置功能！
```
#### SpringBoot自动配置的原理是什么？介绍SpringBootApplication注解.
```markdown
启动类：
@SpringBootApplication
public class JpaApplication {
    public static void main(String[] args) {
        SpringApplication.run(JpaApplication.class, args);
    }
}
它主要加载了@SpringBootApplication注解主配置类，这个@SpringBootApplication注解主配置类里边
    最主要的功能就是SpringBoot开启了一个@EnableAutoConfiguration注解的自动配置功能。
@EnableAutoConfiguration作用：
它主要利用了一个EnableAutoConfigurationImportSelector选择器给Spring容器中来导入一些组件。
    @Import(EnableAutoConfigurationImportSelector.class)
    public @interface EnableAutoConfiguration
@SpringBootApplication注解等同于下面三个注解：
    @SpringBootConfiguration： 底层是Configuration注解，说白了就是支持JavaConfig的方式来进行配置
    @EnableAutoConfiguration：开启自动配置功能
    @ComponentScan：就是扫描注解，默认是扫描当前类下的package
    其中@EnableAutoConfiguration是关键(启用自动配置)，内部实际上就去加载META-INF/spring.factories文件的信息，
    然后筛选出以EnableAutoConfiguration为key的数据，加载到IOC容器中，实现自动配置功能！
注解@EnableAutoConfiguration,@Configuration,@ConditionalOnClass就是自动配置的核心，
    @EnableAutoConfiguration给容器导入META-INF/spring.factories里定义的自动配置类。
    筛选有效的自动配置类。
    每一个自动配置类结合对应的xxxProperties.java读取配置文件进行自动配置功能
```
####  spring-boot全局异常处理
[spring-boot-route（四）全局异常处理](https://www.cnblogs.com/zhixie/p/13768583.html)
```markdown
SpringBoot提供的的注解@ControllerAdvice表示开启全局异常捕获，在自定义的异常方法上使用ExceptionHandler来进行统一处理。
```

## 四，Mybatis面试题
[MyBatis面试题（2020最新版）](https://thinkwon.blog.csdn.net/article/details/101292950)
### 1.MyBatis是什么？
```markdown
MyBatis是一款优秀的持久层框架，一个半ORM（对象关系映射）框架，它支持定制化SQL、存储过程以及高级映射。
    MyBatis避免了几乎所有的JDBC代码和手动设置参数以及获取结果集。
    MyBatis可以使用简单的XML或注解来配置和映射原生类型、接口和Java的POJO为数据库中的记录。
ORM是什么？
ORM（Object Relational Mapping），对象关系映射，是一种为了解决关系型数据库数据与简单Java对象（POJO）的映射关系的技术。
    简单的说，ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系型数据库中。
为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？
    Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。
    而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。
```
### 2.传统JDBC开发存在的问题&MyBatis是如何解决这些问题的？
```markdown
频繁创建数据库连接对象、释放，容易造成系统资源浪费，影响系统性能。可以使用连接池解决这个问题。但是使用jdbc需要自己实现连接池。
sql语句定义、参数设置、结果集处理存在硬编码。实际项目中sql语句变化的可能性较大，一旦发生变化，需要修改java代码，系统需要重新编译，重新发布。不好维护。
使用preparedStatement向占有位符号传参数存在硬编码，因为sql语句的where条件不一定，可能多也可能少，修改sql还要修改代码，系统不易维护。
结果集处理存在重复代码，处理麻烦。如果可以映射成Java对象会比较方便。
1、数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库连接池可解决此问题。
解决：在mybatis-config.xml中配置数据链接池，使用连接池管理数据库连接。
2、Sql语句写在代码中造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。
解决：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。
3、向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。
解决：Mybatis自动将java对象映射至sql语句。
4、对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便。
解决：Mybatis自动将sql执行结果映射至java对象。
```
### 3.Mybatis优缺点
```markdown
优点：
    与传统的数据库访问技术相比，ORM有以下优点：
    基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML里，解除sql与程序代码的耦合，
        便于统一管理；提供XML标签，支持编写动态SQL语句，并可重用。
    与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接。
    很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持）
    提供映射标签，支持对象与数据库的ORM字段关系映射；提供对象关系映射标签，支持对象关系组件维护
    能够与Spring很好的集成。
缺点：
    SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求
    SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库
```
### 4.MyBatis的解析和运行原理及使用MyBatis的步骤【10+】
```markdown
MyBatis编程步骤是什么样的？
    1、 创建SqlSessionFactory
    2、 通过SqlSessionFactory创建SqlSession
    3、 通过sqlsession执行数据库操作
    4、 调用session.commit()提交事务
    5、 调用session.close()关闭会话       
请说说MyBatis的工作原理:
    1）读取MyBatis配置文件：mybatis-config.xml为MyBatis的全局配置文件，配置了MyBatis的运行环境等信息，例如数据库连接信息。
    2）加载映射文件。映射文件即SQL映射文件，该文件中配置了操作数据库的SQL语句，需要在MyBatis配置文件mybatis-config.xml中加载。
        mybatis-config.xml 文件可以加载多个映射文件，每个文件对应数据库中的一张表。
    3）构造会话工厂：通过MyBatis的环境等配置信息构建会话工厂SqlSessionFactory。
    4）创建会话对象：由会话工厂创建SqlSession对象，该对象中包含了执行SQL语句的所有方法。
    5）Executor执行器：MyBatis底层定义了一个Executor接口来操作数据库，它将根据SqlSession传递的参数动态地生成需要执行的 SQL语句，同时负责查询缓存的维护。
    6）MappedStatement对象：在Executor接口的执行方法中有一个MappedStatement类型的参数，该参数是对映射信息的封装，用于存储要映射的SQL语句的id、参数等信息。
    7）输入参数映射：输入参数类型可以是Map、List 等集合类型，也可以是基本数据类型和POJO类型。输入参数映射过程类似于JDBC对preparedStatement对象设置参数的过程。
    8）输出结果映射：输出结果类型可以是Map、List 等集合类型，也可以是基本数据类型和POJO类型。输出结果映射过程类似于JDBC对结果集的解析过程。
```
### 8.Mybatis都有哪些Executor执行器【5+】
```markdown
**Mybatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。**
    1.SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。
    2.ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，
        而是放置于Map<String, Statement>内，供下一次使用。简言之，就是重复使用Statement对象。
    3.BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），
        它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。
作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内。
Mybatis中如何指定使用哪一种Executor执行器？
    在Mybatis配置文件中，在设置（settings）可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法
    传递ExecutorType类型参数，如SqlSession openSession(ExecutorType execType)。
配置默认的执行器。SIMPLE就是普通的执行器；REUSE执行器会重用预处理语句（prepared statements）；BATCH执行器将重用语句并执行批量更新。
```
### 9.Mybatis一级缓存和二级缓存【5+】
```markdown
一级缓存：基于PerpetualCache和HashMap本地缓存，它的生命周期是和SQLSession一致的，有多个SQLSession或者分布式的环境中数据库操作，可能会出现脏数据。
    当Session flush或者close之后，该Session中非所有的Cache就将被清空，默认一级缓存是开启。
二级缓存：也是基于PerpetualCache和HashMap本地缓存，不同在于其存储作用域为Mapper级别的，如果多个SQLSession之间需要共享缓存，则需要使用到二级缓存，
    并且二级缓存可以自定义存储源，如Ehcache。默认不开启二级缓存，要开启二级环境，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态)。
开启二级缓存数据查询流程：二级缓存->一级缓存->数据库
缓存更新机制：当某一个作用域（一级缓存Session、二级缓存Mapper）进行C/U/D操作后，默认该作用域下所有select中的缓存将被clear。
如果是一级缓存，那么我在同一个SqlSession里面执行了三行语句，第一行，从表中查询数据，第二行，给这个表添加数据，第三行，执行跟第一行一样的查询语句，
根据一级缓存，那第三行查询的结果不就是第一次缓存的数据吗，可是表已经增加了新的数据，不就出现数据不一致了吗？（insert语句会刷新缓存！）
```
### 10.Mybatis如何防止sql注入？${}和#{}的区别是什么？传入表名用哪个？【5+】
```markdown
防止sql注入：在编写mybatis的映射语句时，尽量采用“#{xxx}”这样的格式
#和$区别：
        #{}	                     ${}
    相当于对数据加上双引号	 相当于直接显示数据
    很大程度上防止SQL注入	 无法防止SQL注入
#{xxx},使用的是PreparedStatement,会有类型转换，比较安全	${xxx}，使用字符串拼接，容易SQL注入
​简单的说就是#{}是经过预编译的，是安全的，${}是未经过预编译的，仅仅是取变量的值，是非安全的，存在SQL注入。
要实现动态传入表名、列名，需要做如下修改：
    添加属性statementType="STATEMENT"，同时sql里的属有变量取值都改成${xxxx}
${}是Properties文件中的变量占位符，它可以用于标签属性值和sql内部，属于静态文本替换，比如${driver}会被静态替换为com.mysql.jdbc.Driver。
#{}是sql的参数占位符，Mybatis会将sql中的#{}替换为?号，在sql执行前会使用PreparedStatement的参数设置方法，按序给sql的?号占位符设置参数值，
比如ps.setInt(0, parameterValue)，#{item.name}的取值方式为使用反射从参数对象中获取item对象的name属性值，相当于param.getItem().getName()。
```
### Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？
```markdown
第一种是使用<resultMap>标签，逐一定义列名和对象属性名之间的映射关系。第二种是使用sql列的别名功能，将列别名书写为对象属性名，
比如T_NAME AS NAME，对象属性名一般是name，小写，但是列名不区分大小写，Mybatis会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成T_NAME AS NaMe，Mybatis一样可以正常工作。
有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。
```
### Mybatis能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别
```markdown
能，Mybatis不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询，多对一查询，其实就是一对一查询，只需要把selectOne()修改为selectList()即可；
多对多查询，其实就是一对多查询，只需要把selectOne()修改为selectList()即可。
关联对象查询，有两种实现方式，一种是单独发送一个sql去查询关联对象，赋给主对象，然后返回主对象。另一种是使用嵌套查询，嵌套查询的含义为使用join查询，
一部分列是A对象的属性值，另外一部分列是关联对象B的属性值，好处是只发一个sql查询，就可以把主对象和其关联对象查出来。
那么问题来了，join查询出来100条记录，如何确定主对象是5个，而不是100个？
其去重复的原理是<resultMap>标签内的<id>子标签，指定了唯一确定一条记录的id列，Mybatis根据<id>列值来完成100条记录的去重复功能，<id>可以有多个，代表了联合主键的语意。
同样主对象的关联对象，也是根据这个原理去重复的，尽管一般情况下，只有主对象会有重复记录，关联对象一般不会重复。
```
### Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？
```markdown
Mybatis动态sql可以让我们在Xml映射文件内，以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能，
Mybatis提供了9种动态sql标签trim|where|set|foreach|if|choose|when|otherwise|bind。
其执行原理为，使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能。
```
### MyBatis与Hibernate的区别是什么？
```markdown
Hibernate 框架：
​ Hibernate是一个开放源代码的对象关系映射框架,它对JDBC进行了非常轻量级的对象封装,建立对象与数据库表的映射。是一个全自动的、完全面向对象的持久层框架。
Mybatis框架：
​ Mybatis是一个开源对象关系映射框架，原名：ibatis,2010年由谷歌接管以后更名。是一个半自动化的持久层框架。
区别：
    开发方面
​       在项目开发过程当中，就速度而言：
​       hibernate开发中，sql语句已经被封装，直接可以使用，加快系统开发；
​       Mybatis 属于半自动化，sql需要手工完成，稍微繁琐；
​       但是，凡事都不是绝对的，如果对于庞大复杂的系统项目来说，复杂语句较多，hibernate 就不是好方案。
    sql优化方面
​       Hibernate 自动生成sql,有些语句较为繁琐，会多消耗一些性能；
​       Mybatis 手动编写sql，可以避免不需要的查询，提高系统性能；
    对象管理比对
​       Hibernate是完整的对象-关系映射的框架，开发工程中，无需过多关注底层实现，只要去管理对象即可；
​       Mybatis需要自行管理映射关系；
```
MyBatis 如何实现模糊查询?
### 12.Mybatis如何找到指定的Mapper的，如何完成查询的。
### 13.MyBatis分页方式和原理【2+】
```markdown
分页方式：逻辑分页，物理分页
    逻辑分页：使用Mybatis自带的RowBounds进行分页，它是一次性查询很多数据，然后在数据中再进行检索。
        弊端：需要消耗大量的内存，有内存溢出的风险，对数据库压力较大。
    物理分页：注解手动SQL分页或者使用分页插件PageHelper,去数据库查询指定条数的分页数据的形式。没有上述弊端。
RowBounds是一次性查询全部结果吗?并不是，Mybatis是对jdbc进行的封装，需要按照jdbc中的配置一次取多少条数据。
Mybatis分页插件的实现原理：
    分页插件的基本原理是使用MyBatis提供的插件接口，实现自定义插件，在插件的拦截方法内等待执行的SQL，然后重写SQL
    根据dialect方言，添加对应的物理分页语句和物理分页参数。
    举例：select * from student，拦截sql后重写为：select t.* from （select * from student）t limit 0，10;
自定义插件实现原理
    Mybatis自定义插件针对MyBatis四大对象（Executor,StatementHandler,ParameterHandler,ResultSetHandler）进行拦截：
        Executor：拦截内部执行器，负责调用StatementHandler操作数据库，并且把结果通过ResultSetHandler进行自动映射，还处理了二级缓存的操作。
        StatementHandler:拦截SQL语法构建的处理，是Mybatis直接和数据库执行SQL脚本的对象，另外也实现了Mybatis的意见缓存。
        ParameterHandler:拦截参数的处理。
        ResultSetHandler:拦截结果集的处理。
```
### 14.MyBatis是否支持延迟加载，延迟加载的原理
```markdown
Mybatis支持延迟加载，设置lazyLoadingEnabled=true即可。
延迟加载的原理是：调用的时候触发加载，而不是在初始化的时候就进行加载。
Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。
在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。
原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，
那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。
这就是延迟加载的基本原理。
当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。
```
### 15.Xml映射文件中，除了常见的select|insert|update|delete标签之外，还有哪些标签？
```markdown
select、insert、update、delete 标签分别对应查询、添加、更新、删除操作。
还有很多其他的标签，<resultMap>、<parameterMap>、<sql>、<include>、<selectKey>，
加上动态sql的9个标签，trim|where|set|foreach|if|choose|when|otherwise|bind等，
其中<sql>为sql片段标签，通过<include>标签引入sql片段，<selectKey>为不支持自增的主键生成策略标签。
parameterType属性表示参数的数据类型，包括基本数据类型和对应的包装类型、String和Java Bean类型，当有多个参数时可以使用#{argn}的形式表示第n个参数。除了基本数据类型都要以全限定类名的形式指定参数类型。
resultType表示返回的结果类型，包括基本数据类型和对应的包装类型、String和Java Bean类型。还可以使用把返回结果封装为复杂类型的resultMap 。
```
### 16.Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？
```markdown
最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，
请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？
Dao接口，就是人们常说的Mapper接口，接口的全限名，就是映射文件中的namespace的值，接口的方法名，就是映射文件中MappedStatement的id值，接口方法内的参数，就是传递给sql的参数。
Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement，举例：com.mybatis3.mappers.StudentDao.findStudentById，
可以唯一找到namespace为com.mybatis3.mappers.StudentDao下面id=findStudentById的MappedStatement。在Mybatis中，每一个<select>、<insert>、<update>、<delete>标签，都会被解析为一个MappedStatement对象。
Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。
Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。
```
### 17.简述Mybatis的插件运行原理，以及如何编写一个插件
```markdown
Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，
Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，
具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。
实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。
```
### 18.Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？
```markdown
不同的Xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复；毕竟namespace不是必须的，只是最佳实践而已。
原因就是namespace+id是作为Map<String, MappedStatement>的key使用的，如果没有namespace，就剩下id，那么，id重复会导致数据互相覆盖。
有了namespace，自然id就可以重复，namespace不同，namespace+id自然也就不同。
```
### 19.Mybatis中如何执行批处理？
```markdown
使用BatchExecutor完成批处理。
```
### 20.Mybatis如何执行Select语句
[Mybatis如何执行Select语句](https://www.cnblogs.com/Chenjiabing/p/13666108.html)
### 21.mybatis在xml文件中处理大于号小于号的方法
[mybatis在xml文件中处理大于号小于号的方法](https://blog.csdn.net/erlian1992/article/details/78218977)
```markdown
1.使用转义字符
&lt;  < 小于号
&gt;  > 大于号
&amp;  &  和
&apos; '  单引号
&quot; "   双引号
2.使用<![CDATA[   ]]>区，将sql语句包括起来，在两者之间嵌入不想被解析程序解析的原始数据，解析器不对
  CDATA区中的内容进行解析，而是将这些数据原封不动地交给下游程序处理。<![CDATA[ ]]>标记的sql语句中的<where>、<if>等标签不会被解析
```

## 五, SpringCloud面试题
[Spring Cloud Alibaba微服务生态的基础实践](https://www.cnblogs.com/zhuhuix/p/13679153.html)
[Spring Cloud Alibaba生态探索：Dubbo、Nacos及Sentinel的完美结合](https://www.cnblogs.com/zhuhuix/p/13710177.html)
[SpringCloud系列之Nacos+Dubbo+Seata应用篇](https://www.cnblogs.com/chinaWu/p/13671620.html)
[思维导图概览SpringCloud](https://www.cnblogs.com/three-fighter/p/13485459.html)
[Spring Cloud面试题（2020最新版）](https://blog.csdn.net/ThinkWon/article/details/104397367)
![](https://img-blog.csdnimg.cn/20200810105241576.png?#pic_center)
### 0.什么是微服务
```markdown
架构演进:架构的发展历程是从单体式架构，到分布式架构，到SOA架构，再到微服务架构。
    单体架构：未做任何拆分的Java Web程序
    分布式架构:按照业务垂直划分，每个业务都是单体架构，通过API互相调用。
    SOA架构：SOA是一种面向服务的架构。其应用程序的不同组件通过网络上的通信协议向其它组件提供服务或消费服务，所以也是分布式架构的一种。
微服务架构是一种架构模式或者说是一种架构风格，它提倡将单一应用程序划分成一组小的服务，每个服务运行独立的自己的进程中，服务之间互相协调、互相配合，为用户提供最终价值。
    服务之间采用轻量级的通信机制互相沟通（通常是基于HTTP的RESTful API)。每个服务都围绕着具体业务进行构建，并且能够被独立地部署到生产环境、类生产环境等。
目前最流行的两种微服务解决方案是SpringCloud和Dubbo。
微服务之间如何通信？
    同步通信：dobbo通过 RPC 远程过程调用、springcloud通过 REST  接口json调用 等。
    异步：消息队列，如：RabbitMq、ActiveM、Kafka 等。
```
### 1.什么是SpringCloud？
![](https://img-blog.csdnimg.cn/20200810112743519.png?#pic_center)
```markdown
Spring Cloud作为Java的微服务框架，它依赖于SpringBoot，有快速开发、持续交付和容易部署等特点。
    SpringCloud是微服务系统架构的一站式解决方案，在平时我们构建微服务的过程中需要做如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等操作，
    SpringCloud为最常见的分布式系统模式提供了一种简单且易于接受的编程模型，帮助开发人员构建有弹性的、可靠的、协调的应用程序。
SpringCloud的版本
    最早的Release版本Angel，第二个Release版本Brixton（英国地名），然后是Camden、Dalston、Edgware、Finchley、Greenwich、Hoxton。
Spring Cloud Config
集中配置管理工具，分布式系统中统一的外部配置管理，默认使用Git来存储配置，可以支持客户端配置的刷新及加密、解密操作。
Spring Cloud Netflix
    Netflix OSS 开源组件集成，包括Eureka、Hystrix、Ribbon、Feign、Zuul等核心组件。
    Eureka：服务治理组件，包括服务端的注册中心和客户端的服务发现机制；
    Ribbon：负载均衡的服务调用组件，具有多种负载均衡调用策略；
    Hystrix：服务容错组件，实现了断路器模式，为依赖服务的出错和延迟提供了容错能力；
    Feign：基于Ribbon和Hystrix的声明式服务调用组件；
    Zuul：API网关组件，对请求提供路由及过滤功能。
Spring Cloud Bus
    用于传播集群状态变化的消息总线，使用轻量级消息代理链接分布式系统中的节点，可以用来动态刷新集群中的服务配置。
Spring Cloud Consul
    基于Hashicorp Consul的服务治理组件。
Spring Cloud Security
    安全工具包，对Zuul代理中的负载均衡OAuth2客户端及登录认证进行支持。
Spring Cloud Sleuth
    Spring Cloud应用程序的分布式请求链路跟踪，支持使用Zipkin、HTrace和基于日志（例如ELK）的跟踪。
Spring Cloud Stream
    轻量级事件驱动微服务框架，可以使用简单的声明式模型来发送及接收消息，主要实现为Apache Kafka及RabbitMQ。
Spring Cloud Task
    用于快速构建短暂、有限数据处理任务的微服务框架，用于向应用中添加功能性和非功能性的特性。
Spring Cloud Zookeeper
    基于Apache Zookeeper的服务治理组件。
Spring Cloud Gateway
    API网关组件，对请求提供路由及过滤功能。
Spring Cloud OpenFeign
    基于Ribbon和Hystrix的声明式服务调用组件，可以动态创建基于Spring MVC注解的接口实现用于服务调用，在Spring Cloud 2.0中已经取代Feign成为了一等公民。
```
### 2.Eureka服务发现框架
![](https://img-blog.csdnimg.cn/20200810120101878.png?#pic_center)
```markdown
Netflix Eureka是由Netflix开源的一款基于REST的服务发现组件，包括Eureka Server及Eureka Client。
    在Netflix，更复杂的负载均衡器将Eureka包装起来，以基于流量，资源使用，错误条件等多种因素提供加权负载均衡，以提供出色的弹性。
服务注册Register：当Eureka客户端向Eureka Server注册时，它提供自身的元数据，比如IP地址、端口，运行状况指示符URL，主页等。
服务续约Renew：Eureka 客户会每隔30秒(默认情况下)发送一次心跳来续约。通过续约来告知Eureka Server该Eureka客户仍然存在，没有出现问题。
    正常情况下，如果Eureka Server在90秒没有收到Eureka客户的续约，它会将实例从其注册表中删除。
获取注册列表信息Fetch Registries：Eureka客户端从服务器获取注册表信息，并将其缓存在本地。客户端会使用该信息查找其他服务，从而进行远程调用。
    该注册列表信息定期（每30秒钟）更新一次。每次返回注册列表信息可能与Eureka客户端的缓存信息不同,Eureka客户端自动处理。
    如果由于某种原因导致注册列表信息不能及时匹配，Eureka客户端则会重新获取整个注册表信息。
    Eureka服务器缓存注册列表信息，整个注册表以及每个应用程序的信息进行了压缩，压缩内容和没有压缩的内容完全相同。
    Eureka客户端和Eureka服务器可以使用JSON/XML格式进行通讯。在默认的情况下Eureka客户端使用压缩JSON格式来获取注册列表的信息。
服务下线Cancel：Eureka客户端在程序关闭时向Eureka服务器发送取消请求。发送请求后，该客户端实例信息将从服务器的实例注册表中删除。
    该下线请求不会自动完成，它需要调用以下内容：DiscoveryManager.getInstance().shutdownComponent();
服务剔除Eviction：在默认的情况下，当Eureka客户端连续90秒(3个续约周期)没有向Eureka服务器发送服务续约，即心跳，Eureka服务器会将该服务实例从服务注册列表删除，即服务剔除。
```
### 3.Ribbon 进程内负载均衡器
>> Ribbon Netflix 公司开源的一个负载均衡的组件。
![](https://img-blog.csdnimg.cn/20200810174308572.png?#pic_center)
#### RestTemplate
```markdown
RestTemplate是Spring提供的一个访问Http服务的客户端类 
```
#### Ribbon的几种负载均衡算法
```markdown
Ribbon是Netflix公司的一个开源的负载均衡 项目，是一个客户端/进程内负载均衡器，运行在消费者端 。
RoundRobinRule ：轮询策略。Ribbon默认采用的策略。若经过一轮轮询没有找到可用的provider，其最多轮询10轮。若最终还没有找到，则返回null。
RandomRule : 随机策略，从所有可用的provider中随机选择一个。
RetryRule : 重试策略。先按照RoundRobinRule策略获取provider，若获取失败，则在指定的时限内重试。默认的时限为500毫秒。
配置文件配置：
    providerName:
      ribbon:
        NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule
```
### 4.Open Feign服务调用映射
[微服务通信之feign的注册、发现过程](https://www.cnblogs.com/enjoyall/p/13755252.html)
>> Feign是一个声明式的Web Service客户端。
![](https://img-blog.csdnimg.cn/20200810182853299.png?0#pic_center)
```markdown
OpenFeign也是运行在消费者端的，使用Ribbon进行负载均衡，所以OpenFeign直接内置了Ribbon。
// 使用 @FeignClient 注解来指定提供者的名字
@FeignClient(value = "eureka-client-provider")
public interface TestClient {
    // 这里一定要注意需要使用的是提供者那端的请求相对路径，这里就相当于映射了
    @RequestMapping(value = "/provider/xxx",
    method = RequestMethod.POST)
    CommonResponse<List<Plan>> getPlans(@RequestBody planGetRequest request);
}
@RestController
public class TestController {
    // 这里就相当于原来自动注入的 Service
    @Autowired
    private TestClient testClient;
    // controller 调用 service 层代码
    @RequestMapping(value = "/test", method = RequestMethod.POST)
    public CommonResponse<List<Plan>> get(@RequestBody planGetRequest request) {
        return testClient.getPlans(request);
    }
}
```
### 5.Hystrix服务降级熔断器
>> Hystrix是Netstflix公司开源的一个项目，它提供了熔断器功能，能够阻止分布式系统中出现联动故障。
![](https://img-blog.csdnimg.cn/20200810205126528.png?#pic_center)
```markdown
Hystrix是一个库，可通过添加等待时间容限和容错逻辑来帮助您控制这些分布式服务之间的交互。
Hystrix通过隔离服务之间的访问点，停止服务之间的级联故障并提供后备选项来实现此目的，所有这些都可以提高系统的整体弹性。
```
### 6.Zuul微服务网关
>> Zuul是由Netflix孵化的一个致力于“网关“解决方案的开源组件。
![](https://img-blog.csdnimg.cn/20200810211514805.png?#pic_center)
```markdown
ZUUL是从设备和web站点到Netflix流应用后端的所有请求的前门。作为边界服务应用，
ZUUL是为了实现动态路由、监视、弹性和安全性而构建的。它还具有根据情况将请求路由到多个Amazon Auto Scaling Groups（亚马逊自动缩放组，亚马逊的一种云计算方式）的能力。
    网关是系统唯一对外的入口，介于客户端与服务器端之间，用于对请求进行鉴权、限流、路由、监控等功能。
    网关相当于一个网络服务架构的入口，所有网络请求必须通过网关转发到具体的服务。
    网关的作用:统一管理微服务请求，权限控制、负载均衡、路由转发、监控、安全控制黑名单和白名单等。
Zuul是对SpringCloud提供的成熟对的路由方案，他会根据请求的路径不同，网关会定位到指定的微服务，并代理请求到不同的微服务接口，他对外隐蔽了微服务的真正接口地址。
三个重要概念：动态路由表，路由定位，反向代理：
    动态路由表：Zuul支持Eureka路由，手动配置路由，这俩种都支持自动更新
    路由定位：根据请求路径，Zuul有自己的一套定位服务规则以及路由表达式匹配
    反向代理：客户端请求到路由网关，网关受理之后，在对目标发送请求，拿到响应之后在 给客户端
它可以和Eureka,Ribbon,Hystrix等组件配合使用，
Zuul的应用场景：
    对外暴露，权限校验，服务聚合，日志审计等
```
### 7.Config 微服务统一配置中心
![](https://img-blog.csdnimg.cn/20200810214123442.png?#pic_center)
```markdown
Spring Cloud中提供了分布式配置中Spring Cloud Config，为外部配置提供了客户端和服务器端的支持。
使用Config 服务器，可以在中心位置管理所有环境中应用程序的外部属性。
```
### 8.Bus消息总线
![](https://img-blog.csdnimg.cn/20200810223142844.png?0#pic_center)
```markdown
Spring Cloud Bus的作用就是管理和广播分布式系统中的消息 ，也就是消息引擎系统中的广播模式。
当然作为消息总线的Spring Cloud Bus可以做很多事而不仅仅是客户端的配置刷新功能。
```
### 9.Gateway
![](https://img-blog.csdnimg.cn/20200810212808923.png?#pic_center)
```markdown
Spring Cloud Gateway是Spring官方基于Spring5.0、Spring Boot2.0 和Project Reactor等技术开发的网关，
Spring Cloud Gateway旨在为微服务架构提供简单、 有效且统一的API路由管理方式。
```
### 10.OAuth2
>> Sprin Cloud构建的微服务系统中可以使用Spring Cloud OAuth2来保护微服务系统。
![](https://img-blog.csdnimg.cn/20200811205313656.png?#pic_center)
```markdown

```
### 11.Sleuth
>> Spring Cloud Sleuth是Spring Cloud个组件，它的主要功能是在分布式系统中提供服务链路追踪的解决方案。
![](https://img-blog.csdnimg.cn/20200811212137615.png?#pic_center)
### SpringBoot和SpringCloud的区别？
```markdown
SpringBoot专注于快速方便的开发单个个体微服务。
SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务整合并管理起来，
    为各个微服务之间提供，配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等集成服务
SpringBoot可以离开SpringCloud独立使用开发项目， 但是SpringCloud离不开SpringBoot ，属于依赖的关系
SpringBoot专注于快速、方便的开发单个微服务个体，SpringCloud关注全局的服务治理框架。
```
### 使用Spring Boot开发分布式微服务时，我们面临以下问题
```markdown
（1）与分布式系统相关的复杂性-这种开销包括网络问题，延迟开销，带宽问题，安全问题。
（2）服务发现-服务发现工具管理群集中的流程和服务如何查找和互相交谈。它涉及一个服务目录，在该目录中注册服务，然后能够查找并连接到该目录中的服务。
（3）冗余-分布式系统中的冗余问题。
（4）负载平衡 --负载平衡改善跨多个计算资源的工作负荷，诸如计算机，计算机集群，网络链路，中央处理单元，或磁盘驱动器的分布。
（5）性能-问题 由于各种运营开销导致的性能问题。
（6）部署复杂性-Devops 技能的要求。
```
### SpringCloud的优缺点
```markdown
优点：
      1.耦合度比较低。不会影响其他模块的开发。
      2.减轻团队的成本，可以并行开发，不用关注其他人怎么开发，先关注自己的开发。
      3.配置比较简单，基本用注解就能实现，不用使用过多的配置文件。
      4.微服务跨平台的，可以用任何一种语言开发。
      5.每个微服务可以有自己的独立的数据库也有用公共的数据库。
      6.直接写后端的代码，不用关注前端怎么开发，直接写自己的后端代码即可，然后暴露接口，通过组件进行服务通信。
缺点：
      1.部署比较麻烦，给运维工程师带来一定的麻烦。
      2.针对数据的管理比麻烦，因为微服务可以每个微服务使用一个数据库。
      3.系统集成测试比较麻烦
      4.性能的监控比较麻烦。【最好开发一个大屏监控系统】
总的来说优点大过于缺点，目前看来SpringCloud是一套非常完善的分布式框架，目前很多企业开始用微服务、SpringCloud的优势是显而易见的。
因此对于想研究微服务架构的同学来说，学习SpringCloud是一个不错的选择。
```
### SpringCloud和Dubbo区别?
```markdown
（1）服务调用方式：dubbo是RPC springcloud Restful Api
（2）注册中心：dubbo是zookeeper springcloud是eureka，也可以是zookeeper
（3）服务网关，dubbo本身没有实现，只能通过其他第三方技术整合，springcloud有Zuul路由网关，作为路由服务器，进行消费者的请求分发,springcloud支持断路器，
    与git完美集成配置文件支持版本控制，事物总线实现配置文件的更新与服务自动装配等等一系列的微服务架构要素。
```
### Eureka和ZooKeeper都可以提供服务注册与发现的功能,请说说两个的区别
```markdown
1.ZooKeeper中的节点服务挂了就要选举
    在选举期间注册服务瘫痪,虽然服务最终会恢复,但是选举期间不可用的，
    选举就是改微服务做了集群，必须有一台主其他的都是从
2.Eureka各个节点是平等关系,服务器挂了没关系，只要有一台Eureka就可以保证服务可用，数据都是最新的。
    如果查询到的数据并不是最新的，就是因为Eureka的自我保护模式导致的
3.Eureka本质上是一个工程,而ZooKeeper只是一个进程
4.Eureka可以很好的应对因网络故障导致部分节点失去联系的情况,而不会像ZooKeeper 一样使得整个注册系统瘫痪
5.ZooKeeper保证的是CP，Eureka保证的是AP
CAP：
    C：一致性>Consistency;
        取舍：(强一致性、单调一致性、会话一致性、最终一致性、弱一致性)
    A：可用性>Availability;
    P：分区容错性>Partition tolerance;
```
### gRPC-微服务间通信实践
[gRPC-微服务间通信实践](https://www.cnblogs.com/jiangyihz/p/13754406.html)
### RPC调用和HTTP调用的区别
[RPC调用和HTTP调用的区别](https://blog.csdn.net/m0_38110132/article/details/81481454)
```markdown
最本质的区别:就是RPC主要是基于TCP/IP协议的，而HTTP服务主要是基于HTTP协议的，HTTP协议是在传输层协议TCP之上的，所以效率来看RPC要更胜一筹啦！
RPC服务：从三个角度来介绍RPC服务：分别是RPC架构，同步异步调用以及流行的RPC框架。
    RPC架构
        客户端（Client），服务的调用方。
        服务端（Server），真正的服务提供者。
        客户端存根，存放服务端的地址消息，再将客户端的请求参数打包成网络消息，然后通过网络远程发送给服务方。
        服务端存根，接收客户端发送过来的消息，将消息解包，并调用本地的方法。
    同步调用与异步调用
        同步调用就是客户端等待调用执行完成并返回结果。
        异步调用就是客户端不等待调用执行完成返回结果，不过依然可以通过回调函数等接收到返回结果的通知。
    流行的RPC框架
        gRPC是Google最近公布的开源软件，基于最新的HTTP2.0协议，并支持常见的众多编程语言。
        Thrift是Facebook的一个开源项目，主要是一个跨语言的服务开发框架。
        Dubbo是阿里集团开源的一个极为出名的RPC框架，在很多互联网公司和企业应用中广泛使用。协议和序列化框架都可以插拔是及其鲜明的特色。
HTTP服务:RESTful风格的服务接口。
        优点就是简单、直接、开发方便。利用现成的http协议进行传输。
        适合对于在接口不多、系统与系统交互较少的情况下，解决信息孤岛初期常使用的一种通信手段；
```
###
[SpringCloud系列之集成分布式事务Seata应用篇](https://www.cnblogs.com/chinaWu/p/13255200.html)
[实战SpringCloud通用请求字段拦截处理](https://www.cnblogs.com/huangying2124/p/13264753.html)
[随笔分类 - Spring Cloud](https://www.cnblogs.com/zhixie/category/1759831.html)

## 六, 微服务项目实战相关
实际工作中 Spring 微服务项目的问题。
61. 谈谈你对微服务的理解。
62. 微服务分别有哪些优点，哪些缺点？
63. 谈谈微服务之间是如何实现通信的。
64. Spring Boot 如何集成 MyBatis？
65. Spring Boot 和 Spring Cloud 有哪些区别？
66. 使用 layui 的数据表格组件展示业务数据，后台实体类应该如何定义
67. JPA 和 Spring Data JPA 是一回事吗？
68. 如果要给项目添加权限管理系统，一般包含哪些需求？
69. 微服务架构的拆分都有哪些原则？
70. Feign 和 Ribbon+RestTemplate 的区别是什么？
描述一下rpc调用过程。
让你实现一个rpc框架，你会怎么做。
链路跟踪和熔断机制了解吗，框架层如何实现的。
了解哪些序列化协议，有什么区别，项目中用的是什么协议。
1.分布式事务的控制。
2.分布式锁如何设计。
3.分布式session如何设计。
4.dubbo的组件有哪些，各有什么作用。
5.zookeeper的负载均衡算法有哪些。

### Dubbo
>> 1.1 服务调用超时问题怎么解决？
    1.2 Dubbo支持哪些序列化方式？
    1.3 Dubbo和SpringCloud的关系？
    1.4 Dubbo的架构设计？一共划分了哪些层？
    1.5 Dubbo的默认集群容错方案？
    1.6 Dubbo使用的是什么通信框架?
    1.7 Dubbo的主要应用场景？
    1.8 Dubbo服务注册与发现的流程？流程说明。
    1.9 Dubbo的集群容错方案有哪些？
    1.10 Dubbo的四大组件
    1.11 Dubbo在安全机制方面是如何解决的
    1.12 Dubbo和SpringCloud的区别？
    1.13 Dubbo支持哪些协议，每种协议的应用场景，优缺点？
    1.14 Dubbo的核心功能有哪些？
    1.15 Dubbo的注册中心集群挂掉，发布者和订阅者之间还能通信么？
    1.16 Dubbo集群的负载均衡有哪些策略
    1.17 为什么需要服务治理？
    1.18 Dubbo超时时间怎样设置？
>> 6.dubbo是如何利用接口就可以通信的。
#### 1.Dubbo提供哪些功能和主要组成【5+】
```markdown
Dubbo的主要功能
    基于接口的远程调用
    日常和负载均衡
    自动服务注册和发现
Dubbo服务的关键节点
    Provider:暴露服务的服务提供方
    Consumer:调用远程服务的服务消费方
    Register:服务注册与发现的注册中心
    Monitor:统计服务的调用次数和调用时间的监控中心
    Container:服务运行容器
```
[Dubbo直连方式](https://www.cnblogs.com/mengd/p/13543836.html)
#### 2.Dubbo的服务注册流程【5+】
[Dubbo服务注册与发现的流程图](http://www.mianshigee.com/question/20621dou)
![](http://cdn.mianshigee.com/upload/article/20200625/20181002113850939.png)
![](http://cdn.mianshigee.com/upload/article/20200625/20190731230024_81309.jpg)
```markdown
Provider(提供者)绑定指定端口并启动服务
指供者连接注册中心，并发本机IP、端口、应用信息和提供服务信息发送至注册中心存储
Consumer(消费者），连接注册中心 ，并发送应用信息、所求服务信息至注册中心
注册中心根据 消费 者所求服务信息匹配对应的提供者列表发送至Consumer 应用缓存。
Consumer 在发起远程调用时基于缓存的消费者列表择其一发起调用。
Provider 状态变更会实时通知注册中心、在由注册中心实时推送至Consumer
```
#### 1.Dubbo的容错机制
```markdown
1.失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过retries="2"来设置重试次数
2.快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。
3.失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。
4.失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。
5.并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过forks="2"来设置最大并行数。
6.广播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息
```
#### 2.Dubbo注册中心挂了还可以继续通信么
```markdown
可以，因为刚开始初始化的时候，消费者会将提供者的地址等信息拉取到本地缓存，所以注册中心挂了可以继续通信。
```
#### 3.Dubbo提供的线程池
```markdown
1.fixed：固定大小线程池，启动时建立线程，不关闭，一直持有。 
2.cached：缓存线程池，空闲一分钟自动删除，需要时重建。 
3.limited：可伸缩线程池，但池中的线程数只会增长不会收缩。(为避免收缩时突然来了大流量引起的性能问题)。
```
#### 4.Dubbo框架设计结构
```markdown
服务接口层：该层是与实际业务逻辑相关的，根据服务提供方和服务消费方的业务设计对应的接口和实现。
配置层：对外配置接口，以ServiceConfig和ReferenceConfig为中心，可以直接new配置类，也可以通过spring解析配置生成配置类。
服务代理层：服务接口透明代理，生成服务的客户端Stub和服务器端Skeleton，以ServiceProxy为中心，扩展接口为ProxyFactory。
服务注册层：封装服务地址的注册与发现，以服务URL为中心，扩展接口为RegistryFactory、Registry和RegistryService。可能没有服务注册中心，此时服务提供方直接暴露服务。
集群层：封装多个提供者的路由及负载均衡，并桥接注册中心，以Invoker为中心，扩展接口为Cluster、Directory、Router和LoadBalance。将多个服务提供方组合为一个服务提供方，实现对服务消费方来透明，只需要与一个服务提供方进行交互。
监控层：RPC调用次数和调用时间监控，以Statistics为中心，扩展接口为MonitorFactory、Monitor和MonitorService。
远程调用层：封将RPC调用，以Invocation和Result为中心，扩展接口为Protocol、Invoker和Exporter。Protocol是服务域，它是Invoker暴露和引用的主功能入口，它负责Invoker的生命周期管理。Invoker是实体域，它是Dubbo的核心模型，其它模型都向它靠扰，或转换成它，它代表一个可执行体，可向它发起invoke调用，它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。
信息交换层：封装请求响应模式，同步转异步，以Request和Response为中心，扩展接口为Exchanger、ExchangeChannel、ExchangeClient和ExchangeServer。
网络传输层：抽象mina和netty为统一接口，以Message为中心，扩展接口为Channel、Transporter、Client、Server和Codec。
数据序列化层：可复用的一些工具，扩展接口为Serialization、 ObjectInput、ObjectOutput和ThreadPool。
```

### 
