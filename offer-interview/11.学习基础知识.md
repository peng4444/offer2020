# 学习基础知识
## 计算机基础
>> [程序员cxuan:computer-basic.pdf]()
>> [全网最硬核讲解计算机启动流程](https://www.cnblogs.com/flashsun/p/13942138.html)
### 1.CPU
[10 张图打开 CPU 缓存一致性的大门](https://www.cnblogs.com/xiaolincoding/p/13886559.html)
[如何写出让 CPU 跑得更快的代码？](https://www.cnblogs.com/xiaolincoding/p/13836230.html)
```markdown
CPU的核心是从程序或者应用程序获取指令并且执行计算。此过程可以分成三个关键阶段：提取、解码、执行。
    CPU从系统的RAM中提取指令，然后解码该指令的实际内容，然后再由CPU的相关部分执行该指令。     
RAM:随机读取存储器，也叫主存，是与CPU直接交换数据的内部存储器。它可以随时读写（刷新时除外），速度快，通常作为操作系统或其他正在运行的查询的临时数据存储介质。
CPU主要由两个部分组成：控制单元和算术逻辑单元（ALU）
    控制单元：从内存中提取指令并解码执行
    算术逻辑单元：处理算术和逻辑运算
从功能来看：CPU的内部由寄存器、控制器、运算器和时钟四个部分组成，各个部分之间通过电信号连通。
    寄存器：是中央处理器内的组成部分。它们可以用来暂存指令、数据和地址。可以看成内存的一种。
    控制器：负责吧内存上的指令、数据读入寄存器，并根据指令的结果控制计算机
    运算器：负责运算从内存中读入寄存器的数据
    时钟：负责发出CPU开始计时的时钟信号
寄存器分类：累加寄存器、标志寄存器、程序计数器、基址寄存器、变址寄存器、通用寄存器、指令寄存器、栈寄存器。
    累加寄存器：存储运行的数据和运算之后的数据。
    标志寄存器：用于反应处理器的状态和运算结果的某些特征以及控制指令的执行。比方说跳转指令。
    程序计数器：用于存放下一条指令所在单元的地址的地方。
    基址寄存器：存储数据内存的起始位置。
    变址寄存器：存储基址寄存器的相对地址。
    通用寄存器：存储任意数据。
    指令寄存器：存储正在被运行的指令，CPU内部使用，程序员无法对该寄存器进行读写。
    栈寄存器：存储渣区域的起始位置。
累加寄存器、标志寄存器、程序计数器、基址寄存器和指令寄存器都只有一个，其他寄存器一般有多个。
CPU指令执行过程：取指令、指令译码、执行指令、访存去数、结果写回。
```
### 2.内存
```markdown
内存：内存是程序与CPU进行沟通的桥梁，计算机所有程序的运行都是在内存中运行的，内存又被称为主存。
    其作用是存放CPU中的运算数据，以及与硬盘等外部存储设备交换的数据。
存储器分类：
    随机存储器（RAM）：内存中最重要的一种，表示既可以从中读取数据也可以写入数据。当机器关闭时，内存中的信息会丢失。
    只读存储器（ROM）：ROM一般只能用于数据的读取，不能写入数据，但是当机器停电时，这些数据不会丢失。
    高速缓存（Cache）：分为一级缓存、二级缓存、三级缓存。位于内存和CPU之间是一个读写速度比内存更快的存储器。
```
### 3.压缩算法
```markdown
RLE算法：把重复数据用数据*重复次数来表示的形式的压缩方法。常用于压缩传真的图像等等。缺点：只能由于特定序列的数据有效果。
哈夫曼算法和莫尔斯编码：
    哈夫曼算法的关键：在于多次出现的数据小于8位的字节数表示，不常用的数据则可以使用超过8位的字节数表示。
    莫尔斯编码：是根据日常文本中各字符的出现频率来决定表示个字符的编码数据长度的。
可逆压缩和非可逆压缩：
    可逆压缩：能还原到压缩前状态的压缩。
    非可逆压缩：无法还原到压缩前状态的压缩。
```
### 4.磁盘
```markdown
磁盘和内存都具有存储功能，都属于存储设备。区别在于，内存是通过电流来实现存储；磁盘是通过磁记录技术来实现存储。
    断电后内存中非数据汇丢失，但是磁盘中的数据可以长久保留。
    内存属于内部存储设备，硬盘属于外部存储设备。磁盘中存储的出现必须加装到内存中才能运行。
    磁盘的物理结构：指的是磁盘存储数据的形式。可分为可变长方式和扇区方式。
虚拟内存：是内存和磁盘交互的第二媒介，就是把磁盘的一部分当成内存来使用。
    虚拟内存的方法欧分页式和分段式两种，Windows采用非是分页式。页的大小为4KB
```
## 正则表达式
[正则表达式](https://blog.csdn.net/qq_39331713/article/details/82871510)
[正则表达式（代码java版）](https://www.cnblogs.com/mxjhaima/p/13737903.html)
### 1.正则基础知识点：
#### 1.元字符->元字符是构造正则表达式的一种基本元素。
```markdown
语法：
    元字符	    说明
    .	    匹配除换行符以外的任意字符
    \w	    匹配字母或数字或下划线或汉字
    \s	    匹配任意的空白符
    \d	    匹配数字
    \b	    匹配单词的开始或结束
    ^	    匹配字符串的开始
    $	    匹配字符串的结束
练习：
    匹配有abc开头的字符串：\babc或者^abc
    匹配8位数字的QQ号码：\d\d\d\d\d\d\d\d\d$
    匹配1开头11位数字的手机号码：^1\d\d\d\d\d\d\d\d\d\d$
```
#### 2. 重复限定符 ->把重复部分用合适的限定符替代
```markdown
语法：
    语法	        说明
    *	    重复零次或更多次
    +	    重复一次或更多次
    ?	    重复零次或一次
    {n}	    重复n次
    {n,}	重复n次或更多次
    {n,m}	重复n到m次
练习：
    匹配8位数字的QQ号码：^\d{8}$
    匹配1开头11位数字的手机号码：^1\d{10}$
    匹配银行卡号是14~18位的数字：^\d{14,18}$
    匹配以a开头的，0个或多个b结尾的字符串: ^ab*$
```
#### 3.分组
>> 正则表达式中用小括号()来做分组，也就是括号中的内容作为一个整体。
```markdown
匹配字符串中包含0到多个ab开头：^(ab)*
```
#### 4. 转义
>> 要把这些元字符、限定符或者关键字转义成普通的字符，做法很简答，就是在要转义的字符前面加个斜杠，也就是\即可。
```markdown
要匹配以(ab)开头： ^(\(ab\))*
```
#### 5.条件或
>> 正则用符号 | 来表示或，也叫做分支条件，当满足正则里的分支条件的任何一种条件时，都会当成是匹配成功。
```markdown
联通有130/131/132/155/156/185/186/145/176等号段: ^(130|131|132|155|156|185|186|145|176)\d{8}$
```
#### 6. 区间
```markdown
正则提供一个元字符中括号 [] 来表示区间条件。
    限定0到9 可以写成[0-9]
    限定A-Z 写成[A-Z]
    限定某些数字 [165]
联通有130/131/132/155/156/185/186/145/176等号段: ^((13[0-2])|(15[56])|(18[5-6])|145|176)\d{8}$
```
### 2.正则进阶知识点：
#### 1. 零宽断言
```markdown
1.断言：俗话的断言就是“我断定什么什么”，而正则中的断言，就是说正则可以指明在指定的内容的前面或后面会出现满足指定规则的内容，
    意思正则也可以像人类那样断定什么什么，比如"ss1aa2bb3",正则可以用断言找出aa2前面有bb3，也可以找出aa2后面有ss1.
2.零宽：就是没有宽度，在正则中，断言只是匹配位置，不占字符，也就是说，匹配结果里是不会返回断言本身。
爬虫抓取csdn里的文章阅读量:"<span class="read-count">阅读数：641</span>"
1.正向先行断言（正前瞻）：
    语法：（?=pattern）
    作用：匹配pattern表达式的前面内容，不返回本身。  
     String reg=".+(?=</span>)";
     String test = "<span class=\"read-count\">阅读数：641</span>";
     Pattern pattern = Pattern.compile(reg);
     Matcher mc=pattern.matcher(test);
     while(mc.find()){
       System.out.println("匹配结果：")
       System.out.println(mc.group());
     }
    //匹配结果：
    //<span class="read-count">阅读数：641
    可是老哥我们要的只是前面的数字呀，那也简单咯，匹配数字 \d,那可以改成：
    String reg="\\d+(?=</span>)";
    String test = "<span class=\"read-count\">阅读数：641</span>";
    Pattern pattern = Pattern.compile(reg);
    Matcher mc=    pattern.matcher(test);
    while(mc.find()){
      System.out.println(mc.group());
    }
    //匹配结果：
    //641
2.正向后行断言（正后顾）:
    语法：（?<=pattern）
    作用：匹配pattern表达式的后面的内容，不返回本身。
     //(?<=<span class="read-count">阅读数：)\d+
     String reg="(?<=<span class=\"read-count\">阅读数：)\\d+";
     String test = "<span class=\"read-count\">阅读数：641</span>";
     Pattern pattern = Pattern.compile(reg);
     Matcher mc=    pattern.matcher(test);
             while(mc.find()){
                 System.out.println(mc.group());
             }
    //匹配结果：
    //641
3.负向先行断言（负前瞻）
    语法：(?!pattern)
    作用：匹配非pattern表达式的前面内容，不返回本身。
    比如有一句 “我爱祖国，我是祖国的花朵”现在要找到不是'的花朵'前面的祖国
    用正则就可以这样写：祖国(?!的花朵)
4.负向后行断言（负后顾）
    语法：(?<!pattern)
    作用：匹配非pattern表达式的后面内容，不返回本身。
```
#### 2. 捕获和非捕获
```markdown
单纯说到捕获，他的意思是匹配表达式，但捕获通常和分组联系在一起，也就是“捕获组”
捕获组：匹配子表达式的内容，把匹配结果保存到内存中中数字编号或显示命名的组里，以深度优先进行编号，之后可以通过序号或名称来使用这些匹配结果。
而根据命名方式的不同，又可以分为两种组：
    1.数字编号捕获组：
    语法：(exp)
    解释：从表达式左侧开始，每出现一个左括号和它对应的右括号之间的内容为一个分组，在分组中，第0组为整个表达式，第一组开始为分组。
    比如固定电话的：020-85653333
    他的正则表达式为：(0\d{2})-(\d{8})
    按照左括号的顺序，这个表达式有如下分组：
     String test = "020-85653333";
             String reg="(0\\d{2})-(\\d{8})";
             Pattern pattern = Pattern.compile(reg);
             Matcher mc= pattern.matcher(test);
             if(mc.find()){
                 System.out.println("分组的个数有："+mc.groupCount());
                 for(int i=0;i<=mc.groupCount();i++){
                     System.out.println("第"+i+"个分组为："+mc.group(i));
                 }
            }
    输出：分组的个数有：2
         第0个分组为：020-85653333
         第1个分组为：020
         第2个分组为：85653333
    2.命名编号捕获组：
      语法：(?<name>exp)
      解释：分组的命名由表达式中的name指定
      比如区号也可以这样写:(?<quhao>\0\d{2})-(?<haoma>\d{8})
      按照左括号的顺序，这个表达式有如下分组：
      String test = "020-85653333";
              String reg="(?<quhao>0\\d{2})-(?<haoma>\\d{8})";
              Pattern pattern = Pattern.compile(reg);
              Matcher mc= pattern.matcher(test);
              if(mc.find()){
                  System.out.println("分组的个数有："+mc.groupCount());
                  System.out.println(mc.group("quhao"));
                  System.out.println(mc.group("haoma"));
              }
        输出：分组的个数有：2
             分组名称为:quhao,匹配内容为：020
             分组名称为:haoma,匹配内容为：85653333
    3.非捕获组：
      语法：(?:exp)
      解释：和捕获组刚好相反，它用来标识那些不需要捕获的分组，说的通俗一点，就是你可以根据需要去保存你的分组。
    
```
#### 3. 反向引用
```markdown
捕获会返回一个捕获组，这个分组是保存在内存中，不仅可以在正则表达式外部通过程序进行引用，也可以在正则表达式内部进行引用，这种引用方式就是反向引用。
根据捕获组的命名规则，反向引用可分为：
    1.数字编号组反向引用：\k
        或\number
    2.命名编号组反向引用：\k
        或者\'name'
```
#### 4. 贪婪和非贪婪
```markdown
贪婪匹配：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符，这匹配方式叫做贪婪匹配。
特性：一次性读入整个字符串进行匹配，每当不匹配就舍弃最右边一个字符，继续匹配，依次匹配和舍弃（这种匹配-舍弃的方式也叫做回溯），直到匹配成功或者把整个字符串舍弃完为止，因此它是一种最大化的数据返回，能多不会少。
```
#### 5. 反义
```markdown
正则也提供了一些常用的反义元字符：
    元字符	            解释
    \W	        匹配任意不是字母，数字，下划线，汉字的字符
    \S	        匹配任意不是空白符的字符
    \D	        匹配任意非数字的字符
    \B	        匹配不是单词开头或结束的位置
    [^x]	    匹配除了x以外的任意字符
    [^aeiou]	匹配除了aeiou这几个字母以外的任意字符
```

##