# 学习基础知识


## 正则表达式
[正则表达式](https://blog.csdn.net/qq_39331713/article/details/82871510)
### 1.正则基础知识点：
#### 1.元字符->元字符是构造正则表达式的一种基本元素。
```markdown
语法：
    元字符	    说明
    .	    匹配除换行符以外的任意字符
    \w	    匹配字母或数字或下划线或汉字
    \s	    匹配任意的空白符
    \d	    匹配数字
    \b	    匹配单词的开始或结束
    ^	    匹配字符串的开始
    $	    匹配字符串的结束
练习：
    匹配有abc开头的字符串：\babc或者^abc
    匹配8位数字的QQ号码：\d\d\d\d\d\d\d\d\d$
    匹配1开头11位数字的手机号码：^1\d\d\d\d\d\d\d\d\d\d$
```
#### 2. 重复限定符 ->把重复部分用合适的限定符替代
```markdown
语法：
    语法	        说明
    *	    重复零次或更多次
    +	    重复一次或更多次
    ?	    重复零次或一次
    {n}	    重复n次
    {n,}	重复n次或更多次
    {n,m}	重复n到m次
练习：
    匹配8位数字的QQ号码：^\d{8}$
    匹配1开头11位数字的手机号码：^1\d{10}$
    匹配银行卡号是14~18位的数字：^\d{14,18}$
    匹配以a开头的，0个或多个b结尾的字符串: ^ab*$
```
#### 3.分组
>> 正则表达式中用小括号()来做分组，也就是括号中的内容作为一个整体。
```markdown
匹配字符串中包含0到多个ab开头：^(ab)*
```
#### 4. 转义
>> 要把这些元字符、限定符或者关键字转义成普通的字符，做法很简答，就是在要转义的字符前面加个斜杠，也就是\即可。
```markdown
要匹配以(ab)开头： ^(\(ab\))*
```
#### 5.条件或
>> 正则用符号 | 来表示或，也叫做分支条件，当满足正则里的分支条件的任何一种条件时，都会当成是匹配成功。
```markdown
联通有130/131/132/155/156/185/186/145/176等号段: ^(130|131|132|155|156|185|186|145|176)\d{8}$
```
#### 6. 区间
```markdown
正则提供一个元字符中括号 [] 来表示区间条件。
    限定0到9 可以写成[0-9]
    限定A-Z 写成[A-Z]
    限定某些数字 [165]
联通有130/131/132/155/156/185/186/145/176等号段: ^((13[0-2])|(15[56])|(18[5-6])|145|176)\d{8}$
```

### 2.正则进阶知识点：
#### 1. 零宽断言
```markdown
1.断言：俗话的断言就是“我断定什么什么”，而正则中的断言，就是说正则可以指明在指定的内容的前面或后面会出现满足指定规则的内容，
    意思正则也可以像人类那样断定什么什么，比如"ss1aa2bb3",正则可以用断言找出aa2前面有bb3，也可以找出aa2后面有ss1.
2.零宽：就是没有宽度，在正则中，断言只是匹配位置，不占字符，也就是说，匹配结果里是不会返回断言本身。
爬虫抓取csdn里的文章阅读量:"<span class="read-count">阅读数：641</span>"
1.正向先行断言（正前瞻）：
    语法：（?=pattern）
    作用：匹配pattern表达式的前面内容，不返回本身。  
     String reg=".+(?=</span>)";
     String test = "<span class=\"read-count\">阅读数：641</span>";
     Pattern pattern = Pattern.compile(reg);
     Matcher mc=pattern.matcher(test);
     while(mc.find()){
       System.out.println("匹配结果：")
       System.out.println(mc.group());
     }
    //匹配结果：
    //<span class="read-count">阅读数：641
    可是老哥我们要的只是前面的数字呀，那也简单咯，匹配数字 \d,那可以改成：
    String reg="\\d+(?=</span>)";
    String test = "<span class=\"read-count\">阅读数：641</span>";
    Pattern pattern = Pattern.compile(reg);
    Matcher mc=    pattern.matcher(test);
    while(mc.find()){
      System.out.println(mc.group());
    }
    //匹配结果：
    //641
2.正向后行断言（正后顾）:
    语法：（?<=pattern）
    作用：匹配pattern表达式的后面的内容，不返回本身。
     //(?<=<span class="read-count">阅读数：)\d+
     String reg="(?<=<span class=\"read-count\">阅读数：)\\d+";
     String test = "<span class=\"read-count\">阅读数：641</span>";
     Pattern pattern = Pattern.compile(reg);
     Matcher mc=    pattern.matcher(test);
             while(mc.find()){
                 System.out.println(mc.group());
             }
    //匹配结果：
    //641
3.负向先行断言（负前瞻）
    语法：(?!pattern)
    作用：匹配非pattern表达式的前面内容，不返回本身。
    比如有一句 “我爱祖国，我是祖国的花朵”现在要找到不是'的花朵'前面的祖国
    用正则就可以这样写：祖国(?!的花朵)
4.负向后行断言（负后顾）
    语法：(?<!pattern)
    作用：匹配非pattern表达式的后面内容，不返回本身。
```
#### 2. 捕获和非捕获
```markdown
单纯说到捕获，他的意思是匹配表达式，但捕获通常和分组联系在一起，也就是“捕获组”
捕获组：匹配子表达式的内容，把匹配结果保存到内存中中数字编号或显示命名的组里，以深度优先进行编号，之后可以通过序号或名称来使用这些匹配结果。
而根据命名方式的不同，又可以分为两种组：
    1.数字编号捕获组：
    语法：(exp)
    解释：从表达式左侧开始，每出现一个左括号和它对应的右括号之间的内容为一个分组，在分组中，第0组为整个表达式，第一组开始为分组。
    比如固定电话的：020-85653333
    他的正则表达式为：(0\d{2})-(\d{8})
    按照左括号的顺序，这个表达式有如下分组：
     String test = "020-85653333";
             String reg="(0\\d{2})-(\\d{8})";
             Pattern pattern = Pattern.compile(reg);
             Matcher mc= pattern.matcher(test);
             if(mc.find()){
                 System.out.println("分组的个数有："+mc.groupCount());
                 for(int i=0;i<=mc.groupCount();i++){
                     System.out.println("第"+i+"个分组为："+mc.group(i));
                 }
            }
    输出：分组的个数有：2
         第0个分组为：020-85653333
         第1个分组为：020
         第2个分组为：85653333
    2.命名编号捕获组：
      语法：(?<name>exp)
      解释：分组的命名由表达式中的name指定
      比如区号也可以这样写:(?<quhao>\0\d{2})-(?<haoma>\d{8})
      按照左括号的顺序，这个表达式有如下分组：
      String test = "020-85653333";
              String reg="(?<quhao>0\\d{2})-(?<haoma>\\d{8})";
              Pattern pattern = Pattern.compile(reg);
              Matcher mc= pattern.matcher(test);
              if(mc.find()){
                  System.out.println("分组的个数有："+mc.groupCount());
                  System.out.println(mc.group("quhao"));
                  System.out.println(mc.group("haoma"));
              }
        输出：分组的个数有：2
             分组名称为:quhao,匹配内容为：020
             分组名称为:haoma,匹配内容为：85653333
    3.非捕获组：
      语法：(?:exp)
      解释：和捕获组刚好相反，它用来标识那些不需要捕获的分组，说的通俗一点，就是你可以根据需要去保存你的分组。
    
```
#### 3. 反向引用
```markdown
捕获会返回一个捕获组，这个分组是保存在内存中，不仅可以在正则表达式外部通过程序进行引用，也可以在正则表达式内部进行引用，这种引用方式就是反向引用。
根据捕获组的命名规则，反向引用可分为：
    1.数字编号组反向引用：\k
        或\number
    2.命名编号组反向引用：\k
        或者\'name'
```
#### 4. 贪婪和非贪婪
```markdown
贪婪匹配：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符，这匹配方式叫做贪婪匹配。
特性：一次性读入整个字符串进行匹配，每当不匹配就舍弃最右边一个字符，继续匹配，依次匹配和舍弃（这种匹配-舍弃的方式也叫做回溯），直到匹配成功或者把整个字符串舍弃完为止，因此它是一种最大化的数据返回，能多不会少。
```
#### 5. 反义
```markdown
正则也提供了一些常用的反义元字符：
    元字符	            解释
    \W	        匹配任意不是字母，数字，下划线，汉字的字符
    \S	        匹配任意不是空白符的字符
    \D	        匹配任意非数字的字符
    \B	        匹配不是单词开头或结束的位置
    [^x]	    匹配除了x以外的任意字符
    [^aeiou]	匹配除了aeiou这几个字母以外的任意字符
```

## 