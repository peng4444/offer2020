# 学习基础知识


## 正则表达式
[正则表达式](https://blog.csdn.net/qq_39331713/article/details/82871510)
[正则表达式（代码java版）](https://www.cnblogs.com/mxjhaima/p/13737903.html)
### 1.正则基础知识点：
#### 1.元字符->元字符是构造正则表达式的一种基本元素。
```markdown
语法：
    元字符	    说明
    .	    匹配除换行符以外的任意字符
    \w	    匹配字母或数字或下划线或汉字
    \s	    匹配任意的空白符
    \d	    匹配数字
    \b	    匹配单词的开始或结束
    ^	    匹配字符串的开始
    $	    匹配字符串的结束
练习：
    匹配有abc开头的字符串：\babc或者^abc
    匹配8位数字的QQ号码：\d\d\d\d\d\d\d\d\d$
    匹配1开头11位数字的手机号码：^1\d\d\d\d\d\d\d\d\d\d$
```
#### 2. 重复限定符 ->把重复部分用合适的限定符替代
```markdown
语法：
    语法	        说明
    *	    重复零次或更多次
    +	    重复一次或更多次
    ?	    重复零次或一次
    {n}	    重复n次
    {n,}	重复n次或更多次
    {n,m}	重复n到m次
练习：
    匹配8位数字的QQ号码：^\d{8}$
    匹配1开头11位数字的手机号码：^1\d{10}$
    匹配银行卡号是14~18位的数字：^\d{14,18}$
    匹配以a开头的，0个或多个b结尾的字符串: ^ab*$
```
#### 3.分组
>> 正则表达式中用小括号()来做分组，也就是括号中的内容作为一个整体。
```markdown
匹配字符串中包含0到多个ab开头：^(ab)*
```
#### 4. 转义
>> 要把这些元字符、限定符或者关键字转义成普通的字符，做法很简答，就是在要转义的字符前面加个斜杠，也就是\即可。
```markdown
要匹配以(ab)开头： ^(\(ab\))*
```
#### 5.条件或
>> 正则用符号 | 来表示或，也叫做分支条件，当满足正则里的分支条件的任何一种条件时，都会当成是匹配成功。
```markdown
联通有130/131/132/155/156/185/186/145/176等号段: ^(130|131|132|155|156|185|186|145|176)\d{8}$
```
#### 6. 区间
```markdown
正则提供一个元字符中括号 [] 来表示区间条件。
    限定0到9 可以写成[0-9]
    限定A-Z 写成[A-Z]
    限定某些数字 [165]
联通有130/131/132/155/156/185/186/145/176等号段: ^((13[0-2])|(15[56])|(18[5-6])|145|176)\d{8}$
```

### 2.正则进阶知识点：
#### 1. 零宽断言
```markdown
1.断言：俗话的断言就是“我断定什么什么”，而正则中的断言，就是说正则可以指明在指定的内容的前面或后面会出现满足指定规则的内容，
    意思正则也可以像人类那样断定什么什么，比如"ss1aa2bb3",正则可以用断言找出aa2前面有bb3，也可以找出aa2后面有ss1.
2.零宽：就是没有宽度，在正则中，断言只是匹配位置，不占字符，也就是说，匹配结果里是不会返回断言本身。
爬虫抓取csdn里的文章阅读量:"<span class="read-count">阅读数：641</span>"
1.正向先行断言（正前瞻）：
    语法：（?=pattern）
    作用：匹配pattern表达式的前面内容，不返回本身。  
     String reg=".+(?=</span>)";
     String test = "<span class=\"read-count\">阅读数：641</span>";
     Pattern pattern = Pattern.compile(reg);
     Matcher mc=pattern.matcher(test);
     while(mc.find()){
       System.out.println("匹配结果：")
       System.out.println(mc.group());
     }
    //匹配结果：
    //<span class="read-count">阅读数：641
    可是老哥我们要的只是前面的数字呀，那也简单咯，匹配数字 \d,那可以改成：
    String reg="\\d+(?=</span>)";
    String test = "<span class=\"read-count\">阅读数：641</span>";
    Pattern pattern = Pattern.compile(reg);
    Matcher mc=    pattern.matcher(test);
    while(mc.find()){
      System.out.println(mc.group());
    }
    //匹配结果：
    //641
2.正向后行断言（正后顾）:
    语法：（?<=pattern）
    作用：匹配pattern表达式的后面的内容，不返回本身。
     //(?<=<span class="read-count">阅读数：)\d+
     String reg="(?<=<span class=\"read-count\">阅读数：)\\d+";
     String test = "<span class=\"read-count\">阅读数：641</span>";
     Pattern pattern = Pattern.compile(reg);
     Matcher mc=    pattern.matcher(test);
             while(mc.find()){
                 System.out.println(mc.group());
             }
    //匹配结果：
    //641
3.负向先行断言（负前瞻）
    语法：(?!pattern)
    作用：匹配非pattern表达式的前面内容，不返回本身。
    比如有一句 “我爱祖国，我是祖国的花朵”现在要找到不是'的花朵'前面的祖国
    用正则就可以这样写：祖国(?!的花朵)
4.负向后行断言（负后顾）
    语法：(?<!pattern)
    作用：匹配非pattern表达式的后面内容，不返回本身。
```
#### 2. 捕获和非捕获
```markdown
单纯说到捕获，他的意思是匹配表达式，但捕获通常和分组联系在一起，也就是“捕获组”
捕获组：匹配子表达式的内容，把匹配结果保存到内存中中数字编号或显示命名的组里，以深度优先进行编号，之后可以通过序号或名称来使用这些匹配结果。
而根据命名方式的不同，又可以分为两种组：
    1.数字编号捕获组：
    语法：(exp)
    解释：从表达式左侧开始，每出现一个左括号和它对应的右括号之间的内容为一个分组，在分组中，第0组为整个表达式，第一组开始为分组。
    比如固定电话的：020-85653333
    他的正则表达式为：(0\d{2})-(\d{8})
    按照左括号的顺序，这个表达式有如下分组：
     String test = "020-85653333";
             String reg="(0\\d{2})-(\\d{8})";
             Pattern pattern = Pattern.compile(reg);
             Matcher mc= pattern.matcher(test);
             if(mc.find()){
                 System.out.println("分组的个数有："+mc.groupCount());
                 for(int i=0;i<=mc.groupCount();i++){
                     System.out.println("第"+i+"个分组为："+mc.group(i));
                 }
            }
    输出：分组的个数有：2
         第0个分组为：020-85653333
         第1个分组为：020
         第2个分组为：85653333
    2.命名编号捕获组：
      语法：(?<name>exp)
      解释：分组的命名由表达式中的name指定
      比如区号也可以这样写:(?<quhao>\0\d{2})-(?<haoma>\d{8})
      按照左括号的顺序，这个表达式有如下分组：
      String test = "020-85653333";
              String reg="(?<quhao>0\\d{2})-(?<haoma>\\d{8})";
              Pattern pattern = Pattern.compile(reg);
              Matcher mc= pattern.matcher(test);
              if(mc.find()){
                  System.out.println("分组的个数有："+mc.groupCount());
                  System.out.println(mc.group("quhao"));
                  System.out.println(mc.group("haoma"));
              }
        输出：分组的个数有：2
             分组名称为:quhao,匹配内容为：020
             分组名称为:haoma,匹配内容为：85653333
    3.非捕获组：
      语法：(?:exp)
      解释：和捕获组刚好相反，它用来标识那些不需要捕获的分组，说的通俗一点，就是你可以根据需要去保存你的分组。
    
```
#### 3. 反向引用
```markdown
捕获会返回一个捕获组，这个分组是保存在内存中，不仅可以在正则表达式外部通过程序进行引用，也可以在正则表达式内部进行引用，这种引用方式就是反向引用。
根据捕获组的命名规则，反向引用可分为：
    1.数字编号组反向引用：\k
        或\number
    2.命名编号组反向引用：\k
        或者\'name'
```
#### 4. 贪婪和非贪婪
```markdown
贪婪匹配：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符，这匹配方式叫做贪婪匹配。
特性：一次性读入整个字符串进行匹配，每当不匹配就舍弃最右边一个字符，继续匹配，依次匹配和舍弃（这种匹配-舍弃的方式也叫做回溯），直到匹配成功或者把整个字符串舍弃完为止，因此它是一种最大化的数据返回，能多不会少。
```
#### 5. 反义
```markdown
正则也提供了一些常用的反义元字符：
    元字符	            解释
    \W	        匹配任意不是字母，数字，下划线，汉字的字符
    \S	        匹配任意不是空白符的字符
    \D	        匹配任意非数字的字符
    \B	        匹配不是单词开头或结束的位置
    [^x]	    匹配除了x以外的任意字符
    [^aeiou]	匹配除了aeiou这几个字母以外的任意字符
```

### JDK15 新特性
```markdown
JDK15新功能说明
JDK15为用户提供了十四项主要的增强/更改，包括一个孵化器模块，三个预览功能，两个不推荐使用的功能以及两个删除功能。
1、EdDSA 数字签名算法
新加入Edwards-Curve数字签名算法（EdDSA）实现加密签名。在许多其它加密库（如OpenSSL和BoringSSL）中得到支持。
与JDK中的现有签名方案相比，EdDSA 具有更高的安全性和性能。这是一个新的功能。
2、隐藏类
此功能可帮助需要在运行时生成类的框架。框架生成类需要动态扩展其行为，但是又希望限制对这些类的访问。隐藏类很有用，因为它们只能通过反射访问，而不能从普通字节码访问。
此外，隐藏类可以独立于其他类加载，这可以减少框架的内存占用。这是一个新的功能。
3、重新实现DatagramSocket API
重新实现旧版DatagramSocket API，更简单、更现代的实现来代替java.net.DatagramSocket和java.net.MulticastSocketAPI的基础实现，提高了JDK的可维护性和稳定性。
4、ZGC功能转正
ZGC已由JEP333集成到JDK11中，其目标是通过减少GC停顿时间来提高性能。借助JEP377，ZGC从预览功能转变为生产功能。
5、文本块功能转正
文本块由JEP355在 2019年提出，文本块是一种多行字符串文字，它避免了大多数转义序列的需要，以一种可预测的方式自动设置字符串的格式，并在需要时使开发人员可以控制格式。
借助JEP378，文本块已成为Java语言的永久功能。
6、Shenandoah垃圾回收算法转正
Shenandoah垃圾回收从实验特性变为产品特性。这是一个从JDK12引入的回收算法，该算法通过与正在运行的Java线程同时进行疏散工作来减少 GC 暂停时间。
Shenandoah的暂停时间与堆大小无关，无论堆栈是200MB还是200GB，都具有相同的一致暂停时间。
7、密封类（预览）
通过密封的类和接口来增强Java编程语言，用于限制超类的使用，密封的类和接口限制其它可能继承或实现它们的其它类或接口。
8、instanceof 自动匹配模式（预览）
旧写法：
// 先判断类型
if (obj instanceof String) {
    // 然后转换
    String s = (String) obj;
    // 然后才能使用
}
新写法：
if (obj instanceof String s) {
    // 如果类型匹配 直接使用
} else {
    // 如果类型不匹配则不能直接使用
}
这是第二次预览该功能，我们已经在 Java14中首次预览过该特性。
9、Records Class（预览）
Records Class 也是第二次出现的预览功能，它在 JDK14中也出现过一次了，使用Record可以更方便的创建一个常量类，使用的前后代码对比如下。
旧写法：
class Point {
    private final int x;
    private final int y;
    Point(int x, int y) { 
        this.x = x;
        this.y = y;
    }
    int x() { return x; }
    int y() { return y; }
    public boolean equals(Object o) { 
        if (!(o instanceof Point)) return false;
        Point other = (Point) o;
        return other.x == x && other.y = y;
    }
    public int hashCode() {
        return Objects.hash(x, y);
    }
    public String toString() { 
        return String.format("Point[x=%d, y=%d]", x, y);
    }
}
新写法：
record Point(int x, int y) { }
也就是说在使用了record之后，就可以用一行代码编写出一个常量类，并且这个常量类还包含了构造方法、toString()、equals()和hashCode()等方法。
10、外部存储器访问API（预览）
目的是引入一个API，以允许Java程序安全有效地访问Java堆之外的外部内存。这同样是Java14的一个预览特性。
11、其它功能
其它功能里面还有一些弃用和不建议使用的功能，比如移除了Nashorn JavaScript引擎，同时也移除了删除Solaris和SPARC端口，并标记了一些弃用功能。
```
###  JDK10新特性 var
[Java新特性：数据类型可以扔掉了？](https://mp.weixin.qq.com/s?__biz=MzU1NTkwODE4Mw==&mid=2247489219&idx=1&sn=9ebebc38b6f22fd71464587352e5dc56&chksm=fbcc7bfbccbbf2ed181d16d7e2489401dbb23302a7947bd2893b4976ba7064f0cc6ddf5b0d19&mpshare=1&scene=23&srcid=0921ulXfDXLyOhRWcFdsg8nv&sharer_sharetime=1600649048555&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
```markdown
1.使用对比
    String str = "Hello,0921";
    var s = "Hello,0921";
    var n1 = 111L;
    var n2 = 555.666;
    var n3 = n1 + n2;//当遇到不同类型相加时（int+ double）会发生数据类型向上转型
    System.out.println(n3);
    var list = new ArrayList<>();
    list.add("Hello");
    list.add("Java");
2.优点分析
    ① 提高了可读性
    ② 命名对齐
3、使用规则 & 反例
    var 必须满足以下条件：
        1.它只能用于局部变量上；
        2.声明时必须初始化；
        3.不能用作方法参数和全局变量（类变量）。
    反例一：未初始化和赋值 null
        var flag = null;
        var flag;
    反例二：中途类型更改
        var flag = true;
        flag = 1;
    反例三：全局变量
    反例四：作为返回值
        private String name;
        public var getName(){
            return name;
        }
4、原理分析
    反编译工具打开被编译的类发现：var 竟然被替换成一个个确定的数据类型了。
    由此我们可以得出结论：var关键字的实现和它的名字密切相关，var只是局部类型推断，它只会在Java编码期和编译期有效，
    当类被编译为class文件时，var就会变成一个个确定的数据类型（通过推断得出）。所以我们可以把var通俗的理解为Java的语法糖，
    使用它可以让我们快速优雅的实现业务代码，但var在字节码层面是不存在的。
``` 