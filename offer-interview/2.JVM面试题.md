# JVM面试题

[TOC]

## 三、JVM
### 1.JVM的主要组成部分及其作用
```markdown
Class Loader类加载器：类加载器的作用是加载类文件到内存，比如编写一个HelloWord.java程序，然后通过javac编译成class文件。
Class Loader承担加载到内存中被执行的责任，当然，不可能随便建立一个.class文件就能被加载的，Class Loader加载的class文件是有格式要求。
 Execution Engine执行引擎：Class Loader只管加载，只要符合文件结构就加载，至于说能不能运行，则不是它负责的，
那是由Execution Engine负责的。执行引擎也叫做解释器 (Interpreter)，负责解释命令，提交操作系统执行。
 Native Interface本地接口：本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序，Java诞生的时候是C/C++横行的时候，
要想立足，必须有一个聪明的、睿智的调用C/C++程序，于是就在内存中专门开辟了一块区域处理标记为native的代码。
 Runtime data area运行数据区：运行数据区是整个JVM的重点。
```
### 2.JVM内存模型和Java运行时内存数据区
>>[一份热乎乎的腾讯后端面试真题](https://www.cnblogs.com/jay-huaxiao/p/12776714.html)
#### 1.Java运行时内存数据区
![](https://user-gold-cdn.xitu.io/2020/4/26/171b3b57de3b838c?w=727&h=478&f=png&s=203974)
```markdown
堆：线程公有，存放对象。
栈：线程私有，由栈帧组成，保存函数的一些信息。
PC计数器：代码指令行号计数器,线程私有
方法区（持久代、元数据区）,线程公有
堆：Java内存管理中最大的一块，用来存储对象实例和数组，线程共享。
栈：分为虚拟机栈和本地方法栈，这里主要指的是虚拟机栈。
虚拟机栈由一个个栈帧组成，每一个栈帧又由局部变量表、动态链接（对象引用）、方法出口等信息组成，线程私有。
```
#### 2.Java中成员变量、局部变量、静态变量、常量分别存储在那些内存区域中？
```markdown
 成员变量：堆
 局部变量：
     局部变量是基本类型（8 种基本类型）：栈
     局部变量是对象：对象实例存储在堆中，对象引用存储在栈中
 静态变量（static 修饰）：方法区（元数据区）
 常量（final 修饰）：方法区（元数据区）
```
#### 3.JVM内存模型(JMM)
![](https://user-gold-cdn.xitu.io/2020/4/26/171b3a11106f2cad?w=823&h=759&f=png&s=231498)
### 3.JMM与Java运行时内存区域划分的区别与联系
```markdown
区别:两者是不同的概念层次。
    JMM是抽象的，他是用来描述⼀组规则，通过这个规则来控制各个变量的访问方式，围绕原子性、有序性、可见性等展开的。
    而Java运行时内存的划分是具体的，是JVM运行Java程序时，必要的内存划分。
联系
    都存在私有数据区域和共享数据区域。⼀般来说，JMM中的主内存属于共享数据区域，他是包含了堆和方法区；
    同样，JMM中的本地内存属于私有数据区域，包含了程序计数器、本地方法栈、虚拟机栈。
```
### 3.cms和g1有没有了解过，它们有什么区别
>>[一份热乎乎的腾讯后端面试真题](https://www.cnblogs.com/jay-huaxiao/p/12776714.html)
```markdown
CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收集器一起使用；
G1收集器收集范围是老年代和新生代，不需要结合其他收集器使用；
CMS收集器以最小的停顿时间为目标的收集器；
G1收集器可预测垃圾回收的停顿时间
CMS收集器是使用“标记-清除”算法进行的垃圾回收，容易产生内存碎片
G1收集器使用的是“标记-整理”算法，进行了空间整合，降低了内存空间碎片。
```
### 4.谈谈你对垃圾回收的了解，什么时候发生垃圾回收，回收过程
>>[一份热乎乎的腾讯后端面试真题](https://www.cnblogs.com/jay-huaxiao/p/12776714.html)
```markdown
可以讲JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代，
如Minor GC，Major GC，full GC这几个讲清楚，还有对象存活判断方法，还有垃圾回收算法，复制算法等等
```
### [5.关于强引用、软引用、弱引用、虚引用，你该如何回答？](https://www.cnblogs.com/cxuanBlog/p/12774370.html)|
```markdown
1. 强引用:被强引用关联的对象不会被回收。使用new一个新对象的方式来创建强引用。
        Object obj = new Object();
new语句产生的都是强引用，虚拟机不会主动去回收，即便内存溢出，也是会抛出异常而不是回收强引用。可以将对象=null，从而在垃圾回收器在下一次回收。
2. 软引用:被软引用关联的对象在内存足够时，不会回收,在内存不够的情况下才会被回收。使用SoftReference类来创建软引用。常用于缓存技术。
        Object obj = new Object();
        SoftReference<Object> sf = new SoftReference<Object>(obj);
        obj = null; // 使对象只被软引用关联
3. 弱引用:被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。使用WeakReference类来创建弱引用。
        Object obj = new Object();
        WeakReference<Object> wf = new WeakReference<Object>(obj);
        obj = null;
4. 虚引用:最弱的引用，在对象被JVM回收之后收到一个系统通知，用于追踪垃圾回收过程，必须与应用队列一起使用。
       一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。
       为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。使用PhantomReference来创建虚引用。
       Object obj = new Object();
       PhantomReference<Object> pf = new PhantomReference<Object>(obj, null);
       obj = null;
```
### 6.对象创建的过程
```markdown
1.类加载检查：在执行到new命令时，查看new后面的参数是否正确定位到常量池中的符号引用，并且该符号引用是否被正确的加载、连接和初始化。
2.内存分配：为对象分配内存，有指针碰撞和空闲列表两种方式。
     指针碰撞：适用于内存完整，无碎片。内存使用和未使用中间由指针隔开，分配的时候指针移动相应的位置。
     空闲列表：适用于内存不完整，有碎片。维护一个列表，列表记录可用的内存，使用时分配给对象一个足够的内存空间并更新列表
3.初始化零值：将对象分配到的空间初始化零值（不包括对象头）
4.设置对象头：对象头信息包括哈希码、GC 分代信息、元数据信息、对象是哪个类的示例等
5.执行 init 方法：给对象设置程序值，执行构造方法。
```
### 7.对象有哪几部分构成？虚拟机如何访问对象
```markdown
对象在内存中的组成部分（对象在内存的划分、对象的内存布局）:
     对象头：
         第一：元数据、GC 分代、哈希值等自身运行信息；
         第二：类型指针，确定属于哪个类的实例
     实例数据：对象真正存储的有效信息，定义的各种字段的值。
     对齐填充：没有实际意义，JVM 内存地址需要 8 字节的整数倍
虚拟机如何访问对象
     句柄：堆中专门划分一个区域作为句柄池，虚拟机栈存储是堆中句柄的地址，句柄存储的是对象的实例数据和类型数据的地址
     直接指针：栈中的引用直接指向的就是对象的实例数据和类型数据的地址。
     对比：直接指针避免二次寻址；使用句柄，在对象移动时，只修改句柄地址而不用改变引用的地址。
```
### 8.内存泄露和内存溢出分别是什么？什么原因造成？如何避免？
```markdown
内存泄露：本应被回收的对象因为其他对象的引用而不能被回收，从而在堆中寄存，造成内存泄露，长周期对象持有短周期对象的引用会造成。
 内存溢出：无法为对象分配足够的内存，对象申请过多
避免：
 不要在循环中创建对象
 不要一次调用过多数据
 大量字符串使用 StringBuffer 或者 StringBuilder
 方法区很少进行垃圾回收，尽量避免申请常量和静态变量
```
### 9.给对象分配内存如何保证线程安全？
```markdown
CAS+失败重试：CAS是乐观锁，每次都假设成功，在执行，失败就重试，找到成功。保证更新的原子性
TLAB：为每一个线程，预先在Eden区域分配一块内存，对象先分配到这里，当该区域内存不足或用完之后，使用CAS+失败重试机制
```
### 10.常量池都包括哪些内容？常量池的位置？
```markdown
Java 中有三个常量池：字符串常量池、运行时常量池、class常量池
 字符常量池：全局字符串池里的内容是在类加载完成，经过验证，准备阶段之后在堆中生成字符串对象实例，也就是编译期间字符常量池已经创建完成。
 class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池(constant pool table)——注意这里的class常量池是存放在class文件中，而不是
在jvm中，用于存放编译器生成的各种字面量(Literal)和符号引用(SymbolicReferences)。字面量就是我们所说的常量概念，符号引用就是在类加载阶段的解析阶段，把符号引用替换成直接引用。
 jvm在执行某个类的时候，必须经过加载、连接、初始化，而连接又包括验证、准备、
解析三个阶段。而当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中，运行时常量池也是每个类都有一个。
 关于class常量池和运行时常量池可以这么理解：在java文件编译时，类的字面量和符
号引用，会存放在class类常量池，但是当类文件加载到jvm之后，class常量池的内容就被会加载到运行时常量池。
常量池的位置
 在JDK1.7之前运行时常量池逻辑包含字符串常量池存放在方法区，此时hotspot虚拟机对方法区的实现为永久代。
 在JDK1.7字符串常量池被从方法区拿到了堆中，这里没有提到运行时常量池，也就是
说字符串常量池被单独拿到堆，运行时常量池剩下的东西还在方法区 , 也就是hotspot中的永久代。
 在JDK1.8hotspot移除了永久代用元空间(Metaspace)取而代之，这时候 字符串常量
池还在堆,运行时常量池还在方法区,只不过方法区的实现从永久代变成了元空间(Metaspace)。
```
### 11.[JAVA GC（垃圾回收机制）面试讲解](https://www.cnblogs.com/dmzna/p/12913458.html)
```markdown
1.什么是GC？
大白话说就是垃圾回收机制，内存空间是有限的，创建的每个对象和变量都会占据内存，gc做的就是对象清除将内存释放出来。
2.需要GC的区域
垃圾回收的场所，了解过JVM内存模型的朋友应该会很清楚，堆是Java虚拟机进行垃圾回收的主要场所，其次要是方法区。
3.堆内存的结构
Java将堆内存分为3大部分：新生代、老年代和永久代，其中新生代又进一步划分为Eden、S0、S1(Survivor)三个区,Eden，S0，S1比例8:1:1。
4.堆内存上对象的分配与回收：
创建的对象会优先在Eden分配，如果是大对象（很长的字符串数组）则可以直接进入老年代。虚拟机提供一个-XX:PretenureSizeThreadhold参数，
令大于这个参数值的对象直接在老年代中分配，避免在Eden区和两个Survivor区发生大量的内存拷贝。
另外，长期存活的对象将进入老年代，每一次MinorGC（年轻代GC），对象年龄就大一岁，默认15岁晋升到老年代，通过-XX:MaxTenuringThreshold设置晋升年龄。
5.堆内存上的对象回收也叫做垃圾回收，那么垃圾回收什么时候开始呢？
垃圾回收主要是完成清理对象，整理内存的工作。上面说到GC经常发生的区域是堆区，堆区还可以细分为新生代、老年代。
新生代还分为一个Eden区和两个Survivor区。垃圾回收分为年轻代区域发生的Minor GC和老年代区域发生的Full GC，分别介绍如下。
6.Minor GC（年轻代GC）:
对象优先在Eden中分配，当Eden中没有足够空间时，虚拟机将发生一次Minor GC，因为Java大多数对象都是朝生夕灭，所以Minor GC非常频繁，而且速度也很快。
7.Full GC（老年代GC）:
Full GC是指发生在老年代的GC，当老年代没有足够的空间时即发生Full GC，发生Full GC一般都会有一次Minor GC。
8.动态对象年龄判定：
如果Survivor空间中相同年龄所有对象的大小总和大于Survivor空间的一半，那么年龄大于等于该对象年龄的对象即可晋升到老年代，不必要等到-XX:MaxTenuringThreshold。
9.空间分配担保：
发生Minor GC时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小。如果大于，则进行一次Full GC（老年代GC），
如果小于，则查看HandlePromotionFailure设置是否允许担保失败，如果允许，那只会进行一次Minor GC，如果不允许，则改为进行一次Full GC。
10.为什么要有Survivor区
Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代。
11.为什么有两个Survivor区
刚刚新建的对象在Eden中，经历一次Minor GC，Eden中的存活对象就会被移动到第一块survivor space S0，Eden被清空；等Eden区再满了，就再触发一次Minor GC，
Eden和S0中的存活对象又会被复制送入第二块survivor space S1（这个过程非常重要，因为这种复制算法保证了S1中来自S0和Eden两部分的存活对象占用连续的内存空间，避免了碎片化的发生）。
S0和Eden被清空，然后下一轮S0与S1交换角色，如此循环往复。如果对象的复制次数达到16次，该对象就会被送到老年代中。
上述机制最大的好处就是，整个过程中，永远有一个survivor space是空的，另一个非空的survivor space无碎片。
根据上面的分析可以得知，当新生代的Survivor分区为 2 个的时候，不论是空间利用率还是程序运行的效率都是最优的，所以这也是为什么Survivor分区是2个的原因了。
```