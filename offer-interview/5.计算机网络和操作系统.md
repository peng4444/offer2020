# 计算机网络和操作系统知识总结

[TOC]


## 一、计算机网络 
>> [参考资料：cyc2018大佬](https://cyc2018.github.io/CS-Notes/#/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E7%9B%AE%E5%BD%951)
>> 参考书籍：《图解TCP/IP第五版》、《图解HTTP》、《计算机网络第七版》
>>1.[参考资料：计算机网络常见面试题](https://www.cnblogs.com/wuwuyong/p/12198928.html)
>>2.[参考资料：总结12道最常见的计算机网络面试题](https://www.cnblogs.com/tanshaoshenghao/p/11835679.html)
>> [随笔分类 - 网络协议](https://www.cnblogs.com/BeiGuo-FengGuang/category/1329919.html)
>> [两万字长文50+张趣图带你领悟网络编程的内功心法](https://www.cnblogs.com/arthinking/p/13429848.html)
### 1.三种体系结构&计算机网络的体系结构&网络协议【10+】
![](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E4%BA%94%E5%B1%82%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png)
>> OSI的体系结构:应用层-表示层-会话层-运输层-网络层-数据链路层-物理层
>> 五层协议的体系结构:应用层-运输层-网络层-数据链路层-物理层
>> TCP/IP的体系结构:应用层-传输层-网络层-链路层
```markdown
1.应用层(application-layer）**定义了用于在网络中进行通信和传输数据的接口**，任务是通过应用进程间的交互来完成特定网络应用。
    应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。
    在互联网中应用层协议很多，如**域名系统DNS**，支持万维网应用的**HTTP协议**，支持电子邮件的**SMTP协议**等等。我们把应用层交互的数据单元称为报文。
    功能：文件传输，电子邮件，文件服务，虚拟终端:TFTP，HTTP，SNMP，FTP，SMTP，DNS，RIP，Telnet
2.表示层：网络服务和应用程序之间的数据转换，如字符编码、数据压缩、加密解密；
3.会话层：控制计算机之间的连接，负责建立、管理和终止本地和远程引用程序之间的连接，提供全双工、半双工或者单工操作；
4.运输层(transport layer)的主要任务就是**负责向两台主机进程之间的通信提供通用的数据传输服务**。应用进程利用该服务传送应用层报文。
“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。
    所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。
[参考资料：运输层 ,跑腿的秘书](https://www.cnblogs.com/king0/p/12932251.html)
    运输层主要使用以下两种协议:   
        1.**传输控制协议 TCP**（Transmission Control Protocol）--提供面向连接的，可靠的数据传输服务。
        2.**用户数据协议 UDP**（User Datagram Protocol）--提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。
5.网络层：**选择合适的网间路由和交换结点，确保数据及时传送**。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。
    在TCP/IP体系结构中，由于网络层使用**IP协议**，因此分组也叫IP数据报，简称数据报。**ICMP,IP,路由器,防火墙**。
6.数据链路层(data link layer)。**将上面的网络层的数据包封装成数据帧，便于物理层传输。**
    在两个相邻节点之间传送数据时，数据链路层将网络层交下来的IP数据报组装成帧，在两个相邻节点间的链路上传送帧。
    每一帧包括数据和必要的控制信息（如**同步信息，地址信息，差错控制等**）。**网卡,网桥,交换机，PPP，CSMA/CD**
7.物理层(physical layer)的作用是**实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。** 
    使其上面的数据链路层不必考虑网络的具体传输介质是什么。在物理层上所传送的数据单位是比特。**中继器,集线器**
```
![](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E4%B8%83%E5%B1%82%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9B%BE.png)
### 2.通信交互方式
```markdown
单工通信，又称为单向通信，只有一个方向的通信，如无线电广播，电视广播；
半双工通信，又称为双向交替通信，双方都可以收发信息，只能交替进行；
全双工通信，又称为双向同时通信，双方可以同时发送和接收数据。
```
### 3.信道复用技术
```markdown
为了提高信道利用率，有哪些信道复用技术？
所谓信道复用技术，指的是大家共享一个信道进行通信，在接收端在使用分用器，把合起来传输的信息分别送到相应的终点；
频分复用:用户在分配到一定的频带后，通信过程中使用都占用这个频带；
时分复用:将时间划分为一段段等长时分复用帧，每一个时分复用的用户周期性的占用帧位；
统计时分复用:时分复用，如果用户没有任何数据要传输，也会周期性的给他分配时隙，这就导致了信道利用率不高。为此出现了统计时分复用。
    统计时分复用使用STDM帧来传送复用的数据，把所有用户数据按时间顺序组成STDM帧，放入一个队列中，依次发送出去，这样就能够更合理的共享信道。
    STDM帧中的数据需要添加用户地址首部信息，以便能够正确的分发给目标用户：
```
### 4.TCP的三次握手机制，为什么要三次握手？【10+】
![](https://img2020.cnblogs.com/blog/1973740/202009/1973740-20200907161704934-291130095.png)
```markdown
首先服务器端处于LISTEN（监听）状态，等待客户的连接请求。
1.客户端–发送带有SYN=1标志，序号Seq=x的数据包–一次握手–服务端，并且客户端进入SYN_SEND状态，等待服务器确认。
2.服务端–接收到请求，发送带有SYN=1,ACK=1标志，序号Seq=y和确认号Ack=x+1的数据包–二次握手–客户端，服务器进入SYN_RECV状态。
3.客户端–接收到请求和确认信息，发送标识ACK=1的数据包号，Seq=x+1，确认号Ack=y+1–三次握手–服务端，客户端和服务器进入ESTABLISHED状态，TCP的三次握手完成。
SYN:是TCP/IP建立连接时使用的握手信号。SYN表示客户端请求跟服务端建立连接。
ACK:确认字符，ACK表示对客户端的连接请求进行应答。Ack=x+1表示对客户端发送的序号Seq=x的请求进行确认。Ack=y+1（表示对服务端发送的序号Seq=y的请求进行确认）。
三次握手的目的是建立可靠的通信信道，通讯简单来说就是数据的发送与接收。最主要的目的就是双方确认自己与对方的发送与接收是正常的。
    第一次握手：Client什么都不能确认；Server确认了对方发送正常，自己接收正常
    第二次握手：Client确认了：自己发送、接收正常，对方发送、接收正常；Server确认了：对方发送正常，自己接收正常
    第三次握手：Client确认了：自己发送、接收正常，对方发送、接收正常；Server确认了：自己发送、接收正常，对方发送、接收正常
1、图中的发送请求中的发送标识SYN、ACK表示的是发送报文中两个标识位！而Seq和Ack分别代表发送序号和确认号。
2、服务端在接收到了客户端的连接请求后，回复中同时发送了SYN、ACK两个标识位，将建立连接的请求和对客户端的确认应答在同一个数据包中发送了，这也是为什么只需要三次握手，就能建立连接。
1、TCP建立三次握手的过程，为什么初始化序列号要随机取，从0开始会出现什么问题?
2、TCP为什么要有确认号?
​为什么两次不行？
​   1、防止已失效的请求报文又传送到了服务端，建立了多余的链接，浪费资源。
​   2、两次握手只能保证单向连接是畅通的。（为了实现可靠数据传输，TCP协议的通信双方，都必须维 护一个序列号，以标识发送出去的数据包中，哪些是已经被对方收到的。
    三次握手的过程即是通信双方相互告知序列号起始值，并确认对方已经收到了序列号起始值的必经步骤；如果只是两次握手，至多只有连接发起方的起始序列号能被确认，另一方选择的序列号则得不到确认）
```
### 5.为什么要传回SYN？传了SYN,为啥还要传ACK？SYN超时，洪泛攻击，以及解决策略？
```markdown
**为什么要传回SYN包？**
    接收端传回发送端所发送的SYN包是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。
**传了SYN包,为啥还要传ACK？**
    双方通信无误必须是两者互相发送信息都无误。传了SYN包，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要ACK信号来进行验证。
**讲一讲SYN包超时，洪泛攻击，以及解决策略？**
    在TCP的三次握手机制的第一步中，客户端会向服务器发送SYN报文段。服务器接收到SYN报文段后会为该TCP分配缓存和变量，
        如果攻击分子大量地往服务器发送SYN报文段，服务器的连接资源终将被耗尽，导致内存溢出无法继续服务。
    **解决策略**：当服务器接受到SYN报文段时，不直接为该TCP分配资源，而只是打开一个半开的套接字。
        接着会使用SYN报文段的源Id，目的Id，端口号以及只有服务器自己知道的一个秘密函数生成一个cookie，并把cookie作为序列号响应给客户端。
    **保活机制**：向对方发送保活探测报文，如果未收到响应则继续发送，尝试次数达到保活探测仍未收到响应则中断连接。
```
### 6.TCP的四次挥手机制，为什么要有TIME_WAIT状态，为什么需要四次握手？服务器出现了大量CLOSE_WAIT状态如何解决【10+】
![](https://img2020.cnblogs.com/blog/1973740/202009/1973740-20200908105517619-975980897.png)
```markdown
1.客户端-发送一个tcp报头标识FIN=1，序号Seq= 1，用来请求关闭客户端到服务器的数据传送。客户端进入FIN_WAIT_1状态。
2.服务器-收到这个FIN，它发回一个ACK=1，序号Seq=v,确认号Ack=u+1。服务器进入CLOSE_WAIT状态。客户端收到服务器返回的ACK报文之后随即进入FIN_WAIT_2状态。
3.服务器-观察自己是否还有没有数据要发送到客户端，如果有，先把数据发送给客户端，再发送FIN报文；
      如果没有，发送一个FIN=1报文，序号Seq=w,确认号Ack=u+1给客户端，请求关闭服务器到客户端的数据传送，服务器进入LAST_ACK状态。
4.客户端-收到FIN报文后，向服务器发送ACK报文，将Seq=u+1，Ack=w+1，然后进入TIME_WAIT状态；
      服务器收到客户端的ACK报文之后就关闭了连接；此时，客户端等待2msl后依然没有收到回复，则证明服务器已正常关闭，客户端也可以关闭连接了。
**为什么需要四次握手？**:任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。
    当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。因为全双工，发送方和接收方都需要FIN报文和ACK报文。
**为什么要有TIME_WAIT状态**:​ 为了解决网络的丢包和网络不稳定所带来的其他问题，确保连接方能在时间范围内，关闭自己的连接。
    因为客户端最后向服务器发送的确认ACK是有可能丢失的，当出现超时，服务端会再次发送FIN报文段，
    如果客户端已经关闭了就收不到了。还有一点是避免新旧连接混杂。
**为什么会TIME-WAIT过多？解决方法是怎样的？**
​    可能原因：高并发短连接的TCP服务器上，当服务器处理完请求后立刻按照主动正常关闭连接
​    解决：负载均衡服务器；Web服务器首先关闭来自负载均衡服务器的连接
**服务器大量CLOSE_WAIT状态的原因**:表示程序出现了问题，对方的socket已经关闭连接，而我方忙于读或写没有及时关闭连接，
    需要检查代码，特别是释放资源的代码，或者是处理请求的线程配置。CLOSE-WAIT：这种状态的含义其实是表示在等待关闭。
```
### 7.TCP粘包和拆包及解决策略【5+】
[TCP粘包和拆包](https://blog.csdn.net/ailunlee/article/details/95944377)
[Netty解决粘包和拆包问题的四种方案](https://blog.csdn.net/yuandengta/article/details/108372312)
```markdown
TCP是个“流”协议，没有界限的一串数据。TCP底层并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分，
一个完整的包可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。
**TCP粘包是指：发送方发送的若干包数据到接收方接收时粘成一包。**
粘包和拆包原因
    （1）要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包；
    （2）接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包；
    （3）要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包；
    （4）待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。即TCP报文长度-TCP头部长度>MSS。
粘包和拆包解决策略
    由于底层的TCP无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的，这个问题只能通过上层的应用协议栈设计来解决，
    根据业界的主流协议的解决方案，归纳如下： 
        1.消息定长。发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。
        2.设置消息边界。服务端从网络流中按消息边界分离出消息内容。在包尾增加回车换行符进行分割，例如FTP协议。
        3.将消息分为消息头和消息体，消息头中包含表示消息总长度（或者消息体长度）的字段。
        4.更复杂的应用层协议。通过自定义协议进行粘包和拆包的处理。
```
### 8.TCP的滑动窗口及作用【5+】
![](https://www.cnblogs.com/images/cnblogs_com/tanshaoshenghao/1426602/o_%e7%bd%91%e7%bb%9c7.png)
```markdown
RTT:发送一个数据包到收到对应的ACK所花费的时间。
RTO:重传时间间隔。
滑动窗口左边的是已发送并且被确认的分组，滑动窗口右边是还没有轮到的分组。
滑动窗口里面也分为两块，一块是已经发送但是未被确认的分组，另一块是窗口内等待发送的分组。
随着已发送的分组不断被确认，窗口内等待发送的分组也会不断被发送。整个窗口就会往右移动，让还没轮到的分组进入窗口内。
滑动窗口起到了一个限流的作用，也就是说当前滑动窗口的大小决定了当前TCP发送包的速率，
而滑动窗口的大小取决于拥塞控制窗口和流量控制窗口的两者间的最小值。
**TCP使用滑动窗口进行流量控制和乱序重排：保证TCP的可靠性，保证TCP的流控特性。**
    流量控制是为了控制发送方发送速率，保证接收方来得及接收。
    接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。
回答了从效率角度数据分包后一次发送多个，窗口大小和流量控制拥塞控制挂钩，批量确认应答，超时重传，这几个角度
```
### 9.TCP和UDP的区别及报文格式【10+】
#### 1.TCP和UDP区别
[聊聊UDP、TCP和实现一个简单的JAVA UDP小Demo](https://www.cnblogs.com/huangqingshi/p/12950639.html)
```markdown
TCP和UDP都是OSI模型中运输层的协议，TCP提供可靠的通信运输，UDP则被用于广播和细节扩展交给应用的通信运输。
TCP:面向连接，可靠，字节流  传输效率低，需要资源多  文件，邮件传输  首部20-60字节  HTTP,FTP,SMTP
UDP:无连接，不可靠，数据报文段  传输效率高，需要资源少  语音，视频直播 首部8个字节  RIP,DNS,SNMP
UDP的特点：
    - 面向非连接
    - 不维护连接状态，支持同时向多个客户端传输相同的消息
    - 数据包报头只有8个字节，额外开销小。
    - 吞吐量最后受限于数据生成速率，传输速率以及集群机器性能。
    - 尽最大努力交付，不保证可靠交付，不需要维持复杂的连接状态表。
    - 面向报文，不对应用程序提交的报文信息进行拆分或者合并。
1.UDP在传送数据之前不需要先建立连接，远地主机在收到UDP报文后，不需要给出任何确认。
    虽然UDP不提供可靠交付，但在某些情况下UDP确是一种最有效的工作方式（一般用于即时通信）
2.TCP提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP不提供广播或多播服务。
    由于TCP要提供可靠的，面向连接的传输服务。TCP一般用于文件传输、发送和接收邮件、远程登录等场景。
UDP的优点：HTTP3.0使用UDP，UDP是面向无连接的，传输效率高，资源消耗少。
如何让UDP实现可靠传输?
[udp如何实现可靠性传输？](https://blog.csdn.net/gettogetto/article/details/76736365)
    传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。
    实现确认机制、重传机制、窗口确认机制。
    如果你不利用Linux协议栈以及上层socket机制，自己通过抓包和发包的方式去实现可靠性传输，那么必须实现如下功能：
    发送：包的分片、包确认、包的重发
    接收：包的调序、包的序号确认
    目前有如下开源程序利用udp实现了可靠的数据传输。分别为RUDP、RTP、UDT。
```
[tcp、udp、ip、icmp报文格式分析](https://www.cnblogs.com/znl233/p/9968592.html)
#### ​2.TCP报文格式
![](https://camo.githubusercontent.com/a0559d56c56e8dddd573e28959aadc165c2ab468/68747470733a2f2f6661726d312e737461746963666c69636b722e636f6d2f3739322f32373139343038383436385f346362303134316663385f622e6a7067)
```markdown
​源端口号和目的端口号：
    ​ 用于寻找发端和收端应用进程。这两个值加上ip首部源端ip地址和目的端ip地址唯一确定一个tcp连接。
​序号字段：
    ​ 序号用来标识从TCP发端向TCP收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节。
     如果将字节流看作在两个应用程序间的单向流动，则TCP用序号对每个字节进行计数。序号是32 bit的无符号数，序号到达 2^32-1后又从0开始。
　　  当建立一个新的连接时，SYN标志变1。序号字段包含由这个主机选择的该连接的初始序号ISN（Initial Sequence Number）。
     该主机要发送数据的第一个字节序号为这个ISN加1，因为SYN标志消耗了一个序号。
​确认序号：
​     既然每个传输的字节都被计数，确认序号包含发送确认的一端所期望收到的下一个序号。因此，确认序号应当是上次已成功收到数据字节序号加1。
     只有ACK标志为 1时确认序号字段才有效。发送ACK无需任何代价，因为32bit的确认序号字段和ACK标志一样，总是TCP首部的一部分。
     因此，我们看到一旦一个连接建立起来，这个字段总是被设置，ACK标志也总是被设置为1。TCP为应用层提供全双工服务。
     这意味数据能在两个方向上独立地进行传输。因此，连接的每一端必须保持每个方向上的传输数据序号。
​首都长度：
    ​ 首部长度给出首部中32bit字的数目。需要这个值是因为任选字段的长度是可变的。这个字段占4bit，因此TCP最多有60字节的首部。
     然而，没有任选字段，正常的长度是20字节。
​标志字段：在TCP首部中有6个标志比特。它们中的多个可同时被设置为1. URG紧急指针（u rgent pointer）有效 ，ACK确认序号有效。
      PSH接收方应该尽快将这个报文段交给应用层。RST重建连接。SYN同步序号用来发起一个连接。FIN发端完成发送任务。
窗口大小：
​     TCP的流量控制由连接的每一端通过声明的窗口大小来提供。窗口大小为字节数，起始于确认序号字段指明的值，这个值是接收端期望接收的字节。
     窗口大小是一个16bit字段，因而窗口大小最大为65535字节。
​检验和：
    ​ 检验和覆盖了整个的TCP报文段：TCP首部和TCP数据。这是一个强制性的字段，一定是由发端计算和存储，并由收端进行验证。
​紧急指针：
​     只有当URG标志置1时紧急指针才有效。紧急指针是一个正的偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。TCP的紧急方式是发送端向另一端发送紧急数据的一种方式。
​ 选项：
    ​ 最常见的可选字段是最长报文大小，又称为MSS(Maximum Segment Size)。每个连接方通常都在通信的第一个报文段（为建立连接而设置 SYN标志的那个段）中指明这个选项。它指明本端所能接收的最大长度的报文段。
```
#### ​3.UDP报文格式
![](https://camo.githubusercontent.com/7a4a8a8bd76bad9b8301c63543ac6225a1df961b/68747470733a2f2f617070776b2e62616964752e636f6d2f6e616170692f646f632f766965773f69683d343832266f3d706e675f365f305f305f3137365f3931375f3530345f3234375f3839322e3937395f313236322e3837392669773d3938362669783d302669793d302661696d773d39383626726e3d3126646f635f69643d31383264393335633331383662636562313865386262373726706e3d31267369676e3d623838626461303362393935346535303636323266393762386232616534333826747970653d31266170705f7665723d322e392e382e322675613d62645f3830305f3830305f496e6372656469626c65535f322e392e382e325f322e332e37266269643d31266170705f75613d496e6372656469626c6553267569643d26637569643d2666723d33264264695f626561723d574946492666726f6d3d335f31303030302662647573733d267069643d312673637265656e3d3830305f383030267379735f7665723d322e332e37)
```markdown
​端口号：
​   用来表示发送和接受进程。由于IP层已经把IP数据报分配给TCP或UDP（根据IP首部中协议字段值），因此TCP端口号由TCP来查看，而UDP端口号由UDP来查看。TCP端口号与UDP端口号是相互独立的。
​长度：
​ UDP长度字段指的是UDP首部和UDP数据的字节长度。该字段的最小值为 8字节（发送一份0字节的UDP数据报是OK）。
​检验和：
​ UDP检验和是一个端到端的检验和。它由发送端计算，然后由接收端验证。其目的是为了发现UDP首部和数据在发送端到接收端之间发生的任何改动。
```
#### 4.IP报文格式：普通的IP首部长为20个字节，除非含有可选项字段。
![](https://camo.githubusercontent.com/0521f7f7a0a63630337192e46078717de2b5d128/68747470733a2f2f7373302e62647374617469632e636f6d2f37306346754853685f5131596e78476b706f574b314846366868792f69742f753d313631343331323739322c3139353435383137363026666d3d32362667703d302e6a7067)
```markdown
4位版本：
​ 目前协议版本号是4，因此IP有时也称作IPV4.
​ 4位首部长度：
​ 首部长度指的是首部占32bit字的数目，包括任何选项。由于它是一个4比特字段，因此首部长度最长为60个字节。
​ 服务类型（TOS）：
​ 服务类型字段包括一个3bit的优先权字段（现在已经被忽略），4bit的TOS子字段和1bit未用位必须置0。4bit的TOS分别代表：最小时延，最大吞吐量，最高可靠性和最小费用。4bit中只能置其中1比特。如果所有4bit均为0，那么就意味着是一般服务。
​ 总长度：
​ 总长度字段是指整个IP数据报的长度，以字节为单位。利用首部长度和总长度字段，就可以知道IP数据报中数据内容的起始位置和长度。由于该字段长16bit，所以IP数据报最长可达65535字节。当数据报被分片时，该字段的值也随着变化。
​ 标识字段：
​ 标识字段唯一地标识主机发送的每一份数据报。通常每发送一份报文它的值就会加1。
​ 生存时间：
​ TTL（time-to-live）生存时间字段设置了数据报可以经过的最多路由器数。它指定了数据报的生存时间。TTL的初始值由源主机设置（通常为 3 2或6 4），一旦经过一个处理它的路由器，它的值就减去 1。当该字段的值为 0时，数据报就被丢弃，并发送 ICMP 报文通知源主机。
​ 首部检验和：
​ 首部检验和字段是根据 I P首部计算的检验和码。它不对首部后面的数据进行计算。 ICMP、IGMP、UDP和TCP在它们各自的首部中均含有同时覆盖首部和数据检验和码。
```
#### ​5.以太网报文格式
![](https://camo.githubusercontent.com/c4fdca94f84cc26b2a8ad29c3f5c5cba6fd36bef/68747470733a2f2f7373302e62647374617469632e636f6d2f37306346764853685f5131596e78476b706f574b314846366868792f69742f753d323733333537363739372c353536373737323726666d3d32362667703d302e6a7067)
```markdown
​ 目的地址和源地址：
​ 是指网卡的硬件地址（也叫MAC 地址），长度是48位，是在网卡出厂时固化的。
​ 数据：
​ 以太网帧中的数据长度规定最小46字节，最大1500字节，ARP和RARP数据包的长度不够46字节，要在后面补填充位。
最大值1500 称为以太网的最大传输单元（MTU），不同的网络类型有不同的MTU，如果一个数据包从以太网路由到拨号链路上，数据包度大于拨号链路的MTU了，则需要对数据包进行分片fragmentation）。
ifconfig 命令的输出中也有“MTU:1500”。注意，MTU 个概念指数据帧中有效载荷的最大长度，不包括帧首部的长度。
```
### 10.TCP协议如何保证可靠传输和有序传输【10+】
[你还在为TCP重传、滑动窗口、流量控制、拥塞控制发愁吗？看完图解就不愁了](https://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&mid=2453143215&idx=2&sn=e9e767ebcbd2fce4688ba71db4fbd32d&chksm=8cf2dc2cbb85553aa034a49abf9c172ebe0d89e6332f87bd9038bc53b6c9642a835f499c8b44&mpshare=1&scene=23&srcid=&sharer_sharetime=1591507618951&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
```markdown
​TCP通过**应用数据分割、对数据包进行编号、数据校验和、流量控制、拥塞控制、ARP协议、超时重传**等措施保证数据的可靠传输；
1.应用数据被分割成TCP认为最适合发送的数据块。
2.TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。
3.**数据包校验和**:TCP将保持它首部和数据的检验和。是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。
    如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。
4.TCP的接收端会丢弃重复的数据：对于重复数据，能够丢弃重复数据。
5.**流量控制**：TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。
    [通俗易懂讲解TCP流量控制机制，了解一下](https://www.cnblogs.com/kubidemanong/p/9987810.html)
    当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。
    TCP使用的流量控制协议是可变大小的滑动窗口协议。（TCP利用滑动窗口实现流量控制）
6.**拥塞控制**：当网络拥塞时，减少数据的发送，降低整个网络的拥塞程度。
    [一文读懂拥塞控制](https://www.cnblogs.com/kubidemanong/p/9973757.html)
    TCP的拥塞控制采用了四种算法，即慢开始、拥塞避免、快重传和快恢复。
    ​拥塞控制目的：为了防止过多的数据注入到网络中，避免网络中的路由器、链路过载
    ​拥塞控制过程：TCP发送发将维护一个拥塞窗口的状态变量，该变量随着网络拥塞程度动态变化，通过慢开始、拥塞避免等算法减少网络拥塞的发生。
7.**ARQ协议(自动重传请求)**：也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。
8.**超时重传**：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。
9.**TCP利用滑动窗口实现流量控制**。流量控制是为了控制发送方发送速率，保证接收方来得及接收。
    接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为0，则发送方不能发送数据。
```
### 11.在地址栏键入URL后，网络世界发生了什么流程？【10+】
[一文摸透从输入URL到页面渲染的过程](https://www.cnblogs.com/AhuntSun-blog/p/12641050.html)
```markdown
在键入URL之前，刚开完机的时候，需要联网，然后才能上网。
    这个阶段包括了获取本机IP地址，获取DNS服务器IP地址，获得网关路由器IP和MAC地址等操作。
--获取本机IP地址，DNS服务器地址，网关路由器地址
--1.浏览器获取域名的IP地址 --DNS域名解析:获取域名对应IP  DNS查找IP过程：浏览器缓存，路由器缓存，DNS缓存
--2.浏览器向web发送一个HTTP请求，-- 三次握手建立TCP连接  TCP:与服务器建立TCP连接，IP:建立TCP协议时，需要发送数据，发送数据在网络层使用IP协议。
--3.建立连接后进行数据交互发送HTTP请求,服务器处理请求并返回HTTP报文,请求结束关闭TCP连接,四次挥手。
    OPSF:Ip数据在路由器之间，路由选择使用OSPF协议。ARP:路由器在于服务器通信时，需要将IP地址转换为MAC地址，需要使用ARP协议。
    HTTP：在TCP建立完成后，使用HTTP协议访问网页。
--4.浏览器解析渲染页面 构建DOM树 样式计算 页面布局 生成分层树 栅格化 显示
--5.合成与显示 连接结束。
```
### 12.Cookie&session&Token
#### 1.Cookie，Cookie的使用过程【5+】
[Cookie＆Session](https://www.cnblogs.com/taojietaoge/p/11341767.html)
```markdown
由于http协议是无状态协议，如果客户通过浏览器访问web应用时没有一个保存用户访问状态的机制，那么将不能持续跟踪应用的操作。
cookie是浏览器的一种缓存机制，它可用于维持客户端与服务器端之间的会话。HTTP/1.1引入Cookie来保存状态信息。
随着现代浏览器开始支持各种各样的存储方式，Cookie渐渐被淘汰。新的浏览器API已经允许开发者直接将数据存储到本地。
Server拿到Cookie后，通过什么信息才能判断是哪个Client呢？服务器的SessionID。
**cookie的使用过程：**
    1.首先用户在客户端浏览器向服务器发起登陆请求
    2.登陆成功后，服务端会把登陆的用户信息设置cookie中，返回给客户端浏览器
    3.客户端浏览器接收到cookie请求后，会把cookie保存到本地（可能是内存，也可能是磁盘，看具体使用情况而定）
    4.以后再次访问该web应用时，客户端浏览器就会把本地的cookie带上，这样服务端就能根据cookie获得用户信息了。
```
#### 2.什么是session，有哪些实现session的机制？实现分布式session的方式?【5+】
```markdown
session是一种维持客户端与服务器端会话的机制。但是与cookie把会话信息保存在客户端本地不一样,session把会话保留在**服务器端**。
存储在服务器端的信息更加安全。存储在服务器上的文件、数据库或者内存中。也可以将Session存储在Redis这种内存型数据库中，效率会更高。
**session的使用过程：**
    1.首先用户在客户端浏览器发起登陆请求
    2.登陆成功后，服务端会把用户信息保存在服务端，并返回一个唯一的session标识给客户端浏览器。
    3.客户端浏览器会把这个唯一的session标识保存在起来
    4.以后再次访问web应用时，客户端浏览器会把这个唯一的session标识带上，这样服务端就能根据这个唯一标识找到用户信息。
```
#### 3.session和cookie有什么区别【5+】
[](https://www.cnblogs.com/yangmaosen/p/13710700.html)
```markdown
在许多web应用中，session机制就是通过cookie来实现的。或者使用URL回写实现。
    1.cookie是浏览器提供的一种缓存机制，它可以用于维持客户端与服务端之间的会话。**一般用来保存用户信息**。
    2.session指的是**维持客户端与服务端会话的一种机制**，它可以通过cookie实现，也可以通过别的手段实现。
    3.如果用cookie实现会话，那么会话会保存在**客户端**浏览器中，而session机制提供的会话是保存在**服务端**的。
    4.**Cookie只能存储ASCII码字符串，而Session则可以存储任何类型的数据**，因此在考虑数据复杂性时首选Session；
    5.Cookie存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在Cookie中，可以将Cookie值进行加密，然后在服务器进行解密；
    6.对于大型网站，如果用户所有的信息都存储在Session中，那么开销是非常大的，因此不建议将所有的用户信息都存储到Session中。
    7.存储的多样性：session可以存储在Redis中，数据库中，应用程序中；而cookie只能存储在浏览器中。
```
#### 4.Token【5+】
[基于token的会话保持机制](https://www.cnblogs.com/54chensongxia/p/13491214.html)
```markdown
适用于前后端分离的项目（前后端代码运行在不同的服务器下）
    请求登录时，token和session id原理相同，是对key和key对应的用户信息进行加密后的加密字符，登录成功后，
    会在响应主体中将{token：“字符串”}返回给客户端。客户端通过cookie都可以进行存储。
    再次请求时不会默认携带，需要在请求拦截器位置给请求头中添加认证字段Authorization携带token信息，服务器就可以通过token信息查找用户登录状态。
基于token的认证机制将认证信息返回给客户端并存储。下次访问其他页面，需要从客户端传递认证信息回服务端。简单的流程如下：
    1.客户端使用用户名跟密码请求登录；
    2.服务端收到请求，去验证用户名与密码；
    3.验证成功后，服务端会签发一个Token，再把这个Token发送给客户端；
    4.客户端收到Token以后可以把它存储起来，比如放在Cookie里或者Local Storage里；
    5.客户端每次向服务端请求资源的时候需要带着服务端签发的Token；
    6.服务端收到请求，然后去验证客户端请求里面带着的Token，如果验证成功，就向客户端返回请求的数据；
基于token的验证机制，有以下的优点：
    1.支持跨域访问，将token置于请求头中，而cookie是不支持跨域访问的；
    2.无状态化，服务端无需存储token，只需要验证token信息是否正确即可，而session需要在服务端存储，一般是通过cookie中的sessionID在服务端查找对应的session；
    3.无需绑定到一个特殊的身份验证方案（传统的用户名密码登陆），只需要生成的token是符合我们预期设定的即可；
    4.更适用于移动端（Android，iOS，小程序等等），像这种原生平台不支持cookie，
        比如说微信小程序，每一次请求都是一次会话，当然我们可以每次去手动为他添加cookie，详情请查看博主另一篇博客；
    5.避免CSRF跨站伪造攻击，还是因为不依赖cookie；
```
### 16.Socket
[Java Socket(套接字)编程、TCP和UDP通信过程详解](https://blog.csdn.net/Dove_Knowledge/article/details/71171471)
```markdown
套接字是网络编程中的一种通信机制，是支持TCP/IP的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，
    简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。
Socket是TCP/IP的抽象，是操作系统对外开放的接口。
Socket通信流程：
```
### 17.长链接和短链接【4+】
>> 在web开发中。假设大多数的url太长 ，怎么转成短链接？ （数据库存储 然后重定向）
```markdown
HTTP1.0的时候默认使用短连接，意思就是没进行一个HTTP操作都需要进行一次连接，如果网页包含其他的资源，每遇到一个资源都需要重新进行一次HTTP连接。
1.1则默认使用长连接。当一个网页打开后，传输的TCP连接在一定时间内是不会关闭的，如果这期间有其他的请求，就会直接进行传输
长链接：多用于操作频繁，点对点的通讯，而且连接数不能太多的情况。都需要TCP三次建立连接。
短链接：长链接对于服务端会耗费一定的资源，web网站的HTTP服务一般都用短链接。
```
### 18.重定向和转发区别【5+】
```markdown
​ 重定向：redirect：
​       地址栏发生变化
​       重定向可以访问其他站点（服务器）的资源
​       重定向是两次请求。不能使用request对象来共享数据
​ 转发：forward：
​       转发地址栏路径不变
​       转发只能访问当前服务器下的资源
​       转发是一次请求，可以使用request对象共享数据
forward比redirect效率高。
```
### 3.[30张图解HTTP常见的面试题](https://www.cnblogs.com/xiaolincoding/p/12442435.html)
[炸裂！万字长文拿下HTTP！](https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&mid=2650129667&idx=3&sn=274618362eb9e759ef62386f731e4950&chksm=f36bd822c41c5134360f576d1970af267bc05e85e7699a8edca695dfd235bde7b78078301ff7&mpshare=1&scene=23&srcid=&sharer_sharetime=1590882441576&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
#### 3.1.HTTP1.0与HTTP1.1之间的区别【3+】
```markdown
HTTP1.0：默认使用Connection:cloose，浏览器每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立即断开TCP连接（无连接），服务器不跟踪每个客户端也不记录过去的请求（无状态）。
​HTTP1.1：默认使用Connection:keep-alive（长连接），避免了连接建立和释放的开销；通过Content-Length字段来判断当前请求的数据是否已经全部接受。不允许同时存在两个并行的响应。
​HTTP2.0：引入二进制数据帧和流的概念，其中帧对数据进行顺序标识；因为有了序列，服务器可以并行的传输数据。
​ http1.0和http1.1的主要区别如下：
 0.1.1新增了连接管理即keepalive，允许持久连接。
​ 1、新增缓存的控制和管理。1.1添加更多的缓存控制策略（如：Entity tag，If-Match）
​ 2、网络连接的优化：1.1支持断点续传，支持 pipeline，无需等待前面的请求响应，即可发送第二次请求。
​ 3、错误状态码的增多：1.1新增了24个错误状态响应码，丰富的错误码更加明确各个状态
​ 4、Host头处理：支持Host头域，不在以IP为请求方标志
​ 5、长连接：在HTTP/1.0中，默认使用的是短链接，HTTP/1.1中，默认使用的是长链接，默认开启Connection:keep-alive
```
#### 3.2.HTTP2.0及http1.1和http2.0的主要区别【2+】
[HTTP2.0](https://www.cnblogs.com/operationhome/p/12577540.html)
```markdown
HTTP/2（超文本传输协议第2版，最初命名为HTTP2.0），简称为h2（基于TLS/1.2或以上版本的加密连接）或h2c（非加密连接)，是HTTP协议的的第二个主要版本。
HTTP2新特性：
    1.头数据压缩 Data compression of HTTP headers
    2.服务器推送 HTTP/2 Server Push
    4.管线化请求 Pipelining of requests，支持一个 TCP 连接发起多请求。
    5.对数据传输采用多路复用，让多个请求合并在同一 TCP连接内Multiplexing multiple requests over a single TCP connection，
        因为每一个tcp连接在创建的时候都需要耗费资源，而且在创建初期，传输也是比较慢的。
    3.采用了二进制而非明文来打包、传输 客户端<——>服务器 间的数据。
​http1.1和http2.0的主要区别：
​ 1、新的传输格式：2.0使用二进制格式，1.0依然使用基于文本格式
​ 2、多路复用：连接共享，不同的request可以使用同一个连接传输（最后根据每个request上的id号组合成 正常的请求）
​ 3、header压缩：由于1.X中header带有大量的信息，并且得重复传输，2.0使用encoder来减少需要传输的 hearder大小
​ 4、服务端推送：同google的SPDUY（1.0的一种升级）一样
```
#### 3.3.HTTP3.0
```markdown
使用UDP
把 TCP 可靠、有序的功能提到应用层来实现，因此 Google 就研究出了 QUIC 协议。
QUIC 层来实现自己的丢包重传和拥塞控制，还有出于安全的考虑我们都会用 HTTPS ，所以需要多次握手。
```
#### 3.3.HTTPS的工作流程【5+】
```markdown
1.Client使用https的URL访问Server，要求与Server建立SSL连接
2.Server把事先配置好的公钥证书返回给客户端。
3.Client验证公钥证书：比如是否在有效期内，证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，
    直到验证到根证书（操作系统内置的Root证书或者Client内置的Root证书）。如果验证通过则继续，不通过则显示警告信息。
4.Client使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给Server。
5.Server使用自己的私钥（private key）解密这个消息，得到对称密钥。至此，Client和Server双方都持有了相同的对称密钥。
6.Server使用对称密钥加密“明文内容A”，发送给Client。
7.Client使用对称密钥解密响应的密文，得到“明文内容A”。
8.Client再次发起HTTPS的请求，使用对称密钥加密请求的“明文内容B”，然后Server使用对称密钥解密密文，得到“明文内容B”。
```
#### 3.4.HTTPS的优缺点【5+】
```markdown
尽管HTTPS并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，
但HTTPS仍是现行架构下最安全的解决方案，主要有以下几个好处：
    1.使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；
    2.HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。
    3.HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。
    4.谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。
虽然说HTTPS有很大的优势，但其相对来说，还是存在不足之处的：
    1.HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电；
    2.HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；
    3.SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。
    4.SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。
    5.HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。
        最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。
```
#### 3.5.讲一下HTTP与HTTPS的特点和区别，HTTP请求和响应的步骤【10+】
```markdown
超文本传输协议HTTP的主要特点：
    - 支持客户/服务器模式
    - 简单快速
    - 灵活
    - 无连接
    - 无状态
HTTP和HTTPS的主要区别在于
    HTTP协议传递的是明文数据，而HTTPS传递的是加密过的数据，也就是说HTTPS更具有安全性。
    也正由HTTPS需要保证安全性，所以它的性能要比HTTP差一点。
    HTTP的端口是80，HTTPS的端口是443
    在OSI七层网络模型中，HTTP是工作在应用层，而HTTPS工作在传输层。
    HTTPS中使用到的对称加密，非对称加密，CA，数字证书的概念HTTPS想要保证客户端与服务器之间的通信安全，就得使用对称加密算法进行加密。
    协商对称加密算法的过程通过非对称加密算法来保证。在非对称加密算法中，客户端获得公钥的过程需要第三方机构（CA）通过颁发数字证书保证安全性。
SSL(Security Sockets layer,安全套接字)
    - 为网络通信提供安全及数据完整性的一种安全协议
    - 是操作系统对外的API,SSL3.0后改名为TLS
    - 采用身份验证和数据加密保证网络通信的安全和数据的完整性。
HTTP请求和响应的步骤：
    - 客户端连接到Web服务器
    - 发送HTTP请求
    - 服务器接收到请求并且返回HTTP响应
    - 释放连接TCP连接
    - 客户端浏览器解析HTML内容
```
#### SSL证书(HTTPS)背后的加密算法
[SSL证书(HTTPS)背后的加密算法](https://juejin.im/post/6844903814378553358)
```markdown
加解密算法目前主流的分为对称加密和非对称加密。
    1.对称加密（共享密匙加密）：客户端和服务器公用一个密匙用来对消息加解密，这种方式称为对称加密。
        客户端和服务器约定好一个加密的密匙。客户端在发消息前用该密匙对消息加密，发送给服务器后，服务器再用该密匙进行解密拿到消息。
        对称加密的优点：对称加密解决了http中消息保密性的问题对称加密的缺点：对称加密虽然保证了消息保密性，但是因为客户端和服务器共享一个密匙，这样就使得密匙特别容易泄露。
        因为密匙泄露风险较高，所以很难保证消息来源的可靠性、消息的完整性和准确性。
    2.非对称加密（公有密匙加密）：采用非对称加密时，客户端和服务端均拥有一个公有密匙和一个私有密匙。公有密匙可以对外暴露，而私有密匙只有自己可见。
        使用公有密匙加密的消息，只有对应的私有密匙才能解开。反过来，使用私有密匙加密的消息，只有公有密匙才能解开。这样客户端在发送消息前，先用服务器的公匙对消息进行加密，服务器收到后再用自己的私匙进行解密。
        非对称加密的优点：非对称加密采用公有密匙和私有密匙的方式，解决了http中消息保密性问题，而且使得私有密匙泄露的风险降低。
        因为公匙加密的消息只有对应的私匙才能解开，所以较大程度上保证了消息的来源性以及消息的准确性和完整性。
        非对称加密的缺点：非对称加密时需要使用到接收方的公匙对消息进行加密，但是公匙不是保密的，任何人都可以拿到，中间人也可以。
        那么中间人可以做两件事，第一件是中间人可以在客户端与服务器交换公匙的时候，将客户端的公匙替换成自己的。这样服务器拿到的公匙将不是客户端的，而是服务器的。
        服务器也无法判断公匙来源的正确性。第二件是中间人可以不替换公匙，但是他可以截获客户端发来的消息，然后篡改，然后用服务器的公匙加密再发往服务器，服务器将收到错误的消息。
        非对称加密的性能相对对称加密来说会慢上几倍甚至几百倍，比较消耗系统资源。正是因为如此，https将两种加密结合了起来。
HTTPS使用数字证书和数字签名来解决。为了解决非对称加密中公匙来源的不安全性。
    1.数字证书的申请,向CA(认证中心)来申请数字证书。
        申请的过程大致是：自己本地先生成一对密匙，然后拿着自己的公匙以及其他信息（比如说企业名称啊什么的）去CA申请数字证书。
        CA在拿到这些信息后，会选择一种单向Hash算法（比如说常见的MD5）对这些信息进行加密，加密之后的东西我们称之为摘要。
        单向Hash算法有一种特点就是单向不可逆的，只要原始内容有一点变化，加密后的数据都将会是千差万别，这样就防止了信息被篡改。
        生成摘要后还不算完，CA还会用自己的私匙对摘要进行加密，摘要加密后的数据我们称之为数字签名。
        最后，CA将会把我们的申请信息（包含服务器的公匙）和数字签名整合在一起，由此而生成数字证书。然后CA将数字证书传递给我们。
    2.数字证书怎么起作用
        服务器会将数字证书发送给客户端，客户端就需要用CA的公匙解密数字证书并验证数字证书的合法性。
        客户端用CA的公匙解密数字证书，如果解密成功则说明证书来源于合法的认证机构。解密成功后，客户端就拿到了摘要。
HTTPS使用SSL（Secure Scoket Layer 安全套接层）
    HTTPS数据传输流程（HTTPS链接建立的过程）：
        - 浏览器/客户端将支持的加密算法信息发送给服务器
        - 服务器选择一套浏览器支持的加密算法，以SSL证书的形式回发浏览器/客户端。 内容包括：证书的发布机构、有效期、所有者、签名以及公钥
        - 浏览器/客户端验证证书的合法性，校验为真则结合证书公钥秘钥加密信息发送给服务器
        - 服务器使用私钥解密信息，验证哈希，使用对称密钥加密响应消息回发浏览器/客户端
        - 浏览器/客户端解密响应消息，并且对消息进行验真，之后进行加密交互数据
        - 随后客户端和服务端就使用对称密钥进行信息传输
```
#### 3.6.HTTP的常见状态码有哪些，代表什么含义？【5+】
[面试被问了三次的http状态码到底有什么](https://www.cnblogs.com/chentang/p/12845775.html)
>> HTTP状态码是用以表示网页服务器超文本响应状态的3位数字代码。
>> 核心作用就是http状态码核心作用是Web Server服务器用来告诉客户端，当前的网页请求发生了什么事，或者说当前Web服务器的响应状态。
>> HTTP状态码常用来判断和分析当前Web服务器的运行状况。
```markdown
**首先状态码的开头不同代表不同的类型：**
    1xx：代表指示信息，表示请求已接收，继续处理
    2xx：代表成功，表示请求已被成功接收，理解，接受
    3xx：重定向，表示完成请求必须进行进一步的操作
    4xx：客户端错误，请求有语法错误或请求无法实现
    5xx：服务器端错误，服务器未能实现合法的请求
**常见状态码：**
    200 OK：正常返回信息
    204 No Content：表示客户端发送给客户端的请求得到了成功处理，但在返回的响应报文中不含实体的主体部分（没有资源可以返回）
    206 Patial Content：表示客户端进行了范围请求，并且服务器成功执行了这部分的GET请求，响应报文中包含由Content-Range指定范围的实体内容。
    301 Moved Permanently：永久性重定向，表示请求的资源被分配了新的URL，之后应使用更改的URL；
    302 Found：临时性重定向，表示请求的资源被分配了新的URL，希望本次访问使用新的URL；
    303 See Other：表示请求的资源被分配了新的URL，应使用GET方法定向获取请求的资源
    400 Bad Request：客户端请求有语法错误，不能被服务器所理解
    401 Unauthorized:请求未被授权，必须和WWW-Authenticate报头域一起
    403 Forbidden：服务器收到请求，但是拒绝提供服务
    404 Not Found：请求资源不存在，输入了错误的URL
    500 Internal Server Error：服务器发生不可预期错误
    503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常
```
#### 3.7.GET请求和POST请求的区别,HTTP请求有哪些【5+】
```markdown
HTTP的请求格式主要包含三个信息：1、请求的类型（GET或POST），2、要访问的资源（如resimga.jif），3、HTTP版本（http/1.1）。
GET请求，请求的数据会附加在URL之后，以?分割URL和传输数据，多个参数⽤&连接。
    URL的编码格式采⽤的是ASCII编码，⽽不是unicode，即是说所有的⾮ASCII字符都要编码之后再传输。
POST请求：POST请求会把请求的数据放置在HTTP请求包的包体中。
    因此，GET请求的数据会暴露在地址栏中，⽽POST请求则不会。
	    GET	                                          POST
可见性	数据在URL中对所有人可见	                数据不会显示在URL中
安全性	get的安全性较差,发送的数据是URL的一部分	  安全，因为参数不会被保存在浏览器历史或web服务器日志中
数据长度	受限制，最长2kb	                               无限制
编码类型	application/x-www-form-urlencoded	multipart/form-data
缓存	      能被缓存	                                 不能被缓存
1.传输数据的⼤⼩  -- 从HTTP报文层面来看，GET请求将信息放在URL，POST将请求信息放在请求体中，
    在HTTP规范中，没有对URL的⻓度和传输的数据⼤⼩进⾏限制。但是在实际开发过程中，对于GET，特定的浏览器和服务器对URL的⻓度有限制。
    因此，在使⽤GET请求时，传输数据会受到URL⻓度的限制。
    对于POST，由于不是URL传值，理论上是不会受限制的，但是实际上各个服务器会规定对POST提交数据⼤⼩进⾏限制，Apache、IIS都有各⾃的配置。
2.安全性  -- 从数据库层面来看，GET符合幂等性和安全性，而POST请求不符合。
    POST的目的是传送实体主体内容，内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。
3.从其他层面来看，GET请求能够被缓存，GET请求能够保存在浏览器的浏览记录里，GET请求的URL能够保存为浏览器书签。这些都是POST请求所不具备的。
GET	    向特定资源发送请求，查询数据，并返回实体
POST	向指定资源提交数据进行处理请求，可能会导致新的资源建立、已有资源修改
PUT	    向服务器上传新的内容
HEAD	类似GET请求，返回的响应中没有具体的内容，用于获取报头
DELETE	请求服务器删除指定标识的资源
OPTIONS	可以用来向服务器发送请求来测试服务器的功能性
TRACE	回显服务器收到的请求，用于测试或诊断
CONNECT	HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器
```
####  ping的工作原理
[ping 的工作原理](https://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&mid=2453142815&idx=2&sn=c1b16ab077446435ccd8a6bc98d5b559&chksm=8cf2df9cbb85568a855e6d51e882292e3565d50fcb8462c27df0fe0063882af9db29e136fe70&mpshare=1&scene=23&srcid=&sharer_sharetime=1590987976205&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
```markdown
ping是基于**ICMP协议**工作的,ICMP全称是Internet Control Message Protocol，也就是互联网控制报文协议。
ICMP主要的功能包括：确认IP包是否成功送达目标地址、报告发送过程中IP包被废弃的原因和改善网络设置等。
ICMP报文是封装在IP包里面，它工作在网络层，是IP协议的助手。
![ICMP 包头格式](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcZiaMXRx5FarzuAMKmf0Cj29gb37HdxOjFprAJ1zycOxZdHEbz4tafArtrZFAibw90Dn1BJmgaG5eg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
ICMP包头的类型字段，大致可以分为两大类：
    一类是用于诊断的查询消息，也就是「查询报文类型」
    另一类是通知出错原因的错误消息，也就是「差错报文类型」
使用ping时，所用到的协议：通过DNS协议，将ping后接的域名转换为ip地址。（DNS使用的传输层协议是UDP）
                        通过ARP解析服务，由ip地址解析出MAC地址，以在数据链路层传输。
```
#### [TCP参数及Linux操作系统调节TCP参数](https://www.cnblogs.com/xiaolincoding/p/13067971.html)
```markdown

```
### 4.IP基础知识
[IP 基础知识“全家桶”，45 张图一套带走](https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&mid=2650136938&idx=3&sn=67976543452d053f38ef98ad432e2b0a&chksm=f36bfc4bc41c755d9635f4868247f5c32af011e39055a93457a48ea624fa64206337bbc732c7&xtrack=1&scene=90&subscene=93&sessionid=1595738415&clicktime=1595738485&enterid=1595738485&ascene=56&devicetype=android-27&version=27001135&nettype=WIFI&abtest_cookie=AAACAA%3D%3D&lang=zh_CN&exportkey=AZt8sKmIZAR5dAcuhZz%2BTNw%3D&pass_ticket=ti6jCKVPm3InI6pMg16GBXD3aOQEiXkZyc7df%2BpfdJBz1TvM0wxYU9GHpOvyR%2Bqh&wx_header=1)
#### 4.1.IP基础知识
```markdown
IP在TCP/IP参考模型中处于第三层，也就是网络层。
网络层的主要作用是：实现主机与主机之间的通信，也叫点对点（end to end）通信。
IP（网络层）和MAC（数据链路层）之间的区别和关系。
    IP的作用是主机之间通信中的，而MAC的作用则是实现「直连」的两个设备之间通信，而IP则负责在「没有直连」的两个网络之间进行通信传输。
    计算机网络中也需要「数据链路层」和「网络层」这个分层才能实现向最终目标地址的通信。
    源IP地址和目标IP地址在传输过程中是不会变化的，只有源MAC地址和目标MAC一直在变化。
```
#### 4.2.IP地址是基础知识
```markdown
在TCP/IP网络通信时，为了保证能正常通信，每个设备都需要配置正确的IP地址，否则无法实现正常的通信。
IP地址（IPv4 地址）由32位正整数来表示,IP地址在计算机是以二进制的方式处理的。
IP 地址分类成了5种类型，分别是A类、B类、C类、D类、E类。
    类别     IP地址范围                   最大主机数        私有IP地址
    A类 0.0.0.0 - 127.255.255.255         16777214      10.0.0.0 - 10.255.255.255
    B类 128.0.0.0 - 191.255.255.255        65534        182.16.0.0 - 127.31.255.255
    C类 192.0.0.0 - 223.255.255.255        254          192.168.0.0 - 192.168.255.255
    D类 224.0.0.0 - 239.255.255.255        IP多播
    E类 240.0.0.0 - 255.255.255.255        预留使用
广播地址用于在同一个链路中相互连接的主机之间发送数据包。 主机号全为1
多播用于将包发送给特定组内的所有主机。
32 比特的 IP 地址被划分为两部分，前面是网络号，后面是主机号。表示形式 a.b.c.d/x
子网划分实际上是将主机地址分为两个部分：子网网络地址和子网主机地址。
    将子网掩码和 IP 地址按位计算 AND，就可得到网络号。
```
#### 4.3.IP协议【5+】
```markdown
DNS域名解析:DNS可以将域名网址自动转换为具体的IP地址。
ARP与RARP协议:ARP是借助ARP请求与ARP响应两种类型的包确定MAC地址的。
DHCP动态获取IP地址
NAT网络地址转换
ICMP互联网控制报文协议:确认IP包是否成功送达目标地址、报告发送过程中IP包被废弃的原因和改善网络设置等。
IGMP因特网组管理协议：工作在主机（组播成员）和最后一跳路由之间
```
#### 4.4.DNS解析的详细过程
[DNS用的是TCP协议还是UDP协议](https://www.cnblogs.com/wuyepeng/p/9835839.html)
```markdown
DNS占用53号端口，同时使用TCP和UDP协议。
    DNS在区域传输的时候使用TCP协议，其他时候使用UDP协议。
DNS 域名解析，DNS 可以将域名网址自动转换为具体的 IP 地址。
浏览器首先看一下自己的缓存里有没有，如果没有就向操作系统的缓存要，还没有就检查本机域名解析文件 hosts，如果还是没有，就会 DNS 服务器进行查询，查询的过程如下：
1.客户端首先会发出一个 DNS 请求，问 www.server.com 的 IP 是啥，并发给本地 DNS 服务器（也就是客户端的 TCP/IP 设置中填写的 DNS 服务器地址）。
2.本地域名服务器收到客户端的请求后，如果缓存里的表格能找到 www.server.com，则它直接返回 IP 地址。如果没有，本地 DNS 会去问它的根域名服务器：“老大， 能告诉我 www.server.com 的 IP 地址吗？” 根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。
3.根 DNS 收到来自本地 DNS 的请求后，发现后置是 .com，说：“www.server.com 这个域名归 .com 区域管理”，我给你 .com 顶级域名服务器地址给你，你去问问它吧。”
4.本地 DNS 收到顶级域名服务器的地址后，发起请求问“老二， 你能告诉我 www.server.com  的 IP 地址吗？”
5.顶级域名服务器说：“我给你负责 www.server.com 区域的权威 DNS 服务器的地址，你去问它应该能问到”。
6.本地 DNS 于是转向问权威 DNS 服务器：“老三，www.server.com对应的IP是啥呀？” server.com 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。
7.权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。
8.本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。
```
#### 4.5.ARP&RARP
```markdown
ARP 协议是已知 IP 地址 求 MAC 地址，那 RARP 协议正好相反。
ARP 是借助 ARP 请求与 ARP 响应两种类型的包确定 MAC 地址的。
    1.主机会通过广播发送 ARP 请求，这个包中包含了想要知道的 MAC 地址的主机 IP 地址。
    2.当同个链路中的所有设备收到ARP请求时，会去拆开ARP请求包里的内容，如果ARP请求包中的目标IP地址与自己的IP地址一致，那么这个设备就将自己的 MAC 地址塞入 ARP 响应包返回给主机。
```
#### 4.6.DHCP
```markdown
DHCP 交互中，全程都是使用 UDP 广播通信。
```
#### 4.7.NAT
```markdown
网络地址转换 NAT
```


## 二、操作系统
>> [参考博客：5万字、97 张图总结操作系统核心知识点](https://www.cnblogs.com/cxuanBlog/p/13297199.html)
[我和面试官之间关于操作系统的一场对弈](https://www.cnblogs.com/javaguide/p/operating-system.html)
### 1.[参考资料：操作系统总结](https://www.cnblogs.com/blknemo/p/12274600.html)
#### 1.基础概念：并发&并行，共享，虚拟，同步&异步，阻塞&非阻塞【5+】
```markdown
**并发**是指宏观上在一段时间内能同时运行多个程序，而**并行**则指两个进程同时运行。
    并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。操作系统通过引入进程和线程，使得程序能够并发运行。
**共享**是指系统中的资源可以被多个并发进程共同使用。有两种共享方式：互斥共享和同时共享。
    互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。
**虚拟技术**把一个物理实体转换为多个逻辑实体。主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。
    多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。
**虚拟内存**使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，
    地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。
**同步**：当一个同步调用发出后，调用者要一直等待返回结果通知后，才能进行后续的执行。
**异步**：当一个异步过程调用发出后，不必阻塞性地等待返回值或消息。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。
    1、同步的执行效率会比较低，耗费时间，但有利于我们对流程进行控制，避免很多不可掌控的意外情况。
    2、异步的执行效率高，节省时间，但是会占用更多的资源，也不利于我们对进程进行控制。
**阻塞**：是指调用结果返回前，当前线程会被挂起，即阻塞。
**非阻塞**：是指即使调用结果没返回，也不会阻塞当前线程。
```
#### 2.计算机硬件（冯诺伊曼的体系结构）
```markdown
计算机硬件是计算机的重要组成部分，其中包含了 5 个重要的组成部分：运算器、控制器、存储器、输入设备、输出设备。
运算器：运算器最主要的功能是对数据和信息进行加工和运算。它是计算机中执行算数和各种逻辑运算的部件。
    运算器的基本运算包括加、减、乘、除、移位等操作，这些是由算术逻辑单元(Arithmetic&logical Unit) 实现的。
    而运算器主要由算数逻辑单元和寄存器构成。
控制器：指按照指定顺序改变主电路或控制电路的部件，它主要起到了控制命令执行的作用，完成协调和指挥整个计算机系统的操作。
    控制器是由程序计数器、指令寄存器、解码译码器等构成。
**运算器和控制器共同组成了CPU**
存储器：存储器就是计算机的记忆设备，顾名思义，存储器可以保存信息。存储器分为两种，一种是主存，也就是内存，
    它是CPU主要交互对象，还有一种是外存，比如硬盘软盘等。
输入设备：输入设备是给计算机获取外部信息的设备，它主要包括键盘和鼠标。
输出设备：输出设备是给用户呈现根据输入设备获取的信息经过一系列的计算后得到显示的设备，它主要包括显示器、打印机等。
总线(Buses)：在整个系统中运行的是称为总线的电气管道的集合，这些总线在组件之间来回传输字节信息。通常总线被设计成传送定长的字节块，也就是字(word)。
    字中的字节数（字长）是一个基本的系统参数，各个系统中都不尽相同。现在大部分的字都是 4 个字节（32 位）或者 8 个字节（64 位）。
I/O设备(I/O Devices)：Input/Output设备是系统和外部世界的连接。I/O设备：用于用户输入的键盘和鼠标，用于用户输出的显示器，
    一个磁盘驱动用来长时间的保存数据和程序。刚开始的时候，可执行程序就保存在磁盘上。
```
#### 3.用户态和核心态
```markdown
在计算机系统中，分两种程序：系统程序和应用程序，为了保证系统程序不被应用程序有意或无意地破坏，为计算机设置了两种状态——用户态、内核态
    用户态：只能受限的访问内存，运行所有的应用程序。
    内核态：运行操作系统程序，cpu可以访问内存的所有数据，包括外围设备。
为什么要有用户态和内核态：
​   **由于需要限制不同的程序之间的访问能力，防止他们获取别的程序的内存数据，或者获取外围设备的数据，并发送到网络。**
数据怎样从用户空间进入到内核空间？又怎么从内核空间到内存空间？或者说，应用进程如何从内核空间拿数据？
用户态切换到内核态的3种方式：
​ a. 系统调用
    ​ 这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，
     比如前例中fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。
​ b. 异常
    ​ 当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。
​ c. 外围设备的中断
    ​ 当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，
     如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。
这3种方式是系统在运行时由用户态转到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。
```
#### 4 什么是操作系统？
```markdown
操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机系统的内核与基石；
    操作系统本质上是运行在计算机上的软件程序 ；
    操作系统为用户提供一个与系统交互的操作界面 ；
    操作系统分内核与外壳（我们可以把外壳理解成围绕着内核的应用程序，而内核就是能操作硬件的程序）。
操作系统也是一种软件，但是操作系统是一种非常复杂的软件。操作系统提供了几种抽象模型
    文件：对 I/O 设备的抽象
    虚拟内存：对程序存储器的抽象
    进程：对一个正在运行程序的抽象
    虚拟机：对整个操作系统的抽象
```
#### 5 什么是系统调用呢？ 
```markdown
操作系统提供的函数就被称为**系统调用**（system call）。软件程序的执行一般是在用户态下执行的，但当程序需要使用操作系统提供的服务时，
    比如说打开某一设备、创建文件、读写文件（这些均属于系统调用）等，就需要向操作系统发出调用服务的请求，就是系统调用。
根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：
    用户态(user mode) : 用户态运行的进程或可以直接读取用户程序的数据。（软件程序运行）
    内核态(kernel mode):可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。（操作系统运行）
在我们运行的用户程序中，凡是与系统态（内核态）级别的资源有关的操作（如文件管理、进程控制、内存管理等)，
    都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。
 异常：当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。
 外围设备的中断：当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号
    对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。
    比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。
系统调用有哪些
    设备管理。完成设备的请求或释放，以及设备启动等功能。
    文件管理。完成文件的读、写、创建及删除等功能。
    进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。
    进程通信。完成进程之间的消息传递或信号传递等功能。
    内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。
```
#### 6 进程和线程的区别，协程【10+】
>> 协程与线程以及进程的关系见下图所示。
![](https://mmbiz.qpic.cn/mmbiz_png/vt35KeC5pmicicicIJf2WxuicHibZgtyC6a71ch4SRJvfB5q4PVPzAXh3ibwqm9aPUicUuqNMfxudiacBur8oib0PR1G6zw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
```markdown
​进程：是资源分配的最小单位，是程序的执行过程，一个进程可以有多个线程，多个线程共享进程的堆和方法区资源，
    但每个线程又有属于自己的本地方法栈、虚拟机栈、程序计数器。
​线程：是任务调度和执行的最小单位，线程间可能存在相互影响，执行开销较小，不利于资源的管理和保护，
    线程间是共享进程中的资源的。
协程：是一种比线程更加轻量级的存在，正如一个进程可以拥有多个线程一样，一个线程可以拥有多个协程。
    协程不是被操作系统内核所管理，而完全是由程序所控制。
**拥有资源**：进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。
**调度**：线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。
**系统开销**：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等，所付出的开销远大于创建或撤销线程时的开销。
    类似地，在进行进程切换时，涉及当前执行进程CPU环境的保存及新调度进程CPU环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。
**通信方面**：线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助IPC。
>> 为什么有了进程还要线程：进程如果被阻塞，哪些等待资源执行的进程就无法执行。进程同一时间只能做一件事。
```
#### 7 进程有哪几种状态【2+】
```markdown
创建状态(new) ：进程正在被创建，尚未到就绪状态。
就绪状态(ready) ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。
运行状态(running) ：进程正在处理器上上运行(单核CPU下任意时刻只有一个进程处于运行状态)。
阻塞状态(waiting) ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待IO操作完成。即使处理器空闲，该进程也不能运行。
结束状态(terminated) ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。
```
#### 8 进程间的通信方式【5+】
[进程间通信](https://www.cnblogs.com/xiaolincoding/p/13402297.html)
```markdown
进程间通信目的：保证先后顺序、依赖关系、消息传递。
**信号(Signal)** ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；（Linux系统上输入kill -l来列出系统使用的信号）
**管道/匿名管道(Pipes)** ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。
    在两个进程之间，可以建立一个通道，一个进程向这个通道里写入字节流，另一个进程从这个管道中读取字节流。（shell中的管线pipelines就是用管道实现的）
**命名管道(Names Pipes)**: 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。
    有名管道严格遵循先进先出(first in first out)。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。
**消息队列(Message Queuing)** ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。
    管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）
    不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。
    消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。
    消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺。
**信号量(Semaphores)** ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。
**共享内存(Shared memory)** ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。
    这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。
**套接字(Sockets)** : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持TCP/IP的网络通信的基本操作单元，
    可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。
管道：速度慢，容量有限，只有父子进程能通讯。
FIFO：任何进程间都能通讯，但速度慢。
消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题。
信号量：不能传递复杂消息，只能用来同步。
共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存。
```
#### 9 线程间的同步的方式【5+】
```markdown
**同步与互斥**：同步：多个进程按一定顺序执行；互斥：多个进程在同一时刻只有一个进程能进入临界区。
    线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。
**信号量(Semphares)**：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。
    信号量是E.W.Dijkstra在1965年提出的一种方法，它使用一个整形变量来累计唤醒次数，以供之后使用。在他的观点中，有一个新的变量类型称作信号量(semaphore)。
    一个信号量的取值可以是0，或任意正数。0表示的是不需要任何唤醒，任意的正数表示的就是唤醒次数。
    Dijkstra 提出了信号量有两个操作，现在通常使用down和up（分别可以用sleep和wakeup来表示）。down这个指令的操作会检查值是否大于0 。
    如果大于0，则将其值减1；若该值为0，则进程将睡眠，而且此时down操作将会继续执行。检查数值、修改变量值以及可能发生的睡眠操作均为一个单一的、不可分割的原子操作(atomic action)完成。
**互斥量(Mutex)**：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会
    被多个线程同时访问。比如Java中的synchronized关键词和各种Lock都是这种机制。
    互斥量是一个处于两种状态之一的共享变量：解锁(unlocked)和加锁(locked)。这样，只需要一个二进制位来表示它，不过一般情况下，通常会用一个 整型(integer)来表示。
    0表示解锁，其他所有的值表示加锁，比1大的值表示加锁的次数。
**事件(Event) :Wait/Notify**：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操。
**临界区**：对临界资源进行访问的那段代码称为临界区。为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。
```
#### 10.进程的调度算法/CPU调度算法【5+】
```markdown
**批处理系统**:批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。
    **先到先服务(FCFS)调度算法**:从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用CPU时再重新调度。
    **最短作业优先(SJF)的调度算法**:从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用CPU时再重新调度。
    **时间片轮转调度算法**:时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称RR(Roundrobin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。
    **高响应比优先级调度**高响应比优先（HRRN）调度算法主要是权衡了短作业和长作业。每次进行进程调度时，先计算「响应比优先级」，然后把「响应比优先级」最高的进程投入运行，
    **最高优先级调度算法**：为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以FCFS方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。
    **多级反馈队列调度算法**:是「时间片轮转算法」和「最高优先级算法」的综合和发展。
**交互式系统**
    **时间片轮转**:将所有就绪进程按FCFS的原则排成一个队列，每次调度时，把CPU时间分配给队首进程，该进程可以执行一个时间片。
        当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把CPU时间分配给队首的进程。
    **优先级调度**:为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。
    **多级反馈队列**:可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。
**实时系统**:实时系统要求一个请求在一个确定时间内得到响应。分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。
```
#### 11.死锁【5+】
```markdown
大部分的死锁都和资源有关，在进程对设备、文件具有独占性（排他性）时会产生死锁。我们把这类需要排他性使用的对象称为资源(resource)。
资源主要分为：可抢占资源和不可抢占资源
死锁：如果一组进程中的每个进程都在等待一个事件，而这个事件只能由该组中的另一个进程触发，这种情况会导致死锁。
死锁的必要条件：
     互斥条件 (Mutual exclusion)：资源不能被共享，只能由一个进程使用。
     请求与保持条件 (Hold and wait)：已经得到资源的进程可以再次申请新的资源。
     不可剥夺 (No pre-emption)：已经分配的资源不能从相应的进程中被强制地剥夺。
     循环等待条件 (Circular wait)：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源。
发生死锁时，上面的情况必须同时会发生。如果其中任意一个条件不会成立，死锁就不会发生。可以通过破坏其中任意一个条件来破坏死锁。
死锁的处理策略：
     鸵鸟策略：忽略死锁带来的影响
     死锁检测与死锁恢复（检测死锁并回复死锁，死锁发生时对其进行检测，一旦发生死锁后，采取行动解决问题）
        从死锁中恢复：通过抢占进行恢复,通过回滚进行恢复,杀死进程恢复。
     死锁预防（通过仔细分配资源来避免死锁）
        破坏互斥条件：没必要的。。。因为我们本身就要互斥
        破坏等待和持有条件：执行前将所有的资源全部分给他
        破坏不可剥夺条件：也就是如果请求不到资源，就主动放弃自己现在持有的资源
        破坏循环等待条件：给资源统一编号，进程只能按编号顺序来请求资源。
     死锁避免（通过破坏死锁产生的四个条件之一来避免死锁）
        单个资源的银行家算法，破坏死锁，破坏互斥条件，破坏保持等待的条件，破坏不可抢占条件，破坏循环等待条件。
[PV操作经典例题——哲学家进餐问题](https://blog.csdn.net/Yun_Ge/article/details/89177918)
```
#### 12.操作系统内存管理方式，分页分段以及段页式的优缺点【5+】
[操作系统-内存管理](https://blog.csdn.net/qq_29677867/article/details/91038642)
```markdown
内存管理方式：块式管理、页式管理、段式管理、段页式管理
    虚拟内存：目的是为了让物理内存扩充为更大的逻辑内存，从而让程序获得更大的可用内存。
    分页系统内存映射：内存管理单元管理者地址空间和物理内存否转换,其中的页表存储着页(程序地址空间)和页框(物理内存空间)的映射表。
    页面置换算法：OPT,LRU,NRU，FIFO，第二次机会算法，CLOCK
0.块式管理：把主存分为一大块、一大块的，当所需的程序片断不在主存时就分配一块主存空间，把程序片断load入主存，就算所需的程序片度只有几个字节也只能把这一块分配给它。
    这样会造成很大的浪费，平均浪费了50％的内存空间，但是易于管理。
1.页式管理：把主存分为一页一页的，每一页的空间要比一块一块的空间小很多，显然这种方法的空间利用率要比块式管理高很多。
2.段式管理：把主存分为一段一段的，每一段的空间又要比一页一页的空间小很多，这种方法在空间利用率上又比页式管理高很多，但是也有另外一个缺点。
    一个程序片断可能会被分为几十段，这样很多时间就会被浪费在计算每一段的物理地址上。
3.段页式管理：结合了段式管理和页式管理的优点。将程序分成若干段，每个段分成若干页。段页式管理每取一数据，要访问3次内存。
分段和分页的区别：页是定长的，段是不定长的。页是物理单位，段是逻辑单位。
```
#### 13.CPU的上下文切换有几种？系统中断进行了几次上下文切换？【5+】
```markdown
上下文切换(Context Switch)是一种将CPU资源从一个进程分配给另一个进程的机制。是内核（操作系统的核心）在CPU上对进程或者线程进行切换。
    操作系统需要先存储当前进程的状态 (包括内存空间的指针，当前执行完的指令等等)，再读入下一个进程的状态，然后执行此进程。
    其实际含义是任务切换, 或者CPU寄存器切换。当多任务内核决定运行另外的任务时, 它保存正在运行任务的当前状态, 也就是CPU寄存器中的全部内容。
    这些内容被保存在任务自己的堆栈中, 入栈工作完成后就把下一个将要运行的任务的当前状况从该任务的栈中重新装入CPU寄存器, 并开始下一个任务的运行, 这一过程就是context switch。
    **上下文频繁的切换，会带来一定的性能开销。**
CPU的上下文切换分三种：**进程上下文切换、线程上下文切换、中断上下文切换**。
     系统调用过程中也会发生CPU上下文切换。CPU寄存器会先保存用户态的状态，然后加载内核态相关内容。
    系统调用结束之后，CPU寄存器要恢复原来保存的用户态，继续运行进程。所以，一次系统调用，发生两次CPU上下文切换。
     进程是由内核管理和调度的，进程的切换只能发生在内核态。进程上下文切换与系统调用的不同在于，
    进程的调用会保存用户空间的虚拟内存，全局变量等信息，但是系统调用的上下文则不会，因为其未发生进程的变化。
     内核中的任务调度实际是在调度线程，进程只是给线程提供虚拟内存、全局变量等资源。
    线程上下文切换时，共享相同的虚拟内存和全局变量等资源不需要修改。
    而线程自己的私有数据，如栈和寄存器等，上下文切换时需要保存。
减少上下文切换开销方法:
    - 无锁并发编程
        多线程竞争锁时，会引起上下文切换，所以多个线程处理数据时，可以用一些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据
    - CAS
        Java的Atomic包使用CAS算法来更新数据，而不需要加锁
    - 控制线程数
        避免创建过多不需要的线程，当任务少的时候，但是创建很多线程来处理，这样会造成大量线程都处于等待状态
    - 协程(GO语言)
        在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。
```
#### 14.内存页面置换算法【5+】
```markdown
 **最优页面置换算法**：最理想的状态下，置换在「未来」最长时间不访问的页面。
 **先进先出页面置换算法（FIFO）**：选择在内存驻留时间很长的页面进行中置换。
 **最近最少使用页面置换算法LRU**：选择最长时间没有被访问的页面进行置换。
 **第二次机会页面置换算法**：FIFO链表页面有个缺陷，那就是出链和入链并不会进行check检查，这样就会容易把经常使用的页面置换出去。
 **时钟页面置换算法**：当缺页错误出现时，算法首先检查表针指向的页面，如果它的R位是0就淘汰该页面，并把新的页面插入到这个位置，然后把表针向前移动一位；
 **最不常用（LFU）算法**：当发生缺页中断时，选择「访问次数」最少的那个页面，并将其淘汰。
```
#### 15.虚拟地址，逻辑地址，物理地址的关系【5+】
```markdown
1)虚拟地址：是由程序产生的由段选择符和段内偏移地址组成的地址。
    这2部分组成的地址并不能直接访问物理内存，而是要通过分段地址的变化处理后才会对应到相应的物理内存地址。
2)逻辑地址：指由程序产生的段内偏移地址。逻辑地址与虚拟地址二者之间没有明确的界限。
3)线性地址：指虚拟地址到物理地址变换的中间层，是处理器可寻址的内存空间（称为线性地址空间）中的地址。
    程序代码会产生逻辑地址，或者说段中的偏移地址，加上相应段基址就成了一个线性地址。
    如果启用了分页机制，那么线性地址可以再经过变换产生物理地址。若是没有采用分页机制，那么线性地址就是物理地址。
4)物理地址：指内存中物理单元的集合，他是地址转换的最终地址，进程在运行时执行指令和访问数据最后都要通过物理地址来存取主存。。
    逻辑（虚拟）地址经过分段（查询段表）转化为线性地址。线性地址经过分页（查询页表）转为物理地址。
```
#### 16.磁盘调度算法
[大厂面试爱问的「调度算法」，20 张图一举拿下](https://www.cnblogs.com/xiaolincoding/p/13631224.html)
```markdown
**先来先服务算法**
**最短寻道时间优先算法**的工作方式是，优先选择从当前磁头位置所需寻道时间最短的请求
**扫描算法**
**循环扫描算法**
**LOOK与C-LOOK算法**
```
#### 17.孤儿进程&僵尸进程
```markdown
孤儿进程
    一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。
    孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。
    由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。
僵尸进程
    一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过wait()或waitpid()获取了子进程信息后才会释放。
        如果子进程退出，而父进程并没有调用wait()或waitpid()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。
    僵尸进程通过 ps 命令显示出来的状态为 Z（zombie）。
    系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。
    要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 进程所收养，这样 init 进程就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程。
```

## 三、计算机组成原理
### [计算机组成原理](https://www.cnblogs.com/reminis/p/12896053.html)
### [【重学计算机】计算机组成原理](https://www.cnblogs.com/flashsun/p/10628433.html)
### [随笔分类 - 重学计算机笔记](https://www.cnblogs.com/flashsun/category/1391951.html)

## 四、Linux
[全方位剖析Linux操作系统](https://www.cnblogs.com/cxuanBlog/p/13789900.html)
[后端程序员必备的 Linux 基础知识+常见命令](https://mp.weixin.qq.com/s?__biz=MzU2NDg0OTgyMA==&mid=2247493578&idx=2&sn=ae265b5b05204fcb949fee41fd2d7d13&chksm=fc461a39cb31932fcd084bf566f9d2ea9111a7da56cc2a408eac8145e8d5a64f5005e1e2e28b&mpshare=1&scene=23&srcid=0901oUWt9SKi6zFY7iH7oC0d&sharer_sharetime=1598924671509&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
### Linux I/O
#### 1.1 五种I/O模型
[带你真正的搞懂，Linux的5种I/O模型](https://www.toutiao.com/a6619988112300835331/)
```markdown
Unix 有五种 I/O 模型：
    阻塞式I/O（blocking IO）: 应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。
    非阻塞式I/O（nonblocking IO）:应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知I/O是否完成，这种方式称为轮询（polling）。
    I/O复用（IO multiplexing）（select和poll）:使用select或者poll等待数据，并且可以等待多个套接字中的任何一个变为可读。
        这一过程会被阻塞，当某一个套接字可读时返回，之后再使用recvfrom把数据从内核复制到进程中。
    信号驱动式I/O（SIGIO）:应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。
    异步I/O（asynchronous IO）（AIO:应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。
```
#### 1.2 I/O复用
```markdown
I/O复用是通过一种机制，一个进程可以监听多个文件描述符，一旦某个fd就绪（一般是读就绪或写就绪），就通知程序进行相应的操作。
同步I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段，应用进程会阻塞。
异步I/O：不会阻塞。
阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O 都是同步 I/O，它们的主要区别在第一个阶段。
非阻塞式 I/O 、信号驱动 I/O 和异步 I/O 在第一阶段不会阻塞。
```
#### 1.3 IO多路复用模型select、poll和epoll函数的区别？【5+】
[IO多路复用中select、poll、epoll之间的区别？](https://blog.csdn.net/weixin_44359909/article/details/107795454)
```markdown
目前Linux上主要的I/O多路复用模型有三种，select、poll、epoll，它们本质上都是同步I/O，即要求读写事件就绪后自己负责进行读写，这会导致请求进程阻塞，直到I/O操作完成。
select、poll、eopll是操作系统处理网络上传输过来的数据的不同实现，数据从经过网线流入网卡，网卡中的驱动程序会向CPU发出中断信号，
    在交互系统中，中断信号的优先级是很高的，CPU立刻去处理这个中断信息，CPU通过终端表找到相应的处理函数：
 select函数监视文件描述符，调用后select函数会阻塞，直到有描述符就绪，或者超时，函数返回，当select函数返回后，就可以遍历描述符，找到就绪的描述符。
    select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制。
 poll没有最大限制（但是数量过大后性能也是会下降）。和select函数一样，poll返回后，需要轮询来获取就绪的描述符。
 epoll是Linux内核为处理大批量文件描述符而作了改进的poll，是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的
    情况下的系统CPU利用率。另一点原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。
 epoll通过监控注册的多个描述字，来进行I/O事件的分发处理。不同poll的是，epoll不仅提供了默认的level-triggered（条件触发）机制，还提供了性能更为强劲的edge triggered（边缘触发）机制
```
#### 1.4 BIO、NIO、AIO有什么区别？【3+】
```markdown
BIO：线程发起IO请求，不管内核是否准备好IO操作，从发起请求起，线程一直阻塞，直到操作完成。(InputStream、OutputStream、Reader、Writer)
NIO：线程发起IO请求，立即返回；内核在做好IO操作的准备之后，通过调用注册的回调函数通知线程做IO操作，线程开始阻塞，直到操作完成。
    (Channels、Buffers、Selectors)
AIO：线程发起IO请求，立即返回；内存做好IO操作的准备之后，做IO操作，直到操作完成或者失败，通过调用注册的回调函数通知线程做IO操作完成或者失败。
BIO 是一个连接一个线程。,NIO是一个请求一个线程。,AIO是一个有效请求一个线程。
BIO：同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。
NIO：同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。
AIO：异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的IO请求都是由OS先完成了再通知服务器应用去启动线程进行处理。
IO多路复用：调用系统级别的select、poll、epoll
```
#### [说了这么多次 I/O，但你知道它的原理么](https://www.cnblogs.com/cxuanBlog/p/13032486.html)
### Linux常用命令【3+】
#### Linux基础命令
```markdown
文件管理：ls、cd、touch创建普通文件、rm删除、mkdir新建目录、mv移动、cp拷贝、chmod修改权限
    通过df命令可以查看磁盘的剩余空间： df -h -h表示按单位格式化输出。-d指定了递归深度为1层，
    可以使用iostat来查看系统的磁盘I/O状况：iostat -d -k -d表示查看磁盘使用状况，-k表示以KB为单位显示。
    通过vmstat命令，可以查看到Swap I/O的情况： vmstat swap列的si表示每秒从磁盘交换到内存的数据量，单位是KB/s，so表示每秒从内存交换到磁盘的数据量，单位也是KB/s。
进程管理：ps显示进程信息、kill杀死进程
系统管理：top、free显示系统运行信息、vmstat输出各资源使用情况
    w、top、uptime这三个命令都可以用来查看系统的load值，下面演示一下使用uptime命令查看系统的load： uptime
    通过free命令能够查看到系统的内存使用情况，加上-m参数表示以MB为单位：free -m
    linux查看进程所占内存命令: 使用 ps -ef | grep mysql 查看mysql这个进程的id
                            使用 top -p 进程id  查看到进程的CUP和内存的占用率
                            可直接使用ps命令查看： ps -aux | grep kafka 
网络通讯：ping测试网络连通性、netstat显示网络相关信息
Linux 命令，查看文件前十行，后十行 head,tail
端口被占用: lsof -i 端口号
           netstat -ntulp | grep 端口号
统计文件有多少行：
    wc [选项] 文件…
      - c 统计字节数。
      - l 统计行数。
      - w 统计字数。
```
#### Linux中常见的网络命令
[面试官问我Linux下常见网络命令](https://mp.weixin.qq.com/s?__biz=MzIwOTE2MzU4NA==&mid=2247486142&idx=1&sn=847511b9f15751f35a6bbab631a612a3&chksm=97794e91a00ec78702acc82c35828011f0f98fff3c1b55741372b73c20e26a1f1e6dde70ae5f&mpshare=1&scene=23&srcid=0924Z8afHzXSvX6tbe72caGH&sharer_sharetime=1600910416242&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
```markdown
ping命令用来测试主机之间网络的连通性。执行ping指令会使用ICMP传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。
        ping www.baidu.com
        ping www.baidu.com -c 6 -i 0.6  其中 –c count 次数，也就是ping的次数；-i interval 间隔 ，每次ping之间的时间空格
    telnet命令用于登录远程主机，对远程主机进行管理。telnet因为采用明文传送报文，安全性不好，很多Linux服务器都不开放telnet服务，而改用更安全的ssh方式了。
    netstat命令用来打印Linux中网络系统的状态信息，可让你得知整个Linux系统的网络情况。
        netstat -a     //列出所有端口
        netstat -at    //列出所有tcp端口
        netstat -au    //列出所有udp端口
        netstat -l //只显示监听端口
        netstat -lt //只列出所有监听 tcp 端口
        netstat -lu //只列出所有监听 udp 端口
    ifconfig命令被用于配置和显示Linux内核中网络接口的网络参数。用ifconfig命令配置的网卡信息，在网卡重启后机器重启后，配置就不存在。
    route命令用来显示并设置Linux内核中的网络路由表，route命令设置的路由主要是静态路由。要注意的是，直接在命令行下执行route命令来添加路由，不会永久保存，当网卡重启或者机器重启之后，该路由就失效了；
        可以在*/etc/rc.local中添加route命令来保证该路由设置永久有效。
    arp命令用于操作主机arp缓冲区，可以显示arp缓冲区的所有条目、删除指定条目或增加静态IP地址与MAC地址的对应关系
        arp -a
        arp -v
    traceroute命令用于追踪数据包在网络上传输时的全部路径，它默认发送的数据包大小是40字节通过traceroute我们可以知道信息从你的计算机到互联网另一端的主机是走的什么路径。
        traceroute www.baidu.com
    host命令是常用的分析域名查询工具，可以检测域名系统工作是否正常
    tcpdump命令是一款抓取数据包的工具，它可以打印所有经过网络接口的数据包的头信息，也可以使用-w选项将数据包保存到文件中，方便以后分析。
```
#### [不可不知的7个JDK命令](https://www.cnblogs.com/wupeixuan/p/12965240.html)
```markdown
javap:使用javap可以查看Java字节码反编译的源文件。
jsp:jps 是用来查询当前所有进程 pid 的。
jstat: jstat 主要用于监控 JVM，主要是 GC 信息，在性能优化的时候经常用到，
jcmd: jcmd 可以查看 JVM 信息。
jmap: jmap 打印出 Java 进程内存中 Object 的情况，或者将 JVM 中的堆以二进制输出成文本。
jhat: jhat 分析 Java 堆的命令，可以将堆中对象以 html 的形式显示出来，支持对象查询语言 OQL
jsatck: jstack 是堆栈跟踪工具，主要用于打印给定进程 pid 的堆栈信息，
    一般在发生死锁或者 CPU 100% 的时候排查问题使用，可以去查询当前运行的线程以及线程的堆栈信息是什么情况
[给你的Java程序拍个片子吧：jstack命令解析](https://www.cnblogs.com/jay-huaxiao/p/12865552.html)
整机 top:    uptime
CPU vmstat -n 2 3  # 每两秒采样一次，采样三次。
    查看额外： mpstat -P ALL 2 查看所有CPU核信息
              pidstat -u 1 -p 进程编号  每个进程使用cpu的用量分解信息
内存 free 应用程序可用内存数 free -m ,free -g  查看内存的单位
    查看额外 pidstat -p 进程号 -r 采样间隔秒数
硬盘 df  查看磁盘剩余空闲数  df -h
磁盘IO iostat   磁盘I/O性能评估 iostat -xdk 2 3
    查看额外 pidstat -d 采样间隔秒数 -p 进程号
网络IO ifstat 默认本地没有，下载    ifstat l  查看网络I/O
```
#### 日志文件找出现最频繁的k个word，以及考虑大文件分割处理
#### 出现高CPU怎么解决？排查
#### Linux 文件类型
```markdown
Linux 支持很多文件类型，其中非常重要的文件类型有: 普通文件，目录文件，链接文件，设备文件，管道文件，Socket套接字文件等。
1.普通文件（-）：用于存储信息和数据，Linux用户可以根据访问权限对普通文件进行查看、更改和删除。比如：图片、声音、PDF、text、视频、源代码等等。
2.目录文件（d，directory file）：目录也是文件的一种，用于表示和管理系统中的文件，目录文件中包含一些文件名和子目录名。打开目录事实上就是打开目录文件。
3.符号链接文件（l，symbolic link）：保留了指向文件的地址而不是文件本身。
4.字符设备（c，char）：用来访问字符设备比如硬盘。
5.设备文件（b，block）：用来访问块设备比如硬盘、软盘。
6.管道文件(p,pipe):一种特殊类型的文件，用于进程之间的通信。
7.套接字(s,socket)：用于进程间的网络通信，也可以用于本机之间的非网络通信。
```
#### linux命令 对日志文件的IP出现的次数进行统计
```java
grep -i -o -E "([0-9]{1,3}\.){3}[0-9]{1,3}" test1.txt | sort -n | uniq -c | sort -n -r | head -6
grep命令 用于文本搜索

-E：用于使用正则匹配

-o：只显示匹配的部分

-i：忽略大小写

sort命令用于排序

-n：数值排序

-r：倒序排序

uniq命令用于去重

-c：显示重复次数

head -6命令显示前6行
```
### 
## 
