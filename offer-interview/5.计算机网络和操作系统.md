# 计算机网络和操作系统知识总结

[TOC]


## 一、计算机网络 >> [参考资料：cyc2018大佬](https://cyc2018.github.io/CS-Notes/#/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E7%9B%AE%E5%BD%951)
>> 参考书籍：《图解TCP/IP第五版》、《图解HTTP》、《计算机网络第七版》
### 1.[参考资料：计算机网络常见面试题](https://www.cnblogs.com/wuwuyong/p/12198928.html)
### 三种体系结构&计算机网络的体系结构&网络协议
>> OSI的体系结构:应用层-表示层-会话层-运输层-网络层-数据链路层-物理层
>> 五层协议的体系结构:应用层-运输层-网络层-数据链路层-物理层
>> TCP/IP的体系结构
```markdown
应用层：telent,ssh.http,smtp,pop,ssl/TLS,ftp,mime,html,snmp,min,sir,rtp ....
运输层: tcp,udp,udp-lite,Sctp,dccp
网际层: ARP,IPv4,IPv6,ICMP,IPsec
网络接口层:以太网，无线LAN,PPP ...  (双绞线电缆，无线，光纤 ...)
```
```markdown
1.应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）
    间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如**域名系统DNS**，
    支持万维网应用的**HTTP协议**，支持电子邮件的**SMTP协议**等等。我们把应用层交互的数据单元称为报文。
    功能：文件传输，电子邮件，文件服务，虚拟终端:TFTP，HTTP，SNMP，FTP，SMTP，DNS，RIP，Telnet
2.运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。
“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。
    所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。
[参考资料：运输层 ,跑腿的秘书](https://www.cnblogs.com/king0/p/12932251.html)
    运输层主要使用以下两种协议:   
        1.**传输控制协议 TCP**（Transmission Control Protocol）--提供面向连接的，可靠的数据传输服务。
        2.**用户数据协议 UDP**（User Datagram Protocol）--提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。
3.网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组
    和包进行传送。在TCP/IP体系结构中，由于网络层使用**IP协议**，因此分组也叫IP数据报，简称数据报。
4.数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。 
    在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。
    每一帧包括数据和必要的控制信息（如**同步信息，地址信息，差错控制等**）。
5.物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。 
    使其上面的数据链路层不必考虑网络的具体传输介质是什么。在物理层上所传送的数据单位是比特。
```
![](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E4%B8%83%E5%B1%82%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9B%BE.png)
### 2.[参考资料：总结12道最常见的计算机网络面试题](https://www.cnblogs.com/tanshaoshenghao/p/11835679.html)
#### 2.1.请详细介绍一下TCP的三次握手机制，为什么要三次握手？
```markdown
1.首先服务器端处于LISTEN（监听）状态，等待客户的连接请求。
2.客户端–发送SYN报文到服务器，将Seq设置为0，并且进入SYN_SEND状态，等待服务器确认； 
3.服务端接收到SYN报文段，需要确认客户的SYN报文,同时发送一个ACK包，将Ack设置为1，也要发送SYN请求信息，将Seq设置为0，
    服务器将上述的所有信息一并发送给客户端，即发送SYN+ACK的数据包，服务器进入SYN_RECV状态; 
4.客户端接收到服务器的SYN+ACK报文后，进行确认，然后将Ack设置为1，Seq设置为1，
    向服务器发送带有ACK标志的报文段，此包发送完毕，客户端和服务器进入ESTABLISHED状态，TCP的三次握手完成。
三次握手的目的是建立可靠的通信信道，通讯简单来说就是数据的发送与接收。
    最主要的目的就是双方确认自己与对方的发送与接收是正常的。为了初始化Sequence Number的初始值。
SYN:是TCP/IP建立连接时使用的握手信号。
ACK:确认字符 ,在数据通信传输中，接收站发给发送站的一种传输控制字符。它表示确认发来的数据已经接受无误。
```
#### 2.2.为什么要传回SYN？传了SYN,为啥还要传ACK？讲一讲SYN超时，洪泛攻击，以及解决策略？
```markdown
**为什么要传回SYN包？**
    接收端传回发送端所发送的SYN包是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。
**传了SYN包,为啥还要传ACK？**
    双方通信无误必须是两者互相发送信息都无误。传了SYN包，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要ACK信号来进行验证。
**讲一讲SYN包超时，洪泛攻击，以及解决策略？**
    在TCP的三次握手机制的第一步中，客户端会向服务器发送SYN报文段。服务器接收到SYN报文段后会为该TCP分配缓存和变量，
    如果攻击分子大量地往服务器发送SYN报文段，服务器的连接资源终将被耗尽，导致内存溢出无法继续服务。
    **解决策略**：当服务器接受到SYN报文段时，不直接为该TCP分配资源，而只是打开一个半开的套接字。
    接着会使用SYN报文段的源Id，目的Id，端口号以及只有服务器自己知道的一个秘密函数生成一个cookie，并把cookie作为序列号响应给客户端。
    **保活机制**：向对方发送保活探测报文，如果未收到响应则继续发送，尝试次数达到保活探测仍未收到响应则中断连接。
```
#### 3. 详细介绍一下TCP的四次挥手机制，为什么要有TIME_WAIT状态，为什么需要四次握手？服务器出现了大量CLOSE_WAIT状态如何解决
```markdown
1.客户端-发送一个FIN报文段，将设置Seq为15和Ack为1，用来关闭客户端到服务器的数据传送，客户端进入FIN_WAIT_1状态；
2.服务器-收到这个FIN后，发回一个ACK报文段，Seq设置为1,服务器进入CLOSE_WAIT状态；客户端收到服务器返回的ACK报文之后随即进入FIN_WAIT_2状态。
3.服务器-观察自己是否还有没有数据要发送到客户端，如果有，先把数据发送给客户端，再发送FIN报文；
    如果没有，那么直接发送一个FIN报文给客户端，请求关闭服务器到客户端的数据传送，服务器进入LAST_ACK状态。
4.客户端-收到FIN报文后，向服务器发送ACK报文，将Seq设置为16，Ack设置为2，然后进入TIME_WAIT状态；
    服务器收到客户端的ACK报文之后就关闭了连接；此时，客户端等待2msl后依然没有收到回复，则证明服务器已正常关闭，客户端也可以关闭连接了。
**为什么需要四次握手？**:任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。
    当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。因为全双工，发送方和接收方都需要FIN报文和ACK报文。
**为什么要有TIME_WAIT状态**因为客户端最后向服务器发送的确认ACK是有可能丢失的，当出现超时，服务端会再次发送FIN报文段，
    如果客户端已经关闭了就收不到了。还有一点是避免新旧连接混杂。
**服务器大量CLOSE_WAIT状态的原因：**表示程序出现了问题，对方的socket已经关闭连接，而我方忙于读或写没有及时关闭连接，
    需要检查代码，特别是释放资源的代码，或者是处理请求的线程配置。
```
#### 4. 详细讲一下TCP的滑动窗口及作用
![](https://www.cnblogs.com/images/cnblogs_com/tanshaoshenghao/1426602/o_%e7%bd%91%e7%bb%9c7.png)
```markdown
RTT:发送一个数据包到收到对应的ACK所花费的时间。
RTO:重传时间间隔。
滑动窗口左边的是已发送并且被确认的分组，滑动窗口右边是还没有轮到的分组。
滑动窗口里面也分为两块，一块是已经发送但是未被确认的分组，另一块是窗口内等待发送的分组。
随着已发送的分组不断被确认，窗口内等待发送的分组也会不断被发送。整个窗口就会往右移动，让还没轮到的分组进入窗口内。
滑动窗口起到了一个限流的作用，也就是说当前滑动窗口的大小决定了当前TCP发送包的速率，
而滑动窗口的大小取决于拥塞控制窗口和流量控制窗口的两者间的最小值。
TCP使用滑动窗口进行流量控制和乱序重排：保证TCP的可靠性，保证TCP的流控特性。
    流量控制是为了控制发送方发送速率，保证接收方来得及接收。
    接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。
```
#### 5. 讲一下HTTP与HTTPS的特点和区别，HTTP请求和响应的步骤【2+】
```markdown
超文本传输协议HTTP的主要特点：
    - 支持客户/服务器模式
    - 简单快速
    - 灵活
    - 无连接
    - 无状态
HTTP和HTTPS的主要区别在于HTTP协议传递的是明文数据，而HTTPS传递的是加密过的数据，也就是说HTTPS更具有安全性。
也正由HTTPS需要保证安全性，所以它的性能要比HTTP差一点。HTTP的端口是80，HTTPS的端口是443
HTTPS中使用到的对称加密，非对称加密，CA，数字证书的概念HTTPS想要保证客户端与服务器之间的通信安全，就得使用对称加密算法进行加密。
协商对称加密算法的过程通过非对称加密算法来保证。在非对称加密算法中，客户端获得公钥的过程需要第三方机构（CA）通过颁发数字证书保证安全性。
SSL(Security Sockets layer,安全套接字)
    - 为网络通信提供安全及数据完整性的一种安全协议
    - 是操作系统对外的API,SSL3.0后改名为TLS
    - 采用身份验证和数据加密保证网络通信的安全和数据的完整性。
HTTP请求和响应的步骤：
    - 客户端连接到Web服务器
    - 发送HTTP请求
    - 服务器接收到请求并且返回HTTP响应
    - 释放连接TCP连接
    - 客户端浏览器解析HTML内容
HTTPS数据传输流程：
    - 浏览器将支持的加密算法信息发送给服务器
    - 服务器选择一套浏览器支持的加密算法，以证书的形式回发浏览器
    - 浏览器验证证书的合法性，并且结合证书公钥秘钥加密信息发送给服务器
    - 服务器使用私钥解密信息，验证哈希，加密响应消息回发浏览器
    - 浏览器解密响应消息，并且对消息进行验真，之后进行加密交互数据
```
#### 6. 讲一讲TCP和UDP各有什么特点，两者有什么区别【1+】
[聊聊UDP、TCP和实现一个简单的JAVA UDP小Demo](https://www.cnblogs.com/huangqingshi/p/12950639.html)
```markdown
UDP的特点：
    - 面向非连接
    - 不维护连接状态，支持同时向多个客户端传输相同的消息
    - 数据包报头只有8个字节，额外开销小。
    - 吞吐量最后受限于数据生成速率，传输速率以及集群机器性能。
    - 尽最大努力交付，不保证可靠交付，不需要维持复杂的连接状态表。
    - 面向报文，不对应用程序提交的报文信息进行拆分或者合并。
```
```markdown
1.UDP在传送数据之前不需要先建立连接，远地主机在收到UDP报文后，不需要给出任何确认。
    虽然UDP不提供可靠交付，但在某些情况下UDP确是一种最有效的工作方式（一般用于即时通信）
2.TCP提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP不提供广播或多播服务。
    由于TCP要提供可靠的，面向连接的传输服务。TCP一般用于文件传输、发送和接收邮件、远程登录等场景。
 面向连接VS无连接，可靠性，有序性，速递，量级。TCP首部字节：20-60，UDP首部字节:8个字节(4个字段组成)
```
[tcp、udp、ip、icmp报文格式分析](https://www.cnblogs.com/znl233/p/9968592.html)
#### 6. TCP协议如何保证可靠传输
[你还在为TCP重传、滑动窗口、流量控制、拥塞控制发愁吗？看完图解就不愁了](https://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&mid=2453143215&idx=2&sn=e9e767ebcbd2fce4688ba71db4fbd32d&chksm=8cf2dc2cbb85553aa034a49abf9c172ebe0d89e6332f87bd9038bc53b6c9642a835f499c8b44&mpshare=1&scene=23&srcid=&sharer_sharetime=1591507618951&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
```markdown
1.应用数据被分割成TCP认为最适合发送的数据块。
2.TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。
3.数据包校验和:TCP将保持它首部和数据的检验和。是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。
    如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。
4.TCP的接收端会丢弃重复的数据：对于重复数据，能够丢弃重复数据。
5.流量控制：TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。
    [通俗易懂讲解TCP流量控制机制，了解一下](https://www.cnblogs.com/kubidemanong/p/9987810.html)
    当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。
    TCP使用的流量控制协议是可变大小的滑动窗口协议。（TCP利用滑动窗口实现流量控制）
6.拥塞控制：当网络拥塞时，减少数据的发送，降低整个网络的拥塞程度。
    [一文读懂拥塞控制](https://www.cnblogs.com/kubidemanong/p/9973757.html)
    TCP的拥塞控制采用了四种算法，即慢开始、拥塞避免、快重传和快恢复。
7.ARQ协议(自动重传请求)：也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。
8.超时重传：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。
9.TCP利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。
    接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为0，则发送方不能发送数据。
```
#### 7. 在地址栏键入URL后，网络世界发生了什么流程？【3+】
[一文摸透从输入URL到页面渲染的过程](https://www.cnblogs.com/AhuntSun-blog/p/12641050.html)
```markdown
1.在键入URL之前，刚开完机的时候，需要联网，然后才能上网。
    这个阶段包括了获取本机IP地址，获取DNS服务器IP地址，获得网关路由器IP和MAC地址等操作。
--获取本机IP地址，DNS服务器地址，网关路由器地址
--1.浏览器获取域名的IP地址 --DNS域名解析:获取域名对应IP  DNS查找过程：浏览器缓存，路由器缓存，DNS缓存
--2.浏览器向web发送一个HTTP请求，-- 三次握手建立TCP连接  TCP:与服务器建立TCP连接，IP:建立TCP协议时，需要发送数据，发送数据在网络层使用IP协议。
--3.建立连接后进行数据交互发送HTTP请求,服务器处理请求并返回HTTP报文,请求结束关闭TCP连接,四次挥手。
    OPSF:Ip数据在路由器之间，路由选择使用OSPF协议。ARP:路由器在于服务器通信时，需要将IP地址转换为MAC地址，需要使用ARP协议。
    HTTP：在TCP建立完成后，使用HTTP协议访问网页。
--4.浏览器解析渲染页面 构建DOM树 样式计算 页面布局 生成分层树 栅格化 显示
--5.合成与显示 连接结束。
```
#### 8. HTTP的常见状态码有哪些，代表什么含义？
[面试被问了三次的http状态码到底有什么](https://www.cnblogs.com/chentang/p/12845775.html)
>> HTTP状态码是用以表示网页服务器超文本响应状态的3位数字代码。
>> 核心作用就是http状态码核心作用是Web Server服务器用来告诉客户端，当前的网页请求发生了什么事，或者说当前Web服务器的响应状态。
>> HTTP状态码常用来判断和分析当前Web服务器的运行状况。
```markdown
**首先状态码的开头不同代表不同的类型：**
    1xx：代表指示信息，表示请求已接收，继续处理
    2xx：代表成功，表示请求已被成功接收，理解，接受
    3xx：重定向，表示完成请求必须进行进一步的操作
    4xx：客户端错误，请求有语法错误或请求无法实现
    5xx：服务器端错误，服务器未能实现合法的请求
**常见状态码：**
    200 OK：正常返回信息
    204 No Content：表示客户端发送给客户端的请求得到了成功处理，但在返回的响应报文中不含实体的主体部分（没有资源可以返回）
    206 Patial Content：表示客户端进行了范围请求，并且服务器成功执行了这部分的GET请求，响应报文中包含由Content-Range指定范围的实体内容。
    301 Moved Permanently：永久性重定向，表示请求的资源被分配了新的URL，之后应使用更改的URL；
    302 Found：临时性重定向，表示请求的资源被分配了新的URL，希望本次访问使用新的URL；
    303 See Other：表示请求的资源被分配了新的URL，应使用GET方法定向获取请求的资源
    400 Bad Request：客户端请求有语法错误，不能被服务器所理解
    401 Unauthorized:请求未被授权，必须和WWW-Authenticate报头域一起
    403 Forbidden：服务器收到请求，但是拒绝提供服务
    404 Not Found：请求资源不存在，输入了错误的URL
    500 Internal Server Error：服务器发生不可预期错误
    503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常
```
4#### 9. GET请求和POST请求的区别
```markdown
HTTP的请求格式主要包含三个信息：1、请求的类型（GET或POST），2、要访问的资源（如resimga.jif），3、HTTP版本（http/1.1）。
GET请求，请求的数据会附加在URL之后，以?分割URL和传输数据，多个参数⽤&连接。
    URL的编码格式采⽤的是ASCII编码，⽽不是unicode，即是说所有的⾮ASCII字符都要编码之后再传输。
POST请求：POST请求会把请求的数据放置在HTTP请求包的包体中。因此，GET请求的数据会暴露在地址栏中，⽽POST请求则不会。
1.传输数据的⼤⼩  -- 从HTTP报文层面来看，GET请求将信息放在URL，POST将请求信息放在请求体中，
    在HTTP规范中，没有对URL的⻓度和传输的数据⼤⼩进⾏限制。但是在实际开发过程中，对于GET，特定的浏览器和服务器对URL的⻓度有限制。
    因此，在使⽤GET请求时，传输数据会受到URL⻓度的限制。
    对于POST，由于不是URL传值，理论上是不会受限制的，但是实际上各个服务器会规定对POST提交数据⼤⼩进⾏限制，Apache、IIS都有各⾃的配置。
2.安全性  -- 从数据库层面来看，GET符合幂等性和安全性，而POST请求不符合。
    POST的目的是传送实体主体内容，内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。
3.从其他层面来看，GET请求能够被缓存，GET请求能够保存在浏览器的浏览记录里，GET请求的URL能够保存为浏览器书签。这些都是POST请求所不具备的。
```
#### 10. 什么是Cookie，Cookie的使用过程是怎么样的？
[Cookie＆Session](https://www.cnblogs.com/taojietaoge/p/11341767.html)
```markdown
由于http协议是无状态协议，如果客户通过浏览器访问web应用时没有一个保存用户访问状态的机制，那么将不能持续跟踪应用的操作。
cookie是浏览器的一种缓存机制，它可用于维持客户端与服务器端之间的会话。HTTP/1.1 引入Cookie来保存状态信息。
随着现代浏览器开始支持各种各样的存储方式，Cookie渐渐被淘汰。新的浏览器API已经允许开发者直接将数据存储到本地。
**cookie的使用过程：**
    1.首先用户在客户端浏览器向服务器发起登陆请求
    2.登陆成功后，服务端会把登陆的用户信息设置cookie中，返回给客户端浏览器
    3.客户端浏览器接收到cookie请求后，会把cookie保存到本地（可能是内存，也可能是磁盘，看具体使用情况而定）
    4.以后再次访问该web应用时，客户端浏览器就会把本地的cookie带上，这样服务端就能根据cookie获得用户信息了
```
#### 11. 什么是session，有哪些实现session的机制？
```markdown
session是一种维持客户端与服务器端会话的机制。但是与cookie把会话信息保存在客户端本地不一样,session把会话保留在**浏览器端**。
存储在服务器端的信息更加安全。存储在服务器上的文件、数据库或者内存中。也可以将Session存储在Redis这种内存型数据库中，效率会更高。
**session的使用过程：**
    1.首先用户在客户端浏览器发起登陆请求
    2.登陆成功后，服务端会把用户信息保存在服务端，并返回一个唯一的session标识给客户端浏览器。
    3.客户端浏览器会把这个唯一的session标识保存在起来
    4.以后再次访问web应用时，客户端浏览器会把这个唯一的session标识带上，这样服务端就能根据这个唯一标识找到用户信息。
```
#### 12. session和cookie有什么区别
```markdown
在许多web应用中，session机制就是通过cookie来实现的。或者使用URL回写实现。
    1.cookie是浏览器提供的一种缓存机制，它可以用于维持客户端与服务端之间的会话。**一般用来保存用户信息**。
    2.session指的是**维持客户端与服务端会话的一种机制**，它可以通过cookie实现，也可以通过别的手段实现。
    3.如果用cookie实现会话，那么会话会保存在**客户端**浏览器中，而session机制提供的会话是保存在**服务端**的。
    4.Cookie只能存储ASCII码字符串，而Session则可以存储任何类型的数据，因此在考虑数据复杂性时首选Session；
    5.Cookie存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在Cookie中，可以将Cookie值进行加密，然后在服务器进行解密；
    6.对于大型网站，如果用户所有的信息都存储在Session中，那么开销是非常大的，因此不建议将所有的用户信息都存储到Session中。
```
#### 13. Socket
```markdown
Socket是TCP/IP的抽象，是操作系统对外开放的接口。
Socket通信流程：
![]()
```
### 3.[30张图解HTTP常见的面试题](https://www.cnblogs.com/xiaolincoding/p/12442435.html)
#### 3.1.HTTP1.0与HTTP1.1之间的区别
```markdown
1.长连接：在HTTP/1.0中，默认使用的是短链接，HTTP/1.1中，默认使用的是长链接，默认开启Connection:keep-alive
2.错误状态响应码:新增24个错误状态响应码
3.缓存处理：引入更多的缓存控制策略
4.带宽优化及网络连接的使用
```
#### 3.2.[HTTP2.0学习 与 Nginx和Tomcat配置HTTP2.0](https://www.cnblogs.com/operationhome/p/12577540.html)
```markdown
HTTP/2（超文本传输协议第2版，最初命名为HTTP2.0），简称为h2（基于TLS/1.2或以上版本的加密连接）或h2c（非加密连接)，是HTTP协议的的第二个主要版本。
HTTP2新特性：
    头数据压缩 Data compression of HTTP headers
    服务器推送 HTTP/2 Server Push
    管线化请求 Pipelining of requests.
    对数据传输采用多路复用，让多个请求合并在同一 TCP连接内Multiplexing multiple requests over a single TCP connection，
        因为每一个tcp连接在创建的时候都需要耗费资源，而且在创建初期，传输也是比较慢的。
    采用了二进制而非明文来打包、传输 客户端<——>服务器 间的数据。
```
#### 3.3.HTTPS的工作原理
```markdown
1.Client 使用https的URL访问 Server，要求与 Server 建立 SSL 连接
2.Server 把事先配置好的公钥证书返回给客户端。
3.Client验证公钥证书：比如是否在有效期内，证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，
    直到验证到根证书（操作系统内置的Root证书或者Client内置的Root证书）。如果验证通过则继续，不通过则显示警告信息。
4.Client使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给Server。
5.Server使用自己的私钥（private key）解密这个消息，得到对称密钥。至此，Client和Server双方都持有了相同的对称密钥。
6.Server使用对称密钥加密“明文内容A”，发送给Client。
7.Client使用对称密钥解密响应的密文，得到“明文内容A”。
8.Client再次发起HTTPS的请求，使用对称密钥加密请求的“明文内容B”，然后Server使用对称密钥解密密文，得到“明文内容B”。
```
#### 3.4.HTTPS的优缺点
```markdown
尽管HTTPS并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，
但HTTPS仍是现行架构下最安全的解决方案，主要有以下几个好处：
    1.使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；
    2.HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。
    3.HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。
    4.谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。
虽然说HTTPS有很大的优势，但其相对来说，还是存在不足之处的：
    1.HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电；
    2.HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；
    3.SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。
    4.SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。
    5.HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。
        最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。
```
#### [炸裂！万字长文拿下HTTP！](https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&mid=2650129667&idx=3&sn=274618362eb9e759ef62386f731e4950&chksm=f36bd822c41c5134360f576d1970af267bc05e85e7699a8edca695dfd235bde7b78078301ff7&mpshare=1&scene=23&srcid=&sharer_sharetime=1590882441576&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
```markdown

```
####  ping的工作原理
[ping 的工作原理](https://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&mid=2453142815&idx=2&sn=c1b16ab077446435ccd8a6bc98d5b559&chksm=8cf2df9cbb85568a855e6d51e882292e3565d50fcb8462c27df0fe0063882af9db29e136fe70&mpshare=1&scene=23&srcid=&sharer_sharetime=1590987976205&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
```markdown
ping是基于ICMP协议工作的,ICMP全称是Internet Control Message Protocol，也就是互联网控制报文协议。
ICMP主要的功能包括：确认IP包是否成功送达目标地址、报告发送过程中IP包被废弃的原因和改善网络设置等。
ICMP报文是封装在IP包里面，它工作在网络层，是IP协议的助手。
![ICMP 包头格式](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcZiaMXRx5FarzuAMKmf0Cj29gb37HdxOjFprAJ1zycOxZdHEbz4tafArtrZFAibw90Dn1BJmgaG5eg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
ICMP 包头的类型字段，大致可以分为两大类：
    一类是用于诊断的查询消息，也就是「查询报文类型」
    另一类是通知出错原因的错误消息，也就是「差错报文类型」
```
#### [TCP参数及Linux操作系统调节TCP参数](https://www.cnblogs.com/xiaolincoding/p/13067971.html)
```markdown

```
### 4.IP 基础知识
[IP 基础知识“全家桶”，45 张图一套带走](https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&mid=2650136938&idx=3&sn=67976543452d053f38ef98ad432e2b0a&chksm=f36bfc4bc41c755d9635f4868247f5c32af011e39055a93457a48ea624fa64206337bbc732c7&xtrack=1&scene=90&subscene=93&sessionid=1595738415&clicktime=1595738485&enterid=1595738485&ascene=56&devicetype=android-27&version=27001135&nettype=WIFI&abtest_cookie=AAACAA%3D%3D&lang=zh_CN&exportkey=AZt8sKmIZAR5dAcuhZz%2BTNw%3D&pass_ticket=ti6jCKVPm3InI6pMg16GBXD3aOQEiXkZyc7df%2BpfdJBz1TvM0wxYU9GHpOvyR%2Bqh&wx_header=1)
#### 4.1.IP基础知识
```markdown
IP在TCP/IP参考模型中处于第三层，也就是网络层。
网络层的主要作用是：实现主机与主机之间的通信，也叫点对点（end to end）通信。
IP（网络层）和MAC（数据链路层）之间的区别和关系。
    IP的作用是主机之间通信中的，而MAC的作用则是实现「直连」的两个设备之间通信，而IP则负责在「没有直连」的两个网络之间进行通信传输。
    计算机网络中也需要「数据链路层」和「网络层」这个分层才能实现向最终目标地址的通信。
    源IP地址和目标IP地址在传输过程中是不会变化的，只有源MAC地址和目标MAC一直在变化。
```
#### 4.2.IP地址是基础知识
```markdown
在TCP/IP网络通信时，为了保证能正常通信，每个设备都需要配置正确的IP地址，否则无法实现正常的通信。
IP地址（IPv4 地址）由32位正整数来表示,IP地址在计算机是以二进制的方式处理的。
IP 地址分类成了5种类型，分别是A类、B类、C类、D类、E类。
```
#### 4.3.IP协议相关技术
```markdown
DNS域名解析:DNS可以将域名网址自动转换为具体的IP地址。
ARP与RARP协议:ARP是借助ARP请求与ARP响应两种类型的包确定MAC地址的。
DHCP动态获取IP地址
NAT网络地址转换
ICMP互联网控制报文协议:确认IP包是否成功送达目标地址、报告发送过程中IP包被废弃的原因和改善网络设置等。
IGMP因特网组管理协议：工作在主机（组播成员）和最后一跳路由之间
```
### 5.### [随笔分类 - 网络协议](https://www.cnblogs.com/BeiGuo-FengGuang/category/1329919.html)
>>说说计算机网络，每层干嘛，有什么协议，

## 二、操作系统
>> [参考博客：5万字、97 张图总结操作系统核心知识点](https://www.cnblogs.com/cxuanBlog/p/13297199.html)
### 1.[参考资料：操作系统总结](https://www.cnblogs.com/blknemo/p/12274600.html)
#### 1.基础概念：并发与并行，共享，虚拟，异步
```markdown
**并发**是指宏观上在一段时间内能同时运行多个程序，而**并行**则指同一时刻能运行多个指令。
    并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。操作系统通过引入进程和线程，使得程序能够并发运行。
**共享**是指系统中的资源可以被多个并发进程共同使用。有两种共享方式：互斥共享和同时共享。
    互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。
**虚拟技术**把一个物理实体转换为多个逻辑实体。主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。
    多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。
**虚拟内存**使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，
    地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。
```
#### 2.计算机硬件（冯诺伊曼的体系结构）
```markdown
计算机硬件是计算机的重要组成部分，其中包含了 5 个重要的组成部分：运算器、控制器、存储器、输入设备、输出设备。
运算器：运算器最主要的功能是对数据和信息进行加工和运算。它是计算机中执行算数和各种逻辑运算的部件。
    运算器的基本运算包括加、减、乘、除、移位等操作，这些是由算术逻辑单元(Arithmetic&logical Unit) 实现的。
    而运算器主要由算数逻辑单元和寄存器构成。
控制器：指按照指定顺序改变主电路或控制电路的部件，它主要起到了控制命令执行的作用，完成协调和指挥整个计算机系统的操作。
    控制器是由程序计数器、指令寄存器、解码译码器等构成。
    运算器和控制器共同组成了CPU
存储器：存储器就是计算机的记忆设备，顾名思义，存储器可以保存信息。存储器分为两种，一种是主存，也就是内存，
    它是CPU主要交互对象，还有一种是外存，比如硬盘软盘等。下面是现代计算机系统的存储架构
输入设备：输入设备是给计算机获取外部信息的设备，它主要包括键盘和鼠标。
输出设备：输出设备是给用户呈现根据输入设备获取的信息经过一系列的计算后得到显示的设备，它主要包括显示器、打印机等。
总线(Buses)：在整个系统中运行的是称为总线的电气管道的集合，这些总线在组件之间来回传输字节信息。通常总线被设计成传送定长的字节块，也就是字(word)。
    字中的字节数（字长）是一个基本的系统参数，各个系统中都不尽相同。现在大部分的字都是 4 个字节（32 位）或者 8 个字节（64 位）。
I/O设备(I/O Devices)：Input/Output设备是系统和外部世界的连接。I/O设备：用于用户输入的键盘和鼠标，用于用户输出的显示器，
    一个磁盘驱动用来长时间的保存数据和程序。刚开始的时候，可执行程序就保存在磁盘上。
```
###2.[我和面试官之间关于操作系统的一场对弈！写了很久，希望对你有帮助！](https://www.cnblogs.com/javaguide/p/operating-system.html)
#### 1.1 什么是操作系统？
```markdown
操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机系统的内核与基石；
    操作系统本质上是运行在计算机上的软件程序 ；
    操作系统为用户提供一个与系统交互的操作界面 ；
    操作系统分内核与外壳（我们可以把外壳理解成围绕着内核的应用程序，而内核就是能操作硬件的程序）。
操作系统也是一种软件，但是操作系统是一种非常复杂的软件。操作系统提供了几种抽象模型
    文件：对 I/O 设备的抽象
    虚拟内存：对程序存储器的抽象
    进程：对一个正在运行程序的抽象
    虚拟机：对整个操作系统的抽象
```
#### 1.2 什么是系统调用呢？ 
```markdown
操作系统提供的函数就被称为系统调用（system call）。软件程序的执行一般是在用户态下执行的，但当程序需要使用操作系统提供的服务时，
    比如说打开某一设备、创建文件、读写文件（这些均属于系统调用）等，就需要向操作系统发出调用服务的请求，这就是系统调用。
根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：
    用户态(user mode) : 用户态运行的进程或可以直接读取用户程序的数据。（软件程序运行）
    内核态(kernel mode):可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。（操作系统运行）
在我们运行的用户程序中，凡是与系统态（内核态）级别的资源有关的操作（如文件管理、进程控制、内存管理等)，
    都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。
 异常：当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。
 外围设备的中断：当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号
    对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。
    比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。
```
#### 1.3 进程和线程的区别【2+】
```markdown
进程是资源分配的基本单位。线程是独立调度的基本单位。一个进程中可以有多个线程，它们共享进程资源。
**拥有资源**：进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。
**调度**：线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。
**系统开销**：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等，所付出的开销远大于创建或撤销线程时的开销。
    类似地，在进行进程切换时，涉及当前执行进程CPU环境的保存及新调度进程CPU环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。
**通信方面**：线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助IPC。
```
#### 1.4 进程有哪几种状态?
```markdown
创建状态(new) ：进程正在被创建，尚未到就绪状态。
就绪状态(ready) ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。
运行状态(running) ：进程正在处理器上上运行(单核CPU下任意时刻只有一个进程处于运行状态)。
阻塞状态(waiting) ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待IO操作完成。即使处理器空闲，该进程也不能运行。
结束状态(terminated) ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。
```
#### 1.5 进程间的通信方式
```markdown
**信号(Signal)** ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；（Linux系统上输入kill -l来列出系统使用的信号）
**管道/匿名管道(Pipes)** ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。
    在两个进程之间，可以建立一个通道，一个进程向这个通道里写入字节流，另一个进程从这个管道中读取字节流。（shell中的管线pipelines就是用管道实现的）
**命名管道(Names Pipes)**: 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。
    有名管道严格遵循先进先出(first in first out)。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。
**消息队列(Message Queuing)** ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。
    管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）
    不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。
    消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。
    消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺。
**信号量(Semaphores)** ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。
**共享内存(Shared memory)** ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。
    这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。
**套接字(Sockets)** : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持TCP/IP的网络通信的基本操作单元，
    可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。
```
#### 1.6 线程间的同步的方式
```markdown
**同步与互斥**：同步：多个进程按一定顺序执行；互斥：多个进程在同一时刻只有一个进程能进入临界区。
    线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。
操作系统一般有下面三种线程同步的方式：
**互斥量(Mutex)**：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会
    被多个线程同时访问。比如Java中的synchronized关键词和各种Lock都是这种机制。
**信号量(Semphares)**：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量
**事件(Event) :Wait/Notify**：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操。
**临界区**：对临界资源进行访问的那段代码称为临界区。为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。
```
#### 1.7 进程的调度算法
```markdown
**批处理系统**:批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。
**先到先服务(FCFS)调度算法**:从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用CPU时再重新调度。
**短作业优先(SJF)的调度算法**:从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用CPU时再重新调度。
**时间片轮转调度算法**:时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称RR(Roundrobin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。
**多级反馈队列调度算法**:前面介绍的几种进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程 。
    多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。因而它是目前被公认的一种较好的进程调度算法，UNIX操作系统采取的便是这种调度算法。
**优先级调度**：为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以FCFS方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。

**交互式系统**
**时间片轮转**:将所有就绪进程按FCFS的原则排成一个队列，每次调度时，把CPU时间分配给队首进程，该进程可以执行一个时间片。
当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把CPU时间分配给队首的进程。
**优先级调度**:为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。
**多级反馈队列**:可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。

**实时系统**:实时系统要求一个请求在一个确定时间内得到响应。分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。
```
#### 1.8 死锁
```markdown
大部分的死锁都和资源有关，在进程对设备、文件具有独占性（排他性）时会产生死锁。我们把这类需要排他性使用的对象称为资源(resource)。
资源主要分为：可抢占资源和不可抢占资源
死锁：如果一组进程中的每个进程都在等待一个事件，而这个事件只能由该组中的另一个进程触发，这种情况会导致死锁。
死锁的必要条件：
     互斥条件 (Mutual exclusion)：资源不能被共享，只能由一个进程使用。
     请求与保持条件 (Hold and wait)：已经得到资源的进程可以再次申请新的资源。
     非抢占条件 (No pre-emption)：已经分配的资源不能从相应的进程中被强制地剥夺。
     循环等待条件 (Circular wait)：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源。
发生死锁时，上面的情况必须同时会发生。如果其中任意一个条件不会成立，死锁就不会发生。可以通过破坏其中任意一个条件来破坏死锁。
死锁的处理策略：
     鸵鸟策略：忽略死锁带来的影响
     死锁检测与死锁恢复（检测死锁并回复死锁，死锁发生时对其进行检测，一旦发生死锁后，采取行动解决问题）
        从死锁中恢复：通过抢占进行恢复,通过回滚进行恢复,杀死进程恢复。
     死锁预防（通过仔细分配资源来避免死锁）
     死锁避免（通过破坏死锁产生的四个条件之一来避免死锁）
        单个资源的银行家算法，破坏死锁，破坏互斥条件，破坏保持等待的条件，破坏不可抢占条件，破坏循环等待条件。
```
#### 1.9 内存管理
```markdown
虚拟内存：目的是为了让物理内存扩充为更大的逻辑内存，从而让程序获得更大的可用内存。
分页系统内存映射：内存管理单元管理者地址空间和物理内存否转换,其中的页表存储着页(程序地址空间)和页框(物理内存空间)的映射表。
页面置换算法：OPT,LRU,NRU，FIFO，第二次机会算法，CLOCK
分页:虚拟内存采用的就是分页技术，也就是将地址空间分成固定的大小的页，每一页再与内存进行映射。
段页式:程序的地址空间划分成多个拥有独立地址空间的段，每一个段上的地址空间划分为大小相同的页。
```
#### 1.10 CPU的上下文切换有几种？系统中断进行了几次上下文切换？
```markdown
上下文切换(Context Switch)是一种将CPU资源从一个进程分配给另一个进程的机制。操作系统需要先存储当前进程的状态 
(包括内存空间的指针，当前执行完的指令等等)，再读入下一个进程的状态，然后执行此进程。
CPU 的上下文切换分三种：进程上下文切换、线程上下文切换、中断上下文切换。
     系统调用过程中也会发生CPU上下文切换。CPU寄存器会先保存用户态的状态，然后加载内核态相关内容。
    系统调用结束之后，CPU寄存器要恢复原来保存的用户态，继续运行进程。所以，一次系统调用，发生两次CPU上下文切换。
 进程是由内核管理和调度的，进程的切换只能发生在内核态。进程上下文切换与系统调用的不同在于，
    进程的调用会保存用户空间的虚拟内存，全局变量等信息，但是系统调用的上下文则不会，因为其未发生进程的变化。
 内核中的任务调度实际是在调度线程，进程只是给线程提供虚拟内存、全局变量等资源。
    线程上下文切换时，共享相同的虚拟内存和全局变量等资源不需要修改。
    而线程自己的私有数据，如栈和寄存器等，上下文切换时需要保存。
```
#### 1.11 页面置换算法？
```markdown
 最优页面置换算法（往后看）：最理想的状态下，我们给页面做个标记，挑选一个最远才会被再次用到的页面调出
 先进先出页面置换算法（FIFO）及其改进（往前看）：这种算法的思想和队列是一样的，该算法总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予淘汰。
 最近最少使用页面置换算法LRU（往前看）：总是选择在最近一段时间内最久不用的页面予以淘汰。 即淘汰最近最长时间未访问过的页面。
 第二次机会页面置换算法：FIFO链表页面有个缺陷，那就是出链和入链并不会进行check检查，这样就会容易把经常使用的页面置换出去。
 时钟页面置换算法：当缺页错误出现时，算法首先检查表针指向的页面，如果它的R位是0就淘汰该页面，并把新的页面插入到这个位置，然后把表针向前移动一位；
```

## 三、计算机组成原理
### [计算机组成原理](https://www.cnblogs.com/reminis/p/12896053.html)
```markdown

```
### [【重学计算机】计算机组成原理](https://www.cnblogs.com/flashsun/p/10628433.html)
```markdown

```
[随笔分类 - 重学计算机笔记](https://www.cnblogs.com/flashsun/category/1391951.html)

## 四、Linux
### Linux I/O
#### 1.1 I/O 模型
[带你真正的搞懂，Linux的5种I/O模型](https://www.toutiao.com/a6619988112300835331/)
```markdown
Unix 有五种 I/O 模型：
    阻塞式I/O（blocking IO）: 应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。
    非阻塞式I/O（nonblocking IO）:应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知I/O是否完成，这种方式称为轮询（polling）。
    I/O复用（IO multiplexing）（select和poll）:使用select或者poll等待数据，并且可以等待多个套接字中的任何一个变为可读。
        这一过程会被阻塞，当某一个套接字可读时返回，之后再使用recvfrom把数据从内核复制到进程中。
    信号驱动式I/O（SIGIO）:应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。
    异步I/O（asynchronous IO）（AIO:应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。
```
#### 1.2 I/O复用
```markdown
同步I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段，应用进程会阻塞。
异步I/O：不会阻塞。
阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O 都是同步 I/O，它们的主要区别在第一个阶段。
非阻塞式 I/O 、信号驱动 I/O 和异步 I/O 在第一阶段不会阻塞。
```
#### 1.3 IO多路复用的select、poll和epoll函数的区别？【2+】
```markdown
 select函数监视文件描述符，调用后select函数会阻塞，直到有描述符就绪，或者超时，函数返回，当select函数返回后，就可以遍历描述符，找到就绪的描述符。
    select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制
 没有最大限制（但是数量过大后性能也是会下降）。和select函数一样，poll返回后，需要轮询来获取就绪的描述符。
 epoll 是Linux内核为处理大批量文件描述符而作了改进的poll，是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的
情况下的系统CPU利用率。另一点原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。
```
#### [说了这么多次 I/O，但你知道它的原理么](https://www.cnblogs.com/cxuanBlog/p/13032486.html)
### Linux常用命令
#### [不可不知的7个JDK 命令](https://www.cnblogs.com/wupeixuan/p/12965240.html)
```markdown
javap:使用javap可以查看Java字节码反编译的源文件。
jsp:jps 是用来查询当前所有进程 pid 的。
jstat: jstat 主要用于监控 JVM，主要是 GC 信息，在性能优化的时候经常用到，
jcmd: jcmd 可以查看 JVM 信息。
jmap: jmap 打印出 Java 进程内存中 Object 的情况，或者将 JVM 中的堆以二进制输出成文本。
jhat: jhat 分析 Java 堆的命令，可以将堆中对象以 html 的形式显示出来，支持对象查询语言 OQL
jsatck: jstack 是堆栈跟踪工具，主要用于打印给定进程 pid 的堆栈信息，
    一般在发生死锁或者 CPU 100% 的时候排查问题使用，可以去查询当前运行的线程以及线程的堆栈信息是什么情况
[给你的Java程序拍个片子吧：jstack命令解析](https://www.cnblogs.com/jay-huaxiao/p/12865552.html)
整机 top:    uptime
CPU vmstat -n 2 3  # 每两秒采样一次，采样三次。
    查看额外： mpstat -P ALL 2 查看所有CPU核信息
              pidstat -u 1 -p 进程编号  每个进程使用cpu的用量分解信息
内存 free 应用程序可用内存数 free -m ,free -g  查看内存的单位
    查看额外 pidstat -p 进程号 -r 采样间隔秒数
硬盘 df  查看磁盘剩余空闲数  df -h
磁盘IO iostat   磁盘I/O性能评估 iostat -xdk 2 3
    查看额外 pidstat -d 采样间隔秒数 -p 进程号
网络IO ifstat 默认本地没有，下载    ifstat l  查看网络I/O
```
#### 20条经典Linux运维面试
```markdown
问:1如何查看当前的Linux服务器的运行级别？
答: ‘who -r’ 和 ‘runlevel’ 命令可以用来查看当前的Linux服务器的运行级别。
问:2如何查看Linux的默认网关？
答: 用 “route -n” 和 “netstat -nr” 命令，我们可以查看默认网关。除了默认的网关信息，这两个命令还可以显示当前的路由表。
问:3如何在Linux上重建初始化内存盘镜像文件？
答: 在CentOS 5.X / RHEL 5.X中，可以用mkinitrd命令来创建初始化内存盘文件，举例如下：
# mkinitrd -f -v /boot/initrd-$(uname -r).img $(uname -r)
如果你想要给特定的内核版本创建初始化内存盘，你就用所需的内核名替换掉 ‘uname -r’ 。
在CentOS 6.X / RHEL 6.X中，则用dracut命令来创建初始化内存盘文件，举例如下：
# dracut -f
以上命令能给当前的系统版本创建初始化内存盘，给特定的内核版本重建初始化内存盘文件则使用以下命令：
# dracut -f initramfs-2.x.xx-xx.el6.x86_64.img 2.x.xx-xx.el6.x86_64
问:4cpio命令是什么？
答: cpio就是复制入和复制出的意思。cpio可以向一个归档文件（或单个文件）复制文件、列表，还可以从中提取文件。
问:5patch命令是什么？如何使用？
答: 顾名思义，patch命令就是用来将修改（或补丁）写进文本文件里。patch命令通常是接收diff的输出并把文件的旧版本转换为新版本。
举个例子，Linux内核源代码由百万行代码文件构成，所以无论何时，任何代码贡献者贡献出代码，只需发送改动的部分而不是整个源代码，
然后接收者用patch命令将改动写进原始的源代码里。
创建一个diff文件给patch使用，
# diff -Naur old_file new_file > diff_file
旧文件和新文件要么都是单个的文件要么都是包含文件的目录，-r参数支持目录树递归。
一旦diff文件创建好，我们就能在旧的文件上打上补丁，把它变成新文件：
# patch < diff_file
问:6aspell有什么用 ?
答: 顾名思义，aspell就是Linux操作系统上的一款交互式拼写检查器。aspell命令继任了更早的一个名为ispell的程序，并且作为一款免费替代品 ，最重要的是它非常好用。当aspell程序主要被其它一些需要拼写检查能力的程序所使用的时候，在命令行中作为一个独立运行的工具的它也能十分有效。
 问:7如何从命令行查看域SPF记录？
答: 我们可以用dig命令来查看域SPF记录。举例如下：
linuxtechi@localhost:~$ dig -t TXT google.com
问:8如何识别Linux系统中指定文件(/etc/fstab)的关联包？
答:
# rpm -qf /etc/fstab
以上命令能列出提供“/etc/fstab”这个文件的包。
问:9哪条命令用来查看bond0的状态？
答:
cat /proc/net/bonding/bond0
问:10Linux系统中的/proc文件系统有什么用？
答: /proc文件系统是一个基于内存的文件系统，其维护着关于当前正在运行的内核状态信息，其中包括CPU、内存、分区划分、I/O地址、直接内存访问通道和正在运行的进程。这个文件系统所代表的并不是各种实际存储信息的文件，它们指向的是内存里的信息。/proc文件系统是由系统自动维护的。
问:11如何在/usr目录下找出大小超过10MB的文件？
答:
# find /usr -size +10M
问:12如何在/home目录下找出120天之前被修改过的文件？
答:
# find /home -mtime +120
问:13如何在/var目录下找出90天之内未被访问过的文件？
答:
# find /var ! -atime -90
问:14在整个目录树下查找文件“core”，如发现则无需提示直接删除它们。
答:
# find / -name core -exec rm {} ;
问:15strings命令有什么作用？
答: strings命令用来提取和显示非文本文件中的文本字符串。（LCTT 译注：当用来分析你系统上莫名其妙出现的二进制程序时，可以从中找到可疑的文件访问，对于追查入侵有用处）
问:16tee 过滤器有什么作用 ?
答: tee 过滤器用来向多个目标发送输出内容。如果用于管道的话，它可以将输出复制一份到一个文件，并复制另外一份到屏幕上（或一些其它程序）。
linuxtechi@localhost:~$ ll /etc | nl | tee /tmp/ll.out
在以上例子中，从ll输出可以捕获到 /tmp/ll.out 文件中，并且同样在屏幕上显示了出来。
问:17export PS1 = ”$LOGNAME@hostname:$PWD: 这条命令是在做什么？
答: 这条export命令会更改登录提示符来显示用户名、本机名和当前工作目录。
问:18ll | awk ‘{print $3,”owns”,$9}’ 这条命令是在做什么？
答: 这条ll命令会显示这些文件的文件名和它们的拥有者。
问:19Linux中的at命令有什么用？
答: at命令用来安排一个程序在未来的做一次一次性执行。所有提交的任务都被放在 /var/spool/at 目录下并且到了执行时间的时候通过atd守护进程来执行。
问:20linux中lspci命令的作用是什么？
答: lspci命令用来显示你的系统上PCI总线和附加设备的信息。指定-v，-vv或-vvv来获取越来越详细的输出，加上-r参数的话，命令的输出则会更具有易读性。
```
## 
###
