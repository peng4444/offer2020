# 计算机网络和操作系统知识总结

[TOC]


## 一、计算机网络 
>> [参考资料：cyc2018大佬](https://cyc2018.github.io/CS-Notes/#/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E7%9B%AE%E5%BD%951)
>> 参考书籍：《图解TCP/IP第五版》、《图解HTTP》、《计算机网络第七版》
>>1.[参考资料：计算机网络常见面试题](https://www.cnblogs.com/wuwuyong/p/12198928.html)
>>2.[参考资料：总结12道最常见的计算机网络面试题](https://www.cnblogs.com/tanshaoshenghao/p/11835679.html)
### 1.三种体系结构&计算机网络的体系结构&网络协议【10+】
![](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E4%BA%94%E5%B1%82%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png)
>> OSI的体系结构:应用层-表示层-会话层-运输层-网络层-数据链路层-物理层
>> 五层协议的体系结构:应用层-运输层-网络层-数据链路层-物理层
>> TCP/IP的体系结构:应用层-传输层-网络层-链路层
```markdown
1.应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）
    间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如**域名系统DNS**，
    支持万维网应用的**HTTP协议**，支持电子邮件的**SMTP协议**等等。我们把应用层交互的数据单元称为报文。
    功能：文件传输，电子邮件，文件服务，虚拟终端:TFTP，HTTP，SNMP，FTP，SMTP，DNS，RIP，Telnet
2.表示层：网络服务和应用程序之间的数据转换，如字符编码、数据压缩、加密解密；
3.会话层：控制计算机之间的连接，负责建立、管理和终止本地和远程引用程序之间的连接，提供全双工、半双工或者单工操作；
4.运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。
“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。
    所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。
[参考资料：运输层 ,跑腿的秘书](https://www.cnblogs.com/king0/p/12932251.html)
    运输层主要使用以下两种协议:   
        1.**传输控制协议 TCP**（Transmission Control Protocol）--提供面向连接的，可靠的数据传输服务。
        2.**用户数据协议 UDP**（User Datagram Protocol）--提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。
5.网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组
    和包进行传送。在TCP/IP体系结构中，由于网络层使用**IP协议**，因此分组也叫IP数据报，简称数据报。**ICMP,路由器,防火墙**。
6.数据链路层(data link layer)通常简称为链路层。两台主机之间的数据帧传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。 
    在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。
    每一帧包括数据和必要的控制信息（如**同步信息，地址信息，差错控制等**）。**网卡,网桥,交换机**
7.物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。 
    使其上面的数据链路层不必考虑网络的具体传输介质是什么。在物理层上所传送的数据单位是比特。**中继器,集线器**
```
![](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E4%B8%83%E5%B1%82%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9B%BE.png)
### 2.通信交互方式
```markdown
单工通信，又称为单向通信，只有一个方向的通信，如无线电广播，电视广播；
半双工通信，又称为双向交替通信，双方都可以收发信息，只能交替进行；
全双工通信，又称为双向同时通信，双方可以同时发送和接收数据。
```
### 3.信道复用技术
```markdown
为了提高信道利用率，有哪些信道复用技术？
所谓信道复用技术，指的是大家共享一个信道进行通信，在接收端在使用分用器，把合起来传输的信息分别送到相应的终点；
频分复用:用户在分配到一定的频带后，通信过程中使用都占用这个频带；
时分复用:将时间划分为一段段等长时分复用帧，每一个时分复用的用户周期性的占用帧位；
统计时分复用:时分复用，如果用户没有任何数据要传输，也会周期性的给他分配时隙，这就导致了信道利用率不高。为此出现了统计时分复用。
    统计时分复用使用STDM帧来传送复用的数据，把所有用户数据按时间顺序组成STDM帧，放入一个队列中，依次发送出去，这样就能够更合理的共享信道。
    STDM帧中的数据需要添加用户地址首部信息，以便能够正确的分发给目标用户：
```
### 4.TCP的三次握手机制，为什么要三次握手？【10+】
![](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B2.png)
```markdown
首先服务器端处于LISTEN（监听）状态，等待客户的连接请求。
1.客户端–发送带有SYN标志的数据包–一次握手–服务端，并且客户端进入SYN_SEND状态，等待服务器确认。
2.服务端–发送带有SYN/ACK=1标志的数据包–二次握手–客户端，服务器进入SYN_RECV状态。
3.客户端–发送带有带有ACK标志的数据包–三次握手–服务端，客户端和服务器进入ESTABLISHED状态，TCP的三次握手完成。
SYN:是TCP/IP建立连接时使用的握手信号。
ACK:确认字符，在数据通信传输中，接收站发给发送站的一种传输控制字符。它表示确认发来的数据已经接受无误。
三次握手的目的是建立可靠的通信信道，通讯简单来说就是数据的发送与接收。最主要的目的就是双方确认自己与对方的发送与接收是正常的。
    第一次握手：Client什么都不能确认；Server确认了对方发送正常，自己接收正常
    第二次握手：Client确认了：自己发送、接收正常，对方发送、接收正常；Server确认了：对方发送正常，自己接收正常
    第三次握手：Client确认了：自己发送、接收正常，对方发送、接收正常；Server确认了：自己发送、接收正常，对方发送、接收正常
```
### 5.为什么要传回SYN？传了SYN,为啥还要传ACK？讲一讲SYN超时，洪泛攻击，以及解决策略？
```markdown
**为什么要传回SYN包？**
    接收端传回发送端所发送的SYN包是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。
**传了SYN包,为啥还要传ACK？**
    双方通信无误必须是两者互相发送信息都无误。传了SYN包，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要ACK信号来进行验证。
**讲一讲SYN包超时，洪泛攻击，以及解决策略？**
    在TCP的三次握手机制的第一步中，客户端会向服务器发送SYN报文段。服务器接收到SYN报文段后会为该TCP分配缓存和变量，
        如果攻击分子大量地往服务器发送SYN报文段，服务器的连接资源终将被耗尽，导致内存溢出无法继续服务。
    **解决策略**：当服务器接受到SYN报文段时，不直接为该TCP分配资源，而只是打开一个半开的套接字。
        接着会使用SYN报文段的源Id，目的Id，端口号以及只有服务器自己知道的一个秘密函数生成一个cookie，并把cookie作为序列号响应给客户端。
    **保活机制**：向对方发送保活探测报文，如果未收到响应则继续发送，尝试次数达到保活探测仍未收到响应则中断连接。
```
### 6.TCP的四次挥手机制，为什么要有TIME_WAIT状态，为什么需要四次握手？服务器出现了大量CLOSE_WAIT状态如何解决【4+】
![](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png)
```markdown
1.客户端-发送一个FIN，用来关闭客户端到服务器的数据传送。客户端进入FIN_WAIT_1状态。
2.服务器-收到这个FIN，它发回一个ACK，确认序号为ACK加1。服务器进入CLOSE_WAIT状态。客户端收到服务器返回的ACK报文之后随即进入FIN_WAIT_2状态。
3.服务器-观察自己是否还有没有数据要发送到客户端，如果有，先把数据发送给客户端，再发送FIN报文；
      如果没有，那么直接发送一个FIN报文给客户端，请求关闭服务器到客户端的数据传送，服务器进入LAST_ACK状态。
4.客户端-收到FIN报文后，向服务器发送ACK报文，将Seq+1，Ack+1，然后进入TIME_WAIT状态；
      服务器收到客户端的ACK报文之后就关闭了连接；此时，客户端等待2msl后依然没有收到回复，则证明服务器已正常关闭，客户端也可以关闭连接了。
**为什么需要四次握手？**:任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。
    当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。因为全双工，发送方和接收方都需要FIN报文和ACK报文。
**为什么要有TIME_WAIT状态**:​ 为了解决网络的丢包和网络不稳定所带来的其他问题，确保连接方能在时间范围内，关闭自己的连接。
    因为客户端最后向服务器发送的确认ACK是有可能丢失的，当出现超时，服务端会再次发送FIN报文段，
    如果客户端已经关闭了就收不到了。还有一点是避免新旧连接混杂。
**为什么会TIME-WAIT过多？解决方法是怎样的？**
​    可能原因：高并发短连接的TCP服务器上，当服务器处理完请求后立刻按照主动正常关闭连接
​    解决：负载均衡服务器；Web服务器首先关闭来自负载均衡服务器的连接
**服务器大量CLOSE_WAIT状态的原因**:表示程序出现了问题，对方的socket已经关闭连接，而我方忙于读或写没有及时关闭连接，
    需要检查代码，特别是释放资源的代码，或者是处理请求的线程配置。CLOSE-WAIT：这种状态的含义其实是表示在等待关闭。
```
### 4.详细讲一下TCP的滑动窗口及作用【2+】
![](https://www.cnblogs.com/images/cnblogs_com/tanshaoshenghao/1426602/o_%e7%bd%91%e7%bb%9c7.png)
```markdown
RTT:发送一个数据包到收到对应的ACK所花费的时间。
RTO:重传时间间隔。
滑动窗口左边的是已发送并且被确认的分组，滑动窗口右边是还没有轮到的分组。
滑动窗口里面也分为两块，一块是已经发送但是未被确认的分组，另一块是窗口内等待发送的分组。
随着已发送的分组不断被确认，窗口内等待发送的分组也会不断被发送。整个窗口就会往右移动，让还没轮到的分组进入窗口内。
滑动窗口起到了一个限流的作用，也就是说当前滑动窗口的大小决定了当前TCP发送包的速率，
而滑动窗口的大小取决于拥塞控制窗口和流量控制窗口的两者间的最小值。
**TCP使用滑动窗口进行流量控制和乱序重排：保证TCP的可靠性，保证TCP的流控特性。**
    流量控制是为了控制发送方发送速率，保证接收方来得及接收。
    接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。
回答了从效率角度数据分包后一次发送多个，窗口大小和流量控制拥塞控制挂钩，批量确认应答，超时重传，这几个角度
```
### 5.讲一下HTTP与HTTPS的特点和区别，HTTP请求和响应的步骤【10+】
```markdown
超文本传输协议HTTP的主要特点：
    - 支持客户/服务器模式
    - 简单快速
    - 灵活
    - 无连接
    - 无状态
HTTP和HTTPS的主要区别在于HTTP协议传递的是明文数据，而HTTPS传递的是加密过的数据，也就是说HTTPS更具有安全性。
    也正由HTTPS需要保证安全性，所以它的性能要比HTTP差一点。
    HTTP的端口是80，HTTPS的端口是443
    HTTPS中使用到的对称加密，非对称加密，CA，数字证书的概念HTTPS想要保证客户端与服务器之间的通信安全，就得使用对称加密算法进行加密。
    协商对称加密算法的过程通过非对称加密算法来保证。在非对称加密算法中，客户端获得公钥的过程需要第三方机构（CA）通过颁发数字证书保证安全性。
SSL(Security Sockets layer,安全套接字)
    - 为网络通信提供安全及数据完整性的一种安全协议
    - 是操作系统对外的API,SSL3.0后改名为TLS
    - 采用身份验证和数据加密保证网络通信的安全和数据的完整性。
HTTP请求和响应的步骤：
    - 客户端连接到Web服务器
    - 发送HTTP请求
    - 服务器接收到请求并且返回HTTP响应
    - 释放连接TCP连接
    - 客户端浏览器解析HTML内容
HTTPS数据传输流程（HTTPS链接建立的过程）：
    - 浏览器/客户端将支持的加密算法信息发送给服务器
    - 服务器选择一套浏览器支持的加密算法，以SSL证书的形式回发浏览器/客户端 内容包括：证书的发布机构、有效期、所有者、签名以及公钥
    - 浏览器/客户端验证证书的合法性，校验为真则结合证书公钥秘钥加密信息发送给服务器
    - 服务器使用私钥解密信息，验证哈希，使用对称密钥加密响应消息回发浏览器/客户端
    - 浏览器/客户端解密响应消息，并且对消息进行验真，之后进行加密交互数据
    - 随后客户端和服务端就使用对称密钥进行信息传输
```
#### 6.TCP和UDP的区别及使用场景【10+】
[聊聊UDP、TCP和实现一个简单的JAVA UDP小Demo](https://www.cnblogs.com/huangqingshi/p/12950639.html)
```markdown
TCP和UDP都是OSI模型中运输层的协议，TCP提供可靠的通信运输，UDP则被用于广播和细节扩展交给应用的通信运输。
TCP:面向连接，可靠，字节流  传输效率低，需要资源多  文件，邮件传输  首部20-60字节  HTTP,FTP,SMTP
UDP:无连接，不可靠，数据报文段  传输效率高，需要资源少  语音，视频直播 首部8个字节  RIP,DNS,SNMP
UDP的特点：
    - 面向非连接
    - 不维护连接状态，支持同时向多个客户端传输相同的消息
    - 数据包报头只有8个字节，额外开销小。
    - 吞吐量最后受限于数据生成速率，传输速率以及集群机器性能。
    - 尽最大努力交付，不保证可靠交付，不需要维持复杂的连接状态表。
    - 面向报文，不对应用程序提交的报文信息进行拆分或者合并。
1.UDP在传送数据之前不需要先建立连接，远地主机在收到UDP报文后，不需要给出任何确认。
    虽然UDP不提供可靠交付，但在某些情况下UDP确是一种最有效的工作方式（一般用于即时通信）
2.TCP提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP不提供广播或多播服务。
    由于TCP要提供可靠的，面向连接的传输服务。TCP一般用于文件传输、发送和接收邮件、远程登录等场景。
 面向连接VS无连接，可靠性，有序性，速递，量级。TCP首部字节：20-60，UDP首部字节:8个字节(4个字段组成)
```
[tcp、udp、ip、icmp报文格式分析](https://www.cnblogs.com/znl233/p/9968592.html)
#### 7.TCP协议如何保证可靠传输和有序传输【3+】
[你还在为TCP重传、滑动窗口、流量控制、拥塞控制发愁吗？看完图解就不愁了](https://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&mid=2453143215&idx=2&sn=e9e767ebcbd2fce4688ba71db4fbd32d&chksm=8cf2dc2cbb85553aa034a49abf9c172ebe0d89e6332f87bd9038bc53b6c9642a835f499c8b44&mpshare=1&scene=23&srcid=&sharer_sharetime=1591507618951&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
```markdown
​TCP通过：应用数据分割、对数据包进行编号、校验和、流量控制、拥塞控制、ARP协议、超时重传等措施保证数据的可靠传输；
1.应用数据被分割成TCP认为最适合发送的数据块。
2.TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。
3.数据包校验和:TCP将保持它首部和数据的检验和。是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。
    如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。
4.TCP的接收端会丢弃重复的数据：对于重复数据，能够丢弃重复数据。
5.**流量控制**：TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。
    [通俗易懂讲解TCP流量控制机制，了解一下](https://www.cnblogs.com/kubidemanong/p/9987810.html)
    当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。
    TCP使用的流量控制协议是可变大小的滑动窗口协议。（TCP利用滑动窗口实现流量控制）
6.**拥塞控制**：当网络拥塞时，减少数据的发送，降低整个网络的拥塞程度。
    [一文读懂拥塞控制](https://www.cnblogs.com/kubidemanong/p/9973757.html)
    TCP的拥塞控制采用了四种算法，即慢开始、拥塞避免、快重传和快恢复。
    ​拥塞控制目的：为了防止过多的数据注入到网络中，避免网络中的路由器、链路过载
    ​拥塞控制过程：TCP发送发将维护一个拥塞窗口的状态变量，该变量随着网络拥塞程度动态变化，通过慢开始、拥塞避免等算法减少网络拥塞的发生。
7.**ARQ协议(自动重传请求)**：也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。
8.**超时重传**：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。
9.**TCP利用滑动窗口实现流量控制**。流量控制是为了控制发送方发送速率，保证接收方来得及接收。
    接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为0，则发送方不能发送数据。
```
#### 8.在地址栏键入URL后，网络世界发生了什么流程？【10+】
[一文摸透从输入URL到页面渲染的过程](https://www.cnblogs.com/AhuntSun-blog/p/12641050.html)
```markdown
在键入URL之前，刚开完机的时候，需要联网，然后才能上网。
    这个阶段包括了获取本机IP地址，获取DNS服务器IP地址，获得网关路由器IP和MAC地址等操作。
--获取本机IP地址，DNS服务器地址，网关路由器地址
--1.浏览器获取域名的IP地址 --DNS域名解析:获取域名对应IP  DNS查找IP过程：浏览器缓存，路由器缓存，DNS缓存
--2.浏览器向web发送一个HTTP请求，-- 三次握手建立TCP连接  TCP:与服务器建立TCP连接，IP:建立TCP协议时，需要发送数据，发送数据在网络层使用IP协议。
--3.建立连接后进行数据交互发送HTTP请求,服务器处理请求并返回HTTP报文,请求结束关闭TCP连接,四次挥手。
    OPSF:Ip数据在路由器之间，路由选择使用OSPF协议。ARP:路由器在于服务器通信时，需要将IP地址转换为MAC地址，需要使用ARP协议。
    HTTP：在TCP建立完成后，使用HTTP协议访问网页。
--4.浏览器解析渲染页面 构建DOM树 样式计算 页面布局 生成分层树 栅格化 显示
--5.合成与显示 连接结束。
静态资源和动态资源是怎么加载的
静态资源
动态资源
```
#### 9.HTTP的常见状态码有哪些，代表什么含义？【5+】
[面试被问了三次的http状态码到底有什么](https://www.cnblogs.com/chentang/p/12845775.html)
>> HTTP状态码是用以表示网页服务器超文本响应状态的3位数字代码。
>> 核心作用就是http状态码核心作用是Web Server服务器用来告诉客户端，当前的网页请求发生了什么事，或者说当前Web服务器的响应状态。
>> HTTP状态码常用来判断和分析当前Web服务器的运行状况。
```markdown
**首先状态码的开头不同代表不同的类型：**
    1xx：代表指示信息，表示请求已接收，继续处理
    2xx：代表成功，表示请求已被成功接收，理解，接受
    3xx：重定向，表示完成请求必须进行进一步的操作
    4xx：客户端错误，请求有语法错误或请求无法实现
    5xx：服务器端错误，服务器未能实现合法的请求
**常见状态码：**
    200 OK：正常返回信息
    204 No Content：表示客户端发送给客户端的请求得到了成功处理，但在返回的响应报文中不含实体的主体部分（没有资源可以返回）
    206 Patial Content：表示客户端进行了范围请求，并且服务器成功执行了这部分的GET请求，响应报文中包含由Content-Range指定范围的实体内容。
    301 Moved Permanently：永久性重定向，表示请求的资源被分配了新的URL，之后应使用更改的URL；
    302 Found：临时性重定向，表示请求的资源被分配了新的URL，希望本次访问使用新的URL；
    303 See Other：表示请求的资源被分配了新的URL，应使用GET方法定向获取请求的资源
    400 Bad Request：客户端请求有语法错误，不能被服务器所理解
    401 Unauthorized:请求未被授权，必须和WWW-Authenticate报头域一起
    403 Forbidden：服务器收到请求，但是拒绝提供服务
    404 Not Found：请求资源不存在，输入了错误的URL
    500 Internal Server Error：服务器发生不可预期错误
    503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常
```
#### 10. GET请求和POST请求的区别,HTTP请求有哪些【5+】
```markdown
HTTP的请求格式主要包含三个信息：1、请求的类型（GET或POST），2、要访问的资源（如resimga.jif），3、HTTP版本（http/1.1）。
GET请求，请求的数据会附加在URL之后，以?分割URL和传输数据，多个参数⽤&连接。
    URL的编码格式采⽤的是ASCII编码，⽽不是unicode，即是说所有的⾮ASCII字符都要编码之后再传输。
POST请求：POST请求会把请求的数据放置在HTTP请求包的包体中。
    因此，GET请求的数据会暴露在地址栏中，⽽POST请求则不会。
1.传输数据的⼤⼩  -- 从HTTP报文层面来看，GET请求将信息放在URL，POST将请求信息放在请求体中，
    在HTTP规范中，没有对URL的⻓度和传输的数据⼤⼩进⾏限制。但是在实际开发过程中，对于GET，特定的浏览器和服务器对URL的⻓度有限制。
    因此，在使⽤GET请求时，传输数据会受到URL⻓度的限制。
    对于POST，由于不是URL传值，理论上是不会受限制的，但是实际上各个服务器会规定对POST提交数据⼤⼩进⾏限制，Apache、IIS都有各⾃的配置。
2.安全性  -- 从数据库层面来看，GET符合幂等性和安全性，而POST请求不符合。
    POST的目的是传送实体主体内容，内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。
3.从其他层面来看，GET请求能够被缓存，GET请求能够保存在浏览器的浏览记录里，GET请求的URL能够保存为浏览器书签。这些都是POST请求所不具备的。
GET	    向特定资源发送请求，查询数据，并返回实体
POST	向指定资源提交数据进行处理请求，可能会导致新的资源建立、已有资源修改
PUT	    向服务器上传新的内容
HEAD	类似GET请求，返回的响应中没有具体的内容，用于获取报头
DELETE	请求服务器删除指定标识的资源
OPTIONS	可以用来向服务器发送请求来测试服务器的功能性
TRACE	回显服务器收到的请求，用于测试或诊断
CONNECT	HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器
```
#### 11. 什么是Cookie，Cookie的使用过程是怎么样的？
[Cookie＆Session](https://www.cnblogs.com/taojietaoge/p/11341767.html)
```markdown
由于http协议是无状态协议，如果客户通过浏览器访问web应用时没有一个保存用户访问状态的机制，那么将不能持续跟踪应用的操作。
cookie是浏览器的一种缓存机制，它可用于维持客户端与服务器端之间的会话。HTTP/1.1引入Cookie来保存状态信息。
随着现代浏览器开始支持各种各样的存储方式，Cookie渐渐被淘汰。新的浏览器API已经允许开发者直接将数据存储到本地。
**cookie的使用过程：**
    1.首先用户在客户端浏览器向服务器发起登陆请求
    2.登陆成功后，服务端会把登陆的用户信息设置cookie中，返回给客户端浏览器
    3.客户端浏览器接收到cookie请求后，会把cookie保存到本地（可能是内存，也可能是磁盘，看具体使用情况而定）
    4.以后再次访问该web应用时，客户端浏览器就会把本地的cookie带上，这样服务端就能根据cookie获得用户信息了。
```
#### 12. 什么是session，有哪些实现session的机制？实现分布式session的方式?【5+】
```markdown
session是一种维持客户端与服务器端会话的机制。但是与cookie把会话信息保存在客户端本地不一样,session把会话保留在**浏览器端**。
存储在服务器端的信息更加安全。存储在服务器上的文件、数据库或者内存中。也可以将Session存储在Redis这种内存型数据库中，效率会更高。
**session的使用过程：**
    1.首先用户在客户端浏览器发起登陆请求
    2.登陆成功后，服务端会把用户信息保存在服务端，并返回一个唯一的session标识给客户端浏览器。
    3.客户端浏览器会把这个唯一的session标识保存在起来
    4.以后再次访问web应用时，客户端浏览器会把这个唯一的session标识带上，这样服务端就能根据这个唯一标识找到用户信息。
```
#### 13. session和cookie有什么区别【5+】
```markdown
在许多web应用中，session机制就是通过cookie来实现的。或者使用URL回写实现。
    1.cookie是浏览器提供的一种缓存机制，它可以用于维持客户端与服务端之间的会话。**一般用来保存用户信息**。
    2.session指的是**维持客户端与服务端会话的一种机制**，它可以通过cookie实现，也可以通过别的手段实现。
    3.如果用cookie实现会话，那么会话会保存在**客户端**浏览器中，而session机制提供的会话是保存在**服务端**的。
    4.Cookie只能存储ASCII码字符串，而Session则可以存储任何类型的数据，因此在考虑数据复杂性时首选Session；
    5.Cookie存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在Cookie中，可以将Cookie值进行加密，然后在服务器进行解密；
    6.对于大型网站，如果用户所有的信息都存储在Session中，那么开销是非常大的，因此不建议将所有的用户信息都存储到Session中。
    7.存储的多样性：session可以存储在Redis中，数据库中，应用程序中；而cookie只能存储在浏览器中。
```
#### 14. Token
[基于token的会话保持机制](https://www.cnblogs.com/54chensongxia/p/13491214.html)
```markdown
适用于前后端分离的项目（前后端代码运行在不同的服务器下）
    请求登录时，token和sessionid原理相同，是对key和key对应的用户信息进行加密后的加密字符，登录成功后，
    会在响应主体中将{token：“字符串”}返回给客户端。客户端通过cookie都可以进行存储。
    再次请求时不会默认携带，需要在请求拦截器位置给请求头中添加认证字段Authorization携带token信息，服务器就可以通过token信息查找用户登录状态。
基于token的认证机制将认证信息返回给客户端并存储。下次访问其他页面，需要从客户端传递认证信息回服务端。简单的流程如下：
    1.客户端使用用户名跟密码请求登录；
    2.服务端收到请求，去验证用户名与密码；
    3.验证成功后，服务端会签发一个Token，再把这个Token发送给客户端；
    4.客户端收到Token以后可以把它存储起来，比如放在Cookie里或者Local Storage里；
    5.客户端每次向服务端请求资源的时候需要带着服务端签发的Token；
    6.服务端收到请求，然后去验证客户端请求里面带着的Token，如果验证成功，就向客户端返回请求的数据；
基于token的验证机制，有以下的优点：
    1.支持跨域访问，将token置于请求头中，而cookie是不支持跨域访问的；
    2.无状态化，服务端无需存储token，只需要验证token信息是否正确即可，而session需要在服务端存储，一般是通过cookie中的sessionID在服务端查找对应的session；
    3.无需绑定到一个特殊的身份验证方案（传统的用户名密码登陆），只需要生成的token是符合我们预期设定的即可；
    4.更适用于移动端（Android，iOS，小程序等等），像这种原生平台不支持cookie，
        比如说微信小程序，每一次请求都是一次会话，当然我们可以每次去手动为他添加cookie，详情请查看博主另一篇博客；
    5.避免CSRF跨站伪造攻击，还是因为不依赖cookie；
```
#### 15. Socket
```markdown
Socket是TCP/IP的抽象，是操作系统对外开放的接口。
Socket通信流程：
```
#### 16.长链接和短链接【4+】
>> 在web开发中。假设大多数的url太长 ，怎么转成短链接？ （数据库存储 然后重定向）
```markdown

```
#### 17.TCP粘包现象原因和解决方法
```markdown
​TCP粘包是指：发送方发送的若干包数据到接收方接收时粘成一包
​ 发送方原因：
    ​ TCP默认使用Nagle算法（主要作用：减少网络中报文段的数量），而Nagle算法主要做两件事：
    ​ 只有上一个分组得到确认，才会发送下一个分组
​     收集多个小分组，在一个确认到来时一起发送
    ​ Nagle算法造成了发送方可能会出现粘包问题
​ 接收方原因：
​     TCP接收到数据包时，并不会马上交到应用层进行处理，或者说应用层并不会立即处理。
     实际上，TCP将接收到的数据包保存在接收缓存里，然后应用程序主动从缓存读取收到的分组。
     这样一来，如果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程 序就有可能读取到多个首尾相接粘到一起的包。
​ 解决粘包问题：
​     最本质原因在与接收对等方无法分辨消息与消息之间的边界在哪，通过使用某种方案给出边界，例如：
    发送定长包。如果每个消息的大小都是一样的，那么在接收对等方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。
    包尾加上\r\n标记。FTP协议正是这么做的。但问题在于如果数据正文中也含有\r\n，则会误判为消息的边界。
    包头加上包体长度。包头是定长的4个字节，说明了包体的长度。接收对等方先接收包体长度，依据包体长度来接收包体。
```
#### 18.重定向和转发区别【5+】
```markdown
​ 重定向：redirect：
​       地址栏发生变化
​       重定向可以访问其他站点（服务器）的资源
​       重定向是两次请求。不能使用request对象来共享数据
​ 转发：forward：
​       转发地址栏路径不变
​       转发只能访问当前服务器下的资源
​       转发是一次请求，可以使用request对象共享数据
forward比redirect效率高。
```
### 3.[30张图解HTTP常见的面试题](https://www.cnblogs.com/xiaolincoding/p/12442435.html)
#### 3.1.HTTP1.0与HTTP1.1之间的区别【1+】
```markdown
HTTP1.0：默认使用Connection:cloose，浏览器每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立即断开TCP连接（无连接），服务器不跟踪每个客户端也不记录过去的请求（无状态）。
​HTTP1.1：默认使用Connection:keep-alive（长连接），避免了连接建立和释放的开销；通过Content-Length字段来判断当前请求的数据是否已经全部接受。不允许同时存在两个并行的响应。
​HTTP2.0：引入二进制数据帧和流的概念，其中帧对数据进行顺序标识；因为有了序列，服务器可以并行的传输数据。
​ http1.0和http1.1的主要区别如下：
​ 1、缓存处理：1.1添加更多的缓存控制策略（如：Entity tag，If-Match）
​ 2、网络连接的优化：1.1支持断点续传
​ 3、错误状态码的增多：1.1新增了24个错误状态响应码，丰富的错误码更加明确各个状态
​ 4、Host头处理：支持Host头域，不在以IP为请求方标志
​ 5、长连接：在HTTP/1.0中，默认使用的是短链接，HTTP/1.1中，默认使用的是长链接，默认开启Connection:keep-alive
```
#### 3.2.HTTP2.0及http1.1和http2.0的主要区别【2+】
[HTTP2.0](https://www.cnblogs.com/operationhome/p/12577540.html)
```markdown
HTTP/2（超文本传输协议第2版，最初命名为HTTP2.0），简称为h2（基于TLS/1.2或以上版本的加密连接）或h2c（非加密连接)，是HTTP协议的的第二个主要版本。
HTTP2新特性：
    头数据压缩 Data compression of HTTP headers
    服务器推送 HTTP/2 Server Push
    管线化请求 Pipelining of requests.
    对数据传输采用多路复用，让多个请求合并在同一 TCP连接内Multiplexing multiple requests over a single TCP connection，
        因为每一个tcp连接在创建的时候都需要耗费资源，而且在创建初期，传输也是比较慢的。
    采用了二进制而非明文来打包、传输 客户端<——>服务器 间的数据。
​http1.1和http2.0的主要区别：
​ 1、新的传输格式：2.0使用二进制格式，1.0依然使用基于文本格式
​ 2、多路复用：连接共享，不同的request可以使用同一个连接传输（最后根据每个request上的id号组合成 正常的请求）
​ 3、header压缩：由于1.X中header带有大量的信息，并且得重复传输，2.0使用encoder来减少需要传输的 hearder大小
​ 4、服务端推送：同google的SPDUY（1.0的一种升级）一样
```
#### 3.3.HTTPS的工作原理
```markdown
1.Client 使用https的URL访问 Server，要求与 Server 建立 SSL 连接
2.Server 把事先配置好的公钥证书返回给客户端。
3.Client验证公钥证书：比如是否在有效期内，证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，
    直到验证到根证书（操作系统内置的Root证书或者Client内置的Root证书）。如果验证通过则继续，不通过则显示警告信息。
4.Client使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给Server。
5.Server使用自己的私钥（private key）解密这个消息，得到对称密钥。至此，Client和Server双方都持有了相同的对称密钥。
6.Server使用对称密钥加密“明文内容A”，发送给Client。
7.Client使用对称密钥解密响应的密文，得到“明文内容A”。
8.Client再次发起HTTPS的请求，使用对称密钥加密请求的“明文内容B”，然后Server使用对称密钥解密密文，得到“明文内容B”。
```
#### 3.4.HTTPS的优缺点
```markdown
尽管HTTPS并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，
但HTTPS仍是现行架构下最安全的解决方案，主要有以下几个好处：
    1.使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；
    2.HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。
    3.HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。
    4.谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。
虽然说HTTPS有很大的优势，但其相对来说，还是存在不足之处的：
    1.HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电；
    2.HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；
    3.SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。
    4.SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。
    5.HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。
        最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。
```
#### [炸裂！万字长文拿下HTTP！](https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&mid=2650129667&idx=3&sn=274618362eb9e759ef62386f731e4950&chksm=f36bd822c41c5134360f576d1970af267bc05e85e7699a8edca695dfd235bde7b78078301ff7&mpshare=1&scene=23&srcid=&sharer_sharetime=1590882441576&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
```markdown

```
####  ping的工作原理
[ping 的工作原理](https://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&mid=2453142815&idx=2&sn=c1b16ab077446435ccd8a6bc98d5b559&chksm=8cf2df9cbb85568a855e6d51e882292e3565d50fcb8462c27df0fe0063882af9db29e136fe70&mpshare=1&scene=23&srcid=&sharer_sharetime=1590987976205&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
```markdown
ping是基于ICMP协议工作的,ICMP全称是Internet Control Message Protocol，也就是互联网控制报文协议。
ICMP主要的功能包括：确认IP包是否成功送达目标地址、报告发送过程中IP包被废弃的原因和改善网络设置等。
ICMP报文是封装在IP包里面，它工作在网络层，是IP协议的助手。
![ICMP 包头格式](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcZiaMXRx5FarzuAMKmf0Cj29gb37HdxOjFprAJ1zycOxZdHEbz4tafArtrZFAibw90Dn1BJmgaG5eg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
ICMP 包头的类型字段，大致可以分为两大类：
    一类是用于诊断的查询消息，也就是「查询报文类型」
    另一类是通知出错原因的错误消息，也就是「差错报文类型」
```
#### [TCP参数及Linux操作系统调节TCP参数](https://www.cnblogs.com/xiaolincoding/p/13067971.html)
```markdown

```
### 4.IP 基础知识
[IP 基础知识“全家桶”，45 张图一套带走](https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&mid=2650136938&idx=3&sn=67976543452d053f38ef98ad432e2b0a&chksm=f36bfc4bc41c755d9635f4868247f5c32af011e39055a93457a48ea624fa64206337bbc732c7&xtrack=1&scene=90&subscene=93&sessionid=1595738415&clicktime=1595738485&enterid=1595738485&ascene=56&devicetype=android-27&version=27001135&nettype=WIFI&abtest_cookie=AAACAA%3D%3D&lang=zh_CN&exportkey=AZt8sKmIZAR5dAcuhZz%2BTNw%3D&pass_ticket=ti6jCKVPm3InI6pMg16GBXD3aOQEiXkZyc7df%2BpfdJBz1TvM0wxYU9GHpOvyR%2Bqh&wx_header=1)
#### 4.1.IP基础知识
```markdown
IP在TCP/IP参考模型中处于第三层，也就是网络层。
网络层的主要作用是：实现主机与主机之间的通信，也叫点对点（end to end）通信。
IP（网络层）和MAC（数据链路层）之间的区别和关系。
    IP的作用是主机之间通信中的，而MAC的作用则是实现「直连」的两个设备之间通信，而IP则负责在「没有直连」的两个网络之间进行通信传输。
    计算机网络中也需要「数据链路层」和「网络层」这个分层才能实现向最终目标地址的通信。
    源IP地址和目标IP地址在传输过程中是不会变化的，只有源MAC地址和目标MAC一直在变化。
```
#### 4.2.IP地址是基础知识
```markdown
在TCP/IP网络通信时，为了保证能正常通信，每个设备都需要配置正确的IP地址，否则无法实现正常的通信。
IP地址（IPv4 地址）由32位正整数来表示,IP地址在计算机是以二进制的方式处理的。
IP 地址分类成了5种类型，分别是A类、B类、C类、D类、E类。
```
#### 4.3.IP协议相关技术
```markdown
DNS域名解析:DNS可以将域名网址自动转换为具体的IP地址。
ARP与RARP协议:ARP是借助ARP请求与ARP响应两种类型的包确定MAC地址的。
DHCP动态获取IP地址
NAT网络地址转换
ICMP互联网控制报文协议:确认IP包是否成功送达目标地址、报告发送过程中IP包被废弃的原因和改善网络设置等。
IGMP因特网组管理协议：工作在主机（组播成员）和最后一跳路由之间
```
### 5.### [随笔分类 - 网络协议](https://www.cnblogs.com/BeiGuo-FengGuang/category/1329919.html)
>>说说计算机网络，每层干嘛，有什么协议，
>>  ARP协议
[两万字长文50+张趣图带你领悟网络编程的内功心法](https://www.cnblogs.com/arthinking/p/13429848.html)

## 二、操作系统
>> [参考博客：5万字、97 张图总结操作系统核心知识点](https://www.cnblogs.com/cxuanBlog/p/13297199.html)
### 1.[参考资料：操作系统总结](https://www.cnblogs.com/blknemo/p/12274600.html)
#### 1.基础概念：并发与并行，共享，虚拟，同步，异步【5+】
```markdown
**并发**是指宏观上在一段时间内能同时运行多个程序，而**并行**则指两个进程同时运行。
    并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。操作系统通过引入进程和线程，使得程序能够并发运行。
**共享**是指系统中的资源可以被多个并发进程共同使用。有两种共享方式：互斥共享和同时共享。
    互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。
**虚拟技术**把一个物理实体转换为多个逻辑实体。主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。
    多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。
**虚拟内存**使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，
    地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。
**同步**：当一个同步调用发出后，调用者要一直等待返回结果。通知后，才能进行后续的执行。
**异步**：当一个异步过程调用发出后，调用者不能立刻得到返回结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。
**阻塞**：是指调用结果返回前，当前线程会被挂起，即阻塞。
**非阻塞**：是指即使调用结果没返回，也不会阻塞当前线程。
```
#### 2.计算机硬件（冯诺伊曼的体系结构）
```markdown
计算机硬件是计算机的重要组成部分，其中包含了 5 个重要的组成部分：运算器、控制器、存储器、输入设备、输出设备。
运算器：运算器最主要的功能是对数据和信息进行加工和运算。它是计算机中执行算数和各种逻辑运算的部件。
    运算器的基本运算包括加、减、乘、除、移位等操作，这些是由算术逻辑单元(Arithmetic&logical Unit) 实现的。
    而运算器主要由算数逻辑单元和寄存器构成。
控制器：指按照指定顺序改变主电路或控制电路的部件，它主要起到了控制命令执行的作用，完成协调和指挥整个计算机系统的操作。
    控制器是由程序计数器、指令寄存器、解码译码器等构成。
    运算器和控制器共同组成了CPU
存储器：存储器就是计算机的记忆设备，顾名思义，存储器可以保存信息。存储器分为两种，一种是主存，也就是内存，
    它是CPU主要交互对象，还有一种是外存，比如硬盘软盘等。下面是现代计算机系统的存储架构
输入设备：输入设备是给计算机获取外部信息的设备，它主要包括键盘和鼠标。
输出设备：输出设备是给用户呈现根据输入设备获取的信息经过一系列的计算后得到显示的设备，它主要包括显示器、打印机等。
总线(Buses)：在整个系统中运行的是称为总线的电气管道的集合，这些总线在组件之间来回传输字节信息。通常总线被设计成传送定长的字节块，也就是字(word)。
    字中的字节数（字长）是一个基本的系统参数，各个系统中都不尽相同。现在大部分的字都是 4 个字节（32 位）或者 8 个字节（64 位）。
I/O设备(I/O Devices)：Input/Output设备是系统和外部世界的连接。I/O设备：用于用户输入的键盘和鼠标，用于用户输出的显示器，
    一个磁盘驱动用来长时间的保存数据和程序。刚开始的时候，可执行程序就保存在磁盘上。
```
#### 3.用户态和核心态
```markdown
在计算机系统中，分两种程序：系统程序和应用程序，为了保证系统程序不被应用程序有意或无意地破坏，为计算机设置了两种状态——用户态、核心态
    用户态：只能受限的访问内存，运行所有的应用程序
    核心态：运行操作系统程序，cpu可以访问内存的所有数据，包括外围设备
为什么要有用户态和内核态：
​   由于需要限制不同的程序之间的访问能力, 防止他们获取别的程序的内存数据, 或者获取外围设备的数据, 并发送到网络
用户态切换到内核态的3种方式：
​ a. 系统调用
    ​ 这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，
     比如前例中fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。
​ b. 异常
    ​ 当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。
​ c. 外围设备的中断
    ​ 当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，
     如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。
这3种方式是系统在运行时由用户态转到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。
```
###2.[我和面试官之间关于操作系统的一场对弈！写了很久，希望对你有帮助！](https://www.cnblogs.com/javaguide/p/operating-system.html)
#### 1.1 什么是操作系统？
```markdown
操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机系统的内核与基石；
    操作系统本质上是运行在计算机上的软件程序 ；
    操作系统为用户提供一个与系统交互的操作界面 ；
    操作系统分内核与外壳（我们可以把外壳理解成围绕着内核的应用程序，而内核就是能操作硬件的程序）。
操作系统也是一种软件，但是操作系统是一种非常复杂的软件。操作系统提供了几种抽象模型
    文件：对 I/O 设备的抽象
    虚拟内存：对程序存储器的抽象
    进程：对一个正在运行程序的抽象
    虚拟机：对整个操作系统的抽象
```
#### 1.2 什么是系统调用呢？ 
```markdown
操作系统提供的函数就被称为系统调用（system call）。软件程序的执行一般是在用户态下执行的，但当程序需要使用操作系统提供的服务时，
    比如说打开某一设备、创建文件、读写文件（这些均属于系统调用）等，就需要向操作系统发出调用服务的请求，这就是系统调用。
根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：
    用户态(user mode) : 用户态运行的进程或可以直接读取用户程序的数据。（软件程序运行）
    内核态(kernel mode):可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。（操作系统运行）
在我们运行的用户程序中，凡是与系统态（内核态）级别的资源有关的操作（如文件管理、进程控制、内存管理等)，
    都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。
 异常：当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。
 外围设备的中断：当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号
    对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。
    比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。
```
#### 1.3 进程和线程的区别，协程【10+】
![](https://mmbiz.qpic.cn/mmbiz_png/vt35KeC5pmicicicIJf2WxuicHibZgtyC6a71ch4SRJvfB5q4PVPzAXh3ibwqm9aPUicUuqNMfxudiacBur8oib0PR1G6zw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
```markdown
​进程：是资源分配的最小单位，是程序的执行过程，一个进程可以有多个线程，多个线程共享进程的堆和方法区资源，
    但每个线程又有属于自己的本地方法栈、虚拟机栈、程序计数器。
​线程：是任务调度和执行的最小单位，线程间可能存在相互影响，执行开销较小，不利于资源的管理和保护，
    线程间是共享进程中的资源的。
协程：是一种比线程更加轻量级的存在，正如一个进程可以拥有多个线程一样，一个线程可以拥有多个协程。
    协程不是被操作系统内核所管理，而完全是由程序所控制。协程与线程以及进程的关系见下图所示。
**拥有资源**：进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。
**调度**：线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。
**系统开销**：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等，所付出的开销远大于创建或撤销线程时的开销。
    类似地，在进行进程切换时，涉及当前执行进程CPU环境的保存及新调度进程CPU环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。
**通信方面**：线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助IPC。
>> 为什么有了进程还要线程：进程如果被阻塞，哪些等待资源执行的进程就无法执行。进程同一时间只能做一件事。
```
#### 1.4 进程有哪几种状态【2+】
```markdown
创建状态(new) ：进程正在被创建，尚未到就绪状态。
就绪状态(ready) ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。
运行状态(running) ：进程正在处理器上上运行(单核CPU下任意时刻只有一个进程处于运行状态)。
阻塞状态(waiting) ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待IO操作完成。即使处理器空闲，该进程也不能运行。
结束状态(terminated) ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。
```
#### 1.5 进程间的通信方式【5+】
[进程间通信](https://www.cnblogs.com/xiaolincoding/p/13402297.html)
```markdown
**信号(Signal)** ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；（Linux系统上输入kill -l来列出系统使用的信号）
**管道/匿名管道(Pipes)** ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。
    在两个进程之间，可以建立一个通道，一个进程向这个通道里写入字节流，另一个进程从这个管道中读取字节流。（shell中的管线pipelines就是用管道实现的）
**命名管道(Names Pipes)**: 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。
    有名管道严格遵循先进先出(first in first out)。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。
**消息队列(Message Queuing)** ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。
    管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）
    不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。
    消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。
    消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺。
**信号量(Semaphores)** ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。
**共享内存(Shared memory)** ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。
    这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。
**套接字(Sockets)** : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持TCP/IP的网络通信的基本操作单元，
    可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。
管道：速度慢，容量有限，只有父子进程能通讯。
FIFO：任何进程间都能通讯，但速度慢。
消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题。
信号量：不能传递复杂消息，只能用来同步。
共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存。
```
#### 1.6 线程间的同步的方式
```markdown
**同步与互斥**：同步：多个进程按一定顺序执行；互斥：多个进程在同一时刻只有一个进程能进入临界区。
    线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。
操作系统一般有下面三种线程同步的方式：
**互斥量(Mutex)**：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会
    被多个线程同时访问。比如Java中的synchronized关键词和各种Lock都是这种机制。
**信号量(Semphares)**：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量
**事件(Event) :Wait/Notify**：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操。
**临界区**：对临界资源进行访问的那段代码称为临界区。为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。
```
#### 1.7 进程的调度算法【5+】
```markdown
**批处理系统**:批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。
**先到先服务(FCFS)调度算法**:从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用CPU时再重新调度。
**短作业优先(SJF)的调度算法**:从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用CPU时再重新调度。
**时间片轮转调度算法**:时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称RR(Roundrobin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。
**多级反馈队列调度算法**:前面介绍的几种进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程 。
    多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。因而它是目前被公认的一种较好的进程调度算法，UNIX操作系统采取的便是这种调度算法。
**优先级调度**：为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以FCFS方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。

**交互式系统**
**时间片轮转**:将所有就绪进程按FCFS的原则排成一个队列，每次调度时，把CPU时间分配给队首进程，该进程可以执行一个时间片。
当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把CPU时间分配给队首的进程。
**优先级调度**:为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。
**多级反馈队列**:可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。

**实时系统**:实时系统要求一个请求在一个确定时间内得到响应。分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。
```
#### 1.8 死锁【5+】
```markdown
大部分的死锁都和资源有关，在进程对设备、文件具有独占性（排他性）时会产生死锁。我们把这类需要排他性使用的对象称为资源(resource)。
资源主要分为：可抢占资源和不可抢占资源
死锁：如果一组进程中的每个进程都在等待一个事件，而这个事件只能由该组中的另一个进程触发，这种情况会导致死锁。
死锁的必要条件：
     互斥条件 (Mutual exclusion)：资源不能被共享，只能由一个进程使用。
     请求与保持条件 (Hold and wait)：已经得到资源的进程可以再次申请新的资源。
     非抢占条件 (No pre-emption)：已经分配的资源不能从相应的进程中被强制地剥夺。
     循环等待条件 (Circular wait)：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源。
发生死锁时，上面的情况必须同时会发生。如果其中任意一个条件不会成立，死锁就不会发生。可以通过破坏其中任意一个条件来破坏死锁。
死锁的处理策略：
     鸵鸟策略：忽略死锁带来的影响
     死锁检测与死锁恢复（检测死锁并回复死锁，死锁发生时对其进行检测，一旦发生死锁后，采取行动解决问题）
        从死锁中恢复：通过抢占进行恢复,通过回滚进行恢复,杀死进程恢复。
     死锁预防（通过仔细分配资源来避免死锁）
     死锁避免（通过破坏死锁产生的四个条件之一来避免死锁）
        单个资源的银行家算法，破坏死锁，破坏互斥条件，破坏保持等待的条件，破坏不可抢占条件，破坏循环等待条件。
[PV操作经典例题——哲学家进餐问题](https://blog.csdn.net/Yun_Ge/article/details/89177918)
```
#### 1.9 操作系统内存管理方式，分页分段以及段页式的优缺点【3+】
```markdown
内存管理方式：块式管理、页式管理、段式管理、段页式管理
    虚拟内存：目的是为了让物理内存扩充为更大的逻辑内存，从而让程序获得更大的可用内存。
    分页系统内存映射：内存管理单元管理者地址空间和物理内存否转换,其中的页表存储着页(程序地址空间)和页框(物理内存空间)的映射表。
    页面置换算法：OPT,LRU,NRU，FIFO，第二次机会算法，CLOCK
0.块式管理：把主存分为一大块、一大块的，当所需的程序片断不在主存时就分配一块主存空间，把程序片断load入主存，就算所需的程序片度只有几个字节也只能把这一块分配给它。
    这样会造成很大的浪费，平均浪费了50％的内存空间，但是易于管理。
1.页式管理：把主存分为一页一页的，每一页的空间要比一块一块的空间小很多，显然这种方法的空间利用率要比块式管理高很多。
2.段式管理：把主存分为一段一段的，每一段的空间又要比一页一页的空间小很多，这种方法在空间利用率上又比页式管理高很多，但是也有另外一个缺点。
    一个程序片断可能会被分为几十段，这样很多时间就会被浪费在计算每一段的物理地址上。
3.段页式管理：结合了段式管理和页式管理的优点。将程序分成若干段，每个段分成若干页。段页式管理每取一数据，要访问3次内存。
```
#### 1.10 CPU的上下文切换有几种？系统中断进行了几次上下文切换？【4+】
>> 1.线程切换需要消耗哪些资源?
```markdown
上下文切换(Context Switch)是一种将CPU资源从一个进程分配给另一个进程的机制。操作系统需要先存储当前进程的状态 
    (包括内存空间的指针，当前执行完的指令等等)，再读入下一个进程的状态，然后执行此进程。
CPU 的上下文切换分三种：进程上下文切换、线程上下文切换、中断上下文切换。
     系统调用过程中也会发生CPU上下文切换。CPU寄存器会先保存用户态的状态，然后加载内核态相关内容。
    系统调用结束之后，CPU寄存器要恢复原来保存的用户态，继续运行进程。所以，一次系统调用，发生两次CPU上下文切换。
     进程是由内核管理和调度的，进程的切换只能发生在内核态。进程上下文切换与系统调用的不同在于，
    进程的调用会保存用户空间的虚拟内存，全局变量等信息，但是系统调用的上下文则不会，因为其未发生进程的变化。
     内核中的任务调度实际是在调度线程，进程只是给线程提供虚拟内存、全局变量等资源。
    线程上下文切换时，共享相同的虚拟内存和全局变量等资源不需要修改。
    而线程自己的私有数据，如栈和寄存器等，上下文切换时需要保存。
```
#### 1.11 页面置换算法
```markdown
 最优页面置换算法（往后看）：最理想的状态下，我们给页面做个标记，挑选一个最远才会被再次用到的页面调出
 先进先出页面置换算法（FIFO）及其改进（往前看）：这种算法的思想和队列是一样的，该算法总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予淘汰。
 最近最少使用页面置换算法LRU（往前看）：总是选择在最近一段时间内最久不用的页面予以淘汰。 即淘汰最近最长时间未访问过的页面。
 第二次机会页面置换算法：FIFO链表页面有个缺陷，那就是出链和入链并不会进行check检查，这样就会容易把经常使用的页面置换出去。
 时钟页面置换算法：当缺页错误出现时，算法首先检查表针指向的页面，如果它的R位是0就淘汰该页面，并把新的页面插入到这个位置，然后把表针向前移动一位；
```
#### 1.12 虚拟地址，逻辑地址，物理地址的关系【1+】
```markdown
1)虚拟地址：是由程序产生的由段选择符和段内偏移地址组成的地址。
    这2部分组成的地址并不能直接访问物理内存，而是要通过分段地址的变化处理后才会对应到相应的物理内存地址。
2)逻辑地址：指由程序产生的段内偏移地址。逻辑地址与虚拟地址二者之间没有明确的界限。
3)线性地址：指虚拟地址到物理地址变换的中间层，是处理器可寻址的内存空间（称为线性地址空间）中的地址。
    程序代码会产生逻辑地址，或者说段中的偏移地址，加上相应段基址就成了一个线性地址。
    如果启用了分页机制，那么线性地址可以再经过变换产生物理地址。若是没有采用分页机制，那么线性地址就是物理地址。
4)物理地址：指内存中物理单元的集合，他是地址转换的最终地址，进程在运行时执行指令和访问数据最后都要通过物理地址来存取主存。。
    逻辑（虚拟）地址经过分段（查询段表）转化为线性地址。线性地址经过分页（查询页表）转为物理地址。
```


## 三、计算机组成原理
### [计算机组成原理](https://www.cnblogs.com/reminis/p/12896053.html)
```markdown

```
#### 计算机由什么部分组成
### [【重学计算机】计算机组成原理](https://www.cnblogs.com/flashsun/p/10628433.html)
```markdown

```
[随笔分类 - 重学计算机笔记](https://www.cnblogs.com/flashsun/category/1391951.html)

## 四、Linux
[后端程序员必备的 Linux 基础知识+常见命令](https://mp.weixin.qq.com/s?__biz=MzU2NDg0OTgyMA==&mid=2247493578&idx=2&sn=ae265b5b05204fcb949fee41fd2d7d13&chksm=fc461a39cb31932fcd084bf566f9d2ea9111a7da56cc2a408eac8145e8d5a64f5005e1e2e28b&mpshare=1&scene=23&srcid=0901oUWt9SKi6zFY7iH7oC0d&sharer_sharetime=1598924671509&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
### Linux I/O
#### 1.1 五种I/O模型
[带你真正的搞懂，Linux的5种I/O模型](https://www.toutiao.com/a6619988112300835331/)
```markdown
Unix 有五种 I/O 模型：
    阻塞式I/O（blocking IO）: 应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。
    非阻塞式I/O（nonblocking IO）:应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知I/O是否完成，这种方式称为轮询（polling）。
    I/O复用（IO multiplexing）（select和poll）:使用select或者poll等待数据，并且可以等待多个套接字中的任何一个变为可读。
        这一过程会被阻塞，当某一个套接字可读时返回，之后再使用recvfrom把数据从内核复制到进程中。
    信号驱动式I/O（SIGIO）:应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。
    异步I/O（asynchronous IO）（AIO:应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。
```
#### 1.2 I/O复用
```markdown
同步I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段，应用进程会阻塞。
异步I/O：不会阻塞。
阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O 都是同步 I/O，它们的主要区别在第一个阶段。
非阻塞式 I/O 、信号驱动 I/O 和异步 I/O 在第一阶段不会阻塞。
```
#### 1.3 IO多路复用的select、poll和epoll函数的区别？【2+】
```markdown
 select函数监视文件描述符，调用后select函数会阻塞，直到有描述符就绪，或者超时，函数返回，当select函数返回后，就可以遍历描述符，找到就绪的描述符。
    select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制
 没有最大限制（但是数量过大后性能也是会下降）。和select函数一样，poll返回后，需要轮询来获取就绪的描述符。
 epoll 是Linux内核为处理大批量文件描述符而作了改进的poll，是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的
    情况下的系统CPU利用率。另一点原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。
```
#### [说了这么多次 I/O，但你知道它的原理么](https://www.cnblogs.com/cxuanBlog/p/13032486.html)
### Linux常用命令【3+】
#### Linux基础命令
```markdown
文件管理：ls、cd、touch创建普通文件、rm删除、mkdir新建目录、mv移动、cp拷贝、chmod修改权限
进程管理：ps显示进程信息、kill杀死进程
系统管理：top、free显示系统运行信息、vmstat输出各资源使用情况
网络通讯：ping测试网络连通性、netstat显示网络相关信息
```
#### [不可不知的7个JDK 命令](https://www.cnblogs.com/wupeixuan/p/12965240.html)
```markdown
javap:使用javap可以查看Java字节码反编译的源文件。
jsp:jps 是用来查询当前所有进程 pid 的。
jstat: jstat 主要用于监控 JVM，主要是 GC 信息，在性能优化的时候经常用到，
jcmd: jcmd 可以查看 JVM 信息。
jmap: jmap 打印出 Java 进程内存中 Object 的情况，或者将 JVM 中的堆以二进制输出成文本。
jhat: jhat 分析 Java 堆的命令，可以将堆中对象以 html 的形式显示出来，支持对象查询语言 OQL
jsatck: jstack 是堆栈跟踪工具，主要用于打印给定进程 pid 的堆栈信息，
    一般在发生死锁或者 CPU 100% 的时候排查问题使用，可以去查询当前运行的线程以及线程的堆栈信息是什么情况
[给你的Java程序拍个片子吧：jstack命令解析](https://www.cnblogs.com/jay-huaxiao/p/12865552.html)
整机 top:    uptime
CPU vmstat -n 2 3  # 每两秒采样一次，采样三次。
    查看额外： mpstat -P ALL 2 查看所有CPU核信息
              pidstat -u 1 -p 进程编号  每个进程使用cpu的用量分解信息
内存 free 应用程序可用内存数 free -m ,free -g  查看内存的单位
    查看额外 pidstat -p 进程号 -r 采样间隔秒数
硬盘 df  查看磁盘剩余空闲数  df -h
磁盘IO iostat   磁盘I/O性能评估 iostat -xdk 2 3
    查看额外 pidstat -d 采样间隔秒数 -p 进程号
网络IO ifstat 默认本地没有，下载    ifstat l  查看网络I/O
```
#### 20条经典Linux运维面试
```markdown
问:1如何查看当前的Linux服务器的运行级别？
答: ‘who -r’ 和 ‘runlevel’ 命令可以用来查看当前的Linux服务器的运行级别。
问:2如何查看Linux的默认网关？
答: 用 “route -n” 和 “netstat -nr” 命令，我们可以查看默认网关。除了默认的网关信息，这两个命令还可以显示当前的路由表。
问:3如何在Linux上重建初始化内存盘镜像文件？
答: 在CentOS 5.X / RHEL 5.X中，可以用mkinitrd命令来创建初始化内存盘文件，举例如下：
# mkinitrd -f -v /boot/initrd-$(uname -r).img $(uname -r)
如果你想要给特定的内核版本创建初始化内存盘，你就用所需的内核名替换掉 ‘uname -r’ 。
在CentOS 6.X / RHEL 6.X中，则用dracut命令来创建初始化内存盘文件，举例如下：
# dracut -f
以上命令能给当前的系统版本创建初始化内存盘，给特定的内核版本重建初始化内存盘文件则使用以下命令：
# dracut -f initramfs-2.x.xx-xx.el6.x86_64.img 2.x.xx-xx.el6.x86_64
问:4cpio命令是什么？
答: cpio就是复制入和复制出的意思。cpio可以向一个归档文件（或单个文件）复制文件、列表，还可以从中提取文件。
问:5patch命令是什么？如何使用？
答: 顾名思义，patch命令就是用来将修改（或补丁）写进文本文件里。patch命令通常是接收diff的输出并把文件的旧版本转换为新版本。
举个例子，Linux内核源代码由百万行代码文件构成，所以无论何时，任何代码贡献者贡献出代码，只需发送改动的部分而不是整个源代码，
然后接收者用patch命令将改动写进原始的源代码里。
创建一个diff文件给patch使用，
# diff -Naur old_file new_file > diff_file
旧文件和新文件要么都是单个的文件要么都是包含文件的目录，-r参数支持目录树递归。
一旦diff文件创建好，我们就能在旧的文件上打上补丁，把它变成新文件：
# patch < diff_file
问:6aspell有什么用 ?
答: 顾名思义，aspell就是Linux操作系统上的一款交互式拼写检查器。aspell命令继任了更早的一个名为ispell的程序，并且作为一款免费替代品 ，最重要的是它非常好用。当aspell程序主要被其它一些需要拼写检查能力的程序所使用的时候，在命令行中作为一个独立运行的工具的它也能十分有效。
 问:7如何从命令行查看域SPF记录？
答: 我们可以用dig命令来查看域SPF记录。举例如下：
linuxtechi@localhost:~$ dig -t TXT google.com
问:8如何识别Linux系统中指定文件(/etc/fstab)的关联包？
答:
# rpm -qf /etc/fstab
以上命令能列出提供“/etc/fstab”这个文件的包。
问:9哪条命令用来查看bond0的状态？
答:
cat /proc/net/bonding/bond0
问:10Linux系统中的/proc文件系统有什么用？
答: /proc文件系统是一个基于内存的文件系统，其维护着关于当前正在运行的内核状态信息，其中包括CPU、内存、分区划分、I/O地址、直接内存访问通道和正在运行的进程。这个文件系统所代表的并不是各种实际存储信息的文件，它们指向的是内存里的信息。/proc文件系统是由系统自动维护的。
问:11如何在/usr目录下找出大小超过10MB的文件？
答:
# find /usr -size +10M
问:12如何在/home目录下找出120天之前被修改过的文件？
答:
# find /home -mtime +120
问:13如何在/var目录下找出90天之内未被访问过的文件？
答:
# find /var ! -atime -90
问:14在整个目录树下查找文件“core”，如发现则无需提示直接删除它们。
答:
# find / -name core -exec rm {} ;
问:15strings命令有什么作用？
答: strings命令用来提取和显示非文本文件中的文本字符串。（LCTT 译注：当用来分析你系统上莫名其妙出现的二进制程序时，可以从中找到可疑的文件访问，对于追查入侵有用处）
问:16tee 过滤器有什么作用 ?
答: tee 过滤器用来向多个目标发送输出内容。如果用于管道的话，它可以将输出复制一份到一个文件，并复制另外一份到屏幕上（或一些其它程序）。
linuxtechi@localhost:~$ ll /etc | nl | tee /tmp/ll.out
在以上例子中，从ll输出可以捕获到 /tmp/ll.out 文件中，并且同样在屏幕上显示了出来。
问:17export PS1 = ”$LOGNAME@hostname:$PWD: 这条命令是在做什么？
答: 这条export命令会更改登录提示符来显示用户名、本机名和当前工作目录。
问:18ll | awk ‘{print $3,”owns”,$9}’ 这条命令是在做什么？
答: 这条ll命令会显示这些文件的文件名和它们的拥有者。
问:19Linux中的at命令有什么用？
答: at命令用来安排一个程序在未来的做一次一次性执行。所有提交的任务都被放在 /var/spool/at 目录下并且到了执行时间的时候通过atd守护进程来执行。
问:20linux中lspci命令的作用是什么？
答: lspci命令用来显示你的系统上PCI总线和附加设备的信息。指定-v，-vv或-vvv来获取越来越详细的输出，加上-r参数的话，命令的输出则会更具有易读性。
```
#### 日志文件找出现最频繁的k个word，以及考虑大文件分割处理
#### 出现高CPU怎么解决？排查
#### Linux 文件类型
```markdown
Linux 支持很多文件类型，其中非常重要的文件类型有: 普通文件，目录文件，链接文件，设备文件，管道文件，Socket套接字文件等。
1.普通文件（-）：用于存储信息和数据，Linux用户可以根据访问权限对普通文件进行查看、更改和删除。比如：图片、声音、PDF、text、视频、源代码等等。
2.目录文件（d，directory file）：目录也是文件的一种，用于表示和管理系统中的文件，目录文件中包含一些文件名和子目录名。打开目录事实上就是打开目录文件。
3.符号链接文件（l，symbolic link）：保留了指向文件的地址而不是文件本身。
4.字符设备（c，char）：用来访问字符设备比如硬盘。
5.设备文件（b，block）：用来访问块设备比如硬盘、软盘。
6.管道文件(p,pipe):一种特殊类型的文件，用于进程之间的通信。
7.套接字(s,socket)：用于进程间的网络通信，也可以用于本机之间的非网络通信。
```
++#### linux命令 对日志文件的IP出现的次数进行统计
```java
grep -i -o -E "([0-9]{1,3}\.){3}[0-9]{1,3}" test1.txt | sort -n | uniq -c | sort -n -r | head -6
grep命令 用于文本搜索

-E：用于使用正则匹配

-o：只显示匹配的部分

-i：忽略大小写

sort命令用于排序

-n：数值排序

-r：倒序排序

uniq命令用于去重

-c：显示重复次数

head -6命令显示前6行
```
