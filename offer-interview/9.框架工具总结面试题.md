# 工具框架面试题
## Spring面试题
[Spring面试题（2020最新版）](https://thinkwon.blog.csdn.net/article/details/104397516)
### 0.对Spring的理解，项目中都用什么？怎么用的？对IOC、和AOP的理解及实现原理。
```markdown
Spring是一个开源框架，处于MVC模式中的控制层，它能应对需求快速的变化，其主要原因它有一种面向切面编程（AOP）的优势，其次它提升了系统性能，
通过依赖倒置机制（IOC），系统中用到的对象不是在系统加载时就全部实例化，而是在调用到这个类时才会实例化该类的对象，从而提升了系统性能。
这两个优秀的性能使得Spring受到许多J2EE公司的青睐，如阿里中使用最多的也是Spring相关技术。
Spring的优点：
    1、降低了组件之间的耦合性，实现了软件各层之间的解耦。
    2、可以使用容易提供的众多服务，如事务管理，消息服务，日志记录等。
    3、容器提供了AOP技术，利用它很容易实现如权限拦截、运行期监控等功能。
Spring中AOP技术是设计模式中的动态代理模式。只需实现jdk提供的动态代理接口InvocationHandler，所有被代理对象的方法都由InvocationHandler接管实际的处理任务。
面向切面编程中还要理解切入点、切面、通知、织入等概念。
Spring中IOC则利用了Java强大的反射机制来实现。所谓依赖注入即组件之间的依赖关系由容器在运行期决定。
其中依赖注入的方法有两种，通过构造函数注入，通过set方法进行注入。
```
### 1.什么是spring?
```markdown
Spring是一个轻量级Java开发框架，最早有Rod Johnson创建，目的是为了解决企业级应用开发的业务逻辑层和其他各层的耦合问题。
它是一个分层的JavaSE/JavaEE full-stack（一站式）轻量级开源框架，为开发Java应用程序提供全面的基础架构支持。
Spring负责基础架构，因此Java开发者可以专注于应用程序的开发。
Spring最根本的使命是解决企业级应用开发的复杂性，即简化Java开发。
Spring可以做很多事情，它为企业级开发提供给了丰富的功能，但是这些功能的底层都依赖于它的两个核心特性，也就是依赖注入（DI）和面向切面编程（AOP）。
为了降低Java开发的复杂性，Spring采取了以下4种关键策略
    - 基于POJO的轻量级和最小侵入性编程；
    - 通过依赖注入和面向接口实现松耦合；
    - 基于切面和惯例进行声明式编程；
    - 通过切面和模板减少样板式代码。
```
### 2.Spring框架的设计目标，设计理念，和核心是什么
```markdown
Spring设计目标：Spring为开发者提供一个一站式轻量级应用开发平台；
Spring设计理念：在JavaEE开发中，支持POJO和JavaBean开发方式，使应用面向接口开发，充分支持OO（面向对象）设计方法；
Spring通过IoC容器实现对象耦合关系的管理，并实现依赖反转，将对象之间的依赖关系交给IoC容器，实现解耦；
Spring框架的核心：IoC容器和AOP模块。通过IoC容器管理POJO对象以及他们之间的耦合关系；通过AOP以动态非侵入的方式增强服务。
IoC让相互协作的组件保持松散的耦合，而AOP编程允许你把遍布于应用各层的功能分离出来形成可重用的功能组件。
```
### 3.Spring的优缺点是什么？
```markdown
优点
    方便解耦，简化开发。Spring就是一个大工厂，可以将所有对象的创建和依赖关系的维护，交给Spring管理。
    AOP编程的支持。Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能。
    声明式事务的支持。只需要通过配置就可以完成对事务的管理，而无需手动编程。
    方便程序的测试。Spring对Junit4支持，可以通过注解方便的测试Spring程序。
    方便集成各种优秀框架。Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架的直接支持（如：Struts、Hibernate、MyBatis等）。
    降低JavaEE API的使用难度。Spring对JavaEE开发中非常难用的一些API（JDBC、JavaMail、远程调用等），都提供了封装，使这些API应用难度大大降低。
缺点
    - Spring明明一个很轻量级的框架，却给人感觉大而全
    - Spring依赖反射，反射影响性能
    - 使用门槛升高，入门Spring需要较长时间
```
### 4.什么是控制反转（IOC），什么是依赖注入（DI）？
```markdown
IOC（Inverse of Control:控制反转）是一种设计思想：就是将原本在程序中手动创建对象的控制权，交由Spring框架来管理。
IoC容器是Spring用来实现IoC的载体，IoC容器实际上就是个Map（key，value）,Map中存放的是各种对象。
BeanFactory接口是Spring Ioc容器的核心接口。
IoC最常见以及最合理的实现方式叫做依赖注入（Dependency Injection，简称 DI）。
    将对象之间的相互依赖关系交给Io 容器来管理，并由IoC容器完成对象的注入。
    这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 
    IoC容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。
IOC是实现方式优点：
    1. 对象之间的耦合度或者说依赖程度降低；
    2. 资源变的容易管理；比如你用Spring容器提供的话很容易就可以实现一个单例。
DI：我们在使用Spring容器的时候，容器通过调用set方法或者是构造器来建立对象之间的依赖关系。
控制反转是目标，依赖注入是我们实现控制反转的一种手段。
Java中实现依赖注入的三种方式？
    - 构造器注入
    - set方法注入
    - 接口注入
```
### 5.Spring有几种配置方式 ？
```markdown
1.基于XML文件的配置:这种配置文件的格式常用<beans>开头，然后运用一系列的bean定义和专门的应用配置选项组成。
    Spring XML配置方式是使用被Spring命名空间所支持的一些列XML的标签来实现的。
2.基于注解的配置:可以使用注解的方式来代替XML方式的bean元素的配置。这就是组件扫描，常用依赖注入的一些注解有：
@Controller @Service @Autowired @RequestMapping @RequestParam @ModelAttribute @Cacheable @CacheFlush @Resource 
@PostConstruct @PreDestroy @Repository @Scope @SessionAttributes @InitBinder @Required @Qualifier
3.组件扫描：容器会扫描base-package指定的包及其子包下面的所有类，如果该类有一些特定的注解，则纳入容器进行管理。
4.在类前面添加的一些特定的注解：@Component 通用注解 @Repository 持久层注解 @Service 业务层注解、 @Controller 控制层注解
5.基于Java的配置
```
### Spring动态代理(JDK 动态代理和 CGLIB 动态代理)
```markdown
AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，
    便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。
这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。
代理分为静态代理和动态代理，静态代理，顾名思义，就是你自己写代理对象，动态代理，则是在运行期，生成一个代理对象。
Spring AOP就是基于动态代理的，如果要代理的对象，实现了某个接口，那么Spring AOP会使用JDK Proxy，去创建代理对象，而对于没有实现接口的对象，
    就无法使用JDK Proxy去进行代理了，这时候Spring AOP会使用Cglib，这时候Spring AOP会使用Cglib生成一个被代理对象的子类来作为代理。
AOP 主要用来解决：在不改变原有业务逻辑的情况下，增强横切逻辑代码，根本上解耦合，避免横切逻辑代码重复
切 ：指的是横切逻辑，原有业务逻辑代码不动，只能操作横切逻辑代码，所以面向横切逻辑
面 ：横切逻辑代码往往要影响的是很多个方法，每个方法如同一个点，多个点构成一个面。这里有一个面的概念
@pointcut切点注解 可以设置拦截方式
```
### spring如何解决循环依赖？
### spring AOP的原理 动态代理
```markdown
​AOP(Aspect-Oriented Programming:⾯向切⾯编程)能够将那些与业务⽆关，却为业务模块所共同调⽤的逻辑或责任（例如事务处理、⽇志管理、权限控制等）封装起来，
    便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。
​Spring AOP就是基于动态代理的，如果要代理的对象，实现了某个接⼝，那么Spring AOP会使⽤JDKProxy，去创建代理对象，⽽对于没有实现接⼝的对象，
    就⽆法使⽤JDK Proxy去进⾏代理了，这时候Spring AOP会使⽤Cglib，这时候Spring AOP会使⽤Cglib⽣成⼀个被代理对象的⼦类来作为代理，
```
### Bean的生命周期
```markdown
单例对象： singleton
    出生：当容器创建时对象出生
    活着：只要容器还在，对象一直或者
    死亡：容器销毁，对象消亡
    总结：单例对象的生命周期和容器相同
多例对象： prototype
    出生: 使用对象时spring框架为我们创建
    活着：对象只要是在使用过程中就一直活着
    死亡：当对象长时间不用且没有其它对象引用时，由java的垃圾回收机制回收
```
### Bean作用域？默认什么级别？是否线程安全？Spring如何保障线程安全的?
```markdown
singleton	单例对象，默认值的作用域
prototype	每次获取都会创建⼀个新的 bean 实例
request	    每⼀次HTTP请求都会产⽣⼀个新的bean，该bean仅在当前HTTP request内有效。
session	    在一次 HTTP session 中，容器将返回同一个实例
global-session	将对象存入到web项目集群的session域中,若不存在集群,则global session相当于session
默认作用域是singleton，多个线程访问同一个bean时会存在线程不安全问题
保障线程安全方法：
    1.在Bean对象中尽量避免定义可变的成员变量（不太现实）。
    2.在类中定义⼀个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中
        ThreadLocal：每个线程中都有一个自己的ThreadLocalMap类对象，可以将线程自己的对象保持到其中，各管各的，线程可以正确的访问到自己的对象。
​        将一个共用的ThreadLocal静态实例作为key，将不同对象的引用保存到不同线程的ThreadLocalMap中，
        然后在线程执行的各处通过这个静态ThreadLocal实例的get()方法取得自己线程保存的那个对象，避免了将这个对象作为参数传递的麻烦。
```
### Spring事务隔离级别和事务传播属性
```markdown
隔离级别：
    1) DEFAULT （默认）
    这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别。另外四个与JDBC的隔离级别相对应。
    2) READ_UNCOMMITTED （读未提交）
    这是事务最低的隔离级别，它允许另外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻像读。
    3) READ_COMMITTED （读已提交）
    保证一个事务修改的数据提交后才能被另外一个事务读取，另外一个事务不能读取该事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻像读。
    4) REPEATABLE_READ （可重复读）
    这种事务隔离级别可以防止脏读、不可重复读，但是可能出现幻像读。它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了不可重复读。
    5) SERIALIZABLE（串行化）
    这是花费最高代价但是最可靠的事务隔离级别，事务被处理为顺序执行。除了防止脏读、不可重复读外，还避免了幻像读。
Spring事务传播属性（Propagation）：
    1) REQUIRED（默认属性）
    如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。 被设置成这个级别时，会为每一个被调用的方法创建一个逻辑事务域。
    如果前面的方法已经创建了事务，那么后面的方法支持当前的事务，如果当前没有事务会重新建立事务。
    2) MANDATORY
    支持当前事务，如果当前没有事务，就抛出异常。
    3) NEVER
    以非事务方式执行，如果当前存在事务，则抛出异常。
    4) NOT_SUPPORTED
    以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
    5) REQUIRES_NEW
    新建事务，如果当前存在事务，把当前事务挂起。
    6) SUPPORTS
    支持当前事务，如果当前没有事务，就以非事务方式执行。
    7) NESTED
    支持当前事务，新增Savepoint点，与当前事务同步提交或回滚。 嵌套事务一个非常重要的概念就是内层事务依赖于外层事务。
    外层事务失败时，会回滚内层事务所做的动作。而内层事务操作失败并不会引起外层事务的回滚。
```
 说说 IoC 中的继承和 Java 继承的区别。
 IoC 自动装载有几种方式？
 IoC 容器自动完成装载，默认的方式是？
### Spring以及Spring MVC常见注解
```markdown
Spring部分：
​ 声明bean的注解
​   @Component 通⽤的注解，可标注任意类为 Spring 组件
​   @Service 在业务逻辑层使用（service层）
​   @Repository 在数据访问层使用（dao层）
​   @Controller 在展现层使用，控制器的声明（controller层）
​ 注入bean的注解
​   @Autowired：可以对类成员变量、方法、构造方法进行标注
​   默认按照类型注入，若要按照名称注入，需要搭配@Qualifier注解一起使用
​   @Resource：默认按照名称来装配注入
@autowired和@resource的区别？
    @Autowired：可以对类成员变量、方法、构造方法进行标注。默认按照类型注入，若要按照名称注入，需要搭配@Qualifier注解一起使用
    @Resource：默认按照名称来装配注入
@Autowired的使用简化了我们的开发，其原理是使用AutowiredAnnotationBeanPostProcessor类来实现，该类实现了Spring框架的一些扩展接口，
    通过实现BeanFactoryAware接口使其内部持有了BeanFactory（可轻松的获取需要依赖的的Bean）；通过实现MergedBeanDefinitionPostProcessor扩展接口，
    在BeanFactory里面的每个Bean实例化前获取到每个Bean里面的@Autowired信息并缓存下来；通过实现Spring框架的postProcessPropertyValues扩展接口
    在BeanFactory里面的每个Bean实例后从缓存取出对应的注解信息，获取依赖对象，并通过反射设置到Bean属性里面。
Spring MVC部分：
​   @Controller 声明该类为SpringMVC中的Controller
​   @RequestMapping 用于映射Web请求
​   @ResponseBody 支持将返回值放在response内，而不是一个页面，通常用户返回json数据
​   @RequestBody 允许request的参数在request体中，而不是在直接连接在地址后面。
​   @PathVariable 用于接收路径参数，比如@RequestMapping("/hello/{name}")申明的路径，将注解放在参数中前，即可获取该值，通常作为Restful的接口实现方法。
``` 
### Spring中用到了哪些设计模式？单例、工厂、代理、适配、观察者之类的说一说就行
[面试官:“谈谈Spring中都用到了那些设计模式?”。](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485303&idx=1&sn=9e4626a1e3f001f9b0d84a6fa0cff04a&chksm=cea248bcf9d5c1aaf48b67cc52bac74eb29d6037848d6cf213b0e5466f2d1fda970db700ba41&token=255050878&lang=zh_CN%23rd)
```markdown
单例设计模式 : Spring 中的 Bean 默认都是单例的。
⼯⼚设计模式 : Spring使⽤⼯⼚模式通过 BeanFactory 、 ApplicationContext 创建bean 对象。
代理设计模式 : Spring AOP 功能的实现。
观察者模式： Spring 事件驱动模型就是观察者模式很经典的⼀个应⽤。
适配器模式：Spring AOP 的增强或通知(Advice)使⽤到了适配器模式、spring MVC 中也是⽤到了适配器模式适配 Controller 。
```
## SpringMVC面试题
[Spring MVC面试题（2020最新版）](https://blog.csdn.net/ThinkWon/article/details/104397427)
###[springmvc的面试知识点总结](https://www.cnblogs.com/yunjiandubu/p/10269713.html)
#### 1.简单谈谈你对MVC的理解。
```markdown
mvc是一种设计模式（设计模式就是日常开发中编写代码的一种好的方法和经验的总结）。
模型（model）-视图（view）-控制器（controller），三层架构的设计模式。
用于实现前端页面的展现与后端业务数据处理的分离。
mvc设计模式的好处
    1.分层设计，实现了业务系统各个组件之间的解耦，有利于业务系统的可扩展性，可维护性。
    2.有利于系统的并行开发，提升开发效率。
```
#### 2.什么是 SpringMVC？SpringMVC的优点?
```markdown
SpringMVC是一个基于Java的实现了MVC设计模式的请求驱动类型的轻量级Web框架，通过把模型-视图-控制器分离，
将web层进行职责解耦，把复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合。
Spring MVC的优点
（1）可以支持各种视图技术,而不仅仅局限于JSP；
（2）与Spring框架集成（如IoC容器、AOP等）；
（3）清晰的角色分配：前端控制器(dispatcherServlet),请求到处理器映射（handlerMapping),处理器适配器（HandlerAdapter),视图解析器（ViewResolver）。
（4）支持各种请求资源的映射策略。
```
#### 3.SpringMVC的核心组件有哪些？
```markdown
（1）前端控制器 DispatcherServlet（不需要程序员开发）
    作用：接收请求、响应结果，相当于转发器，有了DispatcherServlet 就减少了其它组件之间的耦合度。
（2）处理器映射器HandlerMapping（不需要程序员开发）
    作用：根据请求的URL来查找Handler
（3）处理器适配器HandlerAdapter
    注意：在编写Handler的时候要按照HandlerAdapter要求的规则去编写，这样适配器HandlerAdapter才可以正确的去执行Handler。
（4）处理器Handler（需要程序员开发）
（5）视图解析器 ViewResolver（不需要程序员开发）
    作用：进行视图的解析，根据视图逻辑名解析成真正的视图（view）
（6）视图View（需要程序员开发jsp）
    View是一个接口，它的实现类支持不同的视图类型（jsp，freemarker，pdf等等）
```
#### 5.springmvc的工作流程?
![](https://img-blog.csdnimg.cn/20200208211439106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70)
[浅谈SpringMVC执行过程](https://www.cnblogs.com/wangjiming/p/10487832.html)
```markdown
（1）用户发送请求至前端控制器DispatcherServlet；
（2） DispatcherServlet收到请求后，调用HandlerMapping处理器映射器，请求获取Handle；
（3）处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet；
（4）DispatcherServlet 调用 HandlerAdapter处理器适配器；
（5）HandlerAdapter 经过适配调用 具体处理器(Handler，也叫后端控制器)；
（6）Handler执行完成返回ModelAndView；
（7）HandlerAdapter将Handler执行结果ModelAndView返回给DispatcherServlet；
（8）DispatcherServlet将ModelAndView传给ViewResolver视图解析器进行解析；
（9）ViewResolver解析后返回具体View；
（10）DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）
（11）DispatcherServlet响应用户。
```
#### 6.springmvc dispatcherservlet与handleradapter如何关联？
```markdown
DispatcherServlet拦截到请求之后,根据handlerMapping获取到handlerExecutionChain对象,然后,
在handlerExecutionChain对象不为null的情况下,根据handlerExecutionChain中的handler对象获取HandlerAdapter对象;
```
#### 7.有了springmvc的IOC容器,还需要spring的IOC容器吗?为什么?如何处理兼容问题?
```markdown
这个问题再进一步,换个方式提问即是否还需要在web.xml方法里面配置启动springIOC容器的ContextLoaderListener?
可以从正反两方面来回答,首先是需要,通常情况下,类似于数据源,事务,整合其他框架等都是放在spring的配置文件中,而不是springmvc的配置文件中, 
一般情况下,开发过程中的Service,Dao也都是放在spring的IOC容器当中;其次可以是不需要的,也可以都放在springmvc的配置文件当中,
当然需要分多个spring的配置文件,然后通过import节点导入到springmvc的配置文件当中.
几点要注意的地方:
1. springIOC容器和springmvc的IOC容器 扫描的部分有重合的地方,就会导致bean被创建2次,解决方案:使用 exclude-filter和include-filter配合
    来区分哪些bean交给springIOC容器,哪些bean交给springmvcIOC容器;
2. springmvc IOC容器里面的bean可以引用springIOC容器的bean,反之则不行,多个springIOC 容器之间可以设置为父子关系,以实现良好的解耦.
举个栗子,springIOC容器好比是全局作用域,springmvcIOC容器好比是局部作用域,局部的可以引用全局的,而全局的却不能引用局部的.
```
#### 8.tomcat容器如何与springmvc的dispatcherservlet通信的？
```markdown
Apache Tomcat软件是JavaServlet，JavaServerPages，Java ExpressionLanguage和JavaWebSocket技术的开源实现,
SpringMVC则是spring推出的基于servlet标准的MVC框架实现,由此可知,SpringMvc和Tomcat 的结合点就是Servlet.SpringMVC的
DispatcherServlet继承了HttpServlet,那么对于tomcat来说,springmvc实际就是一个Servlet.
一个http请求的具体处理流程:
1. 用户向tomcat容器发送一个请求;
2. tomcat容器接收到请求之后,分析客户的请求信息;
3. tomcat创建一个Httprequest对象,将用户的请求信息封装到该对象中;
4. tomcat创建一个HttpResponse对象;
5. tomcat调用HttpServlet的Service方法,将Httprequest,HTTPResponse传递给Httpservlet对象;
6. HttpServlet调用HttpRequest对象的有关方法,获取Http请求信息,HttpServlet调用HttpResponse对象的有关方法，生成响应数据;
7. tomcat把HttpServlet的响应结果传给Web客户.
要注意的几点东西:
①:web.xml配置文件的作用其实就是配置http请求和servlet之间的映射关系,通过这个配置文件,Tomcat可以把请求转发给不同的servlet实例;
②:springmvc也是servlet标准的一个实现,所有的http请求都映射到DispatcherServlet上去,这个时候,请求就已经由Tomcat转发到springmvc框架中去了,
接着再由DispatcherServlet将请求转发到各个Controller当中去.
```
#### 6.SpringMVC怎么样设定重定向和转发的？
```markdown
（1）转发：在返回值前面加"forward:"，譬如"forward:user.do?name=method4"
（2）重定向：在返回值前面加"redirect:"，譬如"redirect:http://www.baidu.com"
```
#### 7.如何解决POST请求和GET请求的中文乱码问题？
```markdown
（1）解决post请求乱码问题：
在web.xml中配置一个CharacterEncodingFilter过滤器，设置成utf-8；
（2）get请求中文参数出现乱码解决方法有两个：
①修改tomcat配置文件添加编码与工程编码一致，如下：
<ConnectorURIEncoding="utf-8" connectionTimeout="20000" port="8080" protocol="HTTP/1.1" redirectPort="8443"/>
②另外一种方法对参数进行重新编码：
String userName = new String(request.getParamter(“userName”).getBytes(“ISO8859-1”),“utf-8”)
ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码。
```
#### 8. @ModelAttribute注解应该如何使用？
[@ModelAttribute注解的使用总结](https://blog.csdn.net/leo3070/article/details/81046383)
```markdown
@ModelAttribute最主要的作用是将数据添加到模型对象中，用于视图页面展示时使用。
@ModelAttribute等价于model.addAttribute("attributeName", abc);
但是根据@ModelAttribute注释的位置不同，和其他注解组合使用，致使含义有所不同。
1.@ModelAttribute注释方法 
    （1）@ModelAttribute注释void返回值的方法 
    （2）@ModelAttribute注释返回具体类的方法
    （3）@ModelAttribute(value="")注释返回具体类的方法
    （4）@ModelAttribute和@RequestMapping同时注释一个方法
2.@ModelAttribute注释一个方法的参数 
    （1）从model中获取
    （2）从Form表单或URL参数中获取（实际上，不做此注释也能拿到user对象）
3.@ModelAttribute注释一个方法的返回值
    
```
#### 9. 说说你对自定义数据类型转换器的理解？
[springmvc自定义类型转换器Converter](https://blog.csdn.net/qq_43364241/article/details/90296580)
```markdown

```
#### 10.使用Hibernate Validator注解方式校验Email数据格式应该怎么写？
[Hibernate Validator验证注解说明](https://blog.csdn.net/fighterandknight/article/details/72186260)
## SpringBoot面试题
[Spring Boot面试题（2020最新版）](https://blog.csdn.net/ThinkWon/article/details/104397299)
#### springboot启动流程讲讲？那spring启动流程讲讲？【2+】
#### 平时开发中都用哪些注解？【2+】
#### SpringBoot自动配置的原理是什么？介绍SpringBootApplication注解.
```markdown
启动类：
@SpringBootApplication
public class JpaApplication {
    public static void main(String[] args) {
        SpringApplication.run(JpaApplication.class, args);
    }
}
它主要加载了@SpringBootApplication注解主配置类，这个@SpringBootApplication注解主配置类里边
    最主要的功能就是SpringBoot开启了一个@EnableAutoConfiguration注解的自动配置功能。
@EnableAutoConfiguration作用：
它主要利用了一个EnableAutoConfigurationImportSelector选择器给Spring容器中来导入一些组件。
    @Import(EnableAutoConfigurationImportSelector.class)
    public @interface EnableAutoConfiguration
@SpringBootApplication注解等同于下面三个注解：
    @SpringBootConfiguration： 底层是Configuration注解，说白了就是支持JavaConfig的方式来进行配置
    @EnableAutoConfiguration：开启自动配置功能
    @ComponentScan：就是扫描注解，默认是扫描当前类下的package
    其中@EnableAutoConfiguration是关键(启用自动配置)，内部实际上就去加载META-INF/spring.factories文件的信息，
    然后筛选出以EnableAutoConfiguration为key的数据，加载到IOC容器中，实现自动配置功能！
```
41. 谈谈你对 Spring Boot 的理解？
42. Spring Boot 的优势是什么？为什么要使用 Spring Boot？
43. Spring Boot 的配置文件有几种格式？区别是什么？
44. 谈谈你知道的 Spring Boot 核心注解。
45. 如何自动开启 Spring Boot 各个组件？
46. Spring Boot 中 starter 的原理是什么？
47. Spring Boot 不能使用 XML 配置，这句话对吗?
48. 谈谈你对 Redis 的理解。
49. 简单说说 Redis 的实现原理。
50. 什么是 Thymeleaf？
## Mybatis面试题
[MyBatis面试题（2020最新版）](https://thinkwon.blog.csdn.net/article/details/101292950)
### 1.MyBatis是什么？
```markdown
MyBatis是一款优秀的持久层框架，一个半ORM（对象关系映射）框架，它支持定制化SQL、存储过程以及高级映射。
MyBatis避免了几乎所有的JDBC代码和手动设置参数以及获取结果集。
MyBatis可以使用简单的XML或注解来配置和映射原生类型、接口和Java的POJO为数据库中的记录。
```
### 2.ORM是什么？
```markdown
ORM（Object Relational Mapping），对象关系映射，是一种为了解决关系型数据库数据与简单Java对象（POJO）的映射关系的技术。
简单的说，ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系型数据库中。
```
### 3.为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？
```markdown
Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。
而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。
```
### 4.传统JDBC开发存在的问题
```markdown
频繁创建数据库连接对象、释放，容易造成系统资源浪费，影响系统性能。可以使用连接池解决这个问题。但是使用jdbc需要自己实现连接池。
sql语句定义、参数设置、结果集处理存在硬编码。实际项目中sql语句变化的可能性较大，一旦发生变化，需要修改java代码，系统需要重新编译，重新发布。不好维护。
使用preparedStatement向占有位符号传参数存在硬编码，因为sql语句的where条件不一定，可能多也可能少，修改sql还要修改代码，系统不易维护。
结果集处理存在重复代码，处理麻烦。如果可以映射成Java对象会比较方便。
```
### 5.JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？
```markdown
1、数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库连接池可解决此问题。
解决：在mybatis-config.xml中配置数据链接池，使用连接池管理数据库连接。
2、Sql语句写在代码中造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。
解决：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。
3、向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。
解决：Mybatis自动将java对象映射至sql语句。
4、对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便。
解决：Mybatis自动将sql执行结果映射至java对象。
```
### 6.Mybatis优缺点
```markdown
优点：
    与传统的数据库访问技术相比，ORM有以下优点：
    基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML里，解除sql与程序代码的耦合，
        便于统一管理；提供XML标签，支持编写动态SQL语句，并可重用。
    与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接。
    很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持）
    提供映射标签，支持对象与数据库的ORM字段关系映射；提供对象关系映射标签，支持对象关系组件维护
    能够与Spring很好的集成。
缺点：
    SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求
    SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库
```
### 7.MyBatis的解析和运行原理
```markdown
MyBatis编程步骤是什么样的？
    1、 创建SqlSessionFactory
    2、 通过SqlSessionFactory创建SqlSession
    3、 通过sqlsession执行数据库操作
    4、 调用session.commit()提交事务
    5、 调用session.close()关闭会话       
请说说MyBatis的工作原理:
    1）读取MyBatis配置文件：mybatis-config.xml为MyBatis的全局配置文件，配置了MyBatis的运行环境等信息，例如数据库连接信息。
    2）加载映射文件。映射文件即SQL映射文件，该文件中配置了操作数据库的SQL语句，需要在MyBatis配置文件mybatis-config.xml中加载。
        mybatis-config.xml 文件可以加载多个映射文件，每个文件对应数据库中的一张表。
    3）构造会话工厂：通过MyBatis的环境等配置信息构建会话工厂SqlSessionFactory。
    4）创建会话对象：由会话工厂创建SqlSession对象，该对象中包含了执行SQL语句的所有方法。
    5）Executor执行器：MyBatis底层定义了一个Executor接口来操作数据库，它将根据SqlSession传递的参数动态地生成需要执行的 SQL语句，同时负责查询缓存的维护。
    6）MappedStatement对象：在Executor接口的执行方法中有一个MappedStatement类型的参数，该参数是对映射信息的封装，用于存储要映射的SQL语句的id、参数等信息。
    7）输入参数映射：输入参数类型可以是Map、List 等集合类型，也可以是基本数据类型和POJO类型。输入参数映射过程类似于JDBC对preparedStatement对象设置参数的过程。
    8）输出结果映射：输出结果类型可以是Map、List 等集合类型，也可以是基本数据类型和POJO类型。输出结果映射过程类似于JDBC对结果集的解析过程。
```
### 8.Mybatis都有哪些Executor执行器？它们之间的区别是什么？
```markdown
Mybatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。
SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。
ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，
    而是放置于Map<String, Statement>内，供下一次使用。简言之，就是重复使用Statement对象。
BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），
    它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。
作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内。
Mybatis中如何指定使用哪一种Executor执行器？
在Mybatis配置文件中，在设置（settings）可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法
传递ExecutorType类型参数，如SqlSession openSession(ExecutorType execType)。
配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（prepared statements）；BATCH 执行器将重用语句并执行批量更新。
```
### mybatis一级缓存和二级缓存【1+】
### mybatis如何防止sql注入？$和#的区别是什么？传入表名用哪个？
```markdown
防止sql注入：在编写mybatis的映射语句时，尽量采用“#{xxx}”这样的格式
#和$区别：
#	                     $
相当于对数据加上双引号	 相当于直接显示数据
很大程度上防止SQL注入	 无法防止SQL注入
#{xxx},使用的是PreparedStatement,会有类型转换，比较安全	${xxx}，使用字符串拼接，容易SQL注入
​简单的说就是#{}是经过预编译的，是安全的，${}是未经过预编译的，仅仅是取变量的值，是非安全的，存在SQL注入。
要实现动态传入表名、列名，需要做如下修改：
添加属性statementType="STATEMENT"，同时sql里的属有变量取值都改成${xxxx}
```
MyBatis 接口绑定的优点是什么？
MyBatis 如何实现一对一关联关系？
MyBatis 如何实现一对多关联关系？
说说 MyBatis 动态 SQL 的具体使用步骤?
#### MyBatis与Hibernate的区别是什么？
```markdown
Hibernate 框架：
​ Hibernate是一个开放源代码的对象关系映射框架,它对JDBC进行了非常轻量级的对象封装,建立对象与数据库表的映射。是一个全自动的、完全面向对象的持久层框架。
Mybatis框架：
​ Mybatis是一个开源对象关系映射框架，原名：ibatis,2010年由谷歌接管以后更名。是一个半自动化的持久层框架。
区别：
    开发方面
​       在项目开发过程当中，就速度而言：
​       hibernate开发中，sql语句已经被封装，直接可以使用，加快系统开发；
​       Mybatis 属于半自动化，sql需要手工完成，稍微繁琐；
​       但是，凡事都不是绝对的，如果对于庞大复杂的系统项目来说，复杂语句较多，hibernate 就不是好方案。
    sql优化方面
​       Hibernate 自动生成sql,有些语句较为繁琐，会多消耗一些性能；
​       Mybatis 手动编写sql，可以避免不需要的查询，提高系统性能；
    对象管理比对
​       Hibernate 是完整的对象-关系映射的框架，开发工程中，无需过多关注底层实现，只要去管理对象即可；
​       Mybatis 需要自行管理 映射关系；
```
MyBatis 如何实现模糊查询?

## Netty面试题
[Netty面试题（2020最新版）](https://blog.csdn.net/ThinkWon/article/details/104391081)

##SpringCloud面试题
[Spring Cloud面试题（2020最新版）](https://blog.csdn.net/ThinkWon/article/details/104397367)
51. 什么是 Spring Cloud？
52. Spring Cloud 和 Spring 之间有什么关联关系？
53. Spring Cloud 实现服务注册和发现的原理是什么？
54. Ribbon 和 Feign 有什么区别？
55. 为什么要使用 Spring Cloud 熔断器，它的作用是什么？
56. 什么是 Hystrix？
57. Eureka 和 ZooKeeper 有哪些区别？
58. 为什么要使用负载均衡？
59. Spring Cloud 实现服务注册和发现的具体流程是什么？
60. 为什么要使用 Spring Cloud ，它有哪些优势？
##
Spring框架
Spring框架用到了哪些设计模式。
Spring生命周期详细描述。
Spring是如何解决循环依赖的。
Spring扩展点有哪些，项目中是如何应用的。
Spring IOC、AOP描述。
Spring事务和MySQL事务的区别，Spring事务传播机制介绍，Spring事务失效和解决方案。
Spring全局异常捕获如何编写。
AOP动态代理实现：jdk动态代理和cglib实现差异，cglib性能为什么比jdk动态代理性能高，Fastclass机制描述下，哪些方法不能被动态代理。
AOP失效举例，为什么会失效，如何解决。
BeanFactory和FactoryBean的区别。
Spring创建了单例对象，如果多线程并发对属性赋值，造成相互覆盖的情况，如何处理。
SpringMVC和SpringBoot的区别。

### Tomcat的优化经验
```markdown
Tomcat作为Web服务器，它的处理性能直接关系到⽤户体验，下⾯是⼏种常⻅的优化措施:
    去掉对web.xml的监视，把jsp提前编辑成Servlet。
    有富余物理内存的情况，加⼤tomcat使⽤的jvm的内存。
    服务器资源 服务器所能提供CPU、内存、硬盘的性能对处理能⼒有决定性影响。
    对于⾼并发情况下会有⼤量的运算，那么CPU的速度会直接影响到处理速度。
    内存在⼤量数据处理的情况下，将会有较⼤的内存容量需求，可以⽤-Xmx -Xms -XX:MaxPermSize等参数对内存不同功能块进⾏划分。
    我们之前就遇到过内存分配不⾜，导致虚拟机⼀直处于full GC，从⽽导致处理能⼒严重下降。
    硬盘主要问题就是读写性能，当⼤量⽂件进⾏读写时，磁盘极容易成为性能瓶颈。
    最好的办法还是利⽤下⾯提到的缓存。利⽤缓存和压缩 对于静态⻚⾯最好是能够缓存起来，这样就不必每次从磁盘上读。
这⾥我们采⽤了Nginx作为缓存服务器，将图⽚、css、js⽂件都进⾏了缓存，有效的减少了后端tomcat的访问。 　　
另外，为了能加快⽹络传输速度，开启gzip压缩也是必不可少的。但考虑到tomcat已经需要处理很多东⻄了，所以把这个压缩的⼯作就交给前端的Nginx来完成。
除了⽂本可以⽤gzip压缩，其实很多图⽚也可以⽤图像处理⼯具预先进⾏压缩，找到⼀个平衡点可以让画质损失很⼩⽽⽂件可以减⼩很多。曾经我就⻅过⼀个图⽚从300多kb压缩到⼏⼗kb，⾃⼰⼏乎看不出来区别。
采⽤集群 单个服务器性能总是有限的，最好的办法⾃然是实现横向扩展，那么组建tomcat集群是有效提升性能的⼿段。
我们还是采⽤了Nginx来作为请求分流的服务器，后端多个tomcat共享session来协同⼯作。可以参考之前写的《利⽤nginx+tomcat+memcached组 建web服务器负载均衡》。
优化tomcat参数
这⾥以tomcat7的参数配置为例，需要修改conf/server.xml⽂件，主要是优化连接配置，关闭
客户端dns查询。
    <Connector port="8080" 
     protocol="org.apache.coyote.http11.Http11NioProtocol" 
     connectionTimeout="20000" 
     redirectPort="8443" 
     maxThreads="500" 
     minSpareThreads="20" 
     acceptCount="100"
     disableUploadTimeout="true"
     enableLookups="false" 
     URIEncoding="UTF-8" />
```

## 中间件面试题
### 7.消息中间件有过么？
### 8.rabbitMq和kafka区别聊聊，如何要确保数据不丢失，金融行业你该选什么消息中间件？
## 消息队列
```markdown
消息队列的使用场景 https://blog.csdn.net/fygu18/article/details/80863596
1.异步处理
    如用户注册后，需要发注册邮件和注册短信。传统的做法有两种：串行的方式和并行方式
    注册邮件，发送短信写入消息队列后，直接返回，因此写入消息队列的速度很快，基本可以忽略，因此用户的响应时间可能是50毫秒。
    因此架构改变后，系统的吞吐量提高到每秒20QPS。比串行提高了3倍，比并行提高了两倍！
2.应用解耦
    场景说明：用户下单后，订单系统需要通知库存系统。传统的做法是，订单系统调用库存系统的接口。
    传统模式的缺点：
    假如库存系统无法访问，则订单减库存将失败，从而导致订单失败，订单系统与库存系统耦合。
    引入消息队列后
    订单系统：用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户订单下单成功
    库存系统：订阅下单的消息，采用拉/推的方式，获取下单信息，库存系统根据下单信息，进行库存操作
    假如：在下单时库存系统不能正常使用。也不影响正常下单，因为下单后，订单系统写入消息队列就不再关心其他的后续操作了。实现订单系统与库存系统的应用解耦。
3.流量削锋
    应用场景：秒杀活动，一般会因为流量过大，导致流量暴增，应用挂掉。为解决这个问题，一般需要在应用前端加入消息队列。
    可以控制活动的人数，可以缓解短时间内高流量压垮应用。
4.日志处理
    是指将消息队列用在日志处理中，比如Kafka的应用，解决大量日志传输的问题
5.消息通讯
    消息通讯是指，消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等。
    比如说交易系统下订单后可以通过Kafka去通知其他的系统如广告系统、推荐系统等
    Kafka采用发布订阅模型就是设计模式中的观察者模型
    发布订阅模型（Pub-Sub）使用主题（Topic）作为消息通信载体，类似于广播模式；发布者发布一条消息，该消息通过主题传递给所有的订阅者，在一条消息广播之后才订阅的用户则是收不到该条消息的。
```
## kafka
```markdown
Kafka 选主怎么做的？
kafka如何保证生产与消费都是同步的？
kafka 怎么保证不丢消息的
1. Kafka的特性？

2. Kafka中的分区器、序列化器、拦截器是否了解？它们之间的处理顺序是什么？

3. 消费者重平衡（高可用性、伸缩性）

4. 那些情景下会造成消息漏消费？

5. 如何保证消息不被重复消费（幂等性）

6. KafkaConsumer是非线程安全的，那么怎么样实现多线程消费？

7. Kafka生产者客户端中使用了几个线程来处理？分别是什么？

8. 消费者与生产者的工作流程：

9. topic的分区数可不可以增加？
```

## Nginx
Nginx 反向代理实现高并发的具体步骤是什么？
Nginx 搭建 Tomcat 集群的核心配置应该怎么写？

## 微服务项目实战相关
实际工作中 Spring 微服务项目的问题。
61. 谈谈你对微服务的理解。
62. 微服务分别有哪些优点，哪些缺点？
63. 谈谈微服务之间是如何实现通信的。
64. Spring Boot 如何集成 MyBatis？
65. Spring Boot 和 Spring Cloud 有哪些区别？
66. 使用 layui 的数据表格组件展示业务数据，后台实体类应该如何定义
67. JPA 和 Spring Data JPA 是一回事吗？
68. 如果要给项目添加权限管理系统，一般包含哪些需求？
69. 微服务架构的拆分都有哪些原则？
70. Feign 和 Ribbon+RestTemplate 的区别是什么？
