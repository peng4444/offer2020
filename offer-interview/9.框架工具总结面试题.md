# 工具框架面试题
## 一，Spring面试题
[Spring面试题（2020最新版）](https://thinkwon.blog.csdn.net/article/details/104397516)
### 0.对Spring的理解，项目中都用什么？怎么用的？对IOC、和AOP的理解及实现原理。
```markdown
Spring是一个开源框架，处于MVC模式中的控制层，它能应对需求快速的变化，其主要原因它有一种面向切面编程（AOP）的优势，其次它提升了系统性能，
通过依赖倒置机制（IOC），系统中用到的对象不是在系统加载时就全部实例化，而是在调用到这个类时才会实例化该类的对象，从而提升了系统性能。
这两个优秀的性能使得Spring受到许多J2EE公司的青睐，如阿里中使用最多的也是Spring相关技术。
Spring的优点：
    1、降低了组件之间的耦合性，实现了软件各层之间的解耦。
    2、可以使用容易提供的众多服务，如事务管理，消息服务，日志记录等。
    3、容器提供了AOP技术，利用它很容易实现如权限拦截、运行期监控等功能。
Spring中AOP技术是设计模式中的动态代理模式。只需实现jdk提供的动态代理接口InvocationHandler，所有被代理对象的方法都由InvocationHandler接管实际的处理任务。
面向切面编程中还要理解切入点、切面、通知、织入等概念。
Spring中IOC则利用了Java强大的反射机制来实现。所谓依赖注入即组件之间的依赖关系由容器在运行期决定。
其中依赖注入的方法有两种，通过构造函数注入，通过set方法进行注入。
```
### 1.什么是spring?
```markdown
Spring是一个轻量级Java开发框架，最早有Rod Johnson创建，目的是为了解决企业级应用开发的业务逻辑层和其他各层的耦合问题。
它是一个分层的JavaSE/JavaEE full-stack（一站式）轻量级开源框架，为开发Java应用程序提供全面的基础架构支持。
Spring负责基础架构，因此Java开发者可以专注于应用程序的开发。
Spring最根本的使命是解决企业级应用开发的复杂性，即简化Java开发。
Spring可以做很多事情，它为企业级开发提供给了丰富的功能，但是这些功能的底层都依赖于它的两个核心特性，也就是依赖注入（DI）和面向切面编程（AOP）。
为了降低Java开发的复杂性，Spring采取了以下4种关键策略
    - 基于POJO的轻量级和最小侵入性编程；
    - 通过依赖注入和面向接口实现松耦合；
    - 基于切面和惯例进行声明式编程；
    - 通过切面和模板减少样板式代码。
```
### 2.Spring框架的设计目标，设计理念，和核心是什么
```markdown
Spring设计目标：Spring为开发者提供一个一站式轻量级应用开发平台；
Spring设计理念：在JavaEE开发中，支持POJO和JavaBean开发方式，使应用面向接口开发，充分支持OO（面向对象）设计方法；
Spring通过IoC容器实现对象耦合关系的管理，并实现依赖反转，将对象之间的依赖关系交给IoC容器，实现解耦；
Spring框架的核心：IoC容器和AOP模块。通过IoC容器管理POJO对象以及他们之间的耦合关系；通过AOP以动态非侵入的方式增强服务。
IoC让相互协作的组件保持松散的耦合，而AOP编程允许你把遍布于应用各层的功能分离出来形成可重用的功能组件。
```
### 3.Spring的优缺点是什么？
```markdown
优点
    方便解耦，简化开发。Spring就是一个大工厂，可以将所有对象的创建和依赖关系的维护，交给Spring管理。
    AOP编程的支持。Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能。
    声明式事务的支持。只需要通过配置就可以完成对事务的管理，而无需手动编程。
    方便程序的测试。Spring对Junit4支持，可以通过注解方便的测试Spring程序。
    方便集成各种优秀框架。Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架的直接支持（如：Struts、Hibernate、MyBatis等）。
    降低JavaEE API的使用难度。Spring对JavaEE开发中非常难用的一些API（JDBC、JavaMail、远程调用等），都提供了封装，使这些API应用难度大大降低。
缺点
    - Spring明明一个很轻量级的框架，却给人感觉大而全
    - Spring依赖反射，反射影响性能
    - 使用门槛升高，入门Spring需要较长时间
```
### 4.什么是控制反转（IOC），什么是依赖注入（DI）？
>>  说说IoC中的继承和Java继承的区别。
```markdown
IOC（Inverse of Control:控制反转）是一种设计思想：就是将原本在程序中手动创建对象的控制权，交由Spring框架来管理。
IoC容器是Spring用来实现IoC的载体，IoC容器实际上就是个Map（key，value）,Map中存放的是各种对象。
BeanFactory接口是Spring Ioc容器的核心接口。
IoC最常见以及最合理的实现方式叫做依赖注入（Dependency Injection，简称 DI）。
    将对象之间的相互依赖关系交给Io 容器来管理，并由IoC容器完成对象的注入。
    这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 
    IoC容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。
IOC是实现方式优点：
    1. 对象之间的耦合度或者说依赖程度降低；
    2. 资源变的容易管理；比如你用Spring容器提供的话很容易就可以实现一个单例。
DI：我们在使用Spring容器的时候，容器通过调用set方法或者是构造器来建立对象之间的依赖关系。
控制反转是目标，依赖注入是我们实现控制反转的一种手段。
Java中实现依赖注入的三种方式？
    - 构造器注入
    - set方法注入
    - 接口注入
```
### 5.Spring有几种配置方式 ？
>>IoC自动装载有几种方式？
  IoC容器自动完成装载，默认的方式是？
```markdown
1.基于XML文件的配置:这种配置文件的格式常用<beans>开头，然后运用一系列的bean定义和专门的应用配置选项组成。
    Spring XML配置方式是使用被Spring命名空间所支持的一些列XML的标签来实现的。
2.基于注解的配置:可以使用注解的方式来代替XML方式的bean元素的配置。这就是组件扫描，常用依赖注入的一些注解有：
@Controller @Service @Autowired @RequestMapping @RequestParam @ModelAttribute @Cacheable @CacheFlush @Resource 
@PostConstruct @PreDestroy @Repository @Scope @SessionAttributes @InitBinder @Required @Qualifier
3.组件扫描：容器会扫描base-package指定的包及其子包下面的所有类，如果该类有一些特定的注解，则纳入容器进行管理。
4.在类前面添加的一些特定的注解：@Component 通用注解 @Repository 持久层注解 @Service 业务层注解、 @Controller 控制层注解
5.基于Java的配置
```
### 6.Spring什么是三级缓存
[根据 Spring 源码写一个带有三级缓存的 IOC](https://zhuanlan.zhihu.com/p/144627581)
```markdown
1.第一级缓存：单例缓存池singletonObjects。
2.第二级缓存：早期提前暴露的对象缓存earlySingletonObjects。（属性还没有值对象也没有被初始化）
3.第三级缓存：singletonFactories单例对象工厂缓存。
```
### 7.spring如何解决循环依赖？
```markdown
Spring使用了三级缓存解决了循环依赖的问题。
    在populateBean()给属性赋值阶段里面Spring会解析你的属性，并且赋值，当发现，A对象里面依赖了B，此时又会走getBean方法，但这个时候，你去缓存中是可以拿的到的。
    因为我们在对createBeanInstance对象创建完成以后已经放入了缓存当中，所以创建B的时候发现依赖A，直接就从缓存中去拿，此时B创建完，A也创建完，一共执行了4次。
    至此Bean的创建完成，最后将创建好的Bean放入单例缓存池中。
```
### 8.spring AOP的原理及动态代理
[静态代理和动态代理（jdk/cglib）详解](https://www.cnblogs.com/tc971121/p/13474638.html)
```markdown
AOP(Aspect-Oriented Programming:⾯向切⾯编程)能够将那些与业务⽆关，却为业务模块所共同调⽤的逻辑或责任（例如事务处理、⽇志管理、权限控制等）封装起来，
    便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。
​Spring AOP就是基于动态代理的，如果要代理的对象，实现了某个接⼝，那么Spring AOP会使⽤JDKProxy，去创建代理对象，⽽对于没有实现接⼝的对象，
    就⽆法使⽤JDK Proxy去进⾏代理了，这时候Spring AOP会使⽤Cglib，这时候Spring AOP会使⽤Cglib⽣成⼀个被代理对象的⼦类来作为代理，
AOP 主要用来解决：在不改变原有业务逻辑的情况下，增强横切逻辑代码，根本上解耦合，避免横切逻辑代码重复
    切 ：指的是横切逻辑，原有业务逻辑代码不动，只能操作横切逻辑代码，所以面向横切逻辑
    面 ：横切逻辑代码往往要影响的是很多个方法，每个方法如同一个点，多个点构成一个面。这里有一个面的概念
    @pointcut切点注解 可以设置拦截方式
1.JDK动态代理：利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。
2.CGlib动态代理：利用ASM（开源的Java字节码编辑库，操作字节码）开源包，将代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。
3.区别：JDK代理只能对实现接口的类生成代理；CGlib是针对类实现代理，对指定的类生成一个子类，并覆盖其中的方法，这种通过继承类的实现方式，不能代理final修饰的类。
```
### 9.Spring中Bean的生命周期
```markdown
1.实例化 Instantiation
2.属性赋值 Populate
3.初始化 Initialization
4.销毁 Destruction
单例对象： singleton
    出生：当容器创建时对象出生
    活着：只要容器还在，对象一直或者
    死亡：容器销毁，对象消亡
    总结：单例对象的生命周期和容器相同
多例对象： prototype
    出生: 使用对象时spring框架为我们创建
    活着：对象只要是在使用过程中就一直活着
    死亡：当对象长时间不用且没有其它对象引用时，由java的垃圾回收机制回收
```
### 10.Bean作用域？默认什么级别？是否线程安全？Spring如何保障线程安全的?
```markdown
singleton	单例对象，默认值的作用域
prototype	每次获取都会创建⼀个新的 bean 实例
request	    每⼀次HTTP请求都会产⽣⼀个新的bean，该bean仅在当前HTTP request内有效。
session	    在一次 HTTP session 中，容器将返回同一个实例
global-session	将对象存入到web项目集群的session域中,若不存在集群,则global session相当于session
默认作用域是singleton，多个线程访问同一个bean时会存在线程不安全问题
保障线程安全方法：
    1.在Bean对象中尽量避免定义可变的成员变量（不太现实）。
    2.在类中定义⼀个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中
        ThreadLocal：每个线程中都有一个自己的ThreadLocalMap类对象，可以将线程自己的对象保持到其中，各管各的，线程可以正确的访问到自己的对象。
​        将一个共用的ThreadLocal静态实例作为key，将不同对象的引用保存到不同线程的ThreadLocalMap中，
        然后在线程执行的各处通过这个静态ThreadLocal实例的get()方法取得自己线程保存的那个对象，避免了将这个对象作为参数传递的麻烦。
```
### 11.Spring事务隔离级别和事务传播属性
```markdown
Spring事务和MySQL事务的区别，Spring事务传播机制介绍，Spring事务失效和解决方案。
隔离级别：
    1) DEFAULT （默认）
    这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别。另外四个与JDBC的隔离级别相对应。
    2) READ_UNCOMMITTED （读未提交）
    这是事务最低的隔离级别，它允许另外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻像读。
    3) READ_COMMITTED （读已提交）
    保证一个事务修改的数据提交后才能被另外一个事务读取，另外一个事务不能读取该事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻像读。
    4) REPEATABLE_READ （可重复读）
    这种事务隔离级别可以防止脏读、不可重复读，但是可能出现幻像读。它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了不可重复读。
    5) SERIALIZABLE（串行化）
    这是花费最高代价但是最可靠的事务隔离级别，事务被处理为顺序执行。除了防止脏读、不可重复读外，还避免了幻像读。
Spring事务传播属性（Propagation）：
    1) REQUIRED（默认属性）
    如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。 被设置成这个级别时，会为每一个被调用的方法创建一个逻辑事务域。
    如果前面的方法已经创建了事务，那么后面的方法支持当前的事务，如果当前没有事务会重新建立事务。
    2) MANDATORY
    支持当前事务，如果当前没有事务，就抛出异常。
    3) NEVER
    以非事务方式执行，如果当前存在事务，则抛出异常。
    4) NOT_SUPPORTED
    以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
    5) REQUIRES_NEW
    新建事务，如果当前存在事务，把当前事务挂起。
    6) SUPPORTS
    支持当前事务，如果当前没有事务，就以非事务方式执行。
    7) NESTED
    支持当前事务，新增Savepoint点，与当前事务同步提交或回滚。 嵌套事务一个非常重要的概念就是内层事务依赖于外层事务。
    外层事务失败时，会回滚内层事务所做的动作。而内层事务操作失败并不会引起外层事务的回滚。
```
### 12.Spring以及Spring MVC常见注解
```markdown
Spring部分：
​ 声明bean的注解
​   @Component 通⽤的注解，可标注任意类为 Spring 组件
​   @Service 在业务逻辑层使用（service层）
​   @Repository 在数据访问层使用（dao层）
​   @Controller 在展现层使用，控制器的声明（controller层）
​ 注入bean的注解
​   @Autowired：可以对类成员变量、方法、构造方法进行标注
​   默认按照类型注入，若要按照名称注入，需要搭配@Qualifier注解一起使用
​   @Resource：默认按照名称来装配注入
@autowired和@resource的区别？
    @Autowired：可以对类成员变量、方法、构造方法进行标注。默认按照类型注入，若要按照名称注入，需要搭配@Qualifier注解一起使用
    @Resource：默认按照名称来装配注入
@Autowired的使用简化了我们的开发，其原理是使用AutowiredAnnotationBeanPostProcessor类来实现，该类实现了Spring框架的一些扩展接口，
    通过实现BeanFactoryAware接口使其内部持有了BeanFactory（可轻松的获取需要依赖的的Bean）；通过实现MergedBeanDefinitionPostProcessor扩展接口，
    在BeanFactory里面的每个Bean实例化前获取到每个Bean里面的@Autowired信息并缓存下来；通过实现Spring框架的postProcessPropertyValues扩展接口
    在BeanFactory里面的每个Bean实例后从缓存取出对应的注解信息，获取依赖对象，并通过反射设置到Bean属性里面。
Spring MVC部分：
​   @Controller 声明该类为SpringMVC中的Controller
​   @RequestMapping 用于映射Web请求
​   @ResponseBody 支持将返回值放在response内，而不是一个页面，通常用户返回json数据
​   @RequestBody 允许request的参数在request体中，而不是在直接连接在地址后面。
​   @PathVariable 用于接收路径参数，比如@RequestMapping("/hello/{name}")申明的路径，将注解放在参数中前，即可获取该值，通常作为Restful的接口实现方法。
```
### 13.BeanFactory和ApplicationContext的区别
```markdown
1.BeanFactory是Spring里面最低层的接口，提供了最简单的容器的功能，只提供了实例化对象和拿对象的功能。
2.ApplicationContext应用上下文，继承BeanFactory接口，它是Spring的一各更高级的容器，提供了更多的有用的功能。
    如国际化，访问资源，载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，消息发送、响应机制，AOP等。
3.BeanFactory在启动的时候不会去实例化Bean，中有从容器中拿Bean的时候才会去实例化。
    ApplicationContext在启动的时候就把所有的Bean全部实例化了。它还可以为Bean配置lazy-init=true来让Bean延迟实例化
```
### 14.BeanFactory和FactoryBean的区别
### 15.Spring中用到了哪些设计模式？单例、工厂、代理、适配、观察者之类的说一说就行
[面试官:“谈谈Spring中都用到了那些设计模式?”。](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485303&idx=1&sn=9e4626a1e3f001f9b0d84a6fa0cff04a&chksm=cea248bcf9d5c1aaf48b67cc52bac74eb29d6037848d6cf213b0e5466f2d1fda970db700ba41&token=255050878&lang=zh_CN%23rd)
```markdown
单例设计模式 : Spring 中的 Bean 默认都是单例的。
⼯⼚设计模式 : Spring使⽤⼯⼚模式通过 BeanFactory 、 ApplicationContext 创建bean 对象。
代理设计模式 : Spring AOP 功能的实现。
观察者模式： Spring 事件驱动模型就是观察者模式很经典的⼀个应⽤。
适配器模式：Spring AOP 的增强或通知(Advice)使⽤到了适配器模式、spring MVC 中也是⽤到了适配器模式适配 Controller 。
```
### 16.Spring全局异常捕获如何编写
### 17.@Transactional错误使用失效场景【2+】
```markdown
@Transactional 在private上：当标记在protected、private、package-visible方法上时，不会产生错误，但也不会表现出为它指定的事务配置。可以认为它作为一个普通的方法参与到一个public方法的事务中。
@Transactional 的事务传播方式配置错误。
@Transactional 注解属性 rollbackFor 设置错误：Spring默认抛出了未检查unchecked异常（继承自 RuntimeException 的异常）或者 Error才回滚事务；其他异常不会触发回滚事务。
同一个类中方法调用，导致@Transactional失效：由于使用Spring AOP代理造成的，因为只有当事务方法被当前类以外的代码调用时，才会由Spring生成的代理对象来管理。
异常被 catch 捕获导致@Transactional失效。
数据库引擎不支持事务。
```
### 18.Spring的后置处理器
```markdown
1.BeanPostProcessor：Bean的后置处理器，主要在bean初始化前后工作。（before和after两个回调中间只处理了init-method）
2.InstantiationAwareBeanPostProcessor：继承于BeanPostProcessor，主要在实例化bean前后工作（TargetSource的AOP创建代理对象就是通过该接口实现）
3.BeanFactoryPostProcessor：Bean工厂的后置处理器，在bean定义(bean definitions)加载完成后，bean尚未初始化前执行。
4.BeanDefinitionRegistryPostProcessor：继承于BeanFactoryPostProcessor。
    其自定义的方法postProcessBeanDefinitionRegistry会在bean定义(bean definitions)将要加载，bean尚未初始化前真执行，
    即在BeanFactoryPostProcessor的postProcessBeanFactory方法前被调用。
```

## 二，SpringMVC面试题
[Spring MVC面试题（2020最新版）](https://blog.csdn.net/ThinkWon/article/details/104397427)
###[springmvc的面试知识点总结](https://www.cnblogs.com/yunjiandubu/p/10269713.html)
#### 1.简单谈谈你对MVC的理解。
```markdown
mvc是一种设计模式（设计模式就是日常开发中编写代码的一种好的方法和经验的总结）。
模型（model）-视图（view）-控制器（controller），三层架构的设计模式。
用于实现前端页面的展现与后端业务数据处理的分离。
mvc设计模式的好处
    1.分层设计，实现了业务系统各个组件之间的解耦，有利于业务系统的可扩展性，可维护性。
    2.有利于系统的并行开发，提升开发效率。
```
#### 2.什么是 SpringMVC？SpringMVC的优点?
```markdown
SpringMVC是一个基于Java的实现了MVC设计模式的请求驱动类型的轻量级Web框架，通过把模型-视图-控制器分离，
将web层进行职责解耦，把复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合。
Spring MVC的优点
（1）可以支持各种视图技术,而不仅仅局限于JSP；
（2）与Spring框架集成（如IoC容器、AOP等）；
（3）清晰的角色分配：前端控制器(dispatcherServlet),请求到处理器映射（handlerMapping),处理器适配器（HandlerAdapter),视图解析器（ViewResolver）。
（4）支持各种请求资源的映射策略。
```
#### 3.SpringMVC的核心组件有哪些？
```markdown
（1）前端控制器 DispatcherServlet（不需要程序员开发）
    作用：接收请求、响应结果，相当于转发器，有了DispatcherServlet 就减少了其它组件之间的耦合度。
（2）处理器映射器HandlerMapping（不需要程序员开发）
    作用：根据请求的URL来查找Handler
（3）处理器适配器HandlerAdapter
    注意：在编写Handler的时候要按照HandlerAdapter要求的规则去编写，这样适配器HandlerAdapter才可以正确的去执行Handler。
（4）处理器Handler（需要程序员开发）
（5）视图解析器 ViewResolver（不需要程序员开发）
    作用：进行视图的解析，根据视图逻辑名解析成真正的视图（view）
（6）视图View（需要程序员开发jsp）
    View是一个接口，它的实现类支持不同的视图类型（jsp，freemarker，pdf等等）
```
#### 4.springmvc的工作流程?
![](https://img-blog.csdnimg.cn/20200208211439106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70)
[浅谈SpringMVC执行过程](https://www.cnblogs.com/wangjiming/p/10487832.html)
```markdown
（1）用户发送请求至前端控制器DispatcherServlet；
（2） DispatcherServlet收到请求后，调用HandlerMapping处理器映射器，请求获取Handle；
（3）处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet；
（4）DispatcherServlet 调用 HandlerAdapter处理器适配器；
（5）HandlerAdapter 经过适配调用 具体处理器(Handler，也叫后端控制器)；
（6）Handler执行完成返回ModelAndView；
（7）HandlerAdapter将Handler执行结果ModelAndView返回给DispatcherServlet；
（8）DispatcherServlet将ModelAndView传给ViewResolver视图解析器进行解析；
（9）ViewResolver解析后返回具体View；
（10）DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）
（11）DispatcherServlet响应用户。
```
#### 5.springmvc dispatcherservlet与handleradapter如何关联？
```markdown
DispatcherServlet拦截到请求之后,根据handlerMapping获取到handlerExecutionChain对象,然后,
在handlerExecutionChain对象不为null的情况下,根据handlerExecutionChain中的handler对象获取HandlerAdapter对象;
```
#### 6.有了springmvc的IOC容器,还需要spring的IOC容器吗?为什么?如何处理兼容问题?
```markdown
这个问题再进一步,换个方式提问即是否还需要在web.xml方法里面配置启动springIOC容器的ContextLoaderListener?
可以从正反两方面来回答,首先是需要,通常情况下,类似于数据源,事务,整合其他框架等都是放在spring的配置文件中,而不是springmvc的配置文件中, 
一般情况下,开发过程中的Service,Dao也都是放在spring的IOC容器当中;其次可以是不需要的,也可以都放在springmvc的配置文件当中,
当然需要分多个spring的配置文件,然后通过import节点导入到springmvc的配置文件当中.
几点要注意的地方:
1. springIOC容器和springmvc的IOC容器 扫描的部分有重合的地方,就会导致bean被创建2次,解决方案:使用 exclude-filter和include-filter配合
    来区分哪些bean交给springIOC容器,哪些bean交给springmvcIOC容器;
2. springmvc IOC容器里面的bean可以引用springIOC容器的bean,反之则不行,多个springIOC 容器之间可以设置为父子关系,以实现良好的解耦.
举个栗子,springIOC容器好比是全局作用域,springmvcIOC容器好比是局部作用域,局部的可以引用全局的,而全局的却不能引用局部的.
```
#### 7.tomcat容器如何与springmvc的dispatcherservlet通信的？
```markdown
Apache Tomcat软件是JavaServlet，JavaServerPages，Java ExpressionLanguage和JavaWebSocket技术的开源实现,
SpringMVC则是spring推出的基于servlet标准的MVC框架实现,由此可知,SpringMvc和Tomcat 的结合点就是Servlet.SpringMVC的
DispatcherServlet继承了HttpServlet,那么对于tomcat来说,springmvc实际就是一个Servlet.
一个http请求的具体处理流程:
1. 用户向tomcat容器发送一个请求;
2. tomcat容器接收到请求之后,分析客户的请求信息;
3. tomcat创建一个Httprequest对象,将用户的请求信息封装到该对象中;
4. tomcat创建一个HttpResponse对象;
5. tomcat调用HttpServlet的Service方法,将Httprequest,HTTPResponse传递给Httpservlet对象;
6. HttpServlet调用HttpRequest对象的有关方法,获取Http请求信息,HttpServlet调用HttpResponse对象的有关方法，生成响应数据;
7. tomcat把HttpServlet的响应结果传给Web客户.
要注意的几点东西:
①:web.xml配置文件的作用其实就是配置http请求和servlet之间的映射关系,通过这个配置文件,Tomcat可以把请求转发给不同的servlet实例;
②:springmvc也是servlet标准的一个实现,所有的http请求都映射到DispatcherServlet上去,这个时候,请求就已经由Tomcat转发到springmvc框架中去了,
接着再由DispatcherServlet将请求转发到各个Controller当中去.
```
#### 8.SpringMVC怎么样设定重定向和转发的？
```markdown
（1）转发：在返回值前面加"forward:"，譬如"forward:user.do?name=method4"
（2）重定向：在返回值前面加"redirect:"，譬如"redirect:http://www.baidu.com"
```
#### 9.如何解决POST请求和GET请求的中文乱码问题？
```markdown
（1）解决post请求乱码问题：
在web.xml中配置一个CharacterEncodingFilter过滤器，设置成utf-8；
（2）get请求中文参数出现乱码解决方法有两个：
①修改tomcat配置文件添加编码与工程编码一致，如下：
<ConnectorURIEncoding="utf-8" connectionTimeout="20000" port="8080" protocol="HTTP/1.1" redirectPort="8443"/>
②另外一种方法对参数进行重新编码：
String userName = new String(request.getParamter(“userName”).getBytes(“ISO8859-1”),“utf-8”)
ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码。
```
#### 10. @ModelAttribute注解应该如何使用？
[@ModelAttribute注解的使用总结](https://blog.csdn.net/leo3070/article/details/81046383)
```markdown
@ModelAttribute最主要的作用是将数据添加到模型对象中，用于视图页面展示时使用。
@ModelAttribute等价于model.addAttribute("attributeName", abc);
但是根据@ModelAttribute注释的位置不同，和其他注解组合使用，致使含义有所不同。
1.@ModelAttribute注释方法 
    （1）@ModelAttribute注释void返回值的方法 
    （2）@ModelAttribute注释返回具体类的方法
    （3）@ModelAttribute(value="")注释返回具体类的方法
    （4）@ModelAttribute和@RequestMapping同时注释一个方法
2.@ModelAttribute注释一个方法的参数 
    （1）从model中获取
    （2）从Form表单或URL参数中获取（实际上，不做此注释也能拿到user对象）
3.@ModelAttribute注释一个方法的返回值
    
```
#### 11. 说说你对自定义数据类型转换器的理解？
[springmvc自定义类型转换器Converter](https://blog.csdn.net/qq_43364241/article/details/90296580)
```markdown

```
#### 12.使用Hibernate Validator注解方式校验Email数据格式应该怎么写？
[Hibernate Validator验证注解说明](https://blog.csdn.net/fighterandknight/article/details/72186260)
#### 13.Spring MVC常用注解？当接收一个对象，对某些字段加校验，非空校验，长度校验？
#### 14.SpringMVC的Controller是如何将参数和前端传来的数据一一对应的。

## 三，SpringBoot面试题
[Spring Boot面试题（2020最新版）](https://blog.csdn.net/ThinkWon/article/details/104397299)
#### 1.springBoot是什么?
>> Spring Boot是Spring开源组织下的子项目，是Spring组件一站式解决方案，主要是简化了使用Spring的难度，简省了繁重的配置，提供了各种启动器，开发者能快速上手。
#### 2.SpringBoot哪些优点？
```markdown
Spring Boot 主要有如下优点：
    1.容易上手，提升开发效率，为Spring开发提供一个更快、更广泛的入门体验。
    2.开箱即用，远离繁琐的配置。
    3.提供了一系列大型项目通用的非业务性功能，例如：内嵌服务器、安全管理、运行数据监控、运行状况检查和外部化配置等。
    4.没有代码生成，也不需要XML配置。
    5.避免大量的Maven导入和各种版本冲突。
```
#### 3.SpringBoot的核心注解?【2+】
```markdown
启动类上面的注解是@SpringBootApplication，它也是Spring Boot的核心注解，主要组合包含了以下3个注解：
    @SpringBootConfiguration：组合了@Configuration注解，实现配置文件的功能。
    @EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，
        如关闭数据源自动配置功能：@SpringBootApplication(exclude={DataSourceAutoConfiguration.class})。
    @ComponentScan：Spring组件扫描。
```
#### 4.什么是JavaConfig？
```markdown
Spring JavaConfig是Spring社区的产品，它提供了配置SpringIoC容器的纯Java方法。因此它有助于避免使用XML配置。使用JavaConfig的优点在于：
（1）面向对象的配置。由于配置被定义为JavaConfig中的类，因此用户可以充分利用Java中的面向对象功能。一个配置类可以继承另一个，重写它的@Bean方法等。
（2）减少或消除XML配置。基于依赖注入原则的外化配置的好处已被证明。但是，许多开发人员不希望在XML和Java之间来回切换。
    JavaConfig为开发人员提供了一种纯Java方法来配置与XML配置概念相似的Spring容器。
    从技术角度来讲，只使用JavaConfig配置类来配置容器是可行的，但实际上很多人认为将JavaConfig与XML混合匹配是理想的。
（3）类型安全和重构友好。JavaConfig提供了一种类型安全的方法来配置Spring容器。
    由于Java 5.0对泛型的支持，现在可以按类型而不是按名称检索bean，不需要任何强制转换或基于字符串的查找。
```
#### springboot启动流程讲讲？那spring启动流程讲讲？【2+】

#### SpringBoot自动配置的原理是什么？介绍SpringBootApplication注解.
```markdown
启动类：
@SpringBootApplication
public class JpaApplication {
    public static void main(String[] args) {
        SpringApplication.run(JpaApplication.class, args);
    }
}
它主要加载了@SpringBootApplication注解主配置类，这个@SpringBootApplication注解主配置类里边
    最主要的功能就是SpringBoot开启了一个@EnableAutoConfiguration注解的自动配置功能。
@EnableAutoConfiguration作用：
它主要利用了一个EnableAutoConfigurationImportSelector选择器给Spring容器中来导入一些组件。
    @Import(EnableAutoConfigurationImportSelector.class)
    public @interface EnableAutoConfiguration
@SpringBootApplication注解等同于下面三个注解：
    @SpringBootConfiguration： 底层是Configuration注解，说白了就是支持JavaConfig的方式来进行配置
    @EnableAutoConfiguration：开启自动配置功能
    @ComponentScan：就是扫描注解，默认是扫描当前类下的package
    其中@EnableAutoConfiguration是关键(启用自动配置)，内部实际上就去加载META-INF/spring.factories文件的信息，
    然后筛选出以EnableAutoConfiguration为key的数据，加载到IOC容器中，实现自动配置功能！
注解@EnableAutoConfiguration,@Configuration,@ConditionalOnClass就是自动配置的核心，
    @EnableAutoConfiguration给容器导入META-INF/spring.factories里定义的自动配置类。
    筛选有效的自动配置类。
    每一个自动配置类结合对应的xxxProperties.java读取配置文件进行自动配置功能
```
41. 谈谈你对 Spring Boot 的理解？
42. Spring Boot 的优势是什么？为什么要使用 Spring Boot？
43. Spring Boot 的配置文件有几种格式？区别是什么？
44. 谈谈你知道的 Spring Boot 核心注解。
45. 如何自动开启 Spring Boot 各个组件？
46. Spring Boot 中 starter 的原理是什么？
47. Spring Boot 不能使用 XML 配置，这句话对吗?
48. 谈谈你对 Redis 的理解。
49. 简单说说 Redis 的实现原理。
50. 什么是 Thymeleaf？

## 四，Mybatis面试题
[MyBatis面试题（2020最新版）](https://thinkwon.blog.csdn.net/article/details/101292950)
### 1.MyBatis是什么？
```markdown
MyBatis是一款优秀的持久层框架，一个半ORM（对象关系映射）框架，它支持定制化SQL、存储过程以及高级映射。
MyBatis避免了几乎所有的JDBC代码和手动设置参数以及获取结果集。
MyBatis可以使用简单的XML或注解来配置和映射原生类型、接口和Java的POJO为数据库中的记录。
```
### 2.ORM是什么？
```markdown
ORM（Object Relational Mapping），对象关系映射，是一种为了解决关系型数据库数据与简单Java对象（POJO）的映射关系的技术。
简单的说，ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系型数据库中。
```
### 3.为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？
```markdown
Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。
而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。
```
### 4.传统JDBC开发存在的问题
```markdown
频繁创建数据库连接对象、释放，容易造成系统资源浪费，影响系统性能。可以使用连接池解决这个问题。但是使用jdbc需要自己实现连接池。
sql语句定义、参数设置、结果集处理存在硬编码。实际项目中sql语句变化的可能性较大，一旦发生变化，需要修改java代码，系统需要重新编译，重新发布。不好维护。
使用preparedStatement向占有位符号传参数存在硬编码，因为sql语句的where条件不一定，可能多也可能少，修改sql还要修改代码，系统不易维护。
结果集处理存在重复代码，处理麻烦。如果可以映射成Java对象会比较方便。
```
### 5.JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？
```markdown
1、数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库连接池可解决此问题。
解决：在mybatis-config.xml中配置数据链接池，使用连接池管理数据库连接。
2、Sql语句写在代码中造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。
解决：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。
3、向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。
解决：Mybatis自动将java对象映射至sql语句。
4、对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便。
解决：Mybatis自动将sql执行结果映射至java对象。
```
### 6.Mybatis优缺点
```markdown
优点：
    与传统的数据库访问技术相比，ORM有以下优点：
    基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML里，解除sql与程序代码的耦合，
        便于统一管理；提供XML标签，支持编写动态SQL语句，并可重用。
    与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接。
    很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持）
    提供映射标签，支持对象与数据库的ORM字段关系映射；提供对象关系映射标签，支持对象关系组件维护
    能够与Spring很好的集成。
缺点：
    SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求
    SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库
```
### 7.MyBatis的解析和运行原理
```markdown
MyBatis编程步骤是什么样的？
    1、 创建SqlSessionFactory
    2、 通过SqlSessionFactory创建SqlSession
    3、 通过sqlsession执行数据库操作
    4、 调用session.commit()提交事务
    5、 调用session.close()关闭会话       
请说说MyBatis的工作原理:
    1）读取MyBatis配置文件：mybatis-config.xml为MyBatis的全局配置文件，配置了MyBatis的运行环境等信息，例如数据库连接信息。
    2）加载映射文件。映射文件即SQL映射文件，该文件中配置了操作数据库的SQL语句，需要在MyBatis配置文件mybatis-config.xml中加载。
        mybatis-config.xml 文件可以加载多个映射文件，每个文件对应数据库中的一张表。
    3）构造会话工厂：通过MyBatis的环境等配置信息构建会话工厂SqlSessionFactory。
    4）创建会话对象：由会话工厂创建SqlSession对象，该对象中包含了执行SQL语句的所有方法。
    5）Executor执行器：MyBatis底层定义了一个Executor接口来操作数据库，它将根据SqlSession传递的参数动态地生成需要执行的 SQL语句，同时负责查询缓存的维护。
    6）MappedStatement对象：在Executor接口的执行方法中有一个MappedStatement类型的参数，该参数是对映射信息的封装，用于存储要映射的SQL语句的id、参数等信息。
    7）输入参数映射：输入参数类型可以是Map、List 等集合类型，也可以是基本数据类型和POJO类型。输入参数映射过程类似于JDBC对preparedStatement对象设置参数的过程。
    8）输出结果映射：输出结果类型可以是Map、List 等集合类型，也可以是基本数据类型和POJO类型。输出结果映射过程类似于JDBC对结果集的解析过程。
```
### 8.Mybatis都有哪些Executor执行器？它们之间的区别是什么？
```markdown
Mybatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。
SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。
ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，
    而是放置于Map<String, Statement>内，供下一次使用。简言之，就是重复使用Statement对象。
BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），
    它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。
作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内。
Mybatis中如何指定使用哪一种Executor执行器？
在Mybatis配置文件中，在设置（settings）可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法
传递ExecutorType类型参数，如SqlSession openSession(ExecutorType execType)。
配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（prepared statements）；BATCH 执行器将重用语句并执行批量更新。
```
### 9.Mybatis一级缓存和二级缓存【1+】
### 10.Mybatis如何防止sql注入？$和#的区别是什么？传入表名用哪个？

```markdown
防止sql注入：在编写mybatis的映射语句时，尽量采用“#{xxx}”这样的格式
#和$区别：
#	                     $
相当于对数据加上双引号	 相当于直接显示数据
很大程度上防止SQL注入	 无法防止SQL注入
#{xxx},使用的是PreparedStatement,会有类型转换，比较安全	${xxx}，使用字符串拼接，容易SQL注入
​简单的说就是#{}是经过预编译的，是安全的，${}是未经过预编译的，仅仅是取变量的值，是非安全的，存在SQL注入。
要实现动态传入表名、列名，需要做如下修改：
添加属性statementType="STATEMENT"，同时sql里的属有变量取值都改成${xxxx}
```
MyBatis 接口绑定的优点是什么？
MyBatis 如何实现一对一关联关系？
MyBatis 如何实现一对多关联关系？
说说 MyBatis 动态 SQL 的具体使用步骤?
#### MyBatis与Hibernate的区别是什么？
```markdown
Hibernate 框架：
​ Hibernate是一个开放源代码的对象关系映射框架,它对JDBC进行了非常轻量级的对象封装,建立对象与数据库表的映射。是一个全自动的、完全面向对象的持久层框架。
Mybatis框架：
​ Mybatis是一个开源对象关系映射框架，原名：ibatis,2010年由谷歌接管以后更名。是一个半自动化的持久层框架。
区别：
    开发方面
​       在项目开发过程当中，就速度而言：
​       hibernate开发中，sql语句已经被封装，直接可以使用，加快系统开发；
​       Mybatis 属于半自动化，sql需要手工完成，稍微繁琐；
​       但是，凡事都不是绝对的，如果对于庞大复杂的系统项目来说，复杂语句较多，hibernate 就不是好方案。
    sql优化方面
​       Hibernate 自动生成sql,有些语句较为繁琐，会多消耗一些性能；
​       Mybatis 手动编写sql，可以避免不需要的查询，提高系统性能；
    对象管理比对
​       Hibernate 是完整的对象-关系映射的框架，开发工程中，无需过多关注底层实现，只要去管理对象即可；
​       Mybatis 需要自行管理 映射关系；
```
MyBatis 如何实现模糊查询?
### 2.Mybatis如何找到指定的Mapper的，如何完成查询的。

## 五, SpringCloud面试题
怎么保证微服务调用的时候它们执行的一致性？比如调用A,B两个微服务，一个调用成功另一个调用失败，怎么办？
52. Spring Cloud 和 Spring 之间有什么关联关系？
53. Spring Cloud 实现服务注册和发现的原理是什么？
54. Ribbon 和 Feign 有什么区别？
55. 为什么要使用 Spring Cloud 熔断器，它的作用是什么？
56. 什么是 Hystrix？
57. Eureka 和 ZooKeeper 有哪些区别？
58. 为什么要使用负载均衡？
59. Spring Cloud 实现服务注册和发现的具体流程是什么？
60. 为什么要使用 Spring Cloud ，它有哪些优势？
[思维导图概览SpringCloud](https://www.cnblogs.com/three-fighter/p/13485459.html)
[Spring Cloud面试题（2020最新版）](https://blog.csdn.net/ThinkWon/article/details/104397367)
![](https://img-blog.csdnimg.cn/20200810105241576.png?#pic_center)
### 0.什么是微服务
```markdown
架构演进:架构的发展历程是从单体式架构，到分布式架构，到SOA架构，再到微服务架构。
    单体架构：未做任何拆分的Java Web程序
    分布式架构:按照业务垂直划分，每个业务都是单体架构，通过API互相调用。
    SOA架构：SOA是一种面向服务的架构。其应用程序的不同组件通过网络上的通信协议向其它组件提供服务或消费服务，所以也是分布式架构的一种。
    微服务架构是一种架构模式或者说是一种架构风格，它提倡将单一应用程序划分成一组小的服务，每个服务运行独立的自己的进程中，服务之间互相协调、互相配合，为用户提供最终价值。
        服务之间采用轻量级的通信机制互相沟通（通常是基于HTTP的RESTful API)。每个服务都围绕着具体业务进行构建，并且能够被独立地部署到生产环境、类生产环境等。
目前最流行的两种微服务解决方案是SpringCloud和Dubbo。
```
### 1.什么是SpringCloud？
![](https://img-blog.csdnimg.cn/20200810112743519.png?#pic_center)
```markdown
Spring Cloud作为Java的微服务框架，它依赖于Spring Boot，有快速开发、持续交付和容易部署等特点。
    Spring Cloud的组件非常多，涉及微服务的方方面面，井在开源社区Spring、Netflix Pivotal两大公司的推动下越来越完善。
    SpringCloud是微服务系统架构的一站式解决方案，在平时我们构建微服务的过程中需要做如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等操作，
    SpringCloud为最常见的分布式系统模式提供了一种简单且易于接受的编程模型，帮助开发人员构建有弹性的、可靠的、协调的应用程序。
SpringCloud的版本
    最早的Release版本Angel，第二个Release版本Brixton（英国地名），然后是Camden、Dalston、Edgware、Finchley、Greenwich、Hoxton。
Spring Cloud Config
集中配置管理工具，分布式系统中统一的外部配置管理，默认使用Git来存储配置，可以支持客户端配置的刷新及加密、解密操作。
Spring Cloud Netflix
    Netflix OSS 开源组件集成，包括Eureka、Hystrix、Ribbon、Feign、Zuul等核心组件。
    Eureka：服务治理组件，包括服务端的注册中心和客户端的服务发现机制；
    Ribbon：负载均衡的服务调用组件，具有多种负载均衡调用策略；
    Hystrix：服务容错组件，实现了断路器模式，为依赖服务的出错和延迟提供了容错能力；
    Feign：基于Ribbon和Hystrix的声明式服务调用组件；
    Zuul：API网关组件，对请求提供路由及过滤功能。
Spring Cloud Bus
    用于传播集群状态变化的消息总线，使用轻量级消息代理链接分布式系统中的节点，可以用来动态刷新集群中的服务配置。
Spring Cloud Consul
    基于Hashicorp Consul的服务治理组件。
Spring Cloud Security
    安全工具包，对Zuul代理中的负载均衡OAuth2客户端及登录认证进行支持。
Spring Cloud Sleuth
    Spring Cloud应用程序的分布式请求链路跟踪，支持使用Zipkin、HTrace和基于日志（例如ELK）的跟踪。
Spring Cloud Stream
    轻量级事件驱动微服务框架，可以使用简单的声明式模型来发送及接收消息，主要实现为Apache Kafka及RabbitMQ。
Spring Cloud Task
    用于快速构建短暂、有限数据处理任务的微服务框架，用于向应用中添加功能性和非功能性的特性。
Spring Cloud Zookeeper
    基于Apache Zookeeper的服务治理组件。
Spring Cloud Gateway
    API网关组件，对请求提供路由及过滤功能。
Spring Cloud OpenFeign
    基于Ribbon和Hystrix的声明式服务调用组件，可以动态创建基于Spring MVC注解的接口实现用于服务调用，在Spring Cloud 2.0中已经取代Feign成为了一等公民。
```
### 2.Eureka服务发现框架
![](https://img-blog.csdnimg.cn/20200810120101878.png?#pic_center)
```markdown
Netflix Eureka是由Netflix开源的一款基于REST的服务发现组件，包括Eureka Server及Eureka Client。
    在Netflix，更复杂的负载均衡器将Eureka包装起来，以基于流量，资源使用，错误条件等多种因素提供加权负载均衡，以提供出色的弹性。
服务注册Register：当Eureka客户端向Eureka Server注册时，它提供自身的元数据，比如IP地址、端口，运行状况指示符URL，主页等。
服务续约Renew：Eureka 客户会每隔30秒(默认情况下)发送一次心跳来续约。通过续约来告知Eureka Server该Eureka客户仍然存在，没有出现问题。
    正常情况下，如果Eureka Server在90秒没有收到Eureka客户的续约，它会将实例从其注册表中删除。
获取注册列表信息Fetch Registries：Eureka客户端从服务器获取注册表信息，并将其缓存在本地。客户端会使用该信息查找其他服务，从而进行远程调用。
    该注册列表信息定期（每30秒钟）更新一次。每次返回注册列表信息可能与Eureka客户端的缓存信息不同,Eureka客户端自动处理。
    如果由于某种原因导致注册列表信息不能及时匹配，Eureka客户端则会重新获取整个注册表信息。
    Eureka服务器缓存注册列表信息，整个注册表以及每个应用程序的信息进行了压缩，压缩内容和没有压缩的内容完全相同。
    Eureka客户端和Eureka服务器可以使用JSON/XML格式进行通讯。在默认的情况下Eureka客户端使用压缩JSON格式来获取注册列表的信息。
服务下线Cancel：Eureka客户端在程序关闭时向Eureka服务器发送取消请求。发送请求后，该客户端实例信息将从服务器的实例注册表中删除。
    该下线请求不会自动完成，它需要调用以下内容：DiscoveryManager.getInstance().shutdownComponent();
服务剔除Eviction：在默认的情况下，当Eureka客户端连续90秒(3个续约周期)没有向Eureka服务器发送服务续约，即心跳，Eureka服务器会将该服务实例从服务注册列表删除，即服务剔除。
```
### 3.Ribbon 进程内负载均衡器
>> Ribbon Netflix 公司开源的一个负载均衡的组件。
![](https://img-blog.csdnimg.cn/20200810174308572.png?#pic_center)
#### RestTemplate
```markdown
RestTemplate是Spring提供的一个访问Http服务的客户端类 
```
#### Ribbon的几种负载均衡算法
```markdown
Ribbon是Netflix公司的一个开源的负载均衡 项目，是一个客户端/进程内负载均衡器，运行在消费者端 。
RoundRobinRule ：轮询策略。Ribbon默认采用的策略。若经过一轮轮询没有找到可用的provider，其最多轮询10轮。若最终还没有找到，则返回null。
RandomRule : 随机策略，从所有可用的provider中随机选择一个。
RetryRule : 重试策略。先按照RoundRobinRule策略获取provider，若获取失败，则在指定的时限内重试。默认的时限为500毫秒。
配置文件配置：
    providerName:
      ribbon:
        NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule
```
### 4.Open Feign服务调用映射
>> Feign是一个声明式的Web Service客户端。
![](https://img-blog.csdnimg.cn/20200810182853299.png?0#pic_center)
```markdown
OpenFeign也是运行在消费者端的，使用Ribbon进行负载均衡，所以OpenFeign直接内置了Ribbon。
// 使用 @FeignClient 注解来指定提供者的名字
@FeignClient(value = "eureka-client-provider")
public interface TestClient {
    // 这里一定要注意需要使用的是提供者那端的请求相对路径，这里就相当于映射了
    @RequestMapping(value = "/provider/xxx",
    method = RequestMethod.POST)
    CommonResponse<List<Plan>> getPlans(@RequestBody planGetRequest request);
}
@RestController
public class TestController {
    // 这里就相当于原来自动注入的 Service
    @Autowired
    private TestClient testClient;
    // controller 调用 service 层代码
    @RequestMapping(value = "/test", method = RequestMethod.POST)
    public CommonResponse<List<Plan>> get(@RequestBody planGetRequest request) {
        return testClient.getPlans(request);
    }
}
```
### 5.Hystrix服务降级熔断器
>> Hystrix是Netstflix公司开源的一个项目，它提供了熔断器功能，能够阻止分布式系统中出现联动故障。
![](https://img-blog.csdnimg.cn/20200810205126528.png?#pic_center)
```markdown
Hystrix是一个库，可通过添加等待时间容限和容错逻辑来帮助您控制这些分布式服务之间的交互。
Hystrix通过隔离服务之间的访问点，停止服务之间的级联故障并提供后备选项来实现此目的，所有这些都可以提高系统的整体弹性。
```
### 6.Zuul微服务网关
>> Zuul是由Netflix孵化的一个致力于“网关“解决方案的开源组件。
![](https://img-blog.csdnimg.cn/20200810211514805.png?#pic_center)
```markdown
ZUUL是从设备和web站点到Netflix流应用后端的所有请求的前门。作为边界服务应用，
ZUUL是为了实现动态路由、监视、弹性和安全性而构建的。它还具有根据情况将请求路由到多个Amazon Auto Scaling Groups（亚马逊自动缩放组，亚马逊的一种云计算方式）的能力。
    网关是系统唯一对外的入口，介于客户端与服务器端之间，用于对请求进行鉴权、限流、路由、监控等功能。
    网关相当于一个网络服务架构的入口，所有网络请求必须通过网关转发到具体的服务。
    网关的作用:统一管理微服务请求，权限控制、负载均衡、路由转发、监控、安全控制黑名单和白名单等。
Zuul是对SpringCloud提供的成熟对的路由方案，他会根据请求的路径不同，网关会定位到指定的微服务，并代理请求到不同的微服务接口，他对外隐蔽了微服务的真正接口地址。
三个重要概念：动态路由表，路由定位，反向代理：
    动态路由表：Zuul支持Eureka路由，手动配置路由，这俩种都支持自动更新
    路由定位：根据请求路径，Zuul有自己的一套定位服务规则以及路由表达式匹配
    反向代理：客户端请求到路由网关，网关受理之后，在对目标发送请求，拿到响应之后在 给客户端
它可以和Eureka,Ribbon,Hystrix等组件配合使用，
Zuul的应用场景：
    对外暴露，权限校验，服务聚合，日志审计等
```
### 7.Config 微服务统一配置中心
![](https://img-blog.csdnimg.cn/20200810214123442.png?#pic_center)
```markdown
Spring Cloud中提供了分布式配置中Spring Cloud Config，为外部配置提供了客户端和服务器端的支持。
使用Config 服务器，可以在中心位置管理所有环境中应用程序的外部属性。
```
### 8.Bus消息总线
![](https://img-blog.csdnimg.cn/20200810223142844.png?0#pic_center)
```markdown
Spring Cloud Bus的作用就是管理和广播分布式系统中的消息 ，也就是消息引擎系统中的广播模式。
当然作为消息总线的Spring Cloud Bus可以做很多事而不仅仅是客户端的配置刷新功能。
```
### 9.Gateway
![](https://img-blog.csdnimg.cn/20200810212808923.png?#pic_center)
```markdown
Spring Cloud Gateway是Spring官方基于Spring5.0、Spring Boot2.0 和Project Reactor等技术开发的网关，
Spring Cloud Gateway旨在为微服务架构提供简单、 有效且统一的API路由管理方式。
```
### 10.OAuth2
>> Sprin Cloud构建的微服务系统中可以使用Spring Cloud OAuth2来保护微服务系统。
![](https://img-blog.csdnimg.cn/20200811205313656.png?#pic_center)
```markdown

```
### 11.Sleuth
>> Spring Cloud Sleuth是Spring Cloud个组件，它的主要功能是在分布式系统中提供服务链路追踪的解决方案。
![](https://img-blog.csdnimg.cn/20200811212137615.png?#pic_center)
### Tomcat的优化经验
```markdown
Tomcat作为Web服务器，它的处理性能直接关系到⽤户体验，下⾯是⼏种常⻅的优化措施:
    去掉对web.xml的监视，把jsp提前编辑成Servlet。
    有富余物理内存的情况，加⼤tomcat使⽤的jvm的内存。
    服务器资源 服务器所能提供CPU、内存、硬盘的性能对处理能⼒有决定性影响。
    对于⾼并发情况下会有⼤量的运算，那么CPU的速度会直接影响到处理速度。
    内存在⼤量数据处理的情况下，将会有较⼤的内存容量需求，可以⽤-Xmx -Xms -XX:MaxPermSize等参数对内存不同功能块进⾏划分。
    我们之前就遇到过内存分配不⾜，导致虚拟机⼀直处于full GC，从⽽导致处理能⼒严重下降。
    硬盘主要问题就是读写性能，当⼤量⽂件进⾏读写时，磁盘极容易成为性能瓶颈。
    最好的办法还是利⽤下⾯提到的缓存。利⽤缓存和压缩 对于静态⻚⾯最好是能够缓存起来，这样就不必每次从磁盘上读。
这⾥我们采⽤了Nginx作为缓存服务器，将图⽚、css、js⽂件都进⾏了缓存，有效的减少了后端tomcat的访问。 　　
另外，为了能加快⽹络传输速度，开启gzip压缩也是必不可少的。但考虑到tomcat已经需要处理很多东⻄了，所以把这个压缩的⼯作就交给前端的Nginx来完成。
除了⽂本可以⽤gzip压缩，其实很多图⽚也可以⽤图像处理⼯具预先进⾏压缩，找到⼀个平衡点可以让画质损失很⼩⽽⽂件可以减⼩很多。曾经我就⻅过⼀个图⽚从300多kb压缩到⼏⼗kb，⾃⼰⼏乎看不出来区别。
采⽤集群 单个服务器性能总是有限的，最好的办法⾃然是实现横向扩展，那么组建tomcat集群是有效提升性能的⼿段。
我们还是采⽤了Nginx来作为请求分流的服务器，后端多个tomcat共享session来协同⼯作。可以参考之前写的《利⽤nginx+tomcat+memcached组 建web服务器负载均衡》。
优化tomcat参数
这⾥以tomcat7的参数配置为例，需要修改conf/server.xml⽂件，主要是优化连接配置，关闭
客户端dns查询。
    <Connector port="8080" 
     protocol="org.apache.coyote.http11.Http11NioProtocol" 
     connectionTimeout="20000" 
     redirectPort="8443" 
     maxThreads="500" 
     minSpareThreads="20" 
     acceptCount="100"
     disableUploadTimeout="true"
     enableLookups="false" 
     URIEncoding="UTF-8" />
```
### SpringBoot和SpringCloud的区别？
```markdown
SpringBoot专注于快速方便的开发单个个体微服务。
SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务整合并管理起来，
    为各个微服务之间提供，配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等集成服务
SpringBoot可以离开SpringCloud独立使用开发项目， 但是SpringCloud离不开SpringBoot ，属于依赖的关系
SpringBoot专注于快速、方便的开发单个微服务个体，SpringCloud关注全局的服务治理框架。
```
### 使用Spring Boot开发分布式微服务时，我们面临以下问题
```markdown
（1）与分布式系统相关的复杂性-这种开销包括网络问题，延迟开销，带宽问题，安全问题。
（2）服务发现-服务发现工具管理群集中的流程和服务如何查找和互相交谈。它涉及一个服务目录，在该目录中注册服务，然后能够查找并连接到该目录中的服务。
（3）冗余-分布式系统中的冗余问题。
（4）负载平衡 --负载平衡改善跨多个计算资源的工作负荷，诸如计算机，计算机集群，网络链路，中央处理单元，或磁盘驱动器的分布。
（5）性能-问题 由于各种运营开销导致的性能问题。
（6）部署复杂性-Devops 技能的要求。
```
### SpringCloud的优缺点
```markdown
优点：
      1.耦合度比较低。不会影响其他模块的开发。
      2.减轻团队的成本，可以并行开发，不用关注其他人怎么开发，先关注自己的开发。
      3.配置比较简单，基本用注解就能实现，不用使用过多的配置文件。
      4.微服务跨平台的，可以用任何一种语言开发。
      5.每个微服务可以有自己的独立的数据库也有用公共的数据库。
      6.直接写后端的代码，不用关注前端怎么开发，直接写自己的后端代码即可，然后暴露接口，通过组件进行服务通信。
缺点：
      1.部署比较麻烦，给运维工程师带来一定的麻烦。
      2.针对数据的管理比麻烦，因为微服务可以每个微服务使用一个数据库。
      3.系统集成测试比较麻烦
      4.性能的监控比较麻烦。【最好开发一个大屏监控系统】
总的来说优点大过于缺点，目前看来SpringCloud是一套非常完善的分布式框架，目前很多企业开始用微服务、SpringCloud的优势是显而易见的。
因此对于想研究微服务架构的同学来说，学习SpringCloud是一个不错的选择。
```
### SpringCloud和Dubbo区别?
```markdown
（1）服务调用方式：dubbo是RPC springcloud Rest Api
（2）注册中心：dubbo 是zookeeper springcloud是eureka，也可以是zookeeper
（3）服务网关，dubbo本身没有实现，只能通过其他第三方技术整合，springcloud有Zuul路由网关，作为路由服务器，进行消费者的请求分发,springcloud支持断路器，
    与git完美集成配置文件支持版本控制，事物总线实现配置文件的更新与服务自动装配等等一系列的微服务架构要素。
```
### Eureka和ZooKeeper都可以提供服务注册与发现的功能,请说说两个的区别
```markdown
1.ZooKeeper中的节点服务挂了就要选举
    在选举期间注册服务瘫痪,虽然服务最终会恢复,但是选举期间不可用的，
    选举就是改微服务做了集群，必须有一台主其他的都是从
2.Eureka各个节点是平等关系,服务器挂了没关系，只要有一台Eureka就可以保证服务可用，数据都是最新的。
    如果查询到的数据并不是最新的，就是因为Eureka的自我保护模式导致的
3.Eureka本质上是一个工程,而ZooKeeper只是一个进程
4.Eureka可以很好的应对因网络故障导致部分节点失去联系的情况,而不会像ZooKeeper 一样使得整个注册系统瘫痪
5.ZooKeeper保证的是CP，Eureka保证的是AP
CAP：
    C：一致性>Consistency;
        取舍：(强一致性、单调一致性、会话一致性、最终一致性、弱一致性)
    A：可用性>Availability;
    P：分区容错性>Partition tolerance;
```
## 六，中间件面试题
### Zookeeper
>>zookeeper节点类型、服务器角色，watch机制。
>>使用zookeeper实现分布式锁和读写锁。
#### 1.CAP定理
```markdown
一个分布式系统不可能在满足分区容错性（P）的情况下同时满足一致性（C）和可用性（A）。
    在此ZooKeeper保证的是CP，ZooKeeper不能保证每次服务请求的可用性，
    在极端环境下，ZooKeeper可能会丢弃一些请求，消费者程序需要重新请求才能获得结果。
    另外在进行leader选举时集群都是不可用，所以说，ZooKeeper不能保证服务可用性。
```
#### 2.BASE理论
```markdown
BASE理论是基本可用，软状态，最终一致性三个短语的缩写。
BASE理论是对CAP中一致性和可用性（CA）权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于CAP定理逐步演化而来的，它大大降低了我们对系统的要求。
    1.基本可用：基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。
        但是，这绝不等价于系统不可用。比如正常情况下，一个在线搜索引擎需要在0.5秒之内返回给用户相应的查询结果，但由于出现故障，查询结果的响应时间增加了1~2秒。
    2.软状态：软状态指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。
    3.最终一致性：最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。
        因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。
```
#### 3.ZooKeeper特点
```markdown
1.顺序一致性：同一客户端发起的事务请求，最终将会严格地按照顺序被应用到 ZooKeeper 中去。
2.原子性：所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么整个集群中所有的机器都成功应用了某一个事务，要么都没有应用。
3.单一系统映像：无论客户端连到哪一个 ZooKeeper 服务器上，其看到的服务端数据模型都是一致的。
4.可靠性：一旦一次更改请求被应用，更改的结果就会被持久化，直到被下一次更改覆盖。
```
#### 4.ZAB协议
```markdown
ZAB协议包括两种基本的模式：崩溃恢复和消息广播。当整个Zookeeper集群刚刚启动或者Leader服务器宕机、重启或者网络故障导致不存在过半的服务器与
    Leader服务器保持正常通信时，所有服务器进入崩溃恢复模式，首先选举产生新的Leader服务器，然后集群中Follower服务器开始与新的Leader服务器进行数据同步。
    当集群中超过半数机器与该Leader服务器完成数据同步之后，退出恢复模式进入消息广播模式，Leader服务器开始接收客户端的事务请求生成事物提案（超过半数同意）来进行事务请求处理。
```
#### 5.选举算法和流程：FastLeaderElection(默认提供的选举算法)
```markdown
目前有5台服务器，每台服务器均没有数据，它们的编号分别是1,2,3,4,5,按编号依次启动，它们的选择举过程如下：
    1.服务器1启动，给自己投票，然后发投票信息，由于其它机器还没有启动所以它收不到反馈信息，服务器1的状态一直属于Looking。
    2.服务器2启动，给自己投票，同时与之前启动的服务器1交换结果，由于服务器2的编号大所以服务器2胜出，但此时投票数没有大于半数，所以两个服务器的状态依然是LOOKING。
    3.服务器3启动，给自己投票，同时与之前启动的服务器1,2交换信息，由于服务器3的编号最大所以服务器3胜出，此时投票数正好大于半数，所以服务器3成为leader，服务器1,2成为follower。
    4.服务器4启动，给自己投票，同时与之前启动的服务器1,2,3交换信息，尽管服务器4的编号大，但之前服务器3已经胜出，所以服务器4只能成为follower。
    5.服务器5启动，后面的逻辑同服务器4成为follower。
```
#### 6.zk中的监控原理
```markdown
zk类似于linux中的目录节点树方式的数据存储，即分层命名空间，zk并不是专门存储数据的，它的作用是主要是维护和监控存储数据的状态变化，
    通过监控这些数据状态的变化，从而可以达到基于数据的集群管理，zk中的节点的数据上限时1M。
client端会对某个znode建立一个watcher事件，当该znode发生变化时，这些client会收到zk的通知，然后client可以根据znode变化来做出业务上的改变等。
```

### Nginx
Nginx 反向代理实现高并发的具体步骤是什么？
Nginx 搭建 Tomcat 集群的核心配置应该怎么写？
#### 负载均衡算法
```markdown
轮询
加权轮询
随机算法
一致性Hash
```
#### 常见的限流算法
```markdown
常见的限流算法有计数器、漏桶和令牌桶算法。
    漏桶算法在分布式环境中消息中间件或者Redis都是可选的方案。
    发放令牌的频率增加可以提升整体数据处理的速度，而通过每次获取令牌的个数增加或者放慢令牌的发放速度和降低整体数据处理速度。
    而漏桶不行，因为它的流出速率是固定的，程序处理速度也是固定的。
```
### Netty
[Netty面试题（2020最新版）](https://blog.csdn.net/ThinkWon/article/details/104391081)
```markdown
说下Netty，bio、nio、aio区别，select、poll、epoll区别，什么是零拷贝机制。
```
## 七, 消息队列
### 消息队列的使用场景
[消息队列的使用场景](https://blog.csdn.net/fygu18/article/details/80863596)
```markdown
1.异步处理
    如用户注册后，需要发注册邮件和注册短信。传统的做法有两种：串行的方式和并行方式
    注册邮件，发送短信写入消息队列后，直接返回，因此写入消息队列的速度很快，基本可以忽略，因此用户的响应时间可能是50毫秒。
    因此架构改变后，系统的吞吐量提高到每秒20QPS。比串行提高了3倍，比并行提高了两倍！
2.应用解耦
    场景说明：用户下单后，订单系统需要通知库存系统。传统的做法是，订单系统调用库存系统的接口。
    传统模式的缺点：
    假如库存系统无法访问，则订单减库存将失败，从而导致订单失败，订单系统与库存系统耦合。
    引入消息队列后
    订单系统：用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户订单下单成功
    库存系统：订阅下单的消息，采用拉/推的方式，获取下单信息，库存系统根据下单信息，进行库存操作
    假如：在下单时库存系统不能正常使用。也不影响正常下单，因为下单后，订单系统写入消息队列就不再关心其他的后续操作了。实现订单系统与库存系统的应用解耦。
3.流量削锋
    应用场景：秒杀活动，一般会因为流量过大，导致流量暴增，应用挂掉。为解决这个问题，一般需要在应用前端加入消息队列。
    可以控制活动的人数，可以缓解短时间内高流量压垮应用。
4.日志处理
    是指将消息队列用在日志处理中，比如Kafka的应用，解决大量日志传输的问题
5.消息通讯
    消息通讯是指，消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等。
    比如说交易系统下订单后可以通过Kafka去通知其他的系统如广告系统、推荐系统等
    Kafka采用发布订阅模型就是设计模式中的观察者模型
    发布订阅模型（Pub-Sub）使用主题（Topic）作为消息通信载体，类似于广播模式；发布者发布一条消息，该消息通过主题传递给所有的订阅者，在一条消息广播之后才订阅的用户则是收不到该条消息的。
```
### kafka
```markdown
Kafka 选主怎么做的？
kafka如何保证生产与消费都是同步的？
kafka 怎么保证不丢消息的
1. Kafka的特性？
2. Kafka中的分区器、序列化器、拦截器是否了解？它们之间的处理顺序是什么？
3. 消费者重平衡（高可用性、伸缩性）
4. 那些情景下会造成消息漏消费？
5. 如何保证消息不被重复消费（幂等性）
6. KafkaConsumer是非线程安全的，那么怎么样实现多线程消费？
7. Kafka生产者客户端中使用了几个线程来处理？分别是什么？
8. 消费者与生产者的工作流程：
9. topic的分区数可不可以增加？
Kafka、RabbitMQ、RocketMQ区别，为什么RabbitMQ时延最低，知道事务消息吗。
Kafka生产者、消费者、协调者、服务端工作机制，描述数据从生产端到消费端到过程。
如果出现数据丢失或者数据重复消费如何处理。
Kafka为什么高吞吐量。
Kafka是如何实现exactly once语义的。
让你设计一个消息队列，你会怎么设计。
```
#### Kafka的文件存储机制
```markdown
Kafka中消息是以topic进行分类的，生产者通过topic向Kafka broker发送消息，消费者通过topic读取数据。
    然而topic在物理层面又能以partition为分组，一个topic可以分成若干个partition。partition还可以细分为segment，
    一个partition物理上由多个segment组成，segment文件由两部分组成，分别为“.index”文件和“.log”文件，分别表示为segment索引文件和数据文件。
    这两个文件的命令规则为：partition全局的第一个segment从0开始，后续每个segment文件名为上一个segment文件最后一条消息的offset值。
```
#### Kafka 如何保证可靠性
```markdown
如果我们要往Kafka对应的主题发送消息，我们需要通过Producer完成。前面我们讲过Kafka主题对应了多个分区，每个分区下面又对应了多个副本；
    为了让用户设置数据可靠性，Kafka在Producer里面提供了消息确认机制。也就是说我们可以通过配置来决定消息发送到对应分区的几个副本才算消息发送成功。
    可以在定义Producer时通过acks参数指定。这个参数支持以下三种值：
    1.acks=0：意味着如果生产者能够通过网络把消息发送出去，那么就认为消息已成功写入Kafka。
        在这种情况下还是有可能发生错误，比如发送的对象无能被序列化或者网卡发生故障，但如果是分区离线或整个集群长时间不可用，那就不会收到任何错误。
        在acks=0模式下的运行速度是非常快的（这就是为什么很多基准测试都是基于这个模式），你可以得到惊人的吞吐量和带宽利用率，不过如果选择了这种模式，一定会丢失一些消息。
    2.acks=1：意味若Leader在收到消息并把它写入到分区数据文件（不一定同步到磁盘上）时会返回确认或错误响应。
        在这个模式下，如果发生正常的Leader选举，生产者会在选举时收到一个LeaderNotAvailableException异常，如果生产者能恰当地处理这个错误，
        它会重试发送悄息，最终消息会安全到达新的Leader那里。不过在这个模式下仍然有可能丢失数据，比如消息已经成功写入Leader，但在消息被复制到follower副本之前Leader发生崩溃。
    3.acks=all（这个和request.required.acks=-1 含义一样）：意味着Leader在返回确认或错误响应之前，会等待所有同步副本都收到悄息。
        如果和min.insync.replicas参数结合起来，就可以决定在返回确认前至少有多少个副本能够收到悄息，生产者会一直重试直到消息被成功提交。
        不过这也是最慢的做法，因为生产者在继续发送其他消息之前需要等待所有副本都收到当前的消息。
```
#### Kafka消息是采用Pull模式，还是Push模式
```markdown
Kafka最初考虑的问题是，customer应该从brokes拉取消息还是brokers将消息推送到consumer，也就是pull还push。
    在这方面，Kafka遵循了一种大部分消息系统共同的传统的设计：
        producer将消息推送到broker，consumer从broker拉取消息。
    push模式下，当broker推送的速率远大于consumer消费的速率时，consumer恐怕就要崩溃了。
    最终Kafka还是选取了传统的pull模式。
    Pull模式的另外一个好处是consumer可以自主决定是否批量的从broker拉取数据。
    Pull有个缺点是，如果broker没有可供消费的消息，将导致consumer不断在循环中轮询，直到新消息到t达。
    为了避免这点，Kafka有个参数可以让consumer阻塞知道新消息到达。
```
#### Kafka是如何实现高吞吐率的
```markdown
1.顺序读写：kafka的消息是不断追加到文件中的，这个特性使kafka可以充分利用磁盘的顺序读写性能
2.零拷贝：跳过“用户缓冲区”的拷贝，建立一个磁盘空间和内存的直接映射，数据不再复制到“用户态缓冲区”
3.文件分段：kafka的队列topic被分为了多个区partition，每个partition又分为多个段segment，所以一个队列中的消息实际上是保存在N多个片段文件中
4.批量发送：Kafka允许进行批量发送消息，先将消息缓存在内存中，然后一次请求批量发送出去
5.数据压缩：Kafka还支持对消息集合进行压缩，Producer可以通过GZIP或Snappy格式对消息集合进行压缩
```
#### Kafka判断一个节点还活着的两个条件
```markdown
1.节点必须可以维护和ZooKeeper的连接，Zookeeper通过心跳机制检查每个节点的连接
2.如果节点是个follower,他必须能及时的同步leader的写操作，延时不能太久
```
## 八, 微服务项目实战相关
实际工作中 Spring 微服务项目的问题。
61. 谈谈你对微服务的理解。
62. 微服务分别有哪些优点，哪些缺点？
63. 谈谈微服务之间是如何实现通信的。
64. Spring Boot 如何集成 MyBatis？
65. Spring Boot 和 Spring Cloud 有哪些区别？
66. 使用 layui 的数据表格组件展示业务数据，后台实体类应该如何定义
67. JPA 和 Spring Data JPA 是一回事吗？
68. 如果要给项目添加权限管理系统，一般包含哪些需求？
69. 微服务架构的拆分都有哪些原则？
70. Feign 和 Ribbon+RestTemplate 的区别是什么？
描述一下rpc调用过程。
让你实现一个rpc框架，你会怎么做。
链路跟踪和熔断机制了解吗，框架层如何实现的。
了解哪些序列化协议，有什么区别，项目中用的是什么协议。
1.分布式事务的控制。
2.分布式锁如何设计。
3.分布式session如何设计。
4.dubbo的组件有哪些，各有什么作用。
5.zookeeper的负载均衡算法有哪些。

### Dubbo
>> 1.1 服务调用超时问题怎么解决？
    1.2 Dubbo支持哪些序列化方式？
    1.3 Dubbo和SpringCloud的关系？
    1.4 Dubbo的架构设计？一共划分了哪些层？
    1.5 Dubbo的默认集群容错方案？
    1.6 Dubbo使用的是什么通信框架?
    1.7 Dubbo的主要应用场景？
    1.8 Dubbo服务注册与发现的流程？流程说明。
    1.9 Dubbo的集群容错方案有哪些？
    1.10 Dubbo的四大组件
    1.11 Dubbo在安全机制方面是如何解决的
    1.12 Dubbo和SpringCloud的区别？
    1.13 Dubbo支持哪些协议，每种协议的应用场景，优缺点？
    1.14 Dubbo的核心功能有哪些？
    1.15 Dubbo的注册中心集群挂掉，发布者和订阅者之间还能通信么？
    1.16 Dubbo集群的负载均衡有哪些策略
    1.17 为什么需要服务治理？
    1.18 Dubbo超时时间怎样设置？
>> 6.dubbo是如何利用接口就可以通信的。
#### 1.Dubbo的容错机制
```markdown
1.失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过retries="2"来设置重试次数
2.快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。
3.失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。
4.失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。
5.并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过forks="2"来设置最大并行数。
6.广播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息
```
#### 2.Dubbo注册中心挂了还可以继续通信么
```markdown
可以，因为刚开始初始化的时候，消费者会将提供者的地址等信息拉取到本地缓存，所以注册中心挂了可以继续通信。
```
#### 3.Dubbo提供的线程池
```markdown
1.fixed：固定大小线程池，启动时建立线程，不关闭，一直持有。 
2.cached：缓存线程池，空闲一分钟自动删除，需要时重建。 
3.limited：可伸缩线程池，但池中的线程数只会增长不会收缩。(为避免收缩时突然来了大流量引起的性能问题)。
```
#### 4.Dubbo框架设计结构
```markdown
服务接口层：该层是与实际业务逻辑相关的，根据服务提供方和服务消费方的业务设计对应的接口和实现。
配置层：对外配置接口，以ServiceConfig和ReferenceConfig为中心，可以直接new配置类，也可以通过spring解析配置生成配置类。
服务代理层：服务接口透明代理，生成服务的客户端Stub和服务器端Skeleton，以ServiceProxy为中心，扩展接口为ProxyFactory。
服务注册层：封装服务地址的注册与发现，以服务URL为中心，扩展接口为RegistryFactory、Registry和RegistryService。可能没有服务注册中心，此时服务提供方直接暴露服务。
集群层：封装多个提供者的路由及负载均衡，并桥接注册中心，以Invoker为中心，扩展接口为Cluster、Directory、Router和LoadBalance。将多个服务提供方组合为一个服务提供方，实现对服务消费方来透明，只需要与一个服务提供方进行交互。
监控层：RPC调用次数和调用时间监控，以Statistics为中心，扩展接口为MonitorFactory、Monitor和MonitorService。
远程调用层：封将RPC调用，以Invocation和Result为中心，扩展接口为Protocol、Invoker和Exporter。Protocol是服务域，它是Invoker暴露和引用的主功能入口，它负责Invoker的生命周期管理。Invoker是实体域，它是Dubbo的核心模型，其它模型都向它靠扰，或转换成它，它代表一个可执行体，可向它发起invoke调用，它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。
信息交换层：封装请求响应模式，同步转异步，以Request和Response为中心，扩展接口为Exchanger、ExchangeChannel、ExchangeClient和ExchangeServer。
网络传输层：抽象mina和netty为统一接口，以Message为中心，扩展接口为Channel、Transporter、Client、Server和Codec。
数据序列化层：可复用的一些工具，扩展接口为Serialization、 ObjectInput、ObjectOutput和ThreadPool。
```

## 九, 系统设计
### 高并发系统的设计与实现
```markdown
在开发高并发系统时有三把利器用来保护系统：缓存、降级和限流。
    缓存：缓存比较好理解，在大型高并发系统中，如果没有缓存数据库将分分钟被爆，系统也会瞬间瘫痪。使用缓存不单单能够提升系统访问速度、提高并发访问量，
        也是保护数据库、保护系统的有效方式。大型网站一般主要是“读”，缓存的使用很容易被想到。在大型“写”系统中，缓存也常常扮演者非常重要的角色。
        比如累积一些数据批量写入，内存里面的缓存队列（生产消费），以及HBase写数据的机制等等也都是通过缓存提升系统的吞吐量或者实现系统的保护措施。
        甚至消息中间件，你也可以认为是一种分布式的数据缓存。
    降级：服务降级是当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行。
        降级往往会指定不同的级别，面临不同的异常等级执行不同的处理。根据服务方式：可以拒接服务，可以延迟服务，也有时候可以随机服务。
        根据服务范围：可以砍掉某个功能，也可以砍掉某些模块。总之服务降级需要根据不同的业务需求采用不同的降级策略。主要的目的就是服务虽然有损但是总比没有好。
    限流：限流可以认为服务降级的一种，限流就是限制系统的输入和输出流量已达到保护系统的目的。一般来说系统的吞吐量是可以被测算的，为了保证系统的稳定运行，
        一旦达到的需要限制的阈值，就需要限制流量并采取一些措施以完成限制流量的目的。比如：延迟处理，拒绝处理，或者部分拒绝处理等等。
```