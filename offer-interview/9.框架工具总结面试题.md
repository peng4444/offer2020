# 工具框架面试题
## Spring面试题
[Spring面试题（2020最新版）](https://thinkwon.blog.csdn.net/article/details/104397516)
### 0.对Spring的理解，项目中都用什么？怎么用的？对IOC、和AOP的理解及实现原理。
```markdown
Spring是一个开源框架，处于MVC模式中的控制层，它能应对需求快速的变化，其主要原因它有一种面向切面编程（AOP）的优势，其次它提升了系统性能，
通过依赖倒置机制（IOC），系统中用到的对象不是在系统加载时就全部实例化，而是在调用到这个类时才会实例化该类的对象，从而提升了系统性能。
这两个优秀的性能使得Spring受到许多J2EE公司的青睐，如阿里中使用最多的也是Spring相关技术。
Spring的优点：
    1、降低了组件之间的耦合性，实现了软件各层之间的解耦。
    2、可以使用容易提供的众多服务，如事务管理，消息服务，日志记录等。
    3、容器提供了AOP技术，利用它很容易实现如权限拦截、运行期监控等功能。
Spring中AOP技术是设计模式中的动态代理模式。只需实现jdk提供的动态代理接口InvocationHandler，所有被代理对象的方法都由InvocationHandler接管实际的处理任务。
面向切面编程中还要理解切入点、切面、通知、织入等概念。
Spring中IOC则利用了Java强大的反射机制来实现。所谓依赖注入即组件之间的依赖关系由容器在运行期决定。
其中依赖注入的方法有两种，通过构造函数注入，通过set方法进行注入。
```
### 1.什么是spring?
```markdown
Spring是一个轻量级Java开发框架，最早有Rod Johnson创建，目的是为了解决企业级应用开发的业务逻辑层和其他各层的耦合问题。
它是一个分层的JavaSE/JavaEE full-stack（一站式）轻量级开源框架，为开发Java应用程序提供全面的基础架构支持。
Spring负责基础架构，因此Java开发者可以专注于应用程序的开发。
Spring最根本的使命是解决企业级应用开发的复杂性，即简化Java开发。
Spring可以做很多事情，它为企业级开发提供给了丰富的功能，但是这些功能的底层都依赖于它的两个核心特性，也就是依赖注入（DI）和面向切面编程（AOP）。
为了降低Java开发的复杂性，Spring采取了以下4种关键策略
    - 基于POJO的轻量级和最小侵入性编程；
    - 通过依赖注入和面向接口实现松耦合；
    - 基于切面和惯例进行声明式编程；
    - 通过切面和模板减少样板式代码。
```
### 2.Spring框架的设计目标，设计理念，和核心是什么
```markdown
Spring设计目标：Spring为开发者提供一个一站式轻量级应用开发平台；
Spring设计理念：在JavaEE开发中，支持POJO和JavaBean开发方式，使应用面向接口开发，充分支持OO（面向对象）设计方法；
Spring通过IoC容器实现对象耦合关系的管理，并实现依赖反转，将对象之间的依赖关系交给IoC容器，实现解耦；
Spring框架的核心：IoC容器和AOP模块。通过IoC容器管理POJO对象以及他们之间的耦合关系；通过AOP以动态非侵入的方式增强服务。
IoC让相互协作的组件保持松散的耦合，而AOP编程允许你把遍布于应用各层的功能分离出来形成可重用的功能组件。
```
### 3.Spring的优缺点是什么？
```markdown
优点
    方便解耦，简化开发。Spring就是一个大工厂，可以将所有对象的创建和依赖关系的维护，交给Spring管理。
    AOP编程的支持。Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能。
    声明式事务的支持。只需要通过配置就可以完成对事务的管理，而无需手动编程。
    方便程序的测试。Spring对Junit4支持，可以通过注解方便的测试Spring程序。
    方便集成各种优秀框架。Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架的直接支持（如：Struts、Hibernate、MyBatis等）。
    降低JavaEE API的使用难度。Spring对JavaEE开发中非常难用的一些API（JDBC、JavaMail、远程调用等），都提供了封装，使这些API应用难度大大降低。
缺点
    - Spring明明一个很轻量级的框架，却给人感觉大而全
    - Spring依赖反射，反射影响性能
    - 使用门槛升高，入门Spring需要较长时间
```
### 4.什么是控制反转（IOC），什么是依赖注入（DI）？
```markdown
IOC（Inverse of Control:控制反转）是一种设计思想：就是将原本在程序中手动创建对象的控制权，交由Spring框架来管理。
IoC容器是Spring用来实现IoC的载体，IoC容器实际上就是个Map（key，value）,Map中存放的是各种对象。
BeanFactory接口是Spring Ioc容器的核心接口。
IoC最常见以及最合理的实现方式叫做依赖注入（Dependency Injection，简称 DI）。
    将对象之间的相互依赖关系交给Io 容器来管理，并由IoC容器完成对象的注入。
    这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 
    IoC容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。
IOC是实现方式优点：
    1. 对象之间的耦合度或者说依赖程度降低；
    2. 资源变的容易管理；比如你用Spring容器提供的话很容易就可以实现一个单例。
DI：我们在使用Spring容器的时候，容器通过调用set方法或者是构造器来建立对象之间的依赖关系。
控制反转是目标，依赖注入是我们实现控制反转的一种手段。
Java中实现依赖注入的三种方式？
    - 构造器注入
    - set方法注入
    - 接口注入
```
### 5.Spring有几种配置方式 ？
```markdown
1.基于XML文件的配置:这种配置文件的格式常用<beans>开头，然后运用一系列的bean定义和专门的应用配置选项组成。
    Spring XML配置方式是使用被Spring命名空间所支持的一些列XML的标签来实现的。
2.基于注解的配置:可以使用注解的方式来代替XML方式的bean元素的配置。这就是组件扫描，常用依赖注入的一些注解有：
@Controller @Service @Autowired @RequestMapping @RequestParam @ModelAttribute @Cacheable @CacheFlush @Resource 
@PostConstruct @PreDestroy @Repository @Scope @SessionAttributes @InitBinder @Required @Qualifier
3.组件扫描：容器会扫描base-package指定的包及其子包下面的所有类，如果该类有一些特定的注解，则纳入容器进行管理。
4.在类前面添加的一些特定的注解：@Component 通用注解 @Repository 持久层注解 @Service 业务层注解、 @Controller 控制层注解
5.基于Java的配置
```
### Spring动态代理(JDK 动态代理和 CGLIB 动态代理)
```markdown
AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，
    便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。
这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。
代理分为静态代理和动态代理，静态代理，顾名思义，就是你自己写代理对象，动态代理，则是在运行期，生成一个代理对象。
Spring AOP就是基于动态代理的，如果要代理的对象，实现了某个接口，那么Spring AOP会使用JDK Proxy，去创建代理对象，而对于没有实现接口的对象，
    就无法使用JDK Proxy去进行代理了，这时候Spring AOP会使用Cglib，这时候Spring AOP会使用Cglib生成一个被代理对象的子类来作为代理。
AOP 主要用来解决：在不改变原有业务逻辑的情况下，增强横切逻辑代码，根本上解耦合，避免横切逻辑代码重复
切 ：指的是横切逻辑，原有业务逻辑代码不动，只能操作横切逻辑代码，所以面向横切逻辑
面 ：横切逻辑代码往往要影响的是很多个方法，每个方法如同一个点，多个点构成一个面。这里有一个面的概念
@pointcut切点注解 可以设置拦截方式
```
### spring如何解决循环依赖？
### spring AOP的原理。
### spring的生命周期

## SpringMVC面试题
[Spring MVC面试题（2020最新版）](https://blog.csdn.net/ThinkWon/article/details/104397427)
###[springmvc的面试知识点总结](https://www.cnblogs.com/yunjiandubu/p/10269713.html)
#### 1.springmvc的工作流程?
![](https://upload-images.jianshu.io/upload_images/3975098-58f33691fab32bbe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
```markdown
1.请求过来之后,dispatcherServlet的url-pattern拦截请求;
2.判断在springmvc中是否存在对应映射;
3.若不存在,判断是否配置mvc:default-servlet-handler/;
4.如果配置,就会找到目标资源,没有则显示404页面;
5.如果映射存在,则由handlerMapping获handlerExecutionChain对象;(注意两点:
    ① handlerMapping定义了请求到处理器之间的映射,如果发送的请求是没有映射的,那么得到的handlerExecutionChain也不为空,
    而是默认的defaultServletHTTPRequestHandler,用来处理静态资源等(配置了default-servlet-handler,否则报为404);
    ② handlerExecutionChain实际上包含了拦截器和目标方法.)
6.获取HandlerAdapter对象;(包含表单类型的校验,数据类型的转换,格式换等功能)
7.调用 interceptor拦截器的preHandle方法;
8.调用目标方法;
9.调用拦截器的postHandle方法;
10.处理视图时候,观察是否存在异常,存在异常,则由HandlerExceptionResolver来处理异常,并得到新的ModelAndView对象;不存在异常,则由ViewResolver视图解析器来解析视图;
11.调用拦截器的afterComplettion方法;
```
[浅谈SpringMVC执行过程](https://www.cnblogs.com/wangjiming/p/10487832.html)
#### 2.springmvc dispatcherservlet与handleradapter如何关联？
```markdown
DispatcherServlet拦截到请求之后,根据handlerMapping获取到handlerExecutionChain对象,然后,
在handlerExecutionChain对象不为null的情况下,根据handlerExecutionChain中的handler对象获取HandlerAdapter对象;
```
#### 3.有了springmvc的IOC容器,还需要spring的IOC容器吗?为什么?如何处理兼容问题?
```markdown
这个问题再进一步,换个方式提问即是否还需要在web.xml方法里面配置启动springIOC容器的ContextLoaderListener?
可以从正反两方面来回答,首先是需要,通常情况下,类似于数据源,事务,整合其他框架等都是放在spring的配置文件中,而不是springmvc的配置文件中, 
一般情况下,开发过程中的Service,Dao也都是放在spring的IOC容器当中;其次可以是不需要的,也可以都放在springmvc的配置文件当中,
当然需要分多个spring的配置文件,然后通过import节点导入到springmvc的配置文件当中.
几点要注意的地方:
1. springIOC容器和springmvc的IOC容器 扫描的部分有重合的地方,就会导致bean被创建2次,解决方案:使用 exclude-filter和include-filter配合
    来区分哪些bean交给springIOC容器,哪些bean交给springmvcIOC容器;
2. springmvc IOC容器里面的bean可以引用springIOC容器的bean,反之则不行,多个springIOC 容器之间可以设置为父子关系,以实现良好的解耦.
举个栗子,springIOC容器好比是全局作用域,springmvcIOC容器好比是局部作用域,局部的可以引用全局的,而全局的却不能引用局部的.
```
#### 4.tomcat容器如何与springmvc的dispatcherservlet通信的？
```markdown
Apache Tomcat软件是JavaServlet，JavaServerPages，Java ExpressionLanguage和JavaWebSocket技术的开源实现,
SpringMVC则是spring推出的基于servlet标准的MVC框架实现,由此可知,SpringMvc和Tomcat 的结合点就是Servlet.SpringMVC的
DispatcherServlet继承了HttpServlet,那么对于tomcat来说,springmvc实际就是一个Servlet.
一个http请求的具体处理流程:
1. 用户向tomcat容器发送一个请求;
2. tomcat容器接收到请求之后,分析客户的请求信息;
3. tomcat创建一个Httprequest对象,将用户的请求信息封装到该对象中;
4. tomcat创建一个HttpResponse对象;
5. tomcat调用HttpServlet的Service方法,将Httprequest,HTTPResponse传递给Httpservlet对象;
6. HttpServlet调用HttpRequest对象的有关方法,获取Http请求信息,HttpServlet调用HttpResponse对象的有关方法，生成响应数据;
7. tomcat把HttpServlet的响应结果传给Web客户.
要注意的几点东西:
①:web.xml配置文件的作用其实就是配置http请求和servlet之间的映射关系,通过这个配置文件,Tomcat可以把请求转发给不同的servlet实例;
②:springmvc也是servlet标准的一个实现,所有的http请求都映射到DispatcherServlet上去,这个时候,请求就已经由Tomcat转发到springmvc框架中去了,
接着再由DispatcherServlet将请求转发到各个Controller当中去.
```

## SpringBoot面试题
[Spring Boot面试题（2020最新版）](https://blog.csdn.net/ThinkWon/article/details/104397299)
#### springboot启动流程讲讲？那spring启动流程讲讲？
## Mybatis面试题
[MyBatis面试题（2020最新版）](https://thinkwon.blog.csdn.net/article/details/101292950)
### 1.MyBatis是什么？
```markdown
MyBatis是一款优秀的持久层框架，一个半ORM（对象关系映射）框架，它支持定制化SQL、存储过程以及高级映射。
MyBatis避免了几乎所有的JDBC代码和手动设置参数以及获取结果集。MyBatis可以使用简单的XML或注解来配置和映射原生类型、接口和Java的POJO为数据库中的记录。
```
### 2.ORM是什么？
```markdown
ORM（Object Relational Mapping），对象关系映射，是一种为了解决关系型数据库数据与简单Java对象（POJO）的映射关系的技术。
简单的说，ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系型数据库中。
```
### 3.为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？
```markdown
Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。
而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。
```
### 4.传统JDBC开发存在的问题
```markdown
频繁创建数据库连接对象、释放，容易造成系统资源浪费，影响系统性能。可以使用连接池解决这个问题。但是使用jdbc需要自己实现连接池。
sql语句定义、参数设置、结果集处理存在硬编码。实际项目中sql语句变化的可能性较大，一旦发生变化，需要修改java代码，系统需要重新编译，重新发布。不好维护。
使用preparedStatement向占有位符号传参数存在硬编码，因为sql语句的where条件不一定，可能多也可能少，修改sql还要修改代码，系统不易维护。
结果集处理存在重复代码，处理麻烦。如果可以映射成Java对象会比较方便。
```
### 5.JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？
```markdown
1、数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库连接池可解决此问题。
解决：在mybatis-config.xml中配置数据链接池，使用连接池管理数据库连接。
2、Sql语句写在代码中造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。
解决：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。
3、向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。
解决：Mybatis自动将java对象映射至sql语句。
4、对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便。
解决：Mybatis自动将sql执行结果映射至java对象。
```
### 6.Mybatis优缺点
```markdown
优点：
    与传统的数据库访问技术相比，ORM有以下优点：
    基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML里，解除sql与程序代码的耦合，
        便于统一管理；提供XML标签，支持编写动态SQL语句，并可重用。
    与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接。
    很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持）
    提供映射标签，支持对象与数据库的ORM字段关系映射；提供对象关系映射标签，支持对象关系组件维护
    能够与Spring很好的集成。
缺点：
    SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求
    SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库
```
### 7.MyBatis的解析和运行原理
```markdown
MyBatis编程步骤是什么样的？
    1、 创建SqlSessionFactory
    2、 通过SqlSessionFactory创建SqlSession
    3、 通过sqlsession执行数据库操作
    4、 调用session.commit()提交事务
    5、 调用session.close()关闭会话       
请说说MyBatis的工作原理:
    1）读取MyBatis配置文件：mybatis-config.xml为MyBatis的全局配置文件，配置了MyBatis的运行环境等信息，例如数据库连接信息。
    2）加载映射文件。映射文件即SQL映射文件，该文件中配置了操作数据库的SQL语句，需要在MyBatis配置文件mybatis-config.xml中加载。
        mybatis-config.xml 文件可以加载多个映射文件，每个文件对应数据库中的一张表。
    3）构造会话工厂：通过MyBatis的环境等配置信息构建会话工厂SqlSessionFactory。
    4）创建会话对象：由会话工厂创建SqlSession对象，该对象中包含了执行SQL语句的所有方法。
    5）Executor执行器：MyBatis底层定义了一个Executor接口来操作数据库，它将根据SqlSession传递的参数动态地生成需要执行的 SQL语句，同时负责查询缓存的维护。
    6）MappedStatement对象：在Executor接口的执行方法中有一个MappedStatement类型的参数，该参数是对映射信息的封装，用于存储要映射的SQL语句的id、参数等信息。
    7）输入参数映射：输入参数类型可以是Map、List 等集合类型，也可以是基本数据类型和POJO类型。输入参数映射过程类似于JDBC对preparedStatement对象设置参数的过程。
    8）输出结果映射：输出结果类型可以是Map、List 等集合类型，也可以是基本数据类型和POJO类型。输出结果映射过程类似于JDBC对结果集的解析过程。
```
### 8.Mybatis都有哪些Executor执行器？它们之间的区别是什么？
```markdown
Mybatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。
SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。
ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，
    而是放置于Map<String, Statement>内，供下一次使用。简言之，就是重复使用Statement对象。
BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），
    它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。
作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内。
Mybatis中如何指定使用哪一种Executor执行器？
在Mybatis配置文件中，在设置（settings）可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法
传递ExecutorType类型参数，如SqlSession openSession(ExecutorType execType)。
配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（prepared statements）；BATCH 执行器将重用语句并执行批量更新。
```
### mybatis一级缓存和二级缓存【1+】
### mybatis怎么用的，为什么用mybatis，#，{}区别

## Netty面试题
[Netty面试题（2020最新版）](https://blog.csdn.net/ThinkWon/article/details/104391081)

##SpringCloud面试题
[Spring Cloud面试题（2020最新版）](https://blog.csdn.net/ThinkWon/article/details/104397367)

##
Spring框架
Spring框架用到了哪些设计模式。
Spring生命周期详细描述。
Spring是如何解决循环依赖的。
Spring扩展点有哪些，项目中是如何应用的。
Spring IOC、AOP描述。
Spring事务和MySQL事务的区别，Spring事务传播机制介绍，Spring事务失效和解决方案。
Spring全局异常捕获如何编写。
AOP动态代理实现：jdk动态代理和cglib实现差异，cglib性能为什么比jdk动态代理性能高，Fastclass机制描述下，哪些方法不能被动态代理。
AOP失效举例，为什么会失效，如何解决。
BeanFactory和FactoryBean的区别。
Spring创建了单例对象，如果多线程并发对属性赋值，造成相互覆盖的情况，如何处理。
SpringMVC和SpringBoot的区别。

### Tomcat的优化经验
```markdown
Tomcat作为Web服务器，它的处理性能直接关系到⽤户体验，下⾯是⼏种常⻅的优化措施:
    去掉对web.xml的监视，把jsp提前编辑成Servlet。
    有富余物理内存的情况，加⼤tomcat使⽤的jvm的内存。
    服务器资源 服务器所能提供CPU、内存、硬盘的性能对处理能⼒有决定性影响。
    对于⾼并发情况下会有⼤量的运算，那么CPU的速度会直接影响到处理速度。
    内存在⼤量数据处理的情况下，将会有较⼤的内存容量需求，可以⽤-Xmx -Xms -XX:MaxPermSize等参数对内存不同功能块进⾏划分。
    我们之前就遇到过内存分配不⾜，导致虚拟机⼀直处于full GC，从⽽导致处理能⼒严重下降。
    硬盘主要问题就是读写性能，当⼤量⽂件进⾏读写时，磁盘极容易成为性能瓶颈。
    最好的办法还是利⽤下⾯提到的缓存。利⽤缓存和压缩 对于静态⻚⾯最好是能够缓存起来，这样就不必每次从磁盘上读。
这⾥我们采⽤了Nginx作为缓存服务器，将图⽚、css、js⽂件都进⾏了缓存，有效的减少了后端tomcat的访问。 　　
另外，为了能加快⽹络传输速度，开启gzip压缩也是必不可少的。但考虑到tomcat已经需要处理很多东⻄了，所以把这个压缩的⼯作就交给前端的Nginx来完成。
除了⽂本可以⽤gzip压缩，其实很多图⽚也可以⽤图像处理⼯具预先进⾏压缩，找到⼀个平衡点可以让画质损失很⼩⽽⽂件可以减⼩很多。曾经我就⻅过⼀个图⽚从300多kb压缩到⼏⼗kb，⾃⼰⼏乎看不出来区别。
采⽤集群 单个服务器性能总是有限的，最好的办法⾃然是实现横向扩展，那么组建tomcat集群是有效提升性能的⼿段。
我们还是采⽤了Nginx来作为请求分流的服务器，后端多个tomcat共享session来协同⼯作。可以参考之前写的《利⽤nginx+tomcat+memcached组 建web服务器负载均衡》。
优化tomcat参数
这⾥以tomcat7的参数配置为例，需要修改conf/server.xml⽂件，主要是优化连接配置，关闭
客户端dns查询。
    <Connector port="8080" 
     protocol="org.apache.coyote.http11.Http11NioProtocol" 
     connectionTimeout="20000" 
     redirectPort="8443" 
     maxThreads="500" 
     minSpareThreads="20" 
     acceptCount="100"
     disableUploadTimeout="true"
     enableLookups="false" 
     URIEncoding="UTF-8" />
```

## 中间件面试题
### 7.消息中间件有过么？
### 8.rabbitMq和kafka区别聊聊，如何要确保数据不丢失，金融行业你该选什么消息中间件？
## 消息队列
```markdown
消息队列的使用场景 https://blog.csdn.net/fygu18/article/details/80863596
1.异步处理
    如用户注册后，需要发注册邮件和注册短信。传统的做法有两种：串行的方式和并行方式
    注册邮件，发送短信写入消息队列后，直接返回，因此写入消息队列的速度很快，基本可以忽略，因此用户的响应时间可能是50毫秒。
    因此架构改变后，系统的吞吐量提高到每秒20QPS。比串行提高了3倍，比并行提高了两倍！
2.应用解耦
    场景说明：用户下单后，订单系统需要通知库存系统。传统的做法是，订单系统调用库存系统的接口。
    传统模式的缺点：
    假如库存系统无法访问，则订单减库存将失败，从而导致订单失败，订单系统与库存系统耦合。
    引入消息队列后
    订单系统：用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户订单下单成功
    库存系统：订阅下单的消息，采用拉/推的方式，获取下单信息，库存系统根据下单信息，进行库存操作
    假如：在下单时库存系统不能正常使用。也不影响正常下单，因为下单后，订单系统写入消息队列就不再关心其他的后续操作了。实现订单系统与库存系统的应用解耦。
3.流量削锋
    应用场景：秒杀活动，一般会因为流量过大，导致流量暴增，应用挂掉。为解决这个问题，一般需要在应用前端加入消息队列。
    可以控制活动的人数，可以缓解短时间内高流量压垮应用。
4.日志处理
    是指将消息队列用在日志处理中，比如Kafka的应用，解决大量日志传输的问题
5.消息通讯
    消息通讯是指，消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等。
    比如说交易系统下订单后可以通过Kafka去通知其他的系统如广告系统、推荐系统等
    Kafka采用发布订阅模型就是设计模式中的观察者模型
    发布订阅模型（Pub-Sub）使用主题（Topic）作为消息通信载体，类似于广播模式；发布者发布一条消息，该消息通过主题传递给所有的订阅者，在一条消息广播之后才订阅的用户则是收不到该条消息的。
```
## kafka
```markdown
Kafka 选主怎么做的？
kafka如何保证生产与消费都是同步的？
kafka 怎么保证不丢消息的
1. Kafka的特性？

2. Kafka中的分区器、序列化器、拦截器是否了解？它们之间的处理顺序是什么？

3. 消费者重平衡（高可用性、伸缩性）

4. 那些情景下会造成消息漏消费？

5. 如何保证消息不被重复消费（幂等性）

6. KafkaConsumer是非线程安全的，那么怎么样实现多线程消费？

7. Kafka生产者客户端中使用了几个线程来处理？分别是什么？

8. 消费者与生产者的工作流程：

9. topic的分区数可不可以增加？
```

