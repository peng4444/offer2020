# 面试题总结
[一份超级详细的Java面试题【大厂面试真题+Java学习指南】](https://github.com/whx123/JavaHome)

[TOC]


## 一、Java基础
### 1.Java有哪些数据类型，分别占多少个字节？【1+】
```markdown
byte/8
char/16
short/16
int/32
float/32
long/64
double/64
boolean/~
boolean 只有两个值：true、false，可以使用1bit 来存储，但是具体大小没有明确规定。JVM会在编译时期将
boolean 类型的数据转换为int，使用1来表示true，0表示false。JVM支持boolean数组，但是是通过读写byte数组来实现的。
包装类型:基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。
缓存池:new Integer(123) 与 Integer.valueOf(123) 的区别在于：    
    new Integer(123) 每次都会新建一个对象；
    Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。
    valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。
    在 Java 8 中，Integer 缓存池的大小默认为 -128~127。
float与double：Java不能隐式执行向下转型，因为这会使得精度降低。
```
### 2.抽象类和接口的区别？普通类和抽象类有哪些区别？【2+】
```markdown
抽象类和普通类的唯一区别就在于是否实例化。
抽象类必须要有抽象方法吗？抽象类能使用final修饰吗？
     抽象类中可以有普通方法，也可以有抽象方法
     但是有抽象方法的类一定是抽象类，但是抽象类中不一定有抽象方法。
     abstract和final不共存，final不能继承
     abstract和static不共存 ，因为abstract不能修饰属性
```
### 1.Java中==与equals区别比较【2+】
```markdown
[听说你还搞不定java中的==和equals？](https://www.cnblogs.com/yichunguo/p/12383853.html)
==的作用是判断两个对象的值是否相等，即判断两个对象是不是同一个对象。
    基础数据类型==比较的是值，引用对象类型==比较的是内存地址。
equals()的作用也是判断两个对象是否相等，但是一般有两种情况：
    情况1：类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于==。
    情况2：类覆盖了equals()方法，用来比较对象的内容是否相等。
```
[为什么阿里巴巴Java开发手册中强制要求整型包装类对象值用equals方法比较？]( https://www.cnblogs.com/wupeixuan/p/11759459.html )
```java
public class test1 {
    public static void main(String[] args) {
        String a = new String("ab"); // a 为⼀个引⽤
        String b = new String("ab"); // b为另⼀个引⽤,对象的内容⼀样
        String aa = "ab"; // 放在常量池中
        String bb = "ab"; // 从常量池中查找
        if (aa == bb) // true
        System.out.println("aa==bb");
        if (a == b) // false，⾮同⼀对象
        System.out.println("a==b");
        if (a.equals(b)) // true
        System.out.println("aEQb");
        if (42 == 42.0) { // true
            System.out.println("true");
        }
    }
}
```
#### 1.1 所有整型包装类对象之间值的比较，全部使用equals方法比较。【阿里巴巴Java开发手册】
```markdown
在-128至127之间的赋值,Integer对象是在IntegerCache.cache产生，会复用已有对象，这个区间内的Integer值可以直接使用==进行判断，
    但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用equals方法进行判断。
```
#### 1.2 浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用equals来判断。
### 2.为什么重写equals时必须重写hashCode方法【3+】
```markdown
[HashCode()与equals()深入理解](https://www.cnblogs.com/moershiwei/p/12643626.html)
[听说你还搞不定java中的==和equals？](https://www.cnblogs.com/yichunguo/p/12383853.html)
HashCode()的作用是确定该对象在哈希表中的索引位置。
    1、如果两个对象equals为true ，他们的hashcode一定相等。
    2、如果两个对象equals为false，他们的hashcode有可能相等。
    3、如果两个对象hashcode相等，equals不一定为true。
    4、如果两个对象hashcode不相等，equals一定为false。
```
### 3.重载和重写的区别
```markdown
重写必须继承，重载不用。
重载表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数或类型不同）
重写表示子类中的方法与父类中的某个方法的名称和参数完全相同啦，通过子类实例对象调用这个方法时，将调用子类中的定义方法，
    这相当于把父类中定义的那个完全相同的方法给覆盖了，这是面向对象编程的多态性的一种表现。
重写的方法修饰符大于等于父类的方法，即访问权限只能比父类的更大，不能更小，而重载和修饰符无关。
重写覆盖的方法中，只能比父类抛出更少的异常，或者是抛出父类抛出的异常的子异常，因为不能坑爹啊哈哈~
```
### 4.拆箱和装箱分别是什么？分别应用在什么场景？
```markdown
拆箱和装箱：拆箱是把包装类型变成基本类型；装箱是把基本类型变成包装类型。
自动装箱都是通过包装类的valueOf()方法来实现的;自动拆箱都是通过包装类对象的xxxValue()来实现的（如booleanValue()、longValue()等）。
应用场景：当==两边是基本类型和包装类型的时候，包装类型会拆箱，然后==会比较基本类型的两个值；
当equals方法的参数是基本类型的时候，基本类型会装箱，然后equals方法会先比较两个包装类型的类型，在比较值。
```
#### 在使用三目运算符的过程中，可能会进行自动拆箱而导致NPE问题。【Java开发手册】
[我去，这么简单的条件表达式竟然也有这么多坑](https://www.cnblogs.com/goodAndyxublog/p/13047617.html)
```markdown
 boolean flag = true;
 boolean simpleBoolean = false;
 Boolean nullBoolean = null;
 boolean x = flag ? nullBoolean.booleanValue() : simpleBoolean;
反编译后的代码的最后一行，编译器帮我们做了一次自动拆箱，而就是因为这次自动拆箱，导致代码出现对于一个null对象nullBoolean.booleanValue()的调用，导致了NPE。
三目运算符当第二位和第三位操作数的类型相同时，则三目运算符表达式的结果和这两位操作数的类型相同。
当第二，第三位操作数分别为基本类型和该基本类型对应的包装类型时，那么该表达式的结果的类型要求是基本类型。
所以，Java开发手册中提到要高度注意第二位和第三位表达式的类型对齐过程中由于自动拆箱发生的NPE问题，
其实还需要注意使用三目运算符表达式给变量赋值的时候由于自动拆箱导致的NPE问题。
Boolean b = Boolean.valueOf(maps == null ? false : ((Boolean)maps.get("Hollis")).booleanValue());
```
### 5.抽象类和接口有什么区别
```markdown
- 抽象类要被子类继承，接口要被子类实现。
- 抽象类可以有构造方法，接口中不能有构造方法。
- 抽象类中可以有普通成员变量，接口中没有普通成员变量，它的变量只能是公共的静态的常量
- 一个类可以实现多个接口，但是只能继承一个父类，这个父类可以是抽象类。
- 接口只能做方法声明，抽象类中可以作方法声明，也可以做方法实现。
- 抽象级别（从高到低）：接口>抽象类>实现类。
- 抽象类主要是用来抽象类别，接口主要是用来抽象方法功能。
- 抽象类的关键字是abstract，接口的关键字是interface
```
### 6.String为什么不可变？
[Java源码之String](https://www.cnblogs.com/chentang/p/13067765.html)
```markdown
当然在Java平台类库中，包含许多不可变类，例如String , 基本类型的包装类，BigInteger, BigDecimal 等等。
类本身是final修饰的；所有的域几乎都是私有final的；不会对外暴露可以修改对象属性的方法。
String类并没有提供任何可以改变其值的方法。
使用什么方式可以改变String类的不可变性：**反射**
            String str = "chen";
            System.out.println(str);
            Field field = String.class.getDeclaredField("value");
            field.setAccessible(true);
            char[] value = (char[]) field.get(str);
            value[1] = 'a';
            System.out.println(str);
```
[String求求你别秀了](https://www.cnblogs.com/zhuoqingsen/p/String.html)
```markdown
String类有如下这些特点
    1.String类是final类，也即意味着String类不能被继承，并且它的成员方法都默认为final方法。
    2.String类其实是通过char数组来保存字符串的。
    3.String对象一旦被创建就是固定不变的了，对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象。
字符串常量池:
    1.每当我们创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么就直接返回常量池中的实例引用。
    如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中。由于String字符串的不可变性我们可以十分肯定常量池中一定不存在两个相同的字符串。
    2.字符串池的出现避免了相同内容的字符串的创建，节省了内存，省去了创建相同字符串的时间，同时提升了性能；
    另一方面，字符串池的缺点就是牺牲了JVM在常量池中遍历对象所需要的时间，不过其时间成本相比而言比较低。
1.单独使用""引号创建的字符串都是常量,编译期就已经确定存储到String Pool中；
2.使用new String("")创建的对象会存储到heap中,是运行期新创建的；
3.使用只包含常量的字符串连接符如"aa" + "aa"创建的也是常量,编译期就能确定,已经确定存储到String Pool中；
4.使用包含变量(引用)的字符串连接符如"aa" + s1创建的对象是运行期才创建的,存储在heap中；
5.但是如果s1是被final修饰的话，则s1是属于常量。结果存在String Pool，但是 final修饰的是一个方法返回的值也是在编译器确定。
String str1 = "aaa";
String str2 = "aaa";
System.out.println(str1 == str2);// true 因为String有常量池
String str3 = new String("aaa");
String str4 = new String("aaa");
System.out.println(str3 == str4);// false 可以看出用new的方式是生成不同的对象,比较堆上的
System.out.println(str3.equals(str4)); // true equals()比较值
String s0="helloworld";  
String s1="helloworld";  
String s2="hello"+"world";  
System.out.println(s0==s1); //true 可以看出s0跟s1是指向同一个对象   
System.out.println(s0==s2); //true 可以看出s0跟s2是指向同一个对象   
String st0="helloworld";   
String st1=new String("helloworld");   
String st2="hello" + new String("world");   
System.out.println( st0==st1 ); //false    用new String() 创建的字符串不是常量，不能在编译期就确定
System.out.println( st0==st2 ); //false   st2地址存在堆中，不可能相同
System.out.println( st1==st2 ); //false  
String stri1="abc";     
String stri2="def";     
String stri3=stri1+stri2;  
System.out.println(stri3=="abcdef"); //false    变量相+是在的堆内存中创建
String strin0 = "a1";   
String strin1 = "a" + 1;   //这种不是变量，是常量
System.out.println((strin0 == strin1)); //result = true    
String strin4 = "a3.4";   
String strin5 = "a" + 3.4;   
System.out.println((strin4 == strin5)); //result = true  
String string0 = "ab";   
String string1 = "b";   
String string2 = "a" + string1;   
System.out.println((string0 == string2)); //result = false  在字符串的"+"连接中，有字符串引用存在，而引用的值在程序编译期是无法确定的
```
### 7.String str="abc" 与 String str=new String (“abc”) 一样吗？为什么？
```markdown
1.使用String直接赋值：String str= “abc”：可能创建一个或者不创建对象。如果”abc”在字符串常量池中不存在，会在java字符串池中创建一个String对象（”abc”），
然后str指向这个内存地址，无论以后用这种方式创建多少个值为”abc” 的字符串对象，始终只有一个内存地址被分配；如果 “abc” 在字符串池中存在，str直接指向这个内存地址。
2.使用new String创建字符串：String str = new String(“abc”)：至少会创建一个对象，也有可能创建两个。因为用到new关键字，肯定会在堆中创建一个String对象，
如果字符池中已经存在”abc”, 则不会在字符串池中创建一个String对象，如果不存在，则会在字符串常量池中也创建一个对象。注意，此时二者地址不相同。
3.String拼接字符串：字符串拼接又分为变量拼接和已知字符串拼接。只要拼接内容存在变量，那么该拼接后的新变量就是在堆内存中新建的一个对象实体。但是不会在字符常量池中创建新对象。
4.String.intern()：当调用intern方法时，如果常量池已经包含一个等于此String对象的字符串（用equals(Object)方法确定），则返回池中的字符串。
否则，将此String对象添加到常量池中，并返回此String对象的引用。
String str=“abc” 和 String str=new String(“abc”); 产生几个对象？String str = new String("hello")+new String("123");产生了几个对象？
前者 1 或 0， 后者 2 或 1，最后一个是 3 或 4 或 5
先看字符串常量池，如果字符串常量池中没有，都在常量池中创建一个，如果有，前者直接引用，后者在堆内存中还需创建一个 “abc” 实例对象。
字符常量池的位置？字符常量池存储的内容？
字符串常量池的位置，jdk1.7从方法区移至堆中。
字符串常量池存储的是字符串字面量（注意，这里的字面量指的就是String的对象，因为String本身是一个类，而字符常量池在jdk8放在堆中，所以存储的内容全都是对象）
```
### 8.String，Stringbuffer，StringBuilder的区别
[一篇与众不同的String、StringBuilder和StringBuffer详解](https://www.cnblogs.com/cxuanBlog/p/13053615.html)
```markdown
String：
    String是final类，不能被继承。String类是一个不可变的类，一旦创建就不可以修改。
    String实现了equals()方法和hashCode()方法。
StringBuffer：
    继承自AbstractStringBuilder，是可变类。
    StringBuffer是线程安全的，对方法加了同步锁或者对调用的方法加了同步锁。(synchronized)
    可以通过append方法动态构造数据。执行效率比StringBuffer低。
StringBuilder：
    继承自AbstractStringBuilder，是可变类。
    StringBuilder是非线性安全的。
    执行效率比StringBuffer高。
```
### 9.给定三个变量：i1、i2、i3。Integer i1= 120；Integer i2=120；int i3=120；i1和i2一样吗？i1和i3 呢？为什么？如果把120换成130呢，i1,12,i3的关系又如何，为什么？
```markdown
integer包装类和其他包装类不同之处，对于范围在-128到127之间的整数，integer创建对象的时候是直接从缓存读取的，这个时候直接从缓存得的的内容地址是保持一致的，
所以两个integer对象地址是相同的，但是不在这个范围的时候，地址就不在相同的。
对于integer变量和int变量，通过==比较，符合拆箱应用场景，integer会直接拆箱，所以无论什么范围，integer和int，都是直接比较值的。
1.两个基本类型的只能用 ==
2.基本型和封装型用==，封装型将会自动拆箱变为基本型后再进行比较
3.用==来比较两个封装类的话，比较的是地址。(其中-127到127之间的Integer地址相同，超出这个范围则不同)
4.至少有一个封装型的建议使用.equals。用==对基本型和封装性比较必须保证封装型不为null。如果为null则不能转化为基本型就会报错。
5.两个封装型进行equals()比较，首先equals()会比较类型，如果类型相同，则继续比较值，如果值也相同，返回true
6.封装类型调用equals(),但是参数是基本类型，这时候，先会进行自动装箱，基本型转换为其封装类型,若类型不同返回false,若装箱后类型相同，则比较值，如果值相同，则返回true
```
### 关键字static
>>  如果你答出static修饰变量、修饰方法我会认为你合格，答出静态块，我会认为你不错，
    答出静态内部类我会认为你很好，答出静态导包我会对你很满意，满意的原因是能看出你确实非常热衷研究技术。
```markdown
static是Java中非常重要的关键字，static表示的概念是静态的，在Java中，static主要用来
    static修饰变量，static修饰的变量称为静态变量、也称为类变量，类变量属于类所有，对于不同的类来说，static变量只有一份，
        static修饰的变量位于方法区中；static 修饰的变量能够直接通过 类名.变量名来进行访问，不用通过实例化类再进行使用。
        一旦属性定义上使用了static之后，只要一个对象修改了属性的内容，那么所有的对象的static属性的内容都将一起修改，
        也就是说static属性变成了一个公共属性，是全局数据区。
        （static声明的属性与普通属性的最大区别是保存的内存区域的不同，还有就是static属性在没有实例化的情况下可以使用）
    static修饰方法，static修饰的方法被称为静态方法，静态方法能够直接通过类名.方法名来使用，在静态方法内部不能使用非静态属性和方法。
        静态方法不需要创建对象就可以调用。
        static方法不能直接访问非static属性或者方法（必须要产生对象后才能调用），非static方法可以直接访问static属性或者方法
    static修饰代码块，主要分为两种，一种直接定义在类中，使用static{}，这种被称为静态代码块，一种是在类中定义静态内部类，使用static class xxx来进行定义。
    static用于静态导包，通过使用 import static xxx 来实现，这种方式一般不推荐使用
    static和单例模式一起使用，通过双重检查锁来实现线程安全的单例模式。

```
### 关键字final
[我去，你竟然还不会用 Java final 关键字](https://www.cnblogs.com/qing-gee/p/13092011.html)
```markdown
final修饰类：如果一个类使用了final关键字修饰，那么它就无法被继承。
final修饰方法：被final修饰的方法不能被重写。
final修饰变量：被final修饰的变量无法重新赋值。
    1）final修饰的基本数据类型，对于基本数据类型来说，final 修饰的变量，其值不能被改变。
    2）final修饰的引用类型    
    3）final修饰的字段，一种是static的，另外一种是没有static的。
        非static的final字段必须有一个默认值，否则编译器将会提醒没有初始化。
        static的final字段也叫常量，它的名字应该为大写，可以在声明的时候初始化，也可以通过static代码块初始化。
    4) final修饰的参数
        final关键字还可以修饰参数，它意味着参数在方法体内不能被再修改。
```
### 10.throw和throws的区别？
```markdown
throws声明：
如果一个方法内部的代码会抛出检查异常(checked exception)而方法自己又没有完全处理掉，则javac保证你必须在方法的签名上使用throws关键字声明这些可能抛出的异常，否则编译不通过。
throws是另一种处理异常的方式，它不同于 try…catch…finally，throws仅仅是将函数中可能出现的异常向调用者声明，而自己则不具体处理。
throw异常抛出语句：
程序员也可以通过throw语句手动显式的抛出一个异常。throw语句的后面必须是一个异常对象。
throw语句必须写在函数中，执行throw语句的地方就是一个异常抛出点，它和由 JRE自动形成的异常抛出点没有任何差别。
在异常处理中，try语句要捕获的是一个异常对象，那么此异常对象也可以自己抛出。
    try-catch-finally 中哪个部分可以省略？finally 可以省略，其他都不可以省略
    try-catch-finally中，如果catch中return了，finally 还会执行吗？
在try块中即便有return，break，continue等改变执行流的语句，finally也会执行。try…catch…finally中的return只要能执行，就都执行了，他们共同向同一个内存地址
（假设地址是 0×80）写入返回值，后执行的将覆盖先执行的数据，而真正被调用者取的返回值就是最后一次写入的。finally中的return会覆盖try或者catch中的返回值。
finally中的return和方法的return不能共存，因为finally是异常处理的最后执行的部分，finally必定执行，内部的return跟方法最后的return存在冲突。
```
### 11.常见的异常类有哪些？java异常的执行流程？
```markdown
error错误类：NoClassDefFoundError、StackOverFlowError、OutOfMemoryError。
exception类：IOException（FileNotFindException）、RuntimeException（NullPointException）
在Java应用程序中，异常处理机制为：抛出异常，捕捉异常。
抛出异常：当一个方法出现错误引发异常时，方法创建异常对象并交付运行时系统，异常对象中包含了异常类型和异常出现时的程序状态等异常信息。
运行时系统负责寻找处置异常的代码并执行。
捕捉异常：在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器（exceptionhandler）。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。
当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适的异常处理器。运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常
处理器的方法并执行。当运行时系统遍历调用栈而未找到合适的异常处理器，则运行时系统终止。同时，意味着Java程序的终止。
```
### 12.NoClassDefFoundError 和 ClassNotFoundException 区别
[聊聊面试-NoClassDefFoundError 和 ClassNotFoundException 区别](https://www.cnblogs.com/xiao2shiqi/p/11740563.html)
```markdown
NoClassDefFoundError 是一种 Error，Error 在大多数情况下代表无法从程序中恢复的致命错误，产生的原因在于 JVM 或者 ClassLoader
在运行时类加载器在 classpath 下找不到需要的类定义（编译期是可以正常找到的，所以和 ClassNotFoundException 不同的是这是
一个运行期的 Error），这个时候虚拟机就会抛出 NoClassDefFoundError，通常造成该 ERROR 的原因是打包过程中漏掉了部分类，
或者 jar 包出现损坏或篡改，对应的 Class 在 classpath 中不可用等等原因。
ClassNotFoundException 是属于 Exception 的运行时异常，大多是可以从代码中恢复的异常类型，导致该异常的原因大多是因为使用 
Class.forName() 方法动态的加载类信息，但是这个类在类路径中并没有被找到，那么就会在运行时抛出 ClassNotFoundException
以上是大致的 NoClassDefFoundError 和 ClassNotFoundException 的区别，
那么延伸一下可以探讨 Java 类型体系中的 Error 和 Exception
```
### 13.Error和Exception的区别
```markdown
Throwable是Java语言中所有错误或异常的超类。下一层分为Error和Exception。
Error和Exception都是继承Throwable类，它们体现Java设计者在对异常的不同情况所进行的分类处理，
在Java中只有Throwable类的实例才能被try/catch捕获或者声明抛出。
Error在大多数情况下代表程序出现了致命并且不可恢复的错误，它们大多都是不可预测的错误，不需要也不能捕获和抛出，
    例如常见的OutOfMemeryError，StackOverFlowError，还有本文提到的 NoClassDefFoundError，他们都是Error的子类。
Exception属于程序错误，大多是人为编码所导致的，它们大多都可以预测，也可以通过程序处理让程序正常流程，所以是需要进行捕获（try/catch）或者声明抛出（throw）的，
    Exception还分两种情况，可检查异常checked exception（编译期异常），非检查异常unchecked exception（运行期异常）
常见的RuntimeException异常：
    - NullPointerException 空指针异常
    - ArithmeticException 出现异常的运算条件时，抛出此异常
    - IndexOutOfBoundsException 数组索引越界异常
    - ClassNotFoundException 找不到类异常
    - IllegalArgumentException(非法参数异常)
常见的 Checked Exception 异常：
    - IOException (操作输入流和输出流时可能出现的异常)
    - ClassCastException(类型转换异常类)
```
### 14.final, finally, finalize的区别
```markdown
final用于修饰属性,方法和类, 分别表示属性不能被重新赋值, 方法不可被覆盖, 类不可被继承。
finally是异常处理语句结构的一部分，一般以ty-catch-finally出现，finally代码块表示总是被执行。
finalize是Object类的一个方法，该方法一般由垃圾回收器来调用，当我们调用System.gc()方法的时候，
    由垃圾回收器调用finalize()方法，回收垃圾，JVM并不保证此方法总被调用。
```
### 15.try-catch-finally 语法块的执行顺序等问题
>>  [try、catch、finally语句中有return的各类情况](https://www.cnblogs.com/yychuyu/p/13199329.html)
```markdown

```
### 15.设计模式
#### 1.熟悉的设计模式
>> 单例模式，工厂模式，代理模式
#### 2.单例模式
[【极客思考】设计模式：你确定你真的理解了单例模式吗？](https://www.cnblogs.com/huaweiyun/p/12973585.html)
```markdown
一、双重校验锁（DCL） 1.如果不用volatile修饰会怎么样？2.volatile作用是啥？
二、静态内部类
三、枚举
单例模式真的有那么好吗？
    优点：
    1.提供了唯一实例的受控访问。
    2.因为只有一个实例，节约了系统资源，提高系统性能。
    缺点：
    1.单例模式没有抽象层，扩展比较困难。
    2.单例类的职责过重，违背了“单一职责原则”。
四、通过Spring实现的单例。
设计模式的单例是在整个Java应用中只有一个实例，而Spring中的单例是在一个IOC容器中就只有一个单例。
但对于web应用来说，web容器（Jetty或tomcat）对用户的每个请求都会创建一个单独的servlet线程去处理请求，
Spring框架下的接口每个action也都是单例的，那么其实就保证了我们使用的是一个实例。
同时Spring也支持我们通过注解或者xml进行lazy-init，也可以指定scope确定其是否为全局单例，又或者是多个实例，对于程序来说有了更多的选择。
```
[对于单例模式面试官会怎样提问呢？你又该如何回答呢？](https://www.cnblogs.com/Ccwwlx/p/13053922.html)
#### 3.代理模式有什么用？应用场景是什么？
```markdown
代理（Proxy）模式是结构型的设计模式之一，它可以为其他对象提供一种代理（Proxy）以控制对这个对象的访问。
所谓代理，是指具有与被代理的对象具有相同的接口的类，客户端必须通过代理与被代理的目标类交互。
应用场景：
     需要控制对目标对象的访问。
     需要对目标对象进行方法增强。如：添加日志记录，计算耗时等。
     需要延迟加载目标对象。
实现动态代理的两种方式：JDK动态代理和Gglib动态代理
     JDK动态代理是实现了被代理对象的接口，Cglib是继承了被代理对象。
     JDK和Cglib都是在运行期生成字节码，JDK是直接写Class字节码，Cglib使用ASM框架写Class字节码，Cglib代理实现更复杂，生成代理类比JDK效率低。
     JDK调用代理方法，是通过反射机制调用，Cglib是通过FastClass机制直接调用方法，Cglib执行效率更高。
动态代理是什么？与静态代理的区别在于？
Java中的静态代理要求代理主题 (ProxySubject)和真实主题(RealSubject)都实现同一个接口(Subject)。静态代理中代理类在编译期就已经确定，
而动态代理则是JVM运行时动态生成，静态代理的效率相对动态代理来说相对高一些，但是静态代理代码冗余大，一但需要修改接口，代理类和委托类都需要修改。
```
#### 4.简单工厂和抽象工厂有什么区别？
```markdown
工厂模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类
抽象工厂模式：为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类
```
#### 5.装饰者模式和适配器模式以及代理模式的区别？
```markdown
装饰者和代理模式的区别
 装饰者模式关注的是对象的动态添加功能。代理模式关注的是对对象的控制访问，对它的用户隐藏对象的具体信息。
装饰者模式和适配器模式
 装饰者模式和被装饰的类要实现同一个接口，或者装饰类是被装饰的类的子类。适配器模式和被适配的类具有不同的接口。
 适配器模式被用于桥接两个接口，而装饰模式的目的是在不修改类的情况下给类增加新的功能。
```
#### 6.JDK 库中使用的设计模式？
```markdown
装饰器设计模式（Decorator design pattern）被用于多个Java IO类中。
单例模式（Singleton pattern）用于Runtime，Calendar 和其他的一些类中。
工厂模式（Factory pattern）被用于各种不可变的类如Boolean，像Boolean.valueOf，
观察者模式（Observer pattern）被用于Swing和很多的事件监听中。
```
[谈谈Java常用类库中的设计模式 - Part Ⅰ](https://www.cnblogs.com/notayeser/p/12917516.html)
```markdown

```
### 16.生产者消费者模式
[生产者消费者模型在项目中的实际应用](https://www.cnblogs.com/0813lichenyu/p/11599421.html)
### 17.jdk1.8新增的变化
[关于Java8的精心总结](https://www.cnblogs.com/yychuyu/p/13332293.html)
```markdown
新特性：
    接口增强，使用default与static在接口中定义方法
    lambda表达式
    方法引用
    内建函数式接口
方法函数变化：    
    Hashmap 红黑树，扩容
    concurrentHashmap 红黑树，进一步减少锁的粒度
    Jvm常量池的变化，字符常量池在jdk1.7从方法区脱离放入堆中，方法区则在jdk1.8中变成元空间。
```


## 四、Java容器集合
### 1.ArrayList不是线程安全的 & CopyOnWriteArrayList解决
[浅析CopyOnWriteArrayList](https://www.cnblogs.com/zengcongcong/p/12754067.html)
#### 代码演示ArrayList线程不安全
```java
public class ArrayListDemo{
    public static void main(String[] args){
        List<String> list = new ArrayList<>();
        List<String> vector = new Vector<>();
        List<String> synchronizedList = Collections.synchronizedList(new ArrayList<>());
        List<String> copyOnWriteArrayList = new CopyOnWriteArrayList<>();
        
        //多个线程调用list 出现java.util.ConcurrentModificationException
        for(int i = 1;i<=30;i++){
            new Thread(()->{
                list.add((UUID).randomUUID().toString().substring(0,8));
                System.out.println(list);
            },String.valueOf(i)).start();
        }
    }
    
    //1.故障现象：java.util.ConcurrentModificationException
    //2.导致原因：
    //3.解决方案：
        //1.使用Vector类，Vector的add方法被synchronized修饰,不介意使用。
        //2.使用Collections.synchronizedList(new ArrayList<>());
        //3.CopyOnWriteArrayList类,写时复制。读写分离的思想。
    //4.优化建议：
}
```
#### ArrayList线程不安全原因和解决方式。
```markdown
1.为什么ArrayList不是线程安全的？
    并发争抢修改导致，参考花名册签到情况。
    一个人正在写入，另外一个同学过来抢夺，导致数据不一致异常。并发修改异常。
    所有的java.util包中的集合类都被设计为fail-fast，由于fail-fast机制的存在，抛出了modcount修改异常的错误ConcurrentModificationException 
    (modcount是ArrayList源码中的一个变量，用来表示修改的次数，因为ArrayList不是为并发情况而设计的集合类）
2.解决办法：
    1.可以使用Vector集合，Vector集合是线程安全版的ArrayList，其方法都上了一层synchronized进行修饰，
    采取jvm内置锁来保证其并发情况下的原子性、可见性、有序性。但同时也带来了性能问题，因为synchronized一旦膨胀到重量级锁，
    存在用户态到和心态的一个转变，多线程的上下文切换会带来开销。另一个问题是Vector集合的扩容没有ArrayList的策略好。
    2.使用Collections.synchronizedList()，在更新操作中使用了同步锁。
    3.采用JUC提供的并发容器，CopyOnWriteArrayList。
3.CopyOnWriteArrayList
    和ArrayList一样，其底层数据结构也是数组，加上transient不让其被序列化，加上volatile修饰来保证多线程下的其可见性和有序性。
    CopyOnWriteArrayList在更新操作中不仅使用了可重入锁，而且还需要进行数组的复制。
    CopyOnWriteArrayList适合于多线程场景下使用，其采用读写分离的思想，读操作不上锁，写操作上锁，且写操作效率较低。
    CopyOnWriteArrayList基于fail-safe机制，每次修改都会在原先基础上复制一份，修改完毕后在进行替换。
    CopyOnWriteArrayList的add()方法采用的是ReentrantLock进行上锁。
```
#### HashSet和HashMap线程不安全
```markdown
原理同ArrayList;
HashSet解决方案:Collections.synchronizedSet()，CopyOnWriteHashSet
HashMap解决方案：Collections.sychronizedMap()，ConcurrentHashMap。
```
### 2.[不可错过的java面试博客之java集合篇](https://www.cnblogs.com/jichi/p/12834238.html)
#### 2.1 List及ArrayList、Vector、LinkedList
```markdown
1.List是无序的Collection，List一共三个实现类：分别是ArrayList、Vector和LinkedList
    1.1：ArrayList通过数组实现的，允许对元素进行快速随机访问。缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，
        就要将已经有数组的数据复制到新的存储空间中。当从中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。
        适合随机查找和遍历，不适合插入和删除。排列有序，可重复，容量不够的时候，当前容量*1.5倍。(默认容量为10)
    1.2：Vector与ArrayList一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，
        但实现同步需要很高的花费(synchronized锁)，因此，访问它比访问ArrayList慢。(默认容量为10)默认扩展一倍容量。
    1.3：LinkedList是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。还提供了List接口中没有定义的方法，
        专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。底层使用双向循环链表数据结构。线程不安全。
        将LinkedList替换成ConcurrentLinkedQueue实现线程安全。
```
#### 2.2 Set
```markdown
1.Set是存储有序(存入和取出的顺序不一定相同)元素，值不能重复。
    1.1：HashSet（Hash表）value值为一个相同的object对象的HashMap，值存入HashMap的key。
    1.2:TreeSet（二叉树） 有序存储 每增加一个对象都会进行排序
    1.3:LinkHashSet（HashSet+LinkedHashMap）
```
#### 2.3 Map
```markdown
1.Map
    1.1：HashMap（数组+链表+红黑树）根据键的hashCode值存储数据,大多数情况下可以直接定位到它的值，具有很快的访问速度，
          但遍历顺序却是不确定的。HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全。  
          可以用Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。默认大小是16。
    1.2：ConcurrentHashMap和HashMap思路是差不多的，但是因为它支持并发操作，线程安全。分段锁Segment继承ReentrantLock加锁
        ConcurrentHashMap是多个Segment数组，Segment通过继承ReentrantLock来进行加锁，所以每次需要加锁的操作锁住的是一个segment，
        这样只要保证每个Segment是线程安全的，也就实现了全局的线程安全。默认大小是16。
    1.3：HashTable（线程安全synchronized锁）是遗留类，并发性不如ConcurrentHashMap。
        HashTable不允许<键,值>有空值，HashMap允许<键,值>有空值。HashTable使用Enumeration，HashMap使用Iterator。
    1.4：TreeMap（可排序）实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序。
    1.5：LinkHashMap（记录插入顺序）是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历
         LinkedHashMap如何保证有序性:继承自HashMap，内部增加了head tail 和access order。
    1.6：HashTable中hash数组的默认大小是11，增加方式的old*2+1，HashMap中hash数组的默认大小是16，增长方式一定是2的指数倍。
        父类不同：HashMap继承了AbstractMap类，而HashTable继承了Dictionary类
```
#### 2.4 HashMap扩容机制算法
```markdown
HashMap的初始容量16，加载因子为0.75，扩容增量是原容量的1倍。如果HashMap的容量为16，一次扩容后容量为32。
HashMap扩容是指元素个数（包括数组和链表+红黑树中）超过了16*0.75=12（容量×加载因子）之后开始扩容。
HashMap有扩容机制，就是当达到扩容条件时会进行扩容。HashMap的扩容条件就是当HashMap中的元素个数（size）超过临界值（threshold）时就会自动扩容。
在HashMap中，threshold=loadFactor*capacity。非常影响性能的。
在Jdk1.7和Jdk1.8中，HashMap初始化这个容量的时机不同。
jdk1.8中，在调用HashMap的构造函数定义HashMap的时候，就会进行容量的设定。而在Jdk1.7中，要等到第一次put操作时才进行这一操作。
```
#### 2.5 hashmap的工作原理
[HashMap解析（主要JDK1.8，附带1.7出现的问题以及区别）](https://www.cnblogs.com/dmzna/p/13055232.html)
[HashMap是如何工作的](https://www.cnblogs.com/homejim/p/10029796.html)
```markdown
HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，
先对键调用hashCode()方法，计算并返回的hashCode是用于找到Map数组的bucket位置来储存Node对象。关键点在于，HashMap是在bucket中储存键对象和值对象，作为Map.Node。
以下是具体的put过程（JDK1.8版）
    1.对Key求Hash值，然后再计算下标
    2.如果没有碰撞，直接放入桶中（碰撞的意思是计算得到的Hash值相同，需要放到同一个bucket中）
    3.如果碰撞了，则调用equals() 比较value，相同则替换旧值，不同则以链表的方式链接到后面
    4.如果链表长度超过阀值(REEIFY THRESHOLD==8)，就把链表转成红黑树，链表长度低于6，就把红黑树转回链表
    5.如果桶满了(容量16*加载因子0.75)，就需要resize（扩容2倍后重排）
以下是具体get过程(考虑特殊情况如果两个键的hashcode相同，你如何获取值对象？)
    当我们调用get()方法，HashMap会使用键对象的hashcode找到bucket位置，找到bucket位置之后，
    会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。
resize()方法何时进行扩容？
    HashMap使用的是懒加载，构造完HashMap对象后，只要不进行put 方法插入元素之前，HashMap并不会去初始化或者扩容table。
    当首次调用put方法时，HashMap会发现table为空然后调用resize方法进行初始化
    ，当添加完元素后，如果HashMap发现size（元素总数）大于threshold（阈值），则会调用resize方法进行扩容。
    其实主要就是两步：1.创建新的数组 2.复制元素。
```
#### 2.6 拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？
```markdown
选择红黑树是为了解决二叉查找树的缺陷，二叉查找树在特殊情况下会变成一条线性结构遍历查找会非常慢。
而红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，引入红黑树就是为了查找数据快，解决链表查询深度的问题，
红黑树属于平衡二叉树，为了保持“平衡”是需要付出代价的，但是该代价所损耗的资源要比遍历线性链表要少，
所以当长度大于8的时候，会使用红黑树，如果链表长度很短的话，根本不需要引入红黑树，引入反而会慢。
```
#### 2.7 解决hash碰撞还有那些办法？
```markdown
HashMap：如何有效减少碰撞
    扰动函数：促使元素位置分布均匀，减少碰撞概率。
    使用final对象，并且采用合适的equals()和hashCode()方法。
开放定址法
    当冲突发生时，使用某种探查技术在散列表中形成一个探查(测)序列。沿此序列逐个单元地查找，直到找到给定的地址。
    按照形成探查序列的方法不同，可将开放定址法区分为线性探查法、二次探查法、双重散列法等。
再哈希法
    Hi = RHi（key），i=1,2,...k,RHi均是不同的哈希函数，即在同义词产生地址冲突时计算另一个哈希函数地址，直到不发生冲突为止。
    这种方法不易产生聚集，但是增加了计算时间。
    缺点：增加了计算时间。
建立一个公共溢出区
    假设哈希函数的值域为[0,m-1]，则设向量HashTable[0...m-1]为基本表，每个分量存放一个记录，另设立向量OverTable[0....v]为溢出表。
    所有关键字和基本表中关键字为同义词的记录，不管他们由哈希函数得到的哈希地址是什么，一旦发生冲突，都填入溢出表。
    简单地说就是搞个新表存冲突的元素。
链地址法（拉链法）
    将所有关键字为同义词的记录存储在同一线性链表中，也就是把冲突位置的元素构造成链表。
```
#### 2.8 Comparable和Comparator的区别?
```markdown
Comparable&Comparator都是用来实现集合中元素的比较、排序的，只是Comparable是在集合内部定义的方法实现的排序，Comparator是在集合外部实现的排序，
所以，如想实现排序，就需要在集合外定义Comparator接口的方法或在集合内实现Comparable接口的方法。
如果在定义类时，就实现了Comparable接口，直接在里面重写compareTo()方法，如果没实现，后面在业务开发中需要有比较排序的功能，
就再单独写一个类实现Comparator接口，在里面重写compare()方法，然后这个类需要作为参数传入到工具类Collections.sort和Arrays.sort方法中。
最主要的区别就是一个一开始就实现，一个是后期实现。
Comparator位于包java.util下，而Comparable位于包java.lang下。
```
### 3.怎么确保一个集合不能被修改？
```markdown
方式一：final：
    final 修饰的类不能被继承，
    final 修饰的方法不能被重写，
    final 修饰的变量不能修改
   这里需要特别注意，变量是基本类型的时候，值不可修改，变量是对象的时候，引用不可修改。
   集合的值是可以不断添加，但是当引用改变的时候就会报错，所以使用final只能让集合的引用不可修改，而值还是可以修改和添加。
方式二：使用Collections.unmodifiableCollection(Collection c)方法来创建一个只读集合，
    这样改变集合的任何操作都会抛出Java.lang.UnsupportedOperationException异常。
```
### [4.Java7/8中的HashMap和ConcurrentHashMap全解析](https://mp.weixin.qq.com/s?__biz=MzA4OTk2MjU1MQ==&mid=2650552196&idx=1&sn=c2c10f6226950d12eb86e0f7d375bc8d&chksm=881a76dcbf6dffca738314dceea6e710e02f54250371e9ca813b2b7ce196c212073693957a36&mpshare=1&scene=23&srcid=&sharer_sharetime=1578061630556&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
>> Java7 HashMap -> Java7 ConcurrentHashMap -> Java8 HashMap -> Java8 ConcurrentHashMap
```markdown
1.- Java7 HashMap
    capacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。
    loadFactor：负载因子，默认为 0.75。
    threshold：扩容的阈值，等于capacity * loadFactor
    JDK1.7中，HashMap采用位桶+链表的实现，即使用链表来处理冲突，同一hash值的链表都存储在一个数组中。
2.- Java7 ConcurrentHashMap
    ConcurrentHashMap和HashMap思路是差不多的，但是因为它支持并发操作，所以要复杂一些。
    整个ConcurrentHashMap由一个个Segment数组和HashEntry数组组成，Segment代表”部分“或”一段“的意思，所以很多地方都会将其描述为分段锁。
    Segment通过继承ReentrantLock来进行加锁，所以每次需要加锁的操作锁住的是一个segment，是一种可重入锁，扮演锁的角色，HashEntry用于存储键值对数据。
    这样只要保证每个Segment是线程安全的，也就实现了全局的线程安全。当一个线程占用锁访问其中一个数据时，其他段的数据也能被其他线程访问。
3.- Java8 HashMap
    Java8对HashMap进行了一些修改，最大的不同就是利用了红黑树，所以其由 数组+链表+红黑树 组成。
    在Java8中，当链表中的元素达到了8个时(寻址时间复杂度为O(N))，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为O(logN)。
    resize()方法用于初始化数组或数组扩容，每次扩容后，容量为原来的2倍，并进行数据迁移。
4.- Java8 ConcurrentHashMap
    [深入了解ConcurrentHashMap](https://www.cnblogs.com/detectiveHLH/p/13029635.html)
    ConcurrentHashMap取消了Segment分段锁，采用CAS和synchronized来保证并发安全。synchronized只锁住当前链表或红黑树二叉树的首节点，
    这样只要hash不冲突，就不会产生并发，效率也提升了N倍。
```
### [5.透过面试题掌握HashMap和ConcurrentHashMap](https://www.cnblogs.com/notfound9/p/12893238.html)
```markdown
1.HashMap添加一个键值对的过程是怎么样的？
    1.初始化table;2.计算hash值;3.插入或更新节点;4.扩容。
2.ConcurrentHashMap添加一个键值对的过程是怎么样的？
    1.判断null值;2.计算hash;3.进入for循环，插入或更新元素;4.判断是否需要扩容。
3.HashMap与HashTable，ConcurrentHashMap的区别是什么？
    主要从底层数据结构，线程安全，执行效率，是否允许Null值，初始容量及扩容，hash值计算来进行分析。
    1.底层数据结构
        HashMap=数组+链表+红黑树
        Hashtable=数组+链表
        ConcurrentHashMap=数组+链表+红黑树
    2.线程安全
        HashMap非线程安全
        HashTable线程安全
        ConcurrentHashMap线程安全
    3.执行效率
        因为HashMap是非线程安全的，执行效率会高一些。
        其次是ConcurrentHashMap，因为HashTable在进行修改和访问时是对整个HashTable加synchronized锁，所以效率最低。
    4.是否允许null值出现
        HashMap的key和null都可以为null，如果key为null，那么计算的hash值会是0，最终计算得到的数组下标也会是0，
        所以key为null的键值对会存储在数组中的首元素的链表中。value为null的键值对也能正常插入，跟普通键值对插入过程一致。
        HashTable的键和值都不能为null，如果将HashTable的一个键值对的key设置为null，因为null值没法调用hashCode()方法获取哈希值，
        所以会抛出空指针异常。同样value为null时，在put方法中会进行判断，然后抛出空指针异常。
        ConcurrentHashMap的键和值都不能为null,在putVal方法中会进行判断，为null会抛出空指针异常。
    5.初始容量及扩容
        如果不指定初始容量，HashMap和ConcurrentHashMap默认会是16，HashTable的容量默认会是11。
        如果制定了初始容量，HashMap和ConcurrentHashMap的容量会是比初始容量稍微大一些的2的幂次方大小，HashTable会使用初始容量。
        扩容时，HashMap和ConcurrentHashMap扩容时会是原来长度的两倍，HashTable则是2倍加上1。
    6.hash值计算
        HashTable会扩容为2n+1，HashTable之所以容量取11，及扩容时是是2n+1，是为了保证 HashTable的长度是一个素数，因为数组的下标
        是用key的hashCode与数组的长度取模进行计算得到的，而当数组的长度是素数时，可以保证计算得到的数组下标分布得更加均匀。
4.HashMap扩容后是否需要rehash？
    在JDK1.8以后，不需要rehash，因为键值对的Hash值主要是根据key的hashCode()的高16位与低16位进行异或计算后得到，
    根据hash%length，计算得到数组的下标index，因为length是2的整数次幂，当扩容后length变为原来的两倍时，hash%(2*length)的计算结果
    结果差别在于第length位的值是1还是0，如果是0，那么在新数组中的index与旧数组的一直，如果是1，在新数组中的index会是旧数组中的数组中的index+length。
5.HashMap扩容是怎样扩容的，为什么都是2的N次幂的大小？
    在没有指定初始长度的情况下，HashMap数组的默认长度为16，在添加一个新的键值对时，会调用putVal()方法，在方法中，
    成功添加一个新的键值对以后，会判断当前的元素个数是否超过阀值(数组长度*负载因子0.75)，如果超过那么调用resize方法进行扩容。
    具体的扩容步骤如下：1.计算扩容后的长度；2.初始化新数组；3.迁移元素。
6.ConcurrentHashMap是怎么记录元素个数size的？
    HashMap默认是非线程安全的，可以认为每次只有一个线程来执行操作，所以hashMap就使用一个很简单的int类型的size变量来记录HashMap键值对数量就行。
7.为什么ConcurrentHashMap，HashTable不支持key，value为null?
    因为HashMap是非线程安全的，默认单线程环境中使用，如果get(key)为null，可以通过containsKey(key)方法来判断这个key的value为null，还是不存在这个key，
    而ConcurrentHashMap，HashTable是线程安全的，在多线程操作时，因为get(key)和containsKey(key)两个操作和在一起不是一个原子性操作，
    可能在执行中间，有其他线程修改了数据，所以无法区分value为null还是不存在key。
    至于ConcurrentHashMap，HashTable的key不能为null，主要是设计者的设计意图。
8.HashSet和HashMap的区别？
    HashMap主要是用于存储非重复键值对，HashSet存储非重复的对象。虽然HashMap是继承于AbstractMap，实现了Map接口，HashSet继承于AbstractSet，实现了Set接口。
    但是由于它们都有去重的需求，所以HashSet主要实现都是基于HashMap的（如果需要复用一个类，我们可以使用继承模式，也可以使用组合模式。
9.HashMap遍历时删除元素的有哪些实现方法？
    第1种方法 - for-each遍历HashMap.entrySet，使用HashMap.remove()删除(结果：抛出异常)。
    第2种方法-for-each遍历HashMap.keySet，使用HashMap.remove()删除(结果：抛出异常)。
    第3种方法-使用HashMap.entrySet().iterator()遍历删除(结果：正确删除)。
```

## 五、计算机网络和操作系统
### 1. 在地址栏键入URL后，网络世界发生了什么？
[一文摸透从输入URL到页面渲染的过程](https://www.cnblogs.com/AhuntSun-blog/p/12641050.html)
```markdown
1.在键入URL之前，刚开完机的时候，需要联网，然后才能上网。这个阶段包括了获取本机IP地址，获取DNS服务器IP地址，获得网关路由器IP和MAC地址等操作。
--获取本机IP地址，DNS服务器地址，网关路由器地址
--1.获取域名的IP地址 --DNS域名解析:获取域名对应IP
--2.三次握手建立TCP连接
--3.建立连接后进行数据交互 发送HTTP请求  服务器处理请求并返回HTTP报文 请求结束关闭TCP连接
--4.浏览器解析渲染页面 构建DOM树 样式计算 页面布局 生成分层树 栅格化 显示
--5.合成与显示
```

[Java面试后端经验分享（不是面经的面经）:题目整合](https://www.nowcoder.com/discuss/421353?type=5)

[阿里java面经（供后人查看）](https://www.nowcoder.com/discuss/420953?type=2)
[https://www.nowcoder.com/discuss/420929?type=2]计算机

## 六、数据库MySQL和Redis
### 1.MySQL
[100道MySQL数据库经典面试题解析（收藏版）](https://www.cnblogs.com/jay-huaxiao/p/12950484.html)
#### 1. MySQL索引使用有哪些注意事项呢？
>> 可以从三个维度回答这个问题：索引哪些情况会失效，索引不适合哪些场景，索引规则
```markdown
索引哪些情况会失效
    查询条件包含or，可能导致索引失效
    如何字段类型是字符串，where时一定用引号括起来，否则索引失效
    like通配符可能导致索引失效。
    联合索引，查询时的条件列不是联合索引中的第一个列，索引失效。
    在索引列上使用mysql的内置函数，索引失效。
    对索引列运算（如，+、-、*、/），索引失效。
    索引字段上使用（！= 或者 < >，not in）时，可能会导致索引失效。
    索引字段上使用is null， is not null，可能导致索引失效。
    左连接查询或者右连接查询查询关联的字段编码格式不一样，可能导致索引失效。
    mysql估计使用全表扫描要比使用索引快,则不使用索引。
索引不适合哪些场景
    数据量少的不适合加索引
    更新比较频繁的也不适合加索引
    区分度低的字段不适合加索引（如性别）
索引的一些潜规则
    覆盖索引
    回表
    索引数据结构（B+树）
    最左前缀原则
    索引下推
```
#### 2. MySQL 遇到过死锁问题吗，你是如何解决的？
```markdown
我排查死锁的一般步骤是酱紫的：
    查看死锁日志show engine innodb status;
    找出死锁Sql
    分析sql加锁情况
    模拟死锁案发
    分析死锁日志
    分析死锁结果
```
#### 3. 日常工作中你是怎么优化SQL的？
```markdown
可以从这几个维度回答这个问题：
    加索引
    避免返回不必要的数据
    适当分批量进行
    优化sql结构
    分库分表
    读写分离
```
#### 存储过程和函数的区别？
```markdown
 存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。
    函数每次执行都需要编译一次。
 存储过程中可以使用try-catch块和事务，而函数中不可以
 函数有且只有一个输入参数和一个返回值，而存储过程没有这个限制
 函数可以被存储过程调用而存储过程不可以被函数调用
```
#### 视图的操作会对基本表产生影响吗？
```markdown
 视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，视图通常是有一个表或者多个表的行或列的子集。
对视图的修改会影响基本表。它使得我们获取数据更容易，相比多表查询。
 当用户试图修改视图的某些信息时，数据库必须把它转化为对基本表的某些信息的修改，对于简单的视图来说，这是很方便的，
但是，对于比较复杂的试图，可能是不可修改的。
```

## 七、其他
### [1.如何判断一个元素在亿级数据中是否存在？](https://www.cnblogs.com/crossoverJie/p/10018231.html)
[如何从亿量级中判断一个数是否存在？](https://www.cnblogs.com/kubidemanong/p/10147685.html)
```markdown
1.非常大的一个数据量，无法完全放进内存，或没有必要放进内存，造成系统性能消耗。
    1.大多数想到的都是用HashMap来存放数据，因为它的写入查询的效率都比较高。
    写入和判断元素是否存在都有对应的API，所以实现起来也比较简单。会造成内存溢出。
    2.Bloom Filter：用于解决判断一个元素是否在一个集合中，但它的优势是只需要占用很小的内存空间以及有着高效的查询效率。
    因为只是需要判断数据是否存在，也不是需要把数据查询出来，所以完全没有必要将真正的数据存放进去。
    3.bitmap：采用一个二进制位来存储数据的方法。
```
### [2.面试问题---JAVA程序CPU占用过高怎么定位](https://www.cnblogs.com/nijunyang/p/13040511.html)
>> 假如生产环境出现CPU占用过高，谈一谈分析思路和定位
```markdown
结合Linux和JDK命令一起分析
    1.先用top命令找到CPU占用最高的 top |grep java  或者 jps指令找到java进程的pid（6167）
    2.ps -ef 或者jps 进一步定位，得知是一个怎么样的后台程序 top -H -p pid:以线程的形式查看该进程 top -H -p 6167
    3.定位到具体线程或者代码 ps -mp 进程 -o THREAD,tid,time
            -m 显示所有线程
            -p pid进程使用cpu的时间
            -o 该参数后面是用户自定义格式
    4.将需要的线程ID转换为16进制格式(英文小写格式)
    5.jstack 进程 ID | grep tid(16进制线程ID小写英文) -A60  jstack 6167 >threadInfo.txt   信息输出到文件 然后查看。
性能监控工具
    jps(虚拟机进程状况工具) 
    jinfo(Java配置信息工具)
    jmap(内存映射工具)
    jstat(统计信息监控工具)
```
###

##
[一份热乎乎的腾讯后端面试真题](https://www.cnblogs.com/jay-huaxiao/p/12776714.html)
[Java面试系列第2篇-Object类中的方法](https://www.cnblogs.com/extjs4/p/12772027.html)
[Java岗结束春招，总结面经回馈牛客，祝大家都能得偿所愿~](https://www.nowcoder.com/discuss/416945?type=2)
[https://github.com/2020GetGoodOffer/test]
[各大公司面试题分类整理](https://www.cnblogs.com/lvmengtian/p/12796820.html)


[Java 基础知识面试题大集合](https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247489209&idx=3&sn=7b7a91570b32390645c83a4f32a5e2f0&chksm=fa0e7938cd79f02ee9807b7122bcae0c406a3903e01d07991b356da1b102dae759689fdee918&mpshare=1&scene=23&srcid=&sharer_sharetime=1590987905222&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
[Java面试全解析](https://my.oschina.net/u/2539475?tab=newest&catalogId=6934862)


这里列出遇到的面试中高频的考点（被问到三次以上的那种~）：
Java 基础：HashMap源码、泛型、NIO
数据结构与算法：红黑树、堆、 海量数据中找top k 问题、 快速排序、堆排序
JVM ：垃圾回收机制、Full GC、类加载机制
数据库：事务、索引、锁、查询优化、排查慢查询
Spring 框架：IOC、AOP、事务、SpringMVC、常见注解
操作系统：进程和线程、虚拟内存
网络：HTTPS、TCP三次握手四次挥手、HTTP状态码
手撕算法：基本都是剑指offer上面的原题，还有 生产者-消费者模型
再有，如果有读过并发包中的源码，或者对线程安全相关问题有自己的思考，也是很加分的。
## 经典面试题
[集合HashMap、HashTable，ConcourrentHashMap连环斩](https://www.cnblogs.com/zhuoqingsen/p/HashMap.html)


## 面试题总结
java基础
为什么String定义为final。
描述下java集合，项目中用到哪些。
StringBuilder和StringBuffer的区别。
HashMap中常用的方法有哪些，什么时候会触发树化，jdk1.7和1.8实现的差异，1.7的实现为什么会出现死锁，画图说明下。HashMap和TreeMap的区别。
说下枚举类型，底层实现原理，项目中是如何使用的。
详细描述Error和Exception(运行期和编译期)的区别。
创建线程的方式，线程的生命周期。
ThrealLocal实现原理，为什么会出现内存泄漏。
volatile关键字原理，项目中是如何使用的。
synchronized和lock的区别，底层实现原理。AQS队列实现原理，用了哪些设计模式。公平锁和非公平锁、独占锁和共享锁、读写锁分别是如何实现的，为什么说非公平锁比公平锁性能高。
序列化和反序列化。
深拷贝和浅拷贝区别。
java内部类的区别(成员内部类、静态嵌套类、方法内部类、匿名内部类 )。
java线程池参数描述，线程池工作原理，线程池如何调优。
主线程到达一个条件，需要多个子线程去执行任务，等子任务都执行完后再往下走，如何编写代码(CountDownLatch)。
写个程序，两个线程交叉打印1到100的数字，需要多种实现方式。
JVM
JVM运行时数据区域和内存模型描述，jdk8为什么移除方法区。
垃圾回收算法和垃圾回收器描述，在工作中，新生代和老年代分别用的什么垃圾回收器。
新生代和老年代什么时候会触发GC。
四种引用区别。
CMS垃圾回收过程描述，CMS有哪些缺点，对比G1。
GC调优步骤，有实操过吗。
描述下JVM类加载过程，如何自定义类加载器。
描述下双亲委派模型，为什么需要双亲委派模型。
泛型是如何实现的，逃逸分析知道吗，说下。
OOM、内存泄漏如何排查，用到哪些工具，如果不用工具如何进行定位。
机器负载变高如何排查，如果发现是jvm进程引起的，如何定位到代码行。

MySQL
事务描述，ACID讲解。
事务隔离级别描述，脏读、不可重复读、幻读区别，MVCC机制讲解。
Innodb如何解决幻读，间隙锁实现详细描述。
left join和inner join的区别，嵌套子查询如何优化。
如果线上出现慢sql，如何定位和解决，有实际动手优化过慢sql吗。
binlog机制描述，binlog日志格式有哪些。
MySQL主从架构(读写分离)，主从数据复制过程，数据复制过程丢失如何处理。
分库分表如何实现，用过哪些分库分表插件，底层原理是怎样的。
索引有哪些种类，建立索引的原则，聚簇索引和非聚簇索引实现区别，联合索引如何使用。
mysql写入数据的时候，是先把数据写到缓冲区，然后再flush到磁盘的，如何在flush过程中发生了宕机，数据如何恢复。
Redis
redis数据类型，说下跳跃表是如何实现的，可以用什么数据结构替换。
删除过期key策略有哪些，内存淘汰策略有哪些，分别什么时候触发。
redis线程模型和内存模型。
redis持久化机制。
redis集群方案。
让你设计一个redis，你会怎么做，有看过redis源码吗。
了解一致性hash算法吗，描述下。
用redis实现一个分布式锁。
缓存穿透、缓存击穿、缓存雪崩区别和解决方案。
布隆过滤器知道吗，说下原理。
Dubbo
描述一下rpc调用过程。
让你实现一个rpc框架，你会怎么做。
链路跟踪和熔断机制了解吗，框架层如何实现的。
了解哪些序列化协议，有什么区别，项目中用的是什么协议。
说下Netty，bio、nio、aio区别，select、poll、epoll区别，什么是零拷贝机制。
Kafka
Kafka、RabbitMQ、RocketMQ区别，为什么RabbitMQ时延最低，知道事务消息吗。
Kafka生产者、消费者、协调者、服务端工作机制，描述数据从生产端到消费端到过程。
如果出现数据丢失或者数据重复消费如何处理。
Kafka为什么高吞吐量。
Kafka是如何实现exactly once语义的。
让你设计一个消息队列，你会怎么设计。
Zookeeper
zookeeper节点类型、服务器角色，watch机制。
描述下ZAB协议。
应用场景。
使用zookeeper实现分布式锁和读写锁。
算法编程
无重复字符的最长子串
二叉树的直径
二叉树最大宽度
寻找旋转排序数组中的最小值
旋转链表
LRU缓存机制
数据流的中位数
搜索旋转排序数组
设计模式
单例模式：多种实现方式，double check实现原理，枚举类实现(枚举类为什么不能被反射)
模版方法设计模式：工程中的应用
静态代理和动态代理设计模式
装饰器模式
适配器模式
工程方法模式
责任链模式
[如何短时间内快速通过Java面试](https://www.cnblogs.com/javazhiyin/p/13023668.html)
[Java 最常见的 200+ 面试题汇总:没有答案](https://www.cnblogs.com/over/p/10468747.html)
[【2019春招准备：总目录】](https://blog.csdn.net/qq_33907408/article/details/84477343)
[Java面试题：在Java中，如何跳出当前的多重嵌套循环？](https://www.breakyizhan.com/javamianshiti/2361.html)

Java基础
1.HashMap的源码，实现原理，JDK8中对HashMap做了怎样的优化。
2.HaspMap扩容是怎样扩容的，为什么都是2的N次幂的大小。
3.HashMap，HashTable，ConcurrentHashMap的区别。
4.极高并发下HashTable和ConcurrentHashMap哪个性能更好，为什么，如何实现的。
5.HashMap在高并发下如果没有处理线程安全会有怎样的安全隐患，具体表现是什么。
6.java中四种修饰符的限制范围。
7.Object类中的方法。
8.接口和抽象类的区别，注意JDK8的接口可以有实现。
9.动态代理的两种方式，以及区别。
10.Java序列化的方式。
11.传值和传引用的区别，Java是怎么样的，有没有传值引用。
12.一个ArrayList在循环过程中删除，会不会出问题，为什么。
13.@transactional注解在什么情况下会失效，为什么。
数据结构和算法
1.B+树
2.快速排序，堆排序，插入排序（其实八大排序算法都应该了解
3.一致性Hash算法，一致性Hash算法的应用
JVM
1.JVM的内存结构。
2.JVM方法栈的工作过程，方法栈和本地方法栈有什么区别。
3.JVM的栈中引用如何和堆中的对象产生关联。
4.可以了解一下逃逸分析技术。
5.GC的常见算法，CMS以及G1的垃圾回收过程，CMS的各个阶段哪两个是Stop the world的，CMS会不会产生碎片，G1的优势。
6.标记清除和标记整理算法的理解以及优缺点。
7.eden survivor区的比例，为什么是这个比例，eden survivor的工作过程。
8.JVM如何判断一个对象是否该被GC，可以视为root的都有哪几种类型。
9.强软弱虚引用的区别以及GC对他们执行怎样的操作。
10.Java是否可以GC直接内存。
11.Java类加载的过程。
12.双亲委派模型的过程以及优势。
13.常用的JVM调优参数。
14.dump文件的分析。
15.Java有没有主动触发GC的方式（没有）。
多线程
1.Java实现多线程有哪几种方式。
2.Callable和Future的了解。
3.线程池的参数有哪些，在线程池创建一个线程的过程。
4.volitile关键字的作用，原理。
5.synchronized关键字的用法，优缺点。
6.Lock接口有哪些实现类，使用场景是什么。
7.可重入锁的用处及实现原理，写时复制的过程，读写锁，分段锁（ConcurrentHashMap中的segment）
8.悲观锁，乐观锁，优缺点，CAS有什么缺陷，该如何解决。
9.ABC三个线程如何保证顺序执行。
10.线程的状态都有哪些。
11.sleep和wait的区别。
12.notify和notifyall的区别。
13.ThreadLocal的了解，实现原理。
数据库相关
1.常见的数据库优化手段

2.索引的优缺点，什么字段上建立索引

3.数据库连接池。

4.durid的常用配置。


计算机网络

1.TCP，UDP区别。

2.三次握手，四次挥手，为什么要四次挥手。

3.长连接和短连接。

4.连接池适合长连接还是短连接。


设计模式

1.观察者模式

2.代理模式

3.单例模式，有五种写法，可以参考文章单例模式的五种实现方式

4.可以考Spring中使用了哪些设计模式


分布式相关

1.分布式事务的控制。

2.分布式锁如何设计。

3.分布式session如何设计。

4.dubbo的组件有哪些，各有什么作用。

5.zookeeper的负载均衡算法有哪些。

6.dubbo是如何利用接口就可以通信的。


缓存相关
    1.redis和memcached的区别。
    2.redis支持哪些数据结构。
    3.redis是单线程的么，所有的工作都是单线程么。
    4.redis如何存储一个String的。
    5.redis的部署方式，主从，集群。
    6.redis的哨兵模式，一个key值如何在redis集群中找到存储在哪里。
    7.redis持久化策略。


框架相关
    1.SpringMVC的Controller是如何将参数和前端传来的数据一一对应的。
    2.Mybatis如何找到指定的Mapper的，如何完成查询的。
    3.Quartz是如何完成定时任务的。
    4.自定义注解的实现。
    5.Spring使用了哪些设计模式。
    6.Spring的IOC有什么优势。
    7.Spring如何维护它拥有的bean。

一些较新的东西
    1.JDK8的新特性，流的概念及优势，为什么有这种优势。
    2.区块链了解
    3.如何设计双11交易总额面板，要做到高并发高可用。