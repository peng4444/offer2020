# 面试题总结
[一份超级详细的Java面试题【大厂面试真题+Java学习指南】](https://github.com/whx123/JavaHome)

[TOC]


## 一、Java基础
### 1.Java有哪些数据类型，分别占多少个字节？【3+】
![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL0phdmElRTUlOUYlQkElRTclQTElODAlRTglQUYlQUQlRTYlQjMlOTUvSmF2YSVFNSU5RiVCQSVFNiU5QyVBQyVFNiU5NSVCMCVFNiU4RCVBRSVFNyVCMSVCQiVFNSU5RSU4Qi5wbmc?x-oss-process=image/format,png)
```markdown
基本数据类型 对应引用数据类型
byte/8     Byte
char/16    Character
short/16   Short
int/32  - 2^32 ~ 2^32 -1   Integer
float/32   Float
long/64    Long
double/64  Double
boolean/~  Boolean
    boolean 只有两个值：true、false，可以使用1bit 来存储，但是具体大小没有明确规定。
    JVM会在编译时期将 boolean 类型的数据转换为int，使用1来表示true，0表示false。
    JVM支持boolean数组，但是是通过读写byte数组来实现的。
包装类型:基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。
缓存池:new Integer(123) 与 Integer.valueOf(123) 的区别在于：    
    new Integer(123) 每次都会新建一个对象；
    Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。
    valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。
    在 Java 8 中，Integer缓存池的大小默认为 -128~127。
float与double：Java不能隐式执行向下转型，因为这会使得精度降低。浮点型表示不能精确的表示小数。
相互转换
    int i1 = 0; 
    Integer integer1 = new Integer(i);
    Integer integer2 = new Integer(0); 
    int i2 = integer2.intValue(); 
    Boolean booleanObj1 = new Boolean(false);
    boolean baseBool1 = booleanObj.booleanValue();
    boolean baseBool2 = false;
    Boolean booleanObj2 = new Boolean(baseBool2);
```
### 2.Java四种访问权限控制【5+】
![java中四种修饰符的限制范围](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL0phdmElRTUlOUYlQkElRTclQTElODAlRTglQUYlQUQlRTYlQjMlOTUvSmF2YSVFOCVBRSVCRiVFOSU5NyVBRSVFNCVCRiVBRSVFOSVBNSVCMCVFNyVBQyVBNi5wbmc?x-oss-process=image/format,png)
```markdown
private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）
default (即缺省，什么也不写，不使用任何关键字）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。
protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。注意：不能修饰类（外部类）。
public : 对所有类可见。使用对象：类、接口、变量、方法
```
### 3.抽象类和接口的区别？普通类和抽象类有哪些区别？【10+】
```markdown
抽象类和普通类的唯一区别就在于是否实例化。
抽象类必须要有抽象方法吗？抽象类能使用final修饰吗？
     抽象类中可以有普通方法，也可以有抽象方法。但是有抽象方法的类一定是抽象类，抽象类中不一定有抽象方法。
     abstract和final不共存，final不能继承。abstract和static不共存 ，因为abstract不能修饰属性
     抽象类不能直接实例化，普通类可以直接实例化。
接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。
    接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final。
抽象类和接口的区别
    1.实现：抽象类的子类使用extends来继承，接口必须使用implements来实现接口。
    2.构造函数：抽象类可以有构造函数，接口不能有。抽象类中可以包含静态方法，接口中不能包含静态方法。
    3.实现数量：一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过extends关键字扩展多个接口。
    4.访问修饰符：接口的方法默认是public，所有方法在接口中不能有实现(Java8开始接口方法可以有默认实现）。
        抽象方法可以有public、protected和default这些修饰符（抽象方法就是为了被重写所以不能使用private关键字修饰！）
    5.抽象类中可以有普通成员变量，接口中没有普通成员变量（static或者final修饰）。
    6.从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。
        接⼝可以继承接⼝。抽象类可以实现(implements)接⼝，抽象类可继承具体类。抽象类中可以有静态的main⽅法。
```
### 4.值传递和引用传递的区别是什么？【3+】
>> 传值和传引用的区别，Java是怎么样的，有没有传值引用。
```markdown
值传递：在方法的调用过程中，实参把它的实际值传递给形参，此传递过程就是将实参的值复制一份传递到函数中，
    这样如果在函数中对该值（形参的值）进行了操作将不会影响实参的值。因为是直接复制，所以这种方式在传递大量数据时，运行效率会特别低下。
引用传递：弥补了值传递的不足，如果传递的数据量很大，直接复过去的话，会占用大量的内存空间，而引用传递就是将对象的地址值传递过去，
    函数接收的是原始值的首地址值。在方法的执行过程中，形参和实参的内容相同，指向同一块内存地址，
    也就是说操作的其实都是源数据，所以方法的执行将会影响到实际对象。
Java语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。
对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的
```
### 5.JAVA三大特性封装、继承和多态【4+】
```markdown
封装:利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，
    只保留一些对外的接口使其与外部发生联系。用户无需关心对象内部的细节，但可以通过对象对外提供的接口来访问该对象。
    优点：
        减少耦合：可以独立地开发、测试、优化、使用、理解和修改
        减轻维护的负担：可以更容易被程序员理解，并且在调试的时候可以不影响其他模块
        有效地调节性能：可以通过剖析来确定哪些模块影响了系统的性能
        提高软件的可重用性
        降低了构建大型系统的风险：即使整个系统不可用，但是这些独立的模块却有可能是可用的
继承:
    继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。
    Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为 向上转型 。
    继承的好处：
        1、继承的出现提高了代码的复用性，提高软件开发效率。
        2、继承的出现让类与类之间产生了关系，提供了多态的前提。
    继承的注意事项
         1、在Java中，类只支持单继承，不允许多继承，也就是说一个类只能有一个直接父类。
         2、多个类可以继承一个父类。
         3、在Java中，多层继承是可以的，即一个类的父类可以再去继承另外的父类。
           4、在Java中，子类和父类是一种相对概念，也就是说一个类是某个类父类的同时，也可以是另一个类的子类。
多态:Java中多态的代码体现在一个子类对象(实现类对象)既可以给这个子类(实现类对象)引用变量赋值，又可以给这个子类(实现类对象)的父类(接口)变量赋值。
    最终多态体现为父类引用变量可以指向子类对象。
    多态的前提是必须有子父类关系或者类实现接口关系，否则无法完成多态。
    在使用多态后的父类引用变量调用方法时，会调用子类重写后的方法。
    多态分为编译时多态和运行时多态：
    编译时多态主要指方法的重载
    运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定，即方法的重写。
    运行时多态有三个条件：
        继承
        覆盖（重写）
        向上转型
[为何说要多用组合少用继承？如何决定该用组合还是继承？](https://www.cnblogs.com/appsucc/p/13117618.html)
    尽管我们鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。在实际的项目开发中，我们还是要根据具体的情况，来选择该用继承还是组合。
    如果类之间的继承结构稳定，层次比较浅，关系不复杂，我们就可以大胆地使用继承。反之，我们就尽量使用组合来替代继承。
    除此之外，还有一些设计模式、特殊的应用场景，会固定使用继承或者组合。
[java抽象类、多态、接口](https://www.cnblogs.com/Young111/p/10033484.html)
抽象类、抽象方法的定义:
    抽象类定义的格式：abstract class 类名 {}
    抽象方法定义的格式：public abstract 返回值类型 方法名(参数);
    抽象类的特点
        1、抽象类和抽象方法都需要被abstract修饰。抽象方法一定要定义在抽象类中。
        2、抽象类不可以直接创建对象，原因：调用抽象方法没有意义。
        3、只有覆盖了抽象类中所有的抽象方法后，其子类才可以创建对象。否则该子类还是一个抽象类。
```
### 6.Java中==与equals区别比较【10+】
```markdown
[听说你还搞不定java中的==和equals？](https://www.cnblogs.com/yichunguo/p/12383853.html)
==的作用是判断两个对象的值是否相等，即判断两个对象是不是同一个对象。
    基础数据类型==比较的是值，引用对象类型==比较的是内存地址。
equals()的作用也是判断两个对象是否相等，但是一般有两种情况：
    情况1：类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于==。
    情况2：类覆盖了equals()方法，用来比较对象的内容是否相等。（String和Integer等等都重写了equals()方法，成了值比较。）
```
#### 1.代码示例
[为什么阿里巴巴Java开发手册中强制要求整型包装类对象值用equals方法比较？]( https://www.cnblogs.com/wupeixuan/p/11759459.html )
```java
public class test1 {
    public static void main(String[] args) {
        String a = new String("ab"); // a 为⼀个引⽤
        String b = new String("ab"); // b为另⼀个引⽤,对象的内容⼀样
        String aa = "ab"; // 放在常量池中
        String bb = "ab"; // 从常量池中查找
        if (aa == bb) // true
        System.out.println("aa==bb");
        if (a == b) // false，⾮同⼀对象
        System.out.println("a==b");
        if (a.equals(b)) // true
        System.out.println("aEQb");
        if (42 == 42.0) { // true
            System.out.println("true");
        }
    }
}
```
#### 2.String重写equals()方法
```markdown
public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof String) {
            String anotherString = (String)anObject;
            int n = value.length;
            if (n == anotherString.value.length) {
                char v1[] = value;
                char v2[] = anotherString.value;
                int i = 0;
                while (n-- != 0) {
                    if (v1[i] != v2[i])
                        return false;
                    i++;
                }
                return true;
            }
        }
        return false;
    }
```
#### 3.所有整型包装类对象之间值的比较，全部使用equals方法比较。【阿里巴巴Java开发手册】
```markdown
在-128至127之间的赋值,Integer对象是在IntegerCache.cache产生，会复用已有对象，这个区间内的Integer值可以直接使用==进行判断，
    但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用equals方法进行判断。
```
#### 4.浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用equals来判断。
### 7.为什么重写equals时必须重写hashCode方法【10+】
```markdown
[HashCode()与equals()深入理解](https://www.cnblogs.com/moershiwei/p/12643626.html)
[听说你还搞不定java中的==和equals？](https://www.cnblogs.com/yichunguo/p/12383853.html)
HashCode()的作用是确定该对象在哈希表中的索引位置。
    1、如果两个对象equals为true ，他们的hashcode一定相等。
    2、如果两个对象equals为false，他们的hashcode有可能相等。
    3、如果两个对象hashcode相等，equals不一定为true。
    4、如果两个对象hashcode不相等，equals一定为false。
在散列表中，hashCode()相等即两个键值对的哈希值相等，但是哈希值相等并不一定能得出键值相等。
```
#### 1.代码示例
```markdown
public static void main(String[] args) {
        String str1 = "通话";
        String str2 = "重地";
        System.out.println(String.format("str1:%d|str2:%d",str1.hashCode(),str2.hashCode()));
        System.out.println(str1.equals(str2));
}
str1:1179395|str2:1179395 两个str的hashCode()相同，但是equals()为false。
false
```
#### 2.hashCode()能否重写
```markdown
能否重写是取决于方法是否有final关键字,
查看object源码看下hashcode方法和getclass方法就知道了为啥hashcode可以getclass不行了;
```
#### 3.Integer和Long的hashCode()方法实现有什么区别？
```markdown
@Override
    public int hashCode() {
        return Integer.hashCode(value);
    }
    public static int hashCode(int value) {
            return value;
    }
@Override
    public int hashCode() {
        return Long.hashCode(value);
    }
    public static int hashCode(long value) {
        return (int)(value ^ (value >>> 32));
    }        
```
### 8.重载overload和重写override【4+】
```markdown
重写override是子类对父类的允许访问的方法的实现过程进行重新编写,发生在子类中，方法名、参数列表必须相同，
    返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。
    另外，如果父类方法访问修饰符为private则子类就不能重写该方法。也就是说方法提供的行为改变，而方法的外貌并没有改变。
重载overload:发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。
```
### 9.拆箱和装箱分别是什么？分别应用在什么场景？
```markdown
拆箱和装箱：拆箱是把包装类型变成基本类型；装箱是把基本类型变成包装类型。
自动装箱都是通过包装类的valueOf()方法来实现的;自动拆箱都是通过包装类对象的xxxValue()来实现的（如booleanValue()、longValue()等）。
应用场景：当==两边是基本类型和包装类型的时候，包装类型会拆箱，然后==会比较基本类型的两个值；
当equals方法的参数是基本类型的时候，基本类型会装箱，然后equals方法会先比较两个包装类型的类型，在比较值。
```
#### 在使用三目运算符的过程中，可能会进行自动拆箱而导致NPE问题。【Java开发手册】
[我去，这么简单的条件表达式竟然也有这么多坑](https://www.cnblogs.com/goodAndyxublog/p/13047617.html)
```markdown
 boolean flag = true;
 boolean simpleBoolean = false;
 Boolean nullBoolean = null;
 boolean x = flag ? nullBoolean.booleanValue() : simpleBoolean;
反编译后的代码的最后一行，编译器帮我们做了一次自动拆箱，而就是因为这次自动拆箱，导致代码出现对于一个null对象nullBoolean.booleanValue()的调用，导致了NPE。
三目运算符当第二位和第三位操作数的类型相同时，则三目运算符表达式的结果和这两位操作数的类型相同。
当第二，第三位操作数分别为基本类型和该基本类型对应的包装类型时，那么该表达式的结果的类型要求是基本类型。
所以，Java开发手册中提到要高度注意第二位和第三位表达式的类型对齐过程中由于自动拆箱发生的NPE问题，
其实还需要注意使用三目运算符表达式给变量赋值的时候由于自动拆箱导致的NPE问题。
Boolean b = Boolean.valueOf(maps == null ? false : ((Boolean)maps.get("Hollis")).booleanValue());
```
### 10.抽象类和接口有什么区别【5+】
```markdown
- 抽象类要被子类继承，接口要被子类实现。
- 抽象类可以有构造方法，接口中不能有构造方法。
- 抽象类中可以有普通成员变量，接口中没有普通成员变量，它的变量只能是公共的静态的常量
- 一个类可以实现多个接口，但是只能继承一个父类，这个父类可以是抽象类。
- 接口只能做方法声明，抽象类中可以作方法声明，也可以做方法实现。
- 抽象级别（从高到低）：接口>抽象类>实现类。
- 抽象类主要是用来抽象类别，接口主要是用来抽象方法功能。
- 抽象类的关键字是abstract，接口的关键字是interface
```
### 11.String为什么不可变？【5+】
[Java源码之String](https://www.cnblogs.com/chentang/p/13067765.html)
```markdown
当然在Java平台类库中，包含许多不可变类，例如String , 基本类型的包装类，BigInteger,BigDecimal等等。
类本身是final修饰的；所有的域几乎都是私有final的；不会对外暴露可以修改对象属性的方法。
String类并没有提供任何可以改变其值的方法。
使用什么方式可以改变String类的不可变性：**反射**
            String str = "chen";
            System.out.println(str);
            Field field = String.class.getDeclaredField("value");
            field.setAccessible(true);
            char[] value = (char[]) field.get(str);
            value[1] = 'a';
            System.out.println(str);
```
```markdown
String类的常用方法
    indexOf() 返回指定字符的索引
    charAt() 返回指定索引处的字符
    replace() 字符串替代
    substring() 字符串截取
    trim() 字符串去除两端的空格
    split() 分割字符串
    equals() 字符串比较
```
[String求求你别秀了](https://www.cnblogs.com/zhuoqingsen/p/String.html)
```markdown
String类有如下这些特点
    1.String类是final类，也即意味着String类不能被继承，并且它的成员方法都默认为final方法。
    2.String类其实是通过char数组来保存字符串的。
    3.String对象一旦被创建就是固定不变的了，对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象。
字符串常量池:
    1.每当我们创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么就直接返回常量池中的实例引用。
    如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中。由于String字符串的不可变性我们可以十分肯定常量池中一定不存在两个相同的字符串。
    2.字符串池的出现避免了相同内容的字符串的创建，节省了内存，省去了创建相同字符串的时间，同时提升了性能；
    另一方面，字符串池的缺点就是牺牲了JVM在常量池中遍历对象所需要的时间，不过其时间成本相比而言比较低。
1.单独使用""引号创建的字符串都是常量,编译期就已经确定存储到String Pool中；
2.使用new String("")创建的对象会存储到heap中,是运行期新创建的；
3.使用只包含常量的字符串连接符如"aa" + "aa"创建的也是常量,编译期就能确定,已经确定存储到String Pool中；
4.使用包含变量(引用)的字符串连接符如"aa" + s1创建的对象是运行期才创建的,存储在heap中；
5.但是如果s1是被final修饰的话，则s1是属于常量。结果存在String Pool，但是 final修饰的是一个方法返回的值也是在编译器确定。
String str1 = "aaa";
String str2 = "aaa";
System.out.println(str1 == str2);// true 因为String有常量池
String str3 = new String("aaa");
String str4 = new String("aaa");
System.out.println(str3 == str4);// false 可以看出用new的方式是生成不同的对象,比较堆上的
System.out.println(str3.equals(str4)); // true equals()比较值
String s0="helloworld";  
String s1="helloworld";  
String s2="hello"+"world";  
System.out.println(s0==s1); //true 可以看出s0跟s1是指向同一个对象   
System.out.println(s0==s2); //true 可以看出s0跟s2是指向同一个对象   
String st0="helloworld";   
String st1=new String("helloworld");   
String st2="hello" + new String("world");   
System.out.println( st0==st1 ); //false    用new String() 创建的字符串不是常量，不能在编译期就确定
System.out.println( st0==st2 ); //false   st2地址存在堆中，不可能相同
System.out.println( st1==st2 ); //false  
String stri1="abc";     
String stri2="def";     
String stri3=stri1+stri2;  
System.out.println(stri3=="abcdef"); //false    变量相+是在的堆内存中创建
String strin0 = "a1";   
String strin1 = "a" + 1;   //这种不是变量，是常量
System.out.println((strin0 == strin1)); //result = true    
String strin4 = "a3.4";   
String strin5 = "a" + 3.4;   
System.out.println((strin4 == strin5)); //result = true  
String string0 = "ab";   
String string1 = "b";   
String string2 = "a" + string1;   
System.out.println((string0 == string2)); //result = false  在字符串的"+"连接中，有字符串引用存在，而引用的值在程序编译期是无法确定的
```
### 12.String str="abc" 与 String str=new String (“abc”) 一样吗？为什么？【5+】
```markdown
1.使用String直接赋值：String str= “abc”：可能创建一个或者不创建对象。
    如果”abc”在字符串常量池中不存在，会在java字符串池中创建一个String对象（”abc”），然后str指向这个内存地址，
    无论以后用这种方式创建多少个值为”abc” 的字符串对象，始终只有一个内存地址被分配；如果 “abc” 在字符串池中存在，str直接指向这个内存地址。
2.使用new String创建字符串：String str = new String(“abc”)：至少会创建一个对象，也有可能创建两个。
    因为用到new关键字，肯定会在堆中创建一个String对象，如果字符池中已经存在”abc”, 则不会在字符串池中创建一个String对象，
    如果不存在，则会在字符串常量池中也创建一个对象。注意，此时二者地址不相同。
3.String拼接字符串：字符串拼接又分为变量拼接和已知字符串拼接。只要拼接内容存在变量，那么该拼接后的新变量就是在堆内存中新建的一个对象实体。但是不会在字符常量池中创建新对象。
4.String.intern()：当调用intern方法时，如果常量池已经包含一个等于此String对象的字符串（用equals(Object)方法确定），则返回池中的字符串。
    否则，将此String对象添加到常量池中，并返回此String对象的引用。
String str=“abc” 和 String str=new String(“abc”); 产生几个对象？String str = new String("hello")+new String("123");产生了几个对象？
    前者 1 或 0， 后者 2 或 1，最后一个是 3 或 4 或 5
    先看字符串常量池，如果字符串常量池中没有，都在常量池中创建一个，如果有，前者直接引用，后者在堆内存中还需创建一个 “abc” 实例对象。
字符常量池的位置？字符常量池存储的内容？
    字符串常量池的位置，jdk1.7从方法区移至堆中。
    字符串常量池存储的是字符串字面量（注意，这里的字面量指的就是String的对象，因为String本身是一个类，而字符常量池在jdk8放在堆中，所以存储的内容全都是对象）
```
### 13.String，StringBuffer，StringBuilder的区别【10+】
[一篇与众不同的String、StringBuilder和StringBuffer详解](https://www.cnblogs.com/cxuanBlog/p/13053615.html)
```markdown
String：
    String是final类，不能被继承。String类是一个不可变的类，一旦创建就不可以修改。每次修改都会创建新的String对象。
    String实现了equals()方法和hashCode()方法。
    String类的对象是不可变的，也就可以理解为常量，线程安全。
StringBuffer：
    继承自AbstractStringBuilder，是可变类。
    StringBuffer是线程安全的，对方法加了同步锁或者对调用的方法加了同步锁。(synchronized)
    可以通过append方法动态构造数据。执行效率比StringBuffer低。
StringBuilder：
    继承自AbstractStringBuilder，是可变类。
    StringBuilder是非线性安全的。
    执行效率比StringBuffer高。
```
#### 为什么StringBuilder的执行效率比StringBuffer高？】
[用大白话的方式讲明白Java的StringBuilder、StringBuffer的扩容机制](https://www.cnblogs.com/DMingO/p/13407303.html)

```markdown
StringBuffer和StringBuilder,都是继承了AbstractStringBuilder，它们的底层char数组value默认的初始化容量是16，
    扩容只需要修改底层的char数组，两者的扩容最终都会调用到AbstractStringBuilder类相同的方法：
        扩容的步骤：
        1.新的字符串的长度超过了底层原char数组value的大小，才需要进行扩容
        2.先尝试默认扩容，将新容量变成 (value.length << 1) + 2 ，也就是两倍的原数组长度再加二
        3.若默认扩充后的值还是小于至少容量的值，直接扩充到当前需要的至少容量大小；
        4.经过前两步骤确定的新数组大小，若大于Interger.MAX_VALUE,则报异常，若小于等于0，则新数组大小改为Interger.MAX_VALUE -8
        5.确定了新数组的值后，通过Arrays.copy(value,newCapactity)进行复制。最终给value数组完成扩容。
```
### 14.给定三个变量：i1、i2、i3。Integer i1= 120；Integer i2=120；int i3=120；i1和i2一样吗？i1和i3 呢？为什么？如果把120换成130呢，i1,12,i3的关系又如何，为什么？
```markdown
integer包装类和其他包装类不同之处，对于范围在-128到127之间的整数，integer创建对象的时候是直接从缓存读取的，这个时候直接从缓存得的的内容地址是保持一致的，
所以两个integer对象地址是相同的，但是不在这个范围的时候，地址就不在相同的。
对于integer变量和int变量，通过==比较，符合拆箱应用场景，integer会直接拆箱，所以无论什么范围，integer和int，都是直接比较值的。
1.两个基本类型的只能用 ==
2.基本型和封装型用==，封装型将会自动拆箱变为基本型后再进行比较
3.用==来比较两个封装类的话，比较的是地址。(其中-127到127之间的Integer地址相同，超出这个范围则不同)
4.至少有一个封装型的建议使用.equals。用==对基本型和封装性比较必须保证封装型不为null。如果为null则不能转化为基本型就会报错。
5.两个封装型进行equals()比较，首先equals()会比较类型，如果类型相同，则继续比较值，如果值也相同，返回true
6.封装类型调用equals(),但是参数是基本类型，这时候，先会进行自动装箱，基本型转换为其封装类型,若类型不同返回false,若装箱后类型相同，则比较值，如果值相同，则返回true
```
### 15.关键字static【3+】
>>  如果你答出static修饰变量、修饰方法我会认为你合格，答出静态块，我会认为你不错，
    答出静态内部类我会认为你很好，答出静态导包我会对你很满意，满意的原因是能看出你确实非常热衷研究技术。
```markdown
static是Java中非常重要的关键字，static表示的概念是静态的，在Java中，static主要用来
    static修饰变量，static修饰的变量称为静态变量、也称为类变量，类变量属于类所有，对于不同的类来说，static变量只有一份，
        static修饰的变量位于**方法区**中；static 修饰的变量能够直接通过 类名.变量名来进行访问，不用通过实例化类再进行使用。
        一旦属性定义上使用了static之后，只要一个对象修改了属性的内容，那么所有的对象的static属性的内容都将一起修改，
        也就是说static属性变成了一个公共属性，是全局数据区。
        （static声明的属性与普通属性的最大区别是保存的内存区域的不同，还有就是static属性在没有实例化的情况下可以使用）
    static修饰方法，static修饰的方法被称为静态方法，静态方法能够直接通过类名.方法名来使用，在静态方法内部不能使用非静态属性和方法。
        静态方法不需要创建对象就可以调用。
        static方法不能直接访问非static属性或者方法（必须要产生对象后才能调用），非static方法可以直接访问static属性或者方法
    static修饰代码块，主要分为两种，一种直接定义在类中，使用static{}，这种被称为静态代码块，一种是在类中定义静态内部类，使用static class xxx来进行定义。
         静态代码块在非静态代码块之前执行(静态代码块—>非静态代码块—>构造方法)。 该类不管创建多少对象，**静态代码块只执行一次**.
    static用于静态导包，通过使用 import static xxx 来实现，这种方式一般不推荐使用
    static和单例模式一起使用，通过双重检查锁来实现线程安全的单例模式。

```
### 16.关键字final【10+】
[我去，你竟然还不会用 Java final 关键字](https://www.cnblogs.com/qing-gee/p/13092011.html)
```markdown
1.final修饰类：如果一个类使用了final关键字修饰，那么它就无法被继承。类中的所有成员方法都会被隐式地指定为final方法。
2.final修饰方法：被final修饰的方法不能被重写。
3.final修饰变量：可以称为常量，必须初始化。初始化之后不能被修改。
    1）final修饰的基本数据类型，对于基本数据类型来说，final修饰的变量，其值不能被改变。
    2）final修饰的引用类型，则在对其初始化之后便不能再让其指向另一个对象。  
    3）final修饰的字段，一种是static的，另外一种是没有static的。
        非static的final字段必须有一个默认值，否则编译器将会提醒没有初始化。
        static的final字段也叫常量，它的名字应该为大写，可以在声明的时候初始化，也可以通过static代码块初始化。
    4) final修饰的参数
        final关键字还可以修饰参数，它意味着参数在方法体内不能被再修改。
使⽤final关键字修饰⼀个变量时，是指引⽤变量不能变，引⽤变量所指向的对象中的内容还是可以改变的。
    final StringBuffer a=new StringBuffer("immutable");
    a=new StringBuffer("");//编译期错误
    a.append(" broken!");//可以通过编译
```
### 17.什么是反射？反射的应用场景？反射在框架中应用【5+】
[学会反射后，我被录取了！（干货）](https://mp.weixin.qq.com/s?__biz=MzU2NDg0OTgyMA==&mid=2247492715&idx=1&sn=8786978d2bb9b5726daaa475c61aa85f&chksm=fc461998cb31908e5b716fca496f4cdb53799fe227b3fc00a7b30d4b085c2f1e3846ec61de06&mpshare=1&scene=23&srcid=0818UKrIHBlK6qpgrg7A7rBe&sharer_sharetime=1597712309970&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
[反射那些基础-Class](https://www.cnblogs.com/homejim/p/10140928.html)
#### 1.反射机制，思想，作用，原理
```markdown
JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；
    这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。所有反射的入口都是java.lang.Class。
    反射的思想：在程序运行过程中确定和解析数据类的类型。
    反射的作用：对于在编译期无法确定使用哪个数据类的场景，通过反射可以在程序运行时构造出不同的数据类实例。
反射原理：反射首先是能够获取到Java中的反射类的字节码，然后将字节码中的方法，变量，构造函数等映射成 相应的Method、Filed、Constructor等类。
```
#### 2.Java反射的主要组成部分和基本使用
![Java反射相关类](https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdU9zP8mtoSMWgz7sMaewZAoUxxdrLVARADmU5XlPnZkoGOfDhGzd8m8Z2RWLyibnuZjHW3ygE5DeTA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
```markdown
Java反射的主要组成部分有4个：
    Class：任何运行在内存中的所有类都是该Class类的实例对象，每个Class类对象内部都包含了本来的所有信息。记着一句话，通过反射干任何事，先找Class准没错！
    Field：描述一个类的属性，内部包含了该属性的所有信息，例如数据类型，属性名，访问修饰符······
    Constructor：描述一个类的构造方法，内部包含了构造方法的所有信息，例如参数类型，参数名字，访问修饰符······
    Method：描述一个类的所有方法（包括抽象方法），内部包含了该方法的所有信息，与Constructor类似，不同之处是Method拥有返回值类型信息，因为构造方法是没有返回值的。
Java反射的基本使用
    在运行时获取一个类的Class对象
    在运行时构造一个类的实例化对象
    在运行时获取一个类的所有信息：变量、方法、构造器、注解
在Java中，每一个类都会有专属于自己的Class对象，当我们编写完.java文件后，使用javac编译后，就会产生一个字节码文件.class，
在字节码文件中包含类的所有信息，如属性，构造方法，方法······当字节码文件被装载进虚拟机执行时，会在内存中生成Class对象，
它包含了该类内部的所有信息，在程序运行时可以获取这些信息。
public class SmallPineapple {
    public String name;
    public int age;
    private double weight; // 体重只有自己知道
    public SmallPineapple() {}
    public SmallPineapple(String name, int age) {
        this.name = name;
        this.age = age;
    }
    public void getInfo() {
        System.out.print("["+ name + " 的年龄是：" + age + "]");
    }
}
```
#### 3.获取类对象的三种方式
```markdown
因为Java中规定了java.lang.reflect包下的所有类的构造函数都不为public，因此，需要获得这些类的对象都需要调用Class类中适当的的方法。
    获取类对象的三种方式：
       1.Object.getClass()。通过object类的getClass()函数，由于object是根类，每一个类都有这个函数。
            SmallPineapple sp = new SmallPineapple();
            Class clazz = sp.getClass();
       2.类.class。每一个类（包括基本数据类型，注意这里基本数据类型不用转成包装类）都有一个class属性，静态属性，通过类名直接访问。
            这种获取方式只有在编译前已经声明了该类的类型才能获取到 Class 对象
            Class clazz = SmallPineapple.class;
       3.Class.forName("java.lang.System");通过Class类的静态方法forName(String className)。
            Class clazz = Class.forName("com.bean.smallpineapple");
       通过包装类的TYPE成员。对于基本数据类型，除了以上的.class方法之外，对应包装类的TYPE成员变量来获取Class对象。Double.TYPE;
    应用：
       反射是很多框架的基础
       通过反射运行配置文件
       通过反射越过泛型检查
```
#### 4.构造类的实例化对象        
```markdown
通过反射构造一个类的实例方式有2种：
    1.Class 对象调用newInstance()方法
        Class clazz = Class.forName("com.bean.SmallPineapple");
        SmallPineapple smallPineapple = (SmallPineapple) clazz.newInstance();
        smallPineapple.getInfo();
        // [null 的年龄是：0]
    即使SmallPineapple已经显式定义了构造方法，通过newInstance()创建的实例中，所有属性值都是对应类型的初始值，因为newInstance()构造实例会调用默认无参构造器。
    2.Constructor 构造器调用newInstance()方法
        Class clazz = Class.forName("com.bean.SmallPineapple");
        Constructor constructor = clazz.getConstructor(String.class, int.class);
        constructor.setAccessible(true);
        SmallPineapple smallPineapple2 = (SmallPineapple) constructor.newInstance("小菠萝", 21);
        smallPineapple2.getInfo();
        // [小菠萝 的年龄是：21]
    通过getConstructor(Object... paramTypes)方法指定获取指定参数类型的Constructor，Constructor调用newInstance(Object... paramValues) 时传入构造方法参数的值，同样可以构造一个实例，且内部属性已经被赋值。
    通过Class对象调用newInstance()会走默认无参构造方法，如果想通过显式构造方法构造实例，需要提前从Class中调用getConstructor()方法获取对应的构造器，通过构造器去实例化对象。
```
#### 5.获取一个类的所有信息
![](https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdU9zP8mtoSMWgz7sMaewZAoX2uyxysRTWA5liay39KNoFJ7WQq2CqE0lNWgiaxeIichc58AuTAic1suPg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
```markdown
Class对象中包含了该类的所有信息，在编译期我们能看到的信息就是该类的变量、方法、构造器，在运行时最常被获取的也是这些信息。
获取类中的变量（Field）
    Field[] getFields()：获取类中所有被public修饰的所有变量
    Field getField(String name)：根据变量名获取类中的一个变量，该变量必须被public修饰
    Field[] getDeclaredFields()：获取类中所有的变量，但无法获取继承下来的变量
    Field getDeclaredField(String name)：根据姓名获取类中的某个变量，无法获取继承下来的变量
获取类中的方法（Method）
    Method[] getMethods()：获取类中被public修饰的所有方法
    Method getMethod(String name, Class...<?> paramTypes)：根据名字和参数类型获取对应方法，该方法必须被public修饰
    Method[] getDeclaredMethods()：获取所有方法，但无法获取继承下来的方法
    Method getDeclaredMethod(String name, Class...<?> paramTypes)：根据名字和参数类型获取对应方法，无法获取继承下来的方法
获取类的构造器（Constructor）
    Constuctor[] getConstructors()：获取类中所有被public修饰的构造器
    Constructor getConstructor(Class...<?> paramTypes)：根据参数类型获取类中某个构造器，该构造器必须被public修饰
    Constructor[] getDeclaredConstructors()：获取类中所有构造器
    Constructor getDeclaredConstructor(class...<?> paramTypes)：根据参数类型获取对应的构造器
```
#### 6.获取注解
```markdown
Annotation[] getAnnotations()：获取该对象上的所有注解
Annotation getAnnotation(Class annotaionClass)：传入注解类型，获取该对象上的特定一个注解
Annotation[] getDeclaredAnnotations()：获取该对象上的显式标注的所有注解，无法获取继承下来的注解
Annotation getDeclaredAnnotation(Class annotationClass)：根据注解类型，获取该对象上的特定一个注解，无法获取继承下来的注解
只有注解的@Retension标注为RUNTIME时，才能够通过反射获取到该注解，@Retension 有3种保存策略：
    SOURCE：只在**源文件(.java)**中保存，即该注解只会保留在源文件中，编译时编译器会忽略该注解，例如 @Override 注解
    CLASS：保存在字节码文件(.class)中，注解会随着编译跟随字节码文件中，但是运行时不会对该注解进行解析
    RUNTIME：一直保存到运行时，用得最多的一种保存策略，在运行时可以获取到该注解的所有信息
```
#### 7.通过反射调用方法
```markdown
通过反射获取到某个Method类对象后，可以通过调用invoke方法执行。
    invoke(Oject obj, Object... args)：参数``1指定调用该方法的**对象**，参数2`是方法的参数列表值。
如果调用的方法是静态方法，参数1只需要传入null，因为静态方法不与某个对象有关，只与某个类有关。
可以像下面这种做法，通过反射实例化一个对象，然后获取Method方法对象，调用invoke()指定SmallPineapple的getInfo()方法。
    Class clazz = Class.forName("com.bean.SmallPineapple");
    Constructor constructor = clazz.getConstructor(String.class, int.class);
    constructor.setAccessible(true);
    SmallPineapple sp = (SmallPineapple) constructor.newInstance("小菠萝", 21);
    Method method = clazz.getMethod("getInfo");
    if (method != null) {
        method.invoke(sp, null);
    }
    // [小菠萝的年龄是：21]
```
#### 8.反射的应用场景
```markdown
反射常见的应用场景这里介绍3个：
1.Spring实例化对象：当程序启动时，Spring会读取配置文件applicationContext.xml并解析出里面所有的标签实例化到IOC容器中。
    在Spring中，经常会编写一个上下文配置文件applicationContext.xml，里面就是关于bean的配置，程序启动时会读取该xml文件，解析出所有的<bean>标签，并实例化对象放入IOC容器中。
    <?xml version="1.0" encoding="UTF-8"?>
    <beans xmlns="http://www.springframework.org/schema/beans"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
        <bean id="smallpineapple" class="com.bean.SmallPineapple">
            <constructor-arg type="java.lang.String" value="小菠萝"/>
            <constructor-arg type="int" value="21"/>
        </bean>
    </beans>
    在定义好上面的文件后，通过ClassPathXmlApplicationContext加载该配置文件，程序启动时，Spring会将该配置文件中的所有bean都实例化，放入IOC容器中，IOC容器本质上就是一个工厂，通过该工厂传入<bean>标签的id属性获取到对应的实例。
    public class Main {
        public static void main(String[] args) {
            ApplicationContext ac =
                    new ClassPathXmlApplicationContext("applicationContext.xml");
            SmallPineapple smallPineapple = (SmallPineapple) ac.getBean("smallpineapple");
            smallPineapple.getInfo(); // [小菠萝的年龄是：21]
        }
    }
    Spring 在实例化对象的过程经过简化之后，可以理解为反射实例化对象的步骤：
        获取Class对象的构造器
        通过构造器调用newInstance()实例化对象
    当然 Spring 在实例化对象时，做了非常多额外的操作，才能够让现在的开发足够的便捷且稳定。
2.反射+工厂模式：通过反射消除工厂中的多个分支，如果需要生产新的类，无需关注工厂类，工厂类可以应对各种新增的类，反射可以使得程序更加健壮。
    传统的工厂模式，如果需要生产新的子类，需要修改工厂类，在工厂类中增加新的分支；
    public class MapFactory {
        public Map<Object, object> produceMap(String name) {
            if ("HashMap".equals(name)) {
                return new HashMap<>();
            } else if ("TreeMap".equals(name)) {
                return new TreeMap<>();
            } // ···
        }
    }
    利用反射和工厂模式相结合，在产生新的子类时，工厂类不用修改任何东西，可以专注于子类的实现，当子类确定下来时，工厂也就可以生产该子类了。
    反射 + 抽象工厂的核心思想是：在运行时通过参数传入不同子类的全限定名获取到不同的Class对象，调用newInstance()方法返回不同的子类。
        细心的读者会发现提到了子类这个概念，所以反射 + 抽象工厂模式，一般会用于有继承或者接口实现关系。
    例如，在运行时才确定使用哪一种 Map 结构，我们可以利用反射传入某个具体 Map 的全限定名，实例化一个特定的子类。
    public class MapFactory {
        /**
         * @param className 类的全限定名
         */
        public Map<Object, Object> produceMap(String className) {
            Class clazz = Class.forName(className);
            Map<Object, Object> map = clazz.newInstance();
            return map;
        }
    }
    className 可以指定为 java.util.HashMap，或者 java.util.TreeMap 等等，根据业务场景来定。
3.JDBC连接数据库：使用JDBC连接数据库时，指定连接数据库的驱动类时用到反射加载驱动类
    在导入第三方库时，JVM不会主动去加载外部导入的类，而是等到真正使用时，才去加载需要的类，正是如此，我们可以在获取数据库连接时传入驱动类的全限定名，交给JVM加载该类。
    public class DBConnectionUtil {
        /** 指定数据库的驱动类 */
        private static final String DRIVER_CLASS_NAME = "com.mysql.jdbc.Driver";
        public static Connection getConnection() {
            Connection conn = null;
            // 加载驱动类
            Class.forName(DRIVER_CLASS_NAME);
            // 获取数据库连接对象
            conn = DriverManager.getConnection("jdbc:mysql://···", "root", "root");
            return conn;
        }
    }
```
#### 9.Java实现反射的三种方法
```markdown
    1.通过new对象实现反射机制 
    2.通过路径实现反射机制 
    3.通过类名实现反射机制
    public class Student {
        private int id;
        String name;
        protected boolean sex;
        public float score;
    }
    public class Get {
        //获取反射机制三种方式
        public static void main(String[] args) throws ClassNotFoundException {
            //方式一(通过建立对象)
            Student stu = new Student();
            Class classobj1 = stu.getClass();
            System.out.println(classobj1.getName());
            //方式二（所在通过路径-相对路径）
            Class classobj2 = Class.forName("fanshe.Student");
            System.out.println(classobj2.getName());
            //方式三（通过类名）
            Class classobj3 = Student.class;
            System.out.println(classobj3.getName());
        }
    }
Class里面存储了对应类的所有信息，因此，我们可以获得类相关的信息。突破私有字段的保护机制，访问并修改对象的私有字段。
反射中，Class.forName()和ClassLoader.loadClass()区别？
     Class.forName()执行的是类加载过程的链接和初始化。需要整个类完全加载到内存中，以获取该类的信息。
     ClassLoader.loadClass()执行的只是类加载过程中的第一步，加载过程。
        loadClass方法是在双亲委派中调用，此时判断类由哪一个类加载器加载，因此类还未加载到内存中。
```
#### 10.反射的优势及缺陷
```markdown
反射的优点：
    增加程序的灵活性：面对需求变更时，可以灵活地实例化不同对象
但是，有得必有失，一项技术不可能只有优点没有缺点，反射也有两个比较隐晦的缺点：
    破坏类的封装性：可以强制访问 private 修饰的信息
    性能损耗：反射相比直接实例化对象、调用方法、访问变量，中间需要非常多的检查步骤和解析步骤，JVM无法对它们优化。
```
### 18.什么是java序列化？什么情况下需要序列化？如何避免序列化对象中的属性序列化？【5+】
[序列化的几种方式](https://www.jianshu.com/p/7298f0c559dc)
```markdown
内存中的数据对象只有转换为二进制流才可以进行数据持久化和网络传输。将数据对象转换为二进制流的过程称为对象的序列化（Serialization）。
1.在Java中，我们可以通过多种方式来创建对象，并且只要对象没有被回收我们都可以复用此对象。
    但是，创建出来的这些对象都存在于JVM中的堆（stack）内存中，只有JVM处于运行状态的时候，这些对象才可能存在。
    一旦JVM停止，这些对象也就随之消失；但是在真实的应用场景中，我们需要将这些对象持久化下来，
    并且在需要的时候将对象重新读取出来，Java的序列化可以帮助我们实现该功能。
2.对象序列化机制（object serialization）是java语言内建的一种对象持久化方式，
    通过对象序列化，可以将对象的状态信息保存为字节数组，并且可以在有需要的时候将这个
    字节数组通过反序列化的方式转换成对象，对象的序列化可以很容易的在JVM中的活动对象和字节数组（流）之间进行转换。
3.Java类通过实现java.io.Serializable接口来启用序列化功能，未实现此接口的类将无法将其任何状态或者信息进行序列化或者反序列化。
    可序列化类的所有子类型都是可以序列化的。序列化接口没有方法或者字段，仅用于标识可序列化的语义。
    在JAVA中，对象的序列化和反序列化被广泛的应用到RMI（远程方法调用）及网络传输中。
属性避免序列化：
    1.静态数据不能被序列化，因为静态数据不在堆内存中，而是在静态方法区中
    2.将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。
```
### 19.类的实例化顺序【1+】
```markdown
类实例化顺序为：父类静态代码块/静态域->子类静态代码块/静态域 -> 父类非静态代码块 -> 父类构造器 -> 子类非静态代码块 -> 子类构造器
```
### 20.Java泛型【3+】
[用了这么多年的 Java 泛型，你对它到底有多了解？](https://www.cnblogs.com/goodAndyxublog/p/12934938.html)
[如何在运行时(Runtime)获得泛型的真正类型](https://www.cnblogs.com/xiaoheike/p/9867060.html)
[面试官：十问泛型，你能扛住吗？](https://www.cnblogs.com/viyoung/p/13175128.html)
```markdown
泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口和泛型方法。
Java泛型实现方式：Java采用类型擦除（Type erasure generics）的方式实现泛型。
    用大白话讲就是这个泛型只存在源码中，编译器将源码编译成字节码之时，就会把泛型『擦除』，所以字节码中并不存在泛型。
    并不是每一个泛型参数被擦除类型后都会变成Object类，如果泛型类型为T extends String这种方式，最终泛型擦除之后将会变成String。
类型擦除带来的缺陷：
    1.不支持基本数据类型,但是Java是可以向上转型的。查看字节码，泛型参数被擦除之后，强制变成了Object类型。
    2.Java类型擦除式泛型实现方式无论使用效果与运行效率全面落后于C#的具现化式泛型。
    3.由于编译之后，泛型就被擦除，所以在代码运行期间，Java 虚拟机无法获取泛型的实际类型。
Java 泛型发展史：
    1.Java泛型最早是在JDK5的时候才被引入，但是泛型思想最早来自来自C++模板（template）。
```
### 21.Java创建对象的过程【1+】
```markdown
User user = new User();
1.类加载检查：虚拟机遇到一条new指令时，首先去检查这个指令能否在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类
    是否被加载过、解析过和初始化过。如果没有，那必须先执行相应的类加载过程。
2.分配内存：在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便确认了，为对象分配空间的任务
    等同于把一块确定大小的内存从Java堆中划分出来。分配方式有指针碰撞和空闲列表。
    虚拟机采用两种方式保证线程安全：CAS+失败重试，TLAB。
3.初始化零值：保证对象的实例字段在Java代码中可以不赋初始值就直接使用。
4.设置对象头：对象的元数据信息，对象的哈希码，对象的GC分代年龄等等信息放在对象头中。
5.执行init方法：执行new指令之后会接着执行<init>方式，把对象按照意愿进行初始化。
```
### 22.Java创建对象有几种方式【1+】
```markdown
Java创建对象有5种方式
    用new语句创建对象。（要求该Class对象对应的类有默认的空构造器）
    使用反射，使用Class.newInstance()创建对象/调用类对象的构造方法——Constructor
    调用对象的clone()方法。
    运用反序列化手段，调用java.io.ObjectInputStream对象的readObject()方法。
    使用Unsafe
```
### 23.Java中的异常处理机制的简单原理和应⽤
![Java异常体系](https://uploadfiles.nowcoder.com/files/20200810/176673786_1597021488566_u31373892961222888772fm26gp0.jpg)
```markdown
Java对异常进⾏了分类，不同类型的异常分别⽤不同的Java类表示，所有异常的根类为java.lang.Throwable
    Throwable下⾯⼜派⽣了两个⼦类：Error和Exception，
        Error ：是指 java 运行时系统的内部错误和资源耗尽错误。应用程序不会抛出该类对象。如果出现了这样的错误，除了告知用户，剩下的就是尽力使程序安全的终止。
        Exception 包含：RuntimeException、CheckedException
            RuntimeException：运行时异常，如NullPointerException、ClassCastException ；
        ​    RuntimeException是那些可能在Java虚拟机正常运行期间抛出的异常的超类，这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。
            CheckedException：受检异常，如I/O错误导致的IOException、SQLException；CheckedException：
            一般是外部错误，这种异常都发生在编译阶段，Java编译器会强制程序去捕获此类异常，即会出现要求你把这段可能出现异常的程序进行try catch，该类异常一般包括几个方面：
        ​       ①试图在文件尾部读取数据
        ​       ②试图打开一个错误格式的URL
        ​       ③试图根据给定的字符串查找class对象，而这个字符串表示的类并不存在
```        
### 24.throw和throws的区别？【5+】
```markdown
throws声明：
    如果一个方法内部的代码会抛出检查异常(checked exception)而方法自己又没有完全处理掉，则javac保证你必须在方法的签名上使用throws关键字声明这些可能抛出的异常，否则编译不通过。
    throws是另一种处理异常的方式，它不同于 try…catch…finally，throws仅仅是将函数中可能出现的异常向调用者声明，而自己则不具体处理。
throw异常抛出语句：
    程序员也可以通过throw语句手动显式的抛出一个异常。throw语句的后面必须是一个异常对象。
    throw语句必须写在函数中，执行throw语句的地方就是一个异常抛出点，它和由 JRE自动形成的异常抛出点没有任何差别。
    在异常处理中，try语句要捕获的是一个异常对象，那么此异常对象也可以自己抛出。
    try-catch-finally 中哪个部分可以省略？finally 可以省略，其他都不可以省略
    try-catch-finally中，如果catch中return了，finally 还会执行吗？
在try块中即便有return，break，continue等改变执行流的语句，finally也会执行。try…catch…finally中的return只要能执行，就都执行了，他们共同向同一个内存地址
（假设地址是 0×80）写入返回值，后执行的将覆盖先执行的数据，而真正被调用者取的返回值就是最后一次写入的。finally中的return会覆盖try或者catch中的返回值。
finally中的return和方法的return不能共存，因为finally是异常处理的最后执行的部分，finally必定执行，内部的return跟方法最后的return存在冲突。
```
### 25.常见的异常类有哪些？java异常的执行流程？【5+】
```markdown
error错误类：NoClassDefFoundError、StackOverFlowError、OutOfMemoryError。
exception类：IOException（FileNotFindException）、RuntimeException（NullPointException）
在Java应用程序中，异常处理机制为：抛出异常，捕捉异常。
抛出异常：当一个方法出现错误引发异常时，方法创建异常对象并交付运行时系统，异常对象中包含了异常类型和异常出现时的程序状态等异常信息。
运行时系统负责寻找处置异常的代码并执行。
捕捉异常：在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器（exceptionhandler）。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。
当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适的异常处理器。运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常
处理器的方法并执行。当运行时系统遍历调用栈而未找到合适的异常处理器，则运行时系统终止。同时，意味着Java程序的终止。
```
### 26.NoClassDefFoundError和ClassNotFoundException区别【1+】
[聊聊面试-NoClassDefFoundError和ClassNotFoundException区别](https://www.cnblogs.com/xiao2shiqi/p/11740563.html)
```markdown
当应用程序运行的过程中尝试使用类加载器去加载Class文件的时候，如果没有在classpath中查找到指定的类，就会抛出ClassNotFoundException。
当JVM在加载一个类的时候，如果这个类在编译时是可用的，但是在运行时找不到这个类的定义的时候，JVM就会抛出一个NoClassDefFoundError错误。
比如当我们在new一个类的实例的时候，如果在运行是类找不到，则会抛出一个NoClassDefFoundError的错误。（这个情况是我们的class文件被删除了）
总结：当动态加载Class的时候找不到类会抛出异常，当编译后找不到类的时候，会抛error
```
### 27.Error和Exception的区别【4+】
```markdown
Throwable是Java语言中所有错误或异常的超类。下一层分为Error和Exception。
    Error和Exception都是继承Throwable类，它们体现Java设计者在对异常的不同情况所进行的分类处理，
    在Java中只有Throwable类的实例才能被try/catch捕获或者声明抛出。
Error在大多数情况下代表程序出现了致命并且不可恢复的错误，它们大多都是不可预测的错误，不需要也不能捕获和抛出，
    例如常见的OutOfMemeryError，StackOverFlowError，还有本文提到的 NoClassDefFoundError，他们都是Error的子类。
Exception属于程序错误，大多是人为编码所导致的，它们大多都可以预测，也可以通过程序处理让程序正常流程，所以是需要进行捕获（try/catch）或者声明抛出（throw）的，
    Exception还分两种情况，可检查异常checked exception（编译期异常），非检查异常unchecked exception（运行期异常）
常见的RuntimeException异常：
    - NullPointerException 空指针异常
    - ArithmeticException 出现异常的运算条件时，抛出此异常
    - IndexOutOfBoundsException 数组索引越界异常
    - ClassNotFoundException 找不到类异常
    - IllegalArgumentException(非法参数异常)
常见的 Checked Exception 异常：
    - IOException (操作输入流和输出流时可能出现的异常)
    - ClassCastException(类型转换异常类)
```
### 28.final, finally, finalize的区别【5+】
```markdown
final用于修饰属性,方法和类, 分别表示属性不能被重新赋值, 方法不可被覆盖, 类不可被继承。
    内部类要访问局部变量，局部变量必须定义成final类型。
finally是异常处理语句结构的一部分，一般以ty-catch-finally出现，finally代码块表示总是被执行。
finalize是Object类的一个方法，该方法一般由垃圾回收器来调用，当我们调用System.gc()方法的时候，
    由垃圾回收器调用finalize()方法，回收垃圾，JVM并不保证此方法总被调用。
```
### 29.try-catch-finally 语法块的执行顺序等问题【5+】
>>  [try、catch、finally语句中有return的各类情况](https://www.cnblogs.com/yychuyu/p/13199329.html)
```markdown
return语句已经执行了再去执行finally语句，不过并没有直接返回，而是等finally语句执行完了再返回结果
try-catch-finally中如果catch中return了finally一定会执行，catch中的return会等finally中的代码执行完成之后执行。
try-catch-finally其中catch和finally都可以被省略，但是不能同时省略。
```
### 30.设计模式
#### 1.熟悉的设计模式
>> 单例模式，工厂模式，代理模式，观察者模式，模板方法模式，状态模式。
#### 2.单例模式【1+】
[【极客思考】设计模式：你确定你真的理解了单例模式吗？](https://www.cnblogs.com/huaweiyun/p/12973585.html)
```markdown
一个类只能创建一个实例，并提供一个访问它的全局访问点。
一、双重校验锁（DCL） 1.如果不用volatile修饰会怎么样？2.volatile作用是啥？
二、静态内部类
三、枚举
单例模式真的有那么好吗？
    优点：
    1.提供了唯一实例的受控访问。
    2.因为只有一个实例，节约了系统资源，提高系统性能。
    缺点：
    1.单例模式没有抽象层，扩展比较困难。
    2.单例类的职责过重，违背了“单一职责原则”。
四、通过Spring实现的单例。
设计模式的单例是在整个Java应用中只有一个实例，而Spring中的单例是在一个IOC容器中就只有一个单例。
但对于web应用来说，web容器（Jetty或tomcat）对用户的每个请求都会创建一个单独的servlet线程去处理请求，
Spring框架下的接口每个action也都是单例的，那么其实就保证了我们使用的是一个实例。
同时Spring也支持我们通过注解或者xml进行lazy-init，也可以指定scope确定其是否为全局单例，又或者是多个实例，对于程序来说有了更多的选择。
/饿汉式，类加载时就实例化一个对象，能快速创一个单例对象，而且线程安全(只有类加载时初始化)，缺点是不支持延迟加载，不管要不要都会直接创一个对象
public class Id {
   private static final Id instance = new Id();
   private Id() {}
   public static Id getInstance() {
     return instance;
   }
}
//懒汉式单例，只有在调用getInstance时才会实例化一个单例对象,优点是支持延迟加载，缺点是调用方***频繁加锁释放锁，并发度比较低
public class Id {
    public static Id instance;
    private Id(){}
    public static synchronized Id getInstance(){
      if(instance==null){       //step 1.
         instance = new Id();  //step 2
       }
    return instance;
    }
}
//双重检测，支持延迟加载和高并发。只要 instance 被创建之后，再调用 getInstance() 函数都不会进入到加锁逻辑中
public class Id {
  private static volatile Id instance;
  private Id() {}
  public static Id getInstance() {
    if (instance == null) {
      synchronized(Id.class) { // 此处为类级别的锁
        if (instance == null) {
          instance = new IdG();
        }
      }
    }
    return instance;
  }
}
```
[对于单例模式面试官会怎样提问呢？你又该如何回答呢？](https://www.cnblogs.com/Ccwwlx/p/13053922.html)
#### 3.代理模式有什么用？应用场景是什么？【5+】
>>如何实现静态代理？有啥缺陷？
>>动态代理的作用？在哪些地方用到了？（AOP、RPC 框架中都有用到）
>>JDK 的动态代理和 CGLIB 有什么区别？
```markdown
代理（Proxy）模式是结构型的设计模式之一，它可以为其他对象提供一种代理（Proxy）以控制对这个对象的访问。
所谓代理，是指具有与被代理的对象具有相同的接口的类，客户端必须通过代理与被代理的目标类交互。
应用场景：
     需要控制对目标对象的访问。
     需要对目标对象进行方法增强。如：添加日志记录，计算耗时等。
     需要延迟加载目标对象。
    SpringAOP Hibernate数据查询，测试框架的后端mock，rpc,Java注释对象获取等等。
实现动态代理的两种方式：JDK动态代理和Gglib动态代理
     JDK动态代理是实现了被代理对象的接口，Cglib是继承了被代理对象。
     JDK和Cglib都是在运行期生成字节码，JDK是直接写Class字节码，Cglib使用ASM框架写Class字节码，Cglib代理实现更复杂，生成代理类比JDK效率低。
     JDK调用代理方法，是通过反射机制调用，Cglib是通过FastClass机制直接调用方法，Cglib执行效率更高。
动态代理是什么？与静态代理的区别在于？
    Java中的静态代理要求代理主题 (ProxySubject)和真实主题(RealSubject)都实现同一个接口(Subject)。静态代理中代理类在编译期就已经确定，
    而动态代理则是JVM运行时动态生成，静态代理的效率相对动态代理来说相对高一些，但是静态代理代码冗余大，一但需要修改接口，代理类和委托类都需要修改。
```
#### 4.简单工厂和抽象工厂有什么区别？【5+】
```markdown
工厂方法模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类
    用来生产同一等级结构中的固定产品，支持增加任意产品。
简单工厂模式：用来产生同一等级结构中非任意产品，对新增加的产品无能为力。
抽象工厂模式：为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类
    用来生产不同产品族的全部产品，对于新增加的产品无能为力，支持增加产品族。
```
#### 5.装饰者模式和适配器模式以及代理模式的区别？
```markdown
装饰者和代理模式的区别
 装饰者模式关注的是对象的动态添加功能。代理模式关注的是对对象的控制访问，对它的用户隐藏对象的具体信息。
装饰者模式和适配器模式
 装饰者模式和被装饰的类要实现同一个接口，或者装饰类是被装饰的类的子类。适配器模式和被适配的类具有不同的接口。
 适配器模式被用于桥接两个接口，而装饰模式的目的是在不修改类的情况下给类增加新的功能。
```
#### 6.建造者模式及在jdk中的体现，建造者模式和工厂模式区别
[建造者模式及在jdk中的体现，建造者模式和工厂模式区别](https://www.cnblogs.com/lifegoeson/p/13500365.html)
```markdown
java.lang.StringBuilder类，也就是常用的可变字符串类，用到的就是建造者模式。以其中的常用方法append方法为例看源码。
```
### 31.生产者消费者模式
[生产者消费者模型在项目中的实际应用](https://www.cnblogs.com/0813lichenyu/p/11599421.html)
### 32.jdk1.8新特性
[关于Java8的精心总结](https://www.cnblogs.com/yychuyu/p/13332293.html)
```markdown
新特性：
    接口增强，使用default与static在接口中定义方法
    lambda表达式
    方法引用
    内建函数式接口
方法函数变化：    
    Hashmap 红黑树，扩容
    concurrentHashmap 红黑树，进一步减少锁的粒度
    Jvm常量池的变化，字符常量池在jdk1.7从方法区脱离放入堆中，方法区则在jdk1.8中变成元空间。
流的概念及优势，为什么有这种优势？
```
### 33.内部类【3+】
[InnerDemo1:Java内部类的四种分类以及作用](https://www.cnblogs.com/hackerstd/p/12547503.html)
>> java内部类的区别(成员内部类、静态嵌套类、方法内部类、匿名内部类 )
>>内部类的定义：在Java中，可以将一个类的定义放在另外一个类的定义内部，这就是内部类。内部类本身就是类的一个属性，与其他属性定义方式一致。
内部类的最大优点是：可以方便的访问外部类的私有操作反之，外部类也可以通过内部类对象访问内部类的私有属性，
    使用static定义内部类，一定不可能受到外部类的实例化控制，相当于一个外部类。内部类可以在方法中定义
内部类的分类有哪些:内部类可以分为四种：成员内部类、局部内部类、匿名内部类和静态内部类。
#### 1.成员内部类
```markdown
成员内部类:定义在类内部，成员位置上的非静态类，就是成员内部类。
    public class Outer {
        private static  int radius = 1;
        private int count =2;
         class Inner {
            public void visit() {
                System.out.println("visit outer static  variable:" + radius);
                System.out.println("visit outer   variable:" + count);
            }
        }
    }
    成员内部类可以访问外部类所有的变量和方法，包括静态和非静态，私有和公有。
    成员内部类依赖于外部类的实例，它的创建方式外部类实例.new内部类()，如下：
        Outer outer = new Outer();
        Outer.Inner inner = outer.new Inner();
        inner.visit();
（1）该类像是外部类的一个成员，可以无条件的访问外部类的所有成员属性和成员方法（包括private成员和静态成员）；
（2）成员内部类拥有与外部类同名的成员变量时，会发生隐藏现象，即默认情况下访问的是成员内部类中的成员。
    如果要访问外部类中的成员，需要以下形式访问：【外部类.this.成员变量或 外部类.this.成员方法】；
（3）在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问；
（4）成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象；
（5）内部类可以拥有private访问权限、protected访问权限、public访问权限及包访问权限。如果成员内部类用private修饰，则只能在外部类的内部访问；
    如果用public修饰，则任何地方都能访问；如果用protected修饰，则只能在同一个包下或者继承外部类的情况下访问；
    如果是默认访问权限，则只能在同一个包下访问。外部类只能被public和包访问两种权限修饰。
```
#### 2.局部内部类
```markdown
局部内部类:定义在方法中的内部类，就是局部内部类。
    public class Outer {
        private  int out_a = 1;
        private static int STATIC_b = 2;
        public void testFunctionClass(){
            int inner_c =3;
            class Inner {
                private void fun(){
                    System.out.println(out_a);
                    System.out.println(STATIC_b);
                    System.out.println(inner_c);
                }
            }
            Inner  inner = new Inner();
            inner.fun();
        }
        public static void testStaticFunctionClass(){
            int d =3;
            class Inner {
                private void fun(){
                    // System.out.println(out_a); 编译错误，定义在静态方法中的局部类不可以访问外部类的实例变量
                    System.out.println(STATIC_b);
                    System.out.println(d);
                }
            }
            Inner  inner = new Inner();
            inner.fun();
        }
    }
    定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法。
    局部内部类的创建方式，在对应方法内，new 内部类()，如下：
         public static void testStaticFunctionClass(){
            class Inner {}
            Inner  inner = new Inner();
         }
（1）局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内；
（2）局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。
```
#### 3.匿名内部类
```markdown
匿名内部类:匿名内部类就是没有名字的内部类，日常开发中使用的比较多。
    public class Outer {
        private void test(final int i) {
            new Service() {
                public void method() {
                    for (int j = 0; j < i; j++) {
                        System.out.println("匿名内部类" );
                    }
                }
            }.method();
        }
     }
     //匿名内部类必须继承或实现一个已有的接口 
     interface Service{
        void method();
    }
    除了没有名字，匿名内部类还有以下特点：
        匿名内部类必须继承一个抽象类或者实现一个接口。
        匿名内部类不能定义任何静态成员和静态方法。
        当所在的方法的形参需要被匿名内部类使用时，必须声明为final。
        匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。
（1）一般使用匿名内部类的方法来编写事件监听代码；
（2）匿名内部类是不能有访问修饰符和static修饰符的；
（3）匿名内部类是唯一一种没有构造器的类；
（4）匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。
```
#### 4.静态内部类
```markdown
静态内部类:定义在类内部的静态类，就是静态内部类。
    public class Outer {
        private static int radius = 1;
        static class StaticInner {
            public void visit() {
                System.out.println("visit outer static  variable:" + radius);
            }
        }
    }
    静态内部类可以访问外部类所有的静态变量，而不可访问外部类的非静态变量；静态内部类的创建方式,new外部类.静态内部类()，如下：
    Outer.StaticInner inner = new Outer.StaticInner();
    inner.visit();
（1）静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似；
（2）不能使用外部类的非static成员变量或者方法。
```
### 34.深拷⻉和浅拷⻉的区别【3+】
```markdown
克隆：克隆的对象可能包含一些已经修改过的属性，而new出来的对象的属性还是初始化时候的值，所以需要一个新的对象来保存当前对象的状态就需要克隆。
克隆的实现方式：
    1.实现Cloneable接口并重写Object类的clone()方法
    2.实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。
Person p=new Person(“张三”);
    浅拷贝:复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化。
        只复制它本身和其中包含的值的成员变量，而引用类型的成员变量没有复制。
        对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝。
    深拷贝:将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变。
        处了复制对象本身之外，对象所包含的所有成员变量业务将复制。
        对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容。
```    
### 35.说下枚举类型，底层实现原理，项目中是如何使用的
### 36.Object中的方法
[Java面试系列第2篇-Object类中的方法](https://www.cnblogs.com/extjs4/p/12772027.html)
### 37.句柄及引用，指针和句柄的区别
```markdown
句柄是一种特殊的智能指针。当一个应用程序要引用其他系统（如数据库、操作系统）所管理的内存块或对象时，就要使用句柄。
句柄就是个数字，一般和当前系统下的整数的位数一样，比如32bit系统下就是4个字节。这个数字是一个对象的唯一标示，和对象一一对应。
句柄与普通指针的区别在于，指针包含的是引用对象的内存地址，而句柄则是由系统所管理的引用标识，该标识可以被系统重新定位到一个内存地址上。
    这种间接访问对象的模式增强了系统对引用对象的控制。
```
### 38.switch
```markdown
switch是否能作用在byte上，是否能作用在long上，是否能作用在String上
在Java5以前，switch(expr)中，expr只能是byte、short、char、int。
    从Java5开始，Java中引入了枚举类型，expr也可以是enum类型，
    从Java7开始，expr还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。
```
### 39.this和super关键字的用法
```markdown
this是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。
this的用法在java中大体可以分为3种：
    1.普通的直接引用，this相当于是指向当前对象本身。
    2.形参与成员名字重名，用this来区分：
        public Person(String name, int age) {
            this.name = name;
            this.age = age;
        }
    3.引用本类的构造函数
        class Person{
            private String name;
            private int age;
            public Person() {
            }
            public Person(String name) {
                this.name = name;
            }
            public Person(String name, int age) {
                this(name);
                this.age = age;
            }
        }
super可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。
super也有三种用法：
    1.普通的直接引用
        与this类似，super相当于是指向当前对象的父类的引用，这样就可以用super.xxx来引用父类的成员。
    2.子类中的成员变量或方法与父类中的成员变量或方法同名时，用super进行区分
        class Person{
            protected String name;
            public Person(String name) {
                this.name = name;
            }
        }
        class Student extends Person{
            private String name;
            public Student(String name, String name1) {
                super(name);
                this.name = name1;
            }
            public void getInfo(){
                System.out.println(this.name);      //Child
                System.out.println(super.name);     //Father
            }
        }
        public class Test {
            public static void main(String[] args) {
               Student s1 = new Student("Father","Child");
               s1.getInfo();
            }
        }
    3、引用父类构造函数
        super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。
        this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。
```
### 40.面向对象五大基本原则
```markdown
1.单一职责原则SRP(Single Responsibility Principle)
    类的功能要单一，不能包罗万象，跟杂货铺似的。
2.开放封闭原则OCP(Open－Close Principle)
    一个模块对于拓展是开放的，对于修改是封闭的，想要增加功能热烈欢迎，想要修改，哼，一万个不乐意。
3.里式替换原则LSP(the Liskov Substitution Principle LSP)
    子类可以替换父类出现在父类能够出现的任何地方。比如你能代表你爸去你姥姥家干活。哈哈~~
4.依赖倒置原则DIP(the Dependency Inversion Principle DIP)
    高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。
    就是你出国要说你是中国人，而不能说你是哪个村子的。比如说中国人是抽象的，下面有具体的xx省，xx市，xx县。你要依赖的抽象是中国人，而不是你是xx村的。
5.接口分离原则ISP(the Interface Segregation Principle ISP)
    设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。
    就比如一个手机拥有打电话，看视频，玩游戏等功能，把这几个功能拆分成不同的接口，比在一个接口里要好的多。
```
### [1.如何判断一个元素在亿级数据中是否存在？](https://www.cnblogs.com/crossoverJie/p/10018231.html)【2+】
[如何从亿量级中判断一个数是否存在？](https://www.cnblogs.com/kubidemanong/p/10147685.html)
```markdown
1.非常大的一个数据量，无法完全放进内存，或没有必要放进内存，造成系统性能消耗。
    1.大多数想到的都是用HashMap来存放数据，因为它的写入查询的效率都比较高。
    写入和判断元素是否存在都有对应的API，所以实现起来也比较简单。会造成内存溢出。
    2.Bloom Filter：用于解决判断一个元素是否在一个集合中，但它的优势是只需要占用很小的内存空间以及有着高效的查询效率。
    因为只是需要判断数据是否存在，也不是需要把数据查询出来，所以完全没有必要将真正的数据存放进去。
    3.bitmap：采用一个二进制位来存储数据的方法。
```
### [2.面试问题---JAVA程序CPU占用过高怎么定位](https://www.cnblogs.com/nijunyang/p/13040511.html)
>> 假如生产环境出现CPU占用过高，谈一谈分析思路和定位
```markdown
结合Linux和JDK命令一起分析
    1.先用top命令找到CPU占用最高的 top |grep java  或者 jps指令找到java进程的pid（6167）
    2.ps -ef 或者jps 进一步定位，得知是一个怎么样的后台程序 top -H -p pid:以线程的形式查看该进程 top -H -p 6167
    3.定位到具体线程或者代码 ps -mp 进程 -o THREAD,tid,time
            -m 显示所有线程
            -p pid进程使用cpu的时间
            -o 该参数后面是用户自定义格式
    4.将需要的线程ID转换为16进制格式(英文小写格式)
    5.jstack 进程 ID | grep tid(16进制线程ID小写英文) -A60  jstack 6167 >threadInfo.txt   信息输出到文件 然后查看。
性能监控工具
    jps(虚拟机进程状况工具) 
    jinfo(Java配置信息工具)
    jmap(内存映射工具)
    jstat(统计信息监控工具)
```
### 3.面试题：&和&&的区别， | 和|| 的区别？
```markdown
&和| 是位运算符 ，&&和||是逻辑运算符，不能用于位运算。
&：所有的条件都要判断， && 当前一个判断为false时后面不用判断直接返回false
|：所有的条件都要判断， || 当前一个判断为true时，后面一个不用判断直接返回true
```
### 4.如何生成一个有上亿个无序不重复随机数的文件
```markdown
我：用不同区间的随机函数和HashSet生成
面试官：这会整体有序，怎么解决
我：整体再shuffle一下
面试官：有更好的办法吗？    无。。。
6. 还是上个问题，如何对这个文件中的数据排序？
我：分治思想，分成小段排序然后归并
面试官：怎么归并？
我：两两归并。说完就知道错了，然后没想出来。。
```

[各大公司面试题分类整理](https://www.cnblogs.com/lvmengtian/p/12796820.html)
[Java面试全解析](https://my.oschina.net/u/2539475?tab=newest&catalogId=6934862)
[如何短时间内快速通过Java面试](https://www.cnblogs.com/javazhiyin/p/13023668.html)
[Java 最常见的 200+ 面试题汇总:没有答案](https://www.cnblogs.com/over/p/10468747.html)
[【2019春招准备：总目录】](https://blog.csdn.net/qq_33907408/article/details/84477343)

## 二、Java I/O 【5+】
```markdown
按照流的流向分，可以分为输入流和输出流；
按照操作单元划分，可以划分为字节流和字符流；
按照流的角色划分为节点流和处理流。按照流是否直接与特定的地方（如磁盘、内存、设备等）相连，分为节点流和处理流两类。
    节点流：可以从或向一个特定的地方（节点）读写数据。如FileReader.
    处理流：是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写。如BufferedReader.处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装，称为流的链接。
Java Io流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系，
    JavaI0流的40多个类都是从如下4个抽象类基类中派生出来的。
        InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。
        OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。
字节流与字符流的区别
    字节流按8位传输以字节为单位输入输出数据。字符流按16位传输以字符为单位输入输出数据。
JAVA常用的节点流：
    文 件 FileInputStream FileOutputStrean FileReader FileWriter 文件进行处理的节点流。
    字符串 StringReader StringWriter 对字符串进行处理的节点流。
    数 组 ByteArrayInputStream ByteArrayOutputStreamCharArrayReader CharArrayWriter 对数组进行处理的节点流（对应的不再是文件，而是内存中的一个数组）。
    管 道 PipedInputStream PipedOutputStream PipedReaderPipedWriter对管道进行处理的节点流。
常用处理流（关闭处理流使用关闭里面的节点流）
    缓冲流：BufferedInputStrean BufferedOutputStream BufferedReader BufferedWriter  增加缓冲功能，避免频繁读写硬盘。
    转换流：InputStreamReader OutputStreamReader 实现字节流和字符流之间的转换。
    数据流 DataInputStream DataOutputStream  等-提供将基础数据类型写入到文件中，或者读取出来.
流的关闭顺序
    一般情况下是：先打开的后关闭，后打开的先关闭
    另一种情况：看依赖关系，如果流a依赖流b，应该先关闭流a，再关闭流b。例如，处理流a依赖节点流b，应该先关闭处理流a，再关闭节点流b
    可以只关闭处理流，不用关闭节点流。处理流关闭的时候，会调用其处理的节点流的关闭方法。
```
### 按操作方式分类结构图
![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9teS1ibG9nLXRvLXVzZS5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vMjAxOS02L0lPLSVFNiU5MyU4RCVFNCVCRCU5QyVFNiU5NiVCOSVFNSVCQyU4RiVFNSU4OCU4NiVFNyVCMSVCQi5wbmc?x-oss-process=image/format,png)
### 按操作对象分类结构图
![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9teS1ibG9nLXRvLXVzZS5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vMjAxOS02L0lPLSVFNiU5MyU4RCVFNCVCRCU5QyVFNSVBRiVCOSVFOCVCMSVBMSVFNSU4OCU4NiVFNyVCMSVCQi5wbmc?x-oss-process=image/format,png)
### BIO,NIO,AIO 有什么区别?
```markdown
BIO：Block IO同步阻塞式IO，就是我们平常使用的传统IO，它的特点是模式简单使用方便，并发处理能力低。
NIO：Non IO同步非阻塞IO，是传统IO的升级，客户端和服务器端通过Channel（通道）通讯，实现了多路复用。
AIO：AsynchronousIO是NIO的升级，也叫NIO2，实现了异步非堵塞IO ，异步IO的操作基于事件和回调机制。

BIO (Blocking I/O): 同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。
    在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的I/O并且编程模型简单，也不用过多考虑系统的过载、限流等问题。
    线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的BIO模型是无能为力的。
    因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。
NIO (New I/O): NIO是一种同步非阻塞的I/O模型，在Java1.4中引入了NIO框架，对应java.nio包，提供了Channel,Selector,Buffer等抽象。
    NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。
    NIO提供了与传统BIO模型中的Socket和ServerSocket相对应的SocketChannel和ServerSocketChannel两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。
    阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；
    对于高负载、高并发的（网络）应用，应使用NIO的非阻塞模式来开发
AIO (Asynchronous I/O): AIO也就是NIO2。在Java7中引入了NIO的改进版NIO2,它是异步非阻塞的IO模型。
    异步IO是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。
    AIO是异步IO的缩写，虽然NIO在网络操作中，提供了非阻塞的方法，但是NIO的IO行为还是同步的。
    对于NIO来说，我们的业务线程是在IO操作准备好时，得到通知，接着就由这个线程自行进行IO操作，IO操作本身是同步的。
    查阅网上相关资料，我发现就目前来说AIO的应用还不是很广泛，Netty之前也尝试使用过AIO，不过又放弃了。
```
### Files的常用方法都有哪些？
```markdown
Files.exists()：检测文件路径是否存在。
Files.createFile()：创建文件。
Files.createDirectory()：创建文件夹。
Files.delete()：删除一个文件或目录。
Files.copy()：复制文件。
Files.move()：移动文件。
Files.size()：查看文件个数。
Files.read()：读取文件。
Files.write()：写入文件。
```

## 