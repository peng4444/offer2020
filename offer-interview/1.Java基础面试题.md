# Java基础面试题总结
[一份超级详细的Java面试题【大厂面试真题+Java学习指南】](https://github.com/whx123/JavaHome)
[随笔分类 - Java](https://www.cnblogs.com/blknemo/category/1671295.html)
[TOC]


## 一、Java基础
### 0.Java语言特性
```markdown
Java语言的优点？
    ① 平台无关性，摆脱硬件束缚，“一次编写，到处运行”。
    ② 相对安全的内存管理和访问机制，避免大部分内存泄漏和指针越界。
    ③ 热点代码检测和运行时编译及优化，使程序随运行时间增长获得更高性能。
    ④ 完善的应用程序接口，支持第三方类库。
Java如何实现平台无关？
    JVM：Java编译器可生成与计算机体系结构无关的字节码指令，字节码文件不仅可以轻易地在任何机器上解释执行，还可以动态地转换成本地机器代码，转换是由JVM实现的，JVM是平台相关的，屏蔽了不同操作系统的差异。
    语言规范：基本数据类型大小有明确规定，例如int永远为32位，而C/C++ 中可能是16位、32位，也可能是编译器开发商指定的其他大小。
        Java中数值类型有固定字节数，二进制数据以固定格式存储和传输，字符串采用标准的Unicode格式存储。
```
### 1.Java数据类型，占多少个字节？【10+】
![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL0phdmElRTUlOUYlQkElRTclQTElODAlRTglQUYlQUQlRTYlQjMlOTUvSmF2YSVFNSU5RiVCQSVFNiU5QyVBQyVFNiU5NSVCMCVFNiU4RCVBRSVFNyVCMSVCQiVFNSU5RSU4Qi5wbmc?x-oss-process=image/format,png)
```markdown
基本数据类型                               对应引用数据类型          默认值
byte：一个字节，8个bit位，-2^7 ～ 2^7-1          Byte               0
char: 2个字节，16个bit位，0 ～ 2^16-1 ;         Character          '\u0000'
short：2个字节，16个bit位，-2^15 ～ 2^15-1       Short              0
int：4个字节，32个bit位，-2^31 ～ 2^31-1         Integer            0
long：8个字节，64个bit位，-2^63 ～ 2^63-1        Long               0
float：4个字节，32个bit位                       Float              0.0F
double：8个字节，64个bit位。                    Double             0.0D
boolean/用1bit 来存储，但是具体大小没有明确规定。  Boolean            false
    boolean 只有两个值：true、false，可以使用1bit 来存储，但是具体大小没有明确规定。
    JVM会在编译时期将 boolean 类型的数据转换为int，使用1来表示true，0表示false。
    JVM支持boolean数组，但是是通过读写byte数组来实现的。
包装类型:基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。
当**包装类自动装箱**时会在包装类的**valueOf方法**里进行判断，如果自动装箱的数据是在缓存池的范围内，将直接引用缓存池中的对象。
    如果像new出来的对象，即使数值范围在缓存池中，也不会走缓存池
缓存池:new Integer(123) 与 Integer.valueOf(123) 的区别在于：    
    - new Integer(123) 每次都会新建一个对象；
    - Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。
    - valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。
    在Java8中，Integer缓存池的大小默认为-128~127。
包装类缓存的范围为
        Boolean（boolean的包装类）：True，False
        Byte（byte的包装类）：缓存了-128至127的数据，也就是全部缓存了，因为byte只有8位。
        Character（char的包装类）：缓存了0至127的字符数据
        Short（short的包装类）：缓存了-127至128的数据。
        Integer（int的包装类）：缓存了-127至128的数据
        Long（long的包装类）：缓存了-127至128的数据
        Float和Double没有缓存池
float与double：Java不能隐式执行向下转型，因为这会使得精度降低。浮点型表示不能精确的表示小数。
相互转换
    int i1 = 0; 
    Integer integer1 = new Integer(i);
    Integer integer2 = new Integer(0); 
    int i2 = integer2.intValue(); 
    Boolean booleanObj1 = new Boolean(false);
    boolean baseBool1 = booleanObj.booleanValue();
    boolean baseBool2 = false;
    Boolean booleanObj2 = new Boolean(baseBool2);
short s1 = 1;s1 = s1+1;有什么错？s1+1运算时会自动提升表达式的类型为int，然后将int赋值给short类型的变量s1会出现类型转换错误。
short s1 = 1;s1 +=1;有什么错？+=是java语言规定的运算符，java编译器会对它进行特殊处理，因此可以正确编译。
```
### 2.Java四种访问权限控制【5+】
![java中四种修饰符的限制范围](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL0phdmElRTUlOUYlQkElRTclQTElODAlRTglQUYlQUQlRTYlQjMlOTUvSmF2YSVFOCVBRSVCRiVFOSU5NyVBRSVFNCVCRiVBRSVFOSVBNSVCMCVFNyVBQyVBNi5wbmc?x-oss-process=image/format,png)
```markdown
private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）
default (即缺省，什么也不写，不使用任何关键字）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。
protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。注意：不能修饰类（外部类）。
public : 对所有类可见。使用对象：类、接口、变量、方法
```
### 3.普通类和抽象类,抽象类和接口的区别【10+】
[java抽象类、多态、接口](https://www.cnblogs.com/Young111/p/10033484.html)
```markdown
抽象类和普通类的唯一区别就在于是否实例化。
抽象类、抽象方法的定义:
    抽象类定义的格式：abstract class 类名 {}
    抽象方法定义的格式：public abstract 返回值类型 方法名(参数);
    抽象类的特点
        1、抽象类和抽象方法都需要被abstract修饰。抽象方法一定要定义在抽象类中。
        2、抽象类不可以直接创建对象，原因：调用抽象方法没有意义。
        3、只有覆盖了抽象类中所有的抽象方法后，其子类才可以创建对象。否则该子类还是一个抽象类。
抽象类必须要有抽象方法吗？抽象类能使用final修饰吗？
     抽象类中可以有普通方法，也可以有抽象方法。但是有抽象方法的类一定是抽象类，抽象类中不一定有抽象方法。
     abstract和final不共存，final不能继承。abstract和static不共存 ，因为abstract不能修饰属性。
     抽象类不能直接实例化，普通类可以直接实例化。
接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。
    接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final。
    抽象类和接口都不能被实例化。抽象类和接口都可以定义抽象方法，子类/实现类必须覆写这些抽象方法。
抽象类和接口的区别
    1.**实现**：抽象类的子类使用extends来继承，接口必须使用implements来实现接口。抽象类要被子类继承，接口要被子类实现。
    2.**构造方法、静态方法**：抽象类可以有构造方法，接口中不能有构造方法。抽象类中可以包含静态方法，接口中不能包含静态方法。
    3.**实现数量**：一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过extends关键字扩展多个接口。
    4.**访问修饰符**：接口的方法默认是public，所有方法在接口中不能有实现(Java8开始接口方法可以有默认实现，只能是public abstract修饰抽象方法）。
        抽象方法可以有public、protected和default这些修饰符（抽象方法就是为了被重写所以不能使用private关键字修饰）
    5.**抽象类中可以有普通成员变量**，接口中没有普通成员变量，只能是public static final修饰的静态常量。
    6.从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。
        接⼝可以继承接⼝。抽象类可以实现(implements)接⼝，抽象类可继承具体类。抽象类中可以有静态的main⽅法。
```
### 4.值传递和引用传递的区别【5+】
[多图证明，Java到底是值传递还是引用传递？](https://mp.weixin.qq.com/s?__biz=MzU1NTkwODE4Mw==&mid=2247488415&idx=1&sn=b6e8512787df3b8ce5ebdb18883f19a6&chksm=fbcc7ea7ccbbf7b14e3af50eee3707d5edb3d5f5aaea542faa923a289a0f2475e73b0a0381a1&mpshare=1&scene=23&srcid=0902zs8emapSX9Qaq3ZakV6A&sharer_sharetime=1599008934953&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
```markdown
按值调用指方法接收调用者提供的值，按引用调用指方法接收调用者提供的变量地址。
值传递：在方法的调用过程中，实参把它的实际值传递给形参，此传递过程就是将实参的值复制一份传递到函数中，
    这样如果在函数中对该值（形参的值）进行了操作将不会影响实参的值。因为是直接复制，所以这种方式在传递大量数据时，运行效率会特别低下。
引用传递：弥补了值传递的不足，如果传递的数据量很大，直接复过去的话，会占用大量的内存空间，而引用传递就是将对象的地址值传递过去，
    函数接收的是原始值的首地址值。在方法的执行过程中，形参和实参的内容相同，指向同一块内存地址，
    也就是说操作的其实都是源数据，所以方法的执行将会影响到实际对象。
**Java语言的方法调用只支持参数的值传递**:当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。
    对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的。
```
### 5.JAVA三大特性封装、继承和多态,与C++区别【10+】
[Java 多态的实现机制](https://www.cnblogs.com/crane-practice/p/3671074.html)
[为何说要多用组合少用继承？如何决定该用组合还是继承？](https://www.cnblogs.com/appsucc/p/13117618.html)
```markdown
**面向过程**就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。
**面向对象**是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。
Java与C++区别：
​ 相同点：都是面向对象语言，并且都支持封装、继承、多态
​ 不同点：c++支持多继承，并且有指针的概念，由程序员自己管理内存；Java是单继承，可以用接口实现多继承，Java不提供指针来直接访问内存，程序内存更加安全，
        并且Java有JVM⾃动内存管理机制，不需要程序员⼿动释放⽆⽤内存。
1.封装:利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，
    只保留一些对外的接口使其与外部发生联系。用户无需关心对象内部的细节，但可以通过对象对外提供的接口来访问该对象。
    优点：
        - 减少耦合：可以独立地开发、测试、优化、使用、理解和修改
        - 减轻维护的负担：可以更容易被程序员理解，并且在调试的时候可以不影响其他模块
        - 有效地调节性能：可以通过剖析来确定哪些模块影响了系统的性能
        - 提高软件的可重用性
        - 降低了构建大型系统的风险：即使整个系统不可用，但是这些独立的模块却有可能是可用的
2.继承:继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。父类引用指向子类对象称为向上转型 。
    继承的好处：
        1、继承的出现提高了代码的复用性，提高软件开发效率。
        2、继承的出现让类与类之间产生了关系，提供了多态的前提。
    继承的注意事项
         1、在Java中，类只支持单继承，不允许多继承，也就是说一个类只能有一个直接父类。
         2、多个类可以继承一个父类。
         3、在Java中，多层继承是可以的，即一个类的父类可以再去继承另外的父类。
         4、在Java中，子类和父类是一种相对概念，也就是说一个类是某个类父类的同时，也可以是另一个类的子类。
3.多态:Java中多态体现在一个子类对象(实现类对象)既可以给这个子类(实现类对象)引用变量赋值，又可以给这个子类(实现类对象)的父类(接口)变量赋值。
    **对象可以赋给父类对象或者它实现的接口，但是运行时依然表现出子类或实现类的特征。**
    最终多态体现为父类引用变量可以指向子类对象。多态的前提是必须有子父类关系或者类实现接口关系，否则无法完成多态。
    在使用多态后的父类引用变量调用方法时，会调用子类重写后的方法。多态的底层实现是动态绑定，即在运行时才把方法调用与方法实现关联起来。
    **多态分为编译时多态和运行时多态**
        **编译时多态主要指方法的重载。**
        **运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定，即方法的重写。**
    运行时多态有三个条件：继承，覆盖（重写），向上转型
继承：子类拥有父类的某些属性和方法，子类可以替换父类；
组合：是整体与部分的关系，整体离不开部分，部分离开了整体没有意义，如飞机翅膀与飞机的关系；
聚合：也是整体与部分的关系，但整体可以分离部分，部分也可以离开整体，如火车与车厢的关系，还有就是聚合支付的列子等。
    尽管我们鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。在实际的项目开发中，我们还是要根据具体的情况，来选择该用继承还是组合。
    如果类之间的继承结构稳定，层次比较浅，关系不复杂，我们就可以大胆地使用继承。反之，我们就尽量使用组合来替代继承。
    除此之外，还有一些设计模式、特殊的应用场景，会固定使用继承或者组合。
```
### 6.Java中==与equals区别比较【10+】
```markdown
[听说你还搞不定java中的==和equals？](https://www.cnblogs.com/yichunguo/p/12383853.html)
==的作用是判断两个对象的值是否相等，即判断两个对象是不是同一个对象。
    基础数据类型==比较的是值，引用对象类型==比较的是内存地址。
equals()的作用也是判断两个对象是否相等，但是一般有两种情况：
    情况1：类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于==。
    情况2：类覆盖了equals()方法，用来比较对象的内容是否相等。（String和Integer等等都重写了equals()方法，成了值比较。）
```
#### 1.代码示例
[为什么阿里巴巴Java开发手册中强制要求整型包装类对象值用equals方法比较？]( https://www.cnblogs.com/wupeixuan/p/11759459.html )
```java
public class test1 {
    public static void main(String[] args) {
        String a = new String("ab"); // a 为⼀个引⽤
        String b = new String("ab"); // b为另⼀个引⽤,对象的内容⼀样
        String aa = "ab"; // 放在常量池中
        String bb = "ab"; // 从常量池中查找
        if (aa == bb) // true
            System.out.println("aa==bb");
        if (a == b) // false，⾮同⼀对象
            System.out.println("a==b");
        if (a.equals(b)) // true
            System.out.println("aEQb");
        if (42 == 42.0) { // true
            System.out.println("true");
        }
    }
}
```
#### 2.String重写equals()方法
```markdown
public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof String) {
            String anotherString = (String)anObject;
            int n = value.length;
            if (n == anotherString.value.length) {
                char v1[] = value;
                char v2[] = anotherString.value;
                int i = 0;
                while (n-- != 0) {
                    if (v1[i] != v2[i])
                        return false;
                    i++;
                }
                return true;
            }
        }
        return false;
    }
```
#### 3.所有整型包装类对象之间值的比较，全部使用equals方法比较。【阿里巴巴Java开发手册】
```markdown
在-128至127之间的赋值,Integer对象是在IntegerCache.cache产生，会复用已有对象，这个区间内的Integer值可以直接使用==进行判断，
    但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用equals方法进行判断。
```
#### 4.浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用equals来判断。
### 7.为什么重写equals时必须重写hashCode方法【10+】
```markdown
[HashCode()与equals()深入理解](https://www.cnblogs.com/moershiwei/p/12643626.html)
[听说你还搞不定java中的==和equals？](https://www.cnblogs.com/yichunguo/p/12383853.html)
HashCode()的作用是确定该对象在哈希表中的索引位置。
    1、如果两个对象equals为true ，他们的hashcode一定相等。
    2、如果两个对象equals为false，他们的hashcode有可能相等。
    3、如果两个对象hashcode相等，equals不一定为true。
    4、如果两个对象hashcode不相等，equals一定为false。
在散列表中，hashCode()相等即两个键值对的哈希值相等，但是哈希值相等并不一定能得出键值相等。
重写hashcode()没有同时重写equals会怎么样（或者反过来）:
    重写了hashcode保证了能映射到同一个位置，如果两个对象的内容是相同的，
    如果没有重写equals，会默认使用Object的方法，比较两个的地址，所以就会在散列集合中出现重复值，这是不合法的。
重写equals()不重写hashcode()会出现什么问题？
    在存储集合时(set类)，如果原对象.equals(新对象)，但是没有重写hashCode(),即两个对象有不同的hashcode，
    则在集合中将会存储两个两个相同值的对象，从而导致混淆。
```
#### 1.代码示例
```markdown
public static void main(String[] args) {
        String str1 = "通话";
        String str2 = "重地";
        System.out.println(String.format("str1:%d|str2:%d",str1.hashCode(),str2.hashCode()));
        System.out.println(str1.equals(str2));
}
str1:1179395|str2:1179395 两个str的hashCode()相同，但是equals()为false。
false
```
#### 2.hashCode()能否重写
```markdown
能否重写是取决于方法是否有final关键字,
查看object源码看下hashcode方法和getclass方法就知道了为啥hashcode可以getclass不行了;
```
#### 3.Integer和Long的hashCode()方法实现有什么区别？
```markdown
@Override
    public int hashCode() {
        return Integer.hashCode(value);
    }
    public static int hashCode(int value) {
            return value;
    }
@Override
    public int hashCode() {
        return Long.hashCode(value);
    }
    public static int hashCode(long value) {
        return (int)(value ^ (value >>> 32));
    }        
```
### 8.重载overload和重写override【10+】
```markdown
重写override是子类对父类的允许访问的方法的实现过程进行重新编写,发生在子类中，方法名、参数列表必须相同，
    **返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。**
    另外，如果父类方法访问修饰符为private则子类就不能重写该方法。也就是说方法提供的行为改变，而方法的外貌并没有改变。
重载overload:发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，**与方法返回值类型和访问修饰符无关**。
    **方法重载的重点是根据参数类型及个数来区分不同的方法，而不是依靠返回值的不同来确定的。**
重载与修饰符和返回值有关吗，如果定义了两个方法，方法名和参数列表都一样，但是修饰符和返回值不一样，那么虚拟机如何判断调用的是哪个方法？
        public int demo(int a, int b) {
            return a+b;
        }
        public String demo(int a, int b) {
            return "hello";
        }
```
### 9.拆箱和装箱分别是什么？分别应用在什么场景？【5+】
[深入理解Java之装箱与拆箱](https://www.cnblogs.com/kalton/p/13664943.html)
#### 1.拆箱和装箱
```markdown
拆箱和装箱：拆箱是把包装类型变成基本类型；装箱是把基本类型变成包装类型。
    自动装箱都是通过包装类的valueOf()方法来实现的;自动拆箱都是通过包装类对象的xxxValue()来实现的（如booleanValue()、longValue()等）。
    应用场景：当==两边是基本类型和包装类型的时候，包装类型会拆箱，然后==会比较基本类型的两个值；
    当equals方法的参数是基本类型的时候，基本类型会装箱，然后equals方法会先比较两个包装类型的类型，在比较值。
```
#### 2.包装类下的坑
```markdown
valueOf是static的。intValue()。这个方法不是静态的。所以如果这样写
    Integer integer = 1；
    int i = integer;
    是有可能汇报空指针异常的
```
#### 3.在使用三目运算符的过程中，可能会进行自动拆箱而导致NPE问题。【Java开发手册】
[我去，这么简单的条件表达式竟然也有这么多坑](https://www.cnblogs.com/goodAndyxublog/p/13047617.html)
```markdown
 boolean flag = true;
 boolean simpleBoolean = false;
 Boolean nullBoolean = null;
 boolean x = flag ? nullBoolean.booleanValue() : simpleBoolean;
反编译后的代码的最后一行，编译器帮我们做了一次自动拆箱，而就是因为这次自动拆箱，导致代码出现对于一个null对象nullBoolean.booleanValue()的调用，导致了NPE。
三目运算符当第二位和第三位操作数的类型相同时，则三目运算符表达式的结果和这两位操作数的类型相同。
当第二，第三位操作数分别为基本类型和该基本类型对应的包装类型时，那么该表达式的结果的类型要求是基本类型。
所以，Java开发手册中提到要高度注意第二位和第三位表达式的类型对齐过程中由于自动拆箱发生的NPE问题，
其实还需要注意使用三目运算符表达式给变量赋值的时候由于自动拆箱导致的NPE问题。
Boolean b = Boolean.valueOf(maps == null ? false : ((Boolean)maps.get("Hollis")).booleanValue());
```
### 10.Java对象构造器【5+】
[Java 构造函数的详解](https://blog.csdn.net/qq_33642117/article/details/51909346)
[构造函数没有返回值是怎么赋值的？](https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&mid=2650142944&idx=3&sn=5aee9b4e24f7457399063b57fbbff78c&chksm=f36be5c1c41c6cd78af1b586233d57c647a4cabe7daaa7067e9373a7ac8c4749cf9ca403f66f&mpshare=1&scene=23&srcid=1003M2ZU4TBeQ4dBdDrpiHYH&sharer_sharetime=1601693572860&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
```markdown
构造器的无返回值和void方法的区别
构造器是否可以重载 可以
构造器是否可以被重写 不可以
构造函数是面向对象中的一员，构造函数可以叫做构造器，它的函数名与类名相同，不用定义返回值类型，也-没有具体的返回值。
构造函数是在构建创造时对象时调用函数，**作用是可以给对象进行初始化，创建对象都必须要通过构造函数初始化**。
一个类中如果没有定义过构造函数，那么该类会有一个默认的空参数构造函数。如果在类中定义了指定的构造函数，那么该类中的默认构造函数就没有了。
构造代码块作用：给所有的对象进行统一的初始化。
public class Demo{
    Demo(){}//默认无参构造函数
    Demo(int x){}//有参数构造函数
    public static void main(String[] args){
        Demo demo = new Demo();
    }
}
多个构造函数在一个类中出现他们的存在的形式就是叫做重载。重载是在一个类里面，方法名字相同，而参数不同。返回类型可以相同 也可以不同。
**一般函数和构造函数的区别**：构造函数在创建对象时，就会调用与之对应的构造函数，对象进行初始化。
    对象创建时，构造函数会调用也只调用一次。因为构造函数命名时跟类名一样，首字母要大写；
    而一般函数对象创建后，需要函数功能时才调用。对象创建后，一般函数可以被调用多次，一般函数的命名首字母是小写的。
```
### 11.String为什么不可变【10+】
[Java源码之String](https://www.cnblogs.com/chentang/p/13067765.html)
[String求求你别秀了](https://www.cnblogs.com/zhuoqingsen/p/String.html)
```markdown
当然在Java平台类库中，包含许多不可变类，例如String , 基本类型的包装类，BigInteger,BigDecimal等等。
类本身是final修饰的；所有的域几乎都是私有final的；不会对外暴露可以修改对象属性的方法。
String类并没有提供任何可以改变其值的方法。
使用什么方式可以改变String类的不可变性：**反射**
            String str = "chen";
            System.out.println(str);
            Field field = String.class.getDeclaredField("value");
            field.setAccessible(true);
            char[] value = (char[]) field.get(str);
            value[1] = 'a';
            System.out.println(str);
String类的常用方法
    indexOf() 返回指定字符的索引
    charAt() 返回指定索引处的字符
    replace() 字符串替代
    substring() 字符串截取
    trim() 字符串去除两端的空格
    split() 分割字符串
    equals() 字符串比较
    intern() 判断字符串常量池中是否存在一个引用
[String的intern方法使用场景](https://www.cnblogs.com/54chensongxia/p/13668169.html)
String类有如下这些特点
    1.String类是final类，也即意味着String类不能被继承，并且它的成员方法都默认为final方法。
    2.String类其实是通过char数组来保存字符串的。
    3.String对象一旦被创建就是固定不变的了，对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象。
字符串常量池:
    1.每当我们创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么就直接返回常量池中的实例引用。
        如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中。由于String字符串的不可变性我们可以十分肯定常量池中一定不存在两个相同的字符串。
    2.字符串池的出现避免了相同内容的字符串的创建，节省了内存，省去了创建相同字符串的时间，同时提升了性能；
        另一方面，字符串池的缺点就是牺牲了JVM在常量池中遍历对象所需要的时间，不过其时间成本相比而言比较低。
1.单独使用""引号创建的字符串都是常量,编译期就已经确定存储到String Pool中；
2.使用new String("")创建的对象会存储到heap中,是运行期新创建的；
3.使用只包含常量的字符串连接符如"aa" + "aa"创建的也是常量,编译期就能确定,已经确定存储到String Pool中；
4.使用包含变量(引用)的字符串连接符如"aa" + s1创建的对象是运行期才创建的,存储在heap中；
5.但是如果s1是被final修饰的话，则s1是属于常量。结果存在String Pool，但是final修饰的是一个方法返回的值也是在编译器确定。
String str1 = "aaa";
String str2 = "aaa";
System.out.println(str1 == str2);// true 因为String有常量池
String str3 = new String("aaa");
String str4 = new String("aaa");
System.out.println(str3 == str4);// false 可以看出用new的方式是生成不同的对象,比较堆上的
System.out.println(str3.equals(str4)); // true equals()比较值
String s0="helloworld";  
String s1="helloworld";  
String s2="hello"+"world";  
System.out.println(s0==s1); //true 可以看出s0跟s1是指向同一个对象   
System.out.println(s0==s2); //true 可以看出s0跟s2是指向同一个对象   
String st0="helloworld";   
String st1=new String("helloworld");   
String st2="hello" + new String("world");   
System.out.println( st0==st1 ); //false    用new String() 创建的字符串不是常量，不能在编译期就确定
System.out.println( st0==st2 ); //false   st2地址存在堆中，不可能相同
System.out.println( st1==st2 ); //false  
String stri1="abc";     
String stri2="def";     
String stri3=stri1+stri2;  
System.out.println(stri3=="abcdef"); //false    变量相+是在的堆内存中创建
String strin0 = "a1";   
String strin1 = "a" + 1;   //这种不是变量，是常量
System.out.println((strin0 == strin1)); //result = true    
String strin4 = "a3.4";   
String strin5 = "a" + 3.4;   
System.out.println((strin4 == strin5)); //result = true  
String string0 = "ab";   
String string1 = "b";   
String string2 = "a" + string1;   
System.out.println((string0 == string2)); //result = false  在字符串的"+"连接中，有字符串引用存在，而引用的值在程序编译期是无法确定的
```
### 12.String str="abc" 与 String str=new String (“abc”) 一样吗？为什么？【5+】
```markdown
1.使用String直接赋值：String str= “abc”：可能创建一个或者不创建对象。
    如果”abc”在字符串常量池中不存在，会在java字符串池中创建一个String对象（”abc”），然后str指向这个内存地址，
    无论以后用这种方式创建多少个值为”abc” 的字符串对象，始终只有一个内存地址被分配；如果 “abc” 在字符串池中存在，str直接指向这个内存地址。
2.使用new String创建字符串：String str = new String(“abc”)：至少会创建一个对象，也有可能创建两个。
    因为用到new关键字，肯定会在堆中创建一个String对象，如果字符池中已经存在”abc”, 则不会在字符串池中创建一个String对象，
    如果不存在，则会在字符串常量池中也创建一个对象。注意，此时二者地址不相同。
3.String拼接字符串：字符串拼接又分为变量拼接和已知字符串拼接。只要拼接内容存在变量，那么该拼接后的新变量就是在堆内存中新建的一个对象实体。但是不会在字符常量池中创建新对象。
4.String.intern()：当调用intern方法时，如果常量池已经包含一个等于此String对象的字符串（用equals(Object)方法确定），则返回池中的字符串。
    否则，将此String对象添加到常量池中，并返回此String对象的引用。
String str=“abc” 和 String str=new String(“abc”); 产生几个对象？String str = new String("hello")+new String("123");产生了几个对象？
    前者 1 或 0， 后者 2 或 1，最后一个是 3 或 4 或 5
    先看字符串常量池，如果字符串常量池中没有，都在常量池中创建一个，如果有，前者直接引用，后者在堆内存中还需创建一个 “abc” 实例对象。
字符常量池的位置？字符常量池存储的内容？
    字符串常量池的位置，jdk1.7从方法区移至堆中。
    字符串常量池存储的是字符串字面量（注意，这里的字面量指的就是String的对象，因为String本身是一个类，而字符常量池在jdk8放在堆中，所以存储的内容全都是对象）
```
### 13.String，StringBuffer，StringBuilder的区别【10+】
[一篇与众不同的String、StringBuilder和StringBuffer详解](https://www.cnblogs.com/cxuanBlog/p/13053615.html)
```markdown
String：
    String是final类，不能被继承。String类是一个不可变的类，一旦创建就不可以修改。每次修改都会创建新的String对象。
    String实现了equals()方法和hashCode()方法。
    String类的对象是不可变的，也就可以理解为常量，线程安全。
StringBuffer：
    继承自AbstractStringBuilder，是可变类。
    StringBuffer是线程安全的，对方法加了同步锁或者对调用的方法加了同步锁。(synchronized)
    可以通过append方法动态构造数据。执行效率比StringBuffer低。
StringBuilder：
    继承自AbstractStringBuilder，是可变类。
    StringBuilder是非线性安全的。
    执行效率比StringBuffer高。
```
#### 为什么StringBuilder的执行效率比StringBuffer高？】
[用大白话的方式讲明白Java的StringBuilder、StringBuffer的扩容机制](https://www.cnblogs.com/DMingO/p/13407303.html)
```markdown
StringBuffer和StringBuilder,都是继承了AbstractStringBuilder，它们的底层char数组value默认的初始化容量是16，
    扩容只需要修改底层的char数组，两者的扩容最终都会调用到AbstractStringBuilder类相同的方法：
        扩容的步骤：
        1.新的字符串的长度超过了底层原char数组value的大小，才需要进行扩容
        2.先尝试默认扩容，将新容量变成 (value.length << 1) + 2 ，也就是两倍的原数组长度再加二
        3.若默认扩充后的值还是小于至少容量的值，直接扩充到当前需要的至少容量大小；
        4.经过前两步骤确定的新数组大小，若大于Interger.MAX_VALUE,则报异常，若小于等于0，则新数组大小改为Interger.MAX_VALUE -8
        5.确定了新数组的值后，通过Arrays.copy(value,newCapactity)进行复制。最终给value数组完成扩容。
```
### 14.int和Integer的区别【5+】
```markdown
int和Integer的区别？
    1.Integer是int的包装类，int是java的一种基本数据类型
    2.Integer变量必须实例化才能使用，而int变量不需要
    3.Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象，而int则直接存储数据值。
    4.Integer的默认值是null，int的默认值是0。
给定三个变量：i1、i2、i3。Integer i1= 120；Integer i2=120；int i3=120；i1和i2一样吗？i1和i3 呢？为什么？如果把120换成130呢，i1,12,i3的关系又如何，为什么？
integer包装类和其他包装类不同之处，对于范围在-128到127之间的整数，integer创建对象的时候是直接从缓存读取的，这个时候直接从缓存得的的内容地址是保持一致的，
所以两个integer对象地址是相同的，但是不在这个范围的时候，地址就不在相同的。
对于integer变量和int变量，通过==比较，符合拆箱应用场景，integer会直接拆箱，所以无论什么范围，integer和int，都是直接比较值的。
    1.两个基本类型的只能用 ==
    2.基本型和封装型用==，封装型将会自动拆箱变为基本型后再进行比较
    3.用==来比较两个封装类的话，比较的是地址。(其中-127到127之间的Integer地址相同，超出这个范围则不同)
    4.至少有一个封装型的建议使用.equals。用==对基本型和封装性比较必须保证封装型不为null。如果为null则不能转化为基本型就会报错。
    5.两个封装型进行equals()比较，首先equals()会比较类型，如果类型相同，则继续比较值，如果值也相同，返回true
    6.封装类型调用equals(),但是参数是基本类型，这时候，先会进行自动装箱，基本型转换为其封装类型,若类型不同返回false,若装箱后类型相同，则比较值，如果值相同，则返回true
1.当通过new创建两个Integer变量是不相等的
    Integer i1 = new Integer(100);
    Integer i2 = new Integer(100);
    System.out.println(i1==i2);//false;
2.当Integer与int进行比较时，只要两个变量的值相等，则就是true。Integer会自动拆箱为int。
    Integer i1 = new Integer(100);
    int i2 = 100;
    System.out.println(i1==i2);//true;
3.当非new的Integer和new的Integer比较时，结果为false；
    Integer i1= new Integer(100);
    Integer i2 = 100;
    System.out.println(i1==i2);//false   i1.equals(i2);//true
4.当两个非new的Integer变量比较时，值在区间-128到127之间，结果为true，否则为false。
    Integer i1 = 100;Integer i2 = 100;
    System.out.println(i1==i2);//true
    Integer i1 = 200;Integer i2 = 200;
    System.out.println(i1==i2);//false
Java在编译Integer i= 100;时，会翻译为Integer i= Integer.valueOf(100);
Integer的valueOf(int i)定义如下：
    public static Integer valueOf(int i){
        assert IntegerCache.high >=127;
        if(i>=IntegerCache.low&&iM=IntegerCache.high){
            return IntegerCache.cache(i+(-IntegerCache.low));
        }
        return new Integer(i);
    }
```
### 15.关键字static【10+】
```markdown
static是Java中非常重要的关键字，static表示的概念是静态的，在Java中，static主要用来：
    **static修饰变量**，static修饰的变量称为静态变量、也称为类变量，类变量属于类所有，对于不同的类来说，static变量只有一份，
        static修饰的变量位于**方法区**中；static修饰的变量能够直接通过**类名.变量名**来进行访问，不用通过实例化类再进行使用。
        一旦属性定义上使用了static之后，只要一个对象修改了属性的内容，那么所有的对象的static属性的内容都将一起修改，也就是说static属性变成了一个公共属性，是全局数据区。
        （static声明的属性与普通属性的最大区别是保存的内存区域的不同，还有就是static属性在没有实例化的情况下可以使用）
    **static修饰方法**，static修饰的方法被称为静态方法，静态方法能够直接通过类名.方法名来使用，在静态方法内部不能使用非静态属性和方法。
        **静态方法不需要创建对象就可以调用**。
        static方法不能直接访问非static属性或者方法（必须要产生对象后才能调用），非static方法可以直接访问static属性或者方法
    **static修饰代码块**，主要分为两种，一种直接定义在类中，使用static{}，这种被称为静态代码块，一种是在类中定义静态内部类，使用static class xxx来进行定义。
         静态代码块在非静态代码块之前执行(静态代码块—>非静态代码块—>构造方法)。 该类不管创建多少对象，**静态代码块只执行一次**。
    static用于静态导包，通过使用 import static xxx 来实现，这种方式一般不推荐使用
    static和单例模式一起使用，通过双重检查锁来实现线程安全的单例模式。
```
### 16.关键字final【10+】
[我去，你竟然还不会用 Java final 关键字](https://www.cnblogs.com/qing-gee/p/13092011.html)
```markdown
1.final修饰类：如果一个类使用了final关键字修饰，那么它就无法被继承。类中的所有成员方法都会被隐式地指定为final方法。
2.final修饰方法：被final修饰的方法不能被重写。
3.final修饰变量：可以称为常量，必须初始化。初始化之后不能被修改。
    1）final修饰的基本数据类型，对于基本数据类型来说，final修饰的变量，其值不能被改变。
    2）final修饰的引用类型，则在对其初始化之后便不能再让其指向另一个对象。  
    3）final修饰的字段，一种是static的，另外一种是没有static的。
        非static的final字段必须有一个默认值，否则编译器将会提醒没有初始化。
        static的final字段也叫常量，它的名字应该为大写，可以在声明的时候初始化，也可以通过static代码块初始化。
    4) final修饰的参数
        final关键字还可以修饰参数，它意味着参数在方法体内不能被再修改。
使⽤final关键字修饰⼀个变量时，是指引⽤变量不能变，引⽤变量所指向的对象中的内容还是可以改变的。
    final StringBuffer a=new StringBuffer("immutable");
    a=new StringBuffer("");//编译期错误
    a.append(" broken!");//可以通过编译
```
### 17.反射&反射的应用场景&反射在框架中应用【5+】
[学会反射后，我被录取了！（干货）](https://mp.weixin.qq.com/s?__biz=MzU2NDg0OTgyMA==&mid=2247492715&idx=1&sn=8786978d2bb9b5726daaa475c61aa85f&chksm=fc461998cb31908e5b716fca496f4cdb53799fe227b3fc00a7b30d4b085c2f1e3846ec61de06&mpshare=1&scene=23&srcid=0818UKrIHBlK6qpgrg7A7rBe&sharer_sharetime=1597712309970&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
[反射那些基础-Class](https://www.cnblogs.com/homejim/p/10140928.html)
#### 1.反射机制，思想，作用，原理
```markdown
JAVA反射机制是**在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；**
    这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。所有反射的入口都是java.lang.Class。
    反射的思想：在程序运行过程中确定和解析数据类的类型。
    反射的作用：对于在编译期无法确定使用哪个数据类的场景，通过反射可以在程序运行时构造出不同的数据类实例。
反射原理：首先是能够获取到Java中的反射类的字节码，然后将字节码中的方法，变量，构造函数等映射成相应的Method、Filed、Constructor等类。
```
#### 2.Java反射的主要组成部分和基本使用
![Java反射相关类](https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdU9zP8mtoSMWgz7sMaewZAoUxxdrLVARADmU5XlPnZkoGOfDhGzd8m8Z2RWLyibnuZjHW3ygE5DeTA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
```markdown
Java反射的主要组成部分有4个：
    Class：任何运行在内存中的所有类都是该Class类的实例对象，每个Class类对象内部都包含了本来的所有信息。记着一句话，通过反射干任何事，先找Class准没错！
    Field：描述一个类的属性，内部包含了该属性的所有信息，例如数据类型，属性名，访问修饰符······
    Constructor：描述一个类的构造方法，内部包含了构造方法的所有信息，例如参数类型，参数名字，访问修饰符······
    Method：描述一个类的所有方法（包括抽象方法），内部包含了该方法的所有信息，与Constructor类似，不同之处是Method拥有返回值类型信息，因为构造方法是没有返回值的。
Java反射的基本使用
    在运行时获取一个类的Class对象
    在运行时构造一个类的实例化对象
    在运行时获取一个类的所有信息：变量、方法、构造器、注解
在Java中，每一个类都会有专属于自己的Class对象，当我们编写完.java文件后，使用javac编译后，就会产生一个字节码文件.class，
在字节码文件中包含类的所有信息，如属性，构造方法，方法······当字节码文件被装载进虚拟机执行时，会在内存中生成Class对象，
它包含了该类内部的所有信息，在程序运行时可以获取这些信息。
public class SmallPineapple {
    public String name;
    public int age;
    private double weight; // 体重只有自己知道
    public SmallPineapple() {}
    public SmallPineapple(String name, int age) {
        this.name = name;
        this.age = age;
    }
    public void getInfo() {
        System.out.print("["+ name + " 的年龄是：" + age + "]");
    }
}
```
#### 3.获取类对象的三种方式
```markdown
因为Java中规定了java.lang.reflect包下的所有类的构造函数都不为public，因此，需要获得这些类的对象都需要调用Class类中适当的的方法。
    获取类对象的三种方式：
       1.Object.getClass()。通过object类的getClass()函数，由于object是根类，每一个类都有这个函数。
            SmallPineapple sp = new SmallPineapple();
            Class clazz = sp.getClass();
       2.类.class。每一个类（包括基本数据类型，注意这里基本数据类型不用转成包装类）都有一个class属性，静态属性，通过类名直接访问。
            这种获取方式只有在编译前已经声明了该类的类型才能获取到 Class 对象
            Class clazz = SmallPineapple.class;
       3.Class.forName("java.lang.System");通过Class类的静态方法forName(String className)。
            Class clazz = Class.forName("com.bean.smallpineapple");
       通过包装类的TYPE成员。对于基本数据类型，除了以上的.class方法之外，对应包装类的TYPE成员变量来获取Class对象。Double.TYPE;
    应用：
       反射是很多框架的基础
       通过反射运行配置文件
       通过反射越过泛型检查
```
#### 4.构造类的实例化对象        
```markdown
通过反射构造一个类的实例方式有2种：
    1.Class 对象调用newInstance()方法
        Class clazz = Class.forName("com.bean.SmallPineapple");
        SmallPineapple smallPineapple = (SmallPineapple) clazz.newInstance();
        smallPineapple.getInfo();
        // [null 的年龄是：0]
    即使SmallPineapple已经显式定义了构造方法，通过newInstance()创建的实例中，所有属性值都是对应类型的初始值，因为newInstance()构造实例会调用默认无参构造器。
    2.Constructor 构造器调用newInstance()方法
        Class clazz = Class.forName("com.bean.SmallPineapple");
        Constructor constructor = clazz.getConstructor(String.class, int.class);
        constructor.setAccessible(true);
        SmallPineapple smallPineapple2 = (SmallPineapple) constructor.newInstance("小菠萝", 21);
        smallPineapple2.getInfo();
        // [小菠萝 的年龄是：21]
    通过getConstructor(Object... paramTypes)方法指定获取指定参数类型的Constructor，Constructor调用newInstance(Object... paramValues) 时传入构造方法参数的值，同样可以构造一个实例，且内部属性已经被赋值。
    通过Class对象调用newInstance()会走默认无参构造方法，如果想通过显式构造方法构造实例，需要提前从Class中调用getConstructor()方法获取对应的构造器，通过构造器去实例化对象。
```
#### 5.获取一个类的所有信息
![](https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdU9zP8mtoSMWgz7sMaewZAoX2uyxysRTWA5liay39KNoFJ7WQq2CqE0lNWgiaxeIichc58AuTAic1suPg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
```markdown
Class对象中包含了该类的所有信息，在编译期我们能看到的信息就是该类的变量、方法、构造器，在运行时最常被获取的也是这些信息。
获取类中的变量（Field）
    Field[] getFields()：获取类中所有被public修饰的所有变量
    Field getField(String name)：根据变量名获取类中的一个变量，该变量必须被public修饰
    Field[] getDeclaredFields()：获取类中所有的变量，但无法获取继承下来的变量
    Field getDeclaredField(String name)：根据姓名获取类中的某个变量，无法获取继承下来的变量
获取类中的方法（Method）
    Method[] getMethods()：获取类中被public修饰的所有方法
    Method getMethod(String name, Class...<?> paramTypes)：根据名字和参数类型获取对应方法，该方法必须被public修饰
    Method[] getDeclaredMethods()：获取所有方法，但无法获取继承下来的方法
    Method getDeclaredMethod(String name, Class...<?> paramTypes)：根据名字和参数类型获取对应方法，无法获取继承下来的方法
获取类的构造器（Constructor）
    Constuctor[] getConstructors()：获取类中所有被public修饰的构造器
    Constructor getConstructor(Class...<?> paramTypes)：根据参数类型获取类中某个构造器，该构造器必须被public修饰
    Constructor[] getDeclaredConstructors()：获取类中所有构造器
    Constructor getDeclaredConstructor(class...<?> paramTypes)：根据参数类型获取对应的构造器
```
#### 6.获取注解
```markdown
Annotation[] getAnnotations()：获取该对象上的所有注解
Annotation getAnnotation(Class annotaionClass)：传入注解类型，获取该对象上的特定一个注解
Annotation[] getDeclaredAnnotations()：获取该对象上的显式标注的所有注解，无法获取继承下来的注解
Annotation getDeclaredAnnotation(Class annotationClass)：根据注解类型，获取该对象上的特定一个注解，无法获取继承下来的注解
只有注解的@Retension标注为RUNTIME时，才能够通过反射获取到该注解，@Retension 有3种保存策略：
    SOURCE：只在**源文件(.java)**中保存，即该注解只会保留在源文件中，编译时编译器会忽略该注解，例如 @Override 注解
    CLASS：保存在字节码文件(.class)中，注解会随着编译跟随字节码文件中，但是运行时不会对该注解进行解析
    RUNTIME：一直保存到运行时，用得最多的一种保存策略，在运行时可以获取到该注解的所有信息
```
#### 7.通过反射调用方法
```markdown
通过反射获取到某个Method类对象后，可以通过调用invoke方法执行。
    invoke(Oject obj, Object... args)：参数``1指定调用该方法的**对象**，参数2`是方法的参数列表值。
如果调用的方法是静态方法，参数1只需要传入null，因为静态方法不与某个对象有关，只与某个类有关。
可以像下面这种做法，通过反射实例化一个对象，然后获取Method方法对象，调用invoke()指定SmallPineapple的getInfo()方法。
    Class clazz = Class.forName("com.bean.SmallPineapple");
    Constructor constructor = clazz.getConstructor(String.class, int.class);
    constructor.setAccessible(true);
    SmallPineapple sp = (SmallPineapple) constructor.newInstance("小菠萝", 21);
    Method method = clazz.getMethod("getInfo");
    if (method != null) {
        method.invoke(sp, null);
    }
    // [小菠萝的年龄是：21]
```
#### 8.反射的应用场景
```markdown
反射常见的应用场景这里介绍3个：
1.Spring实例化对象：当程序启动时，Spring会读取配置文件applicationContext.xml并解析出里面所有的标签实例化到IOC容器中。
    在Spring中，经常会编写一个上下文配置文件applicationContext.xml，里面就是关于bean的配置，程序启动时会读取该xml文件，解析出所有的<bean>标签，并实例化对象放入IOC容器中。
    <?xml version="1.0" encoding="UTF-8"?>
    <beans xmlns="http://www.springframework.org/schema/beans"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
        <bean id="smallpineapple" class="com.bean.SmallPineapple">
            <constructor-arg type="java.lang.String" value="小菠萝"/>
            <constructor-arg type="int" value="21"/>
        </bean>
    </beans>
    在定义好上面的文件后，通过ClassPathXmlApplicationContext加载该配置文件，程序启动时，Spring会将该配置文件中的所有bean都实例化，放入IOC容器中，IOC容器本质上就是一个工厂，通过该工厂传入<bean>标签的id属性获取到对应的实例。
    public class Main {
        public static void main(String[] args) {
            ApplicationContext ac =
                    new ClassPathXmlApplicationContext("applicationContext.xml");
            SmallPineapple smallPineapple = (SmallPineapple) ac.getBean("smallpineapple");
            smallPineapple.getInfo(); // [小菠萝的年龄是：21]
        }
    }
    Spring 在实例化对象的过程经过简化之后，可以理解为反射实例化对象的步骤：
        获取Class对象的构造器
        通过构造器调用newInstance()实例化对象
    当然 Spring 在实例化对象时，做了非常多额外的操作，才能够让现在的开发足够的便捷且稳定。
2.反射+工厂模式：通过反射消除工厂中的多个分支，如果需要生产新的类，无需关注工厂类，工厂类可以应对各种新增的类，反射可以使得程序更加健壮。
    传统的工厂模式，如果需要生产新的子类，需要修改工厂类，在工厂类中增加新的分支；
    public class MapFactory {
        public Map<Object, object> produceMap(String name) {
            if ("HashMap".equals(name)) {
                return new HashMap<>();
            } else if ("TreeMap".equals(name)) {
                return new TreeMap<>();
            } // ···
        }
    }
    利用反射和工厂模式相结合，在产生新的子类时，工厂类不用修改任何东西，可以专注于子类的实现，当子类确定下来时，工厂也就可以生产该子类了。
    反射 + 抽象工厂的核心思想是：在运行时通过参数传入不同子类的全限定名获取到不同的Class对象，调用newInstance()方法返回不同的子类。
        细心的读者会发现提到了子类这个概念，所以反射 + 抽象工厂模式，一般会用于有继承或者接口实现关系。
    例如，在运行时才确定使用哪一种 Map 结构，我们可以利用反射传入某个具体 Map 的全限定名，实例化一个特定的子类。
    public class MapFactory {
        /**
         * @param className 类的全限定名
         */
        public Map<Object, Object> produceMap(String className) {
            Class clazz = Class.forName(className);
            Map<Object, Object> map = clazz.newInstance();
            return map;
        }
    }
    className 可以指定为 java.util.HashMap，或者 java.util.TreeMap 等等，根据业务场景来定。
3.JDBC连接数据库：使用JDBC连接数据库时，指定连接数据库的驱动类时用到反射加载驱动类
    在导入第三方库时，JVM不会主动去加载外部导入的类，而是等到真正使用时，才去加载需要的类，正是如此，我们可以在获取数据库连接时传入驱动类的全限定名，交给JVM加载该类。
    public class DBConnectionUtil {
        /** 指定数据库的驱动类 */
        private static final String DRIVER_CLASS_NAME = "com.mysql.jdbc.Driver";
        public static Connection getConnection() {
            Connection conn = null;
            // 加载驱动类
            Class.forName(DRIVER_CLASS_NAME);
            // 获取数据库连接对象
            conn = DriverManager.getConnection("jdbc:mysql://···", "root", "root");
            return conn;
        }
    }
```
#### 9.Java实现反射的三种方法
```markdown
1.通过new对象实现反射机制 
2.通过路径实现反射机制 
3.通过类名实现反射机制
    public class Student {
        private int id;
        String name;
        protected boolean sex;
        public float score;
    }
    public class Get {
        //获取反射机制三种方式
        public static void main(String[] args) throws ClassNotFoundException {
            //方式一(通过建立对象)
            Student stu = new Student();
            Class classobj1 = stu.getClass();
            System.out.println(classobj1.getName());
            //方式二（所在通过路径-相对路径）
            Class classobj2 = Class.forName("fanshe.Student");
            System.out.println(classobj2.getName());
            //方式三（通过类名）
            Class classobj3 = Student.class;
            System.out.println(classobj3.getName());
        }
    }
Class里面存储了对应类的所有信息，因此，我们可以获得类相关的信息。突破私有字段的保护机制，访问并修改对象的私有字段。
反射中，Class.forName()和ClassLoader.loadClass()区别？
     Class.forName()执行的是类加载过程的链接和初始化。需要整个类完全加载到内存中，以获取该类的信息。
     ClassLoader.loadClass()执行的只是类加载过程中的第一步，加载过程。
        loadClass方法是在双亲委派中调用，此时判断类由哪一个类加载器加载，因此类还未加载到内存中。
```
#### 10.反射的优势及缺陷
```markdown
反射的优点：
    增加程序的灵活性：面对需求变更时，可以灵活地实例化不同对象
反射也有两个比较隐晦的缺点：
    破坏类的封装性：可以强制访问private修饰的信息
    性能损耗：反射相比直接实例化对象、调用方法、访问变量，中间需要非常多的检查步骤和解析步骤，JVM无法对它们优化。
```
### 18.java序列化？什么情况下需要序列化？如何避免序列化对象中的属性序列化？【5+】
[序列化的几种方式](https://www.jianshu.com/p/7298f0c559dc)
[教你彻底学会Java序列化和反序列化](https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&mid=2650142384&idx=3&sn=698657548eb08a816eaee1ff5b4aa268&chksm=f36beb91c41c62874fa4186efab7cc6621a01843962ed44a3e68355abea14774203836f02786&mpshare=1&scene=23&srcid=0922kAWPm94lsLFKmDRjNxrw&sharer_sharetime=1600739102767&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
```markdown
内存中的数据对象只有转换为二进制流才可以进行数据持久化和网络传输。
    Java序列化是指把Java对象转换为字节序列的过程。（Serialization）。
    Java反序列化是指把字节序列恢复为Java对象的过程。
1.在Java中，可以通过多种方式来创建对象，并且只要对象没有被回收我们都可以复用此对象。
    但是，创建出来的这些对象都存在于JVM中的堆（stack）内存中，只有JVM处于运行状态的时候，这些对象才可能存在。
    一旦JVM停止，这些对象也就随之消失；但是在真实的应用场景中，我们需要将这些对象持久化下来，
    并且在需要的时候将对象重新读取出来，Java的序列化可以帮助我们实现该功能。
2.对象序列化机制（object serialization）是java语言内建的一种对象持久化方式，
    通过对象序列化，可以将对象的状态信息保存为字节数组，并且可以在有需要的时候将这个
    字节数组通过反序列化的方式转换成对象，对象的序列化可以很容易的在JVM中的活动对象和字节数组（流）之间进行转换。
3.Java类通过实现java.io.Serializable接口来启用序列化功能，未实现此接口的类将无法将其任何状态或者信息进行序列化或者反序列化。
    可序列化类的所有子类型都是可以序列化的。序列化接口没有方法或者字段，仅用于标识可序列化的语义。
    在JAVA中，对象的序列化和反序列化被广泛的应用到RMI（远程方法调用）及网络传输中。
属性避免序列化：
    1.静态数据不能被序列化，因为静态数据不在堆内存中，而是在静态方法区中
    2.将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。
**为什么需要序列化和反序列化？**
    1.实现分布式，核心在于RMI，可以利用对象序列化运行远程主机上的服务，实现运行的时候，就像在本地上运行Java对象一样。
    2.实现递归保存对象，进行序列化的时候，单单并不是保存一个对象，而是递归的保存一整个对象序列，即递归保存，通过反序列化，可以递归的得到一整个对象序列。
    3.序列信息可以永久保存，用于序列化的信息，可以永久保存为文件，或者保存在数据库中，在使用的时候，再次随时恢复到内存中，实现内存中的类的信息可以永久的保存。
    4.数据格式统一，实现数据可以完整的传输和保存。然后进行反序列化还原，即对象还是对象，文件还是文件。
Transient关键字:Transient关键字，加上以后，可以阻止该变量被序列化到文件中，反序列化以后，变量的值设定为初始值。
实现Java序列化和反序列化
    import java.io.Serializable;
    import org.apache.commons.lang3.builder.ToStringBuilder;
    import org.apache.commons.lang3.builder.ToStringStyle;
    public class User1 implements Serializable{
      private String name;
      private int age;
      public String getName() {
        return name;
      }
      public void setName(String name) {
        this.name = name;
      }
      public int getAge() {
        return age;
      }
      public void setAge(int age) {
        this.age = age;
      }
      @Override
      public String toString() {
        return new ToStringBuilder(this, ToStringStyle.MULTI_LINE_STYLE)
                       .append("name", name)
                       .append("age", age)
                       .toString();
      }
    }
//进行序列化,以及反序列化
public class SerializableDemo1 {
  public static void main(String[] args) throws Exception, IOException {
    //初始化对象
    User1 user = new User1();
        user.setName("yaomy");
        user.setAge(23);
        System.out.println(user);
        //序列化对象到文件中
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("template"));
        oos.writeObject(user);
        oos.close();
        //反序列化
        File file = new File("template");
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file));
        User1 newUser = (User1)ois.readObject();
        System.out.println(newUser.toString());
  }
}
```
### 19.类的实例化顺序【5+】
```markdown
类实例化顺序为：父类静态代码块/静态域->子类静态代码块/静态域 -> 父类非静态代码块 -> 父类构造器 -> 子类非静态代码块 -> 子类构造器
代码。。。。
```
### 20.Java泛型【5+】
[用了这么多年的 Java 泛型，你对它到底有多了解？](https://www.cnblogs.com/goodAndyxublog/p/12934938.html)
[如何在运行时(Runtime)获得泛型的真正类型](https://www.cnblogs.com/xiaoheike/p/9867060.html)
[面试官：十问泛型，你能扛住吗？](https://www.cnblogs.com/viyoung/p/13175128.html)
[基础篇：深入解析JAVA泛型和Type类型体系](https://www.cnblogs.com/cscw/p/13780497.html)
#### JAVA的Type类型体系
```markdown
Type是所有类型（原生类型-Class、参数化类型-Parameterizedtype、数组类型-GenericArrayType、类型变量-TypeVariable、基本类型-Class）的共同接口;
    反射和注解讲到的Class<T>就是Type的一实现类
Type下面又有四个子接口类ParameterizedType、TypeVariable、GenericArrayType、WildcardType
    List<E>表示泛型，E是TypeVariable类型，List<String>则是ParameterizedType(参数化类型)，List<String>里的String称为实际参数类型
    具体化泛型中的类型时，可以使用 ? extends 或 ? super来表示继承关系；如List<\? extends Data\>，而里面的 ? 称为通配符类型
    GenericArrayType表示一种元素类型是ParameterizedType（参数化类型）或者TypeVariable（类型变量）的数组类型，如T[] 或者 List[]
注解是JDK1.5才出现了的，为了表示被注解的类型的，加入AnnotatedElement类型，字面意思就是被注解的元素。JDK1.8又有了AnnotatedType将Type和被注解元素的概念关联起来。
AnnotatedType也有四个子接口，和Type的四个子接口一一对应，如：ParameterizedType类型被注解则被编译器解析成AnnotatedParameterizedType: @AnTest("list")List<String>list
```
#### Java泛型
```markdown
泛型的本质是参数化类型，把类型明确的工作推迟到创建对象或调用方法的时候才去明确的特殊的类型。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口和泛型方法。
Java泛型实现方式：Java采用类型擦除（Type erasure generics）的方式实现泛型。
    泛型只存在源码中，编译器将源码编译成字节码之时，就会把泛型『擦除』，所以字节码中并不存在泛型。
    并不是每一个泛型参数被擦除类型后都会变成Object类，如果泛型类型为T extends String这种方式，最终泛型擦除之后将会变成String。
类型擦除带来的缺陷：
    1.不支持基本数据类型,但是Java是可以向上转型的。查看字节码，泛型参数被擦除之后，强制变成了Object类型。
    2.Java类型擦除式泛型实现方式无论使用效果与运行效率全面落后于C#的具现化式泛型。
    3.由于编译之后，泛型就被擦除，所以在代码运行期间，Java虚拟机无法获取泛型的实际类型。
泛型的好处：① 类型安全，放置什么出来就是什么，不存在ClassCastException。
          ② 提升可读性，编码阶段就显式知道泛型集合、泛型方法等处理的对象类型。
          ③ 代码重用，合并了同类型的处理代码。
```
### 21.Java创建对象的过程【5+】
```markdown
User user = new User();
1.类加载检查：虚拟机遇到一条new指令时，首先去检查这个指令能否在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类
    是否被加载过、解析过和初始化过。如果没有，那必须先执行相应的类加载过程。
2.分配内存：在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便确认了，为对象分配空间的任务
    等同于把一块确定大小的内存从Java堆中划分出来。分配方式有指针碰撞和空闲列表。
    虚拟机采用两种方式保证线程安全：CAS+失败重试，TLAB。
3.初始化零值：保证对象的实例字段在Java代码中可以不赋初始值就直接使用。
4.设置对象头：对象的元数据信息，对象的哈希码，对象的GC分代年龄等等信息放在对象头中。
5.执行init方法：执行new指令之后会接着执行<init>方式，把对象按照意愿进行初始化。
```
### 22.Java创建对象有几种方式【5+】
```markdown
Java创建对象有5种方式
    用new语句创建对象。（要求该Class对象对应的类有默认的空构造器）
    使用反射，使用Class.newInstance()创建对象/调用类对象的构造方法——Constructor
    调用对象的clone()方法。
    运用反序列化手段，调用java.io.ObjectInputStream对象的readObject()方法。
```
### 23.Java中的异常处理机制和应⽤【10+】
![Java异常体系](https://uploadfiles.nowcoder.com/files/20200810/176673786_1597021488566_u31373892961222888772fm26gp0.jpg)
[Java学习笔记——异常（Exception）](https://www.cnblogs.com/Askia-OpenSource/p/13849161.html)
```markdown
Java对异常进⾏了分类，不同类型的异常分别⽤不同的Java类表示，所有异常的根类为java.lang.Throwable
    java.lang.Throwable派⽣了两个⼦类：Error和Exception:
        Error:是指java运行时系统的内部错误和资源耗尽错误。应用程序不会抛出该类对象。如果出现了这样的错误，除了告知用户，剩下的就是尽力使程序安全的终止。
            Error错误类：NoClassDefFoundError、StackOverFlowError、OutOfMemoryError。
        Exception包含：RuntimeException、CheckedException表示查询需要捕捉，需要处理的异常，是由程序设计出现的问题，程序必须处理。
            RuntimeException：运行时异常，如NullPointerException、ClassCastException、IndexOutOfBoundsException，NumberFormatException,IllegalArgumentException
        ​       RuntimeException是那些可能在Java虚拟机正常运行期间抛出的异常的超类，这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。
            CheckedException：受检异常，如I/O错误导致的FileNotFoundException、ClassNotFoundException、IOException、SQLException；CheckedException：
                一般是外部错误，这种异常都发生在编译阶段，Java编译器会强制程序去捕获此类异常，即会出现要求你把这段可能出现异常的程序进行try catch，
            该类异常一般包括几个方面：
        ​       ①试图在文件尾部读取数据
        ​       ②试图打开一个错误格式的URL
        ​       ③试图根据给定的字符串查找class对象，而这个字符串表示的类并不存在
Error和Exception的区别
    Throwable是Java语言中所有错误或异常的超类。下一层分为Error和Exception。
        Error和Exception都是继承Throwable类，它们体现Java设计者在对异常的不同情况所进行的分类处理，
        **在Java中只有Throwable类的实例才能被try/catch捕获或者声明抛出。**
    Error在大多数情况下代表程序出现了致命并且不可恢复的错误，它们大多都是不可预测的错误，不需要也不能捕获和抛出，
        例如常见的OutOfMemeryError，StackOverFlowError，还有本文提到的 NoClassDefFoundError，他们都是Error的子类。
    Exception属于程序错误，大多是人为编码所导致的，它们大多都可以预测，也可以通过程序处理让程序正常流程，所以是需要进行捕获（try/catch）或者声明抛出（throw）的，
        Exception还分两种情况，可检查异常checked exception（编译期异常），非检查异常unchecked exception（运行期异常）
    常见的RuntimeException异常：
        - NullPointerException 空指针异常
        - ArithmeticException 出现异常的运算条件时，抛出此异常
        - IndexOutOfBoundsException 数组索引越界异常
        - ClassNotFoundException 找不到类异常
        - IllegalArgumentException(非法参数异常)
    常见的 Checked Exception 异常：
        - IOException (操作输入流和输出流时可能出现的异常)
        - ClassCastException(类型转换异常类)
java异常的执行流程？
    在Java应用程序中，异常处理机制为：抛出异常，捕捉异常。
    抛出异常：当一个方法出现错误引发异常时，方法创建异常对象并交付运行时系统，异常对象中包含了异常类型和异常出现时的程序状态等异常信息。
    运行时系统负责寻找处置异常的代码并执行。
    捕捉异常：在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器（exception handler）。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。
    当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适的异常处理器。运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常
    处理器的方法并执行。当运行时系统遍历调用栈而未找到合适的异常处理器，则运行时系统终止。同时，意味着Java程序的终止。
```        
### 24.throw和throws的区别？【5+】
[异常机制及throw与throws的区别](https://blog.csdn.net/ronawilliam/article/details/3299676)
```markdown
throws语句　  
    throws总是出现在一个函数头中，用来标明该成员函数可能抛出的各种异常。对大多数Exception子类来说，Java编译器会强迫你声明在一个成员函数中抛出的异常的类型。
    如果异常的类型是Error或RuntimeException，或它们的子类，这个规则不起作用，因为这在程序的正常部分中是不期待出现的。如果你想明确地抛出一个RuntimeException，你必须用throws语句来声明它的类型。  
throw语句　  
    throw总是出现在函数体中，用来抛出一个异常。程序会在throw语句后立即终止，它后面的语句执行不到，然后在包含它的所有try块中（可能在上层调用函数中）从里向外寻找含有与其匹配的catch子句的try块。
区别一：throw是语句抛出一个异常；throws是方法抛出一个异常；
区别二：throws可以单独使用，但throw不能；
区别三：throw要么和try-catch-finally语句配套使用，要么与throws配套使用。但throws可以单独使用，然后再由处理异常的方法捕获。
try-catch-finally 中哪个部分可以省略？finally 可以省略，其他都不可以省略
try-catch-finally中，如果catch中return了，finally 还会执行吗？
    在try块中即便有return，break，continue等改变执行流的语句，finally也会执行。try…catch…finally中的return只要能执行，就都执行了，他们共同向同一个内存地址
（假设地址是 0×80）写入返回值，后执行的将覆盖先执行的数据，而真正被调用者取的返回值就是最后一次写入的。finally中的return会覆盖try或者catch中的返回值。
finally中的return和方法的return不能共存，因为finally是异常处理的最后执行的部分，finally必定执行，内部的return跟方法最后的return存在冲突。
```
### 26.NoClassDefFoundError和ClassNotFoundException区别【1+】
[聊聊面试-NoClassDefFoundError和ClassNotFoundException区别](https://www.cnblogs.com/xiao2shiqi/p/11740563.html)
```markdown
当应用程序运行的过程中尝试使用类加载器去加载Class文件的时候，如果没有在classpath中查找到指定的类，就会抛出ClassNotFoundException。
当JVM在加载一个类的时候，如果这个类在编译时是可用的，但是在运行时找不到这个类的定义的时候，JVM就会抛出一个NoClassDefFoundError错误。
比如当我们在new一个类的实例的时候，如果在运行是类找不到，则会抛出一个NoClassDefFoundError的错误。（这个情况是我们的class文件被删除了）
总结：当动态加载Class的时候找不到类会抛出异常，当编译后找不到类的时候，会抛error
```
### 27.java中的assert关键字及用法【1+】
[Java陷阱之assert关键字](https://www.cnblogs.com/549294286/p/3303101.html)
```markdown
断言语句在调试代码阶段非常有用，一般用于程序不准备通过捕获异常来处理的错误。
在代码调试阶段让断言语句发挥作用，这样就可以发现一些致命的错误，当程序正式运行时，关闭断言语句但仍让其保留，可用于以后可能的再次调试中。
Java解释器直接运行应用程序时，默认关闭断言语句，在调试程序时可以用-ea启用断言语句，如：java -ea mianClass。
assert关键字语法很简单，有两种用法：
    1、assert <boolean表达式>
        如果<boolean表达式>为true，则程序继续执行。
        如果为false，则程序抛出AssertionError，并终止执行。
    2、assert <boolean表达式> : <错误信息表达式>
        如果<boolean表达式>为true，则程序继续执行。
        如果为false，则程序抛出java.lang.AssertionError，并输入<错误信息表达式>。
断言语句格式：
    assert booleanExpression;
    assert booleanExpression：messageException;
说明：
第一种格式，booleanExpression是求值为boolean值得表达式，当值为true时，继续执行，否则停止执行；
第二种格式，会在结果区输出包含messageException（字符串表达式）的信息，用于提示出现了怎样的问题。形式如：
assert 0>1："0不大于1";
将提示：
Exception in thread "main" java lang AssertionError：0不大于1,at  ***.main(***.java:7)
```
### 28.final, finally, finalize的区别【5+】
```markdown
final用于修饰属性,方法和类, 分别表示属性不能被重新赋值, 方法不可被覆盖, 类不可被继承。
    内部类要访问局部变量，局部变量必须定义成final类型。
finally是异常处理语句结构的一部分，一般以ty-catch-finally出现，finally代码块表示总是被执行。
finalize是Object类的一个方法，该方法一般由垃圾回收器来调用，当我们调用System.gc()方法的时候，
    由垃圾回收器调用finalize()方法，回收垃圾，JVM并不保证此方法总被调用。
```
### 29.try-catch-finally 语法块的执行顺序等问题【5+】
[try、catch、finally语句中有return的各类情况](https://www.cnblogs.com/yychuyu/p/13199329.html)
```markdown
1.try异常之前的会打印，异常之后的不会打印，异常之后的return不会执行，假如无异常，try中return需要等待finally执行完成后返回。
2.catch捕获异常，catch有return,finally有return，只返回finally中的return，**打印异常信息在最后进行**
3.try无异常，try有返回值，finally有return那就是只返回finally中的return，
    return语句已经执行了再去执行finally语句，不过并没有直接返回，而是等finally语句执行完了再返回结果
try-catch-finally中如果catch中return了finally一定会执行，catch中的return会等finally中的代码执行完成之后执行。
try-catch-finally其中catch和finally都可以被省略，但是不能同时省略。
public class Test{
    public static void main(String[] args){
        System.out.println(new Test().test());
    }
    static int test(){
        int x = 1;
        try{
            return x;
        }finally{
            ++x;
        }
    }
    ----------执行结果---------
    1
}
public class Test{
    public static void main(String[] args){
        Test t = new Test();
        int ans = t.get();
        System.out.println(ans);
    }
    public int get(){
        try{
            return 1;
        }finally{
            return 2;
        }
    }
    ----------返回结果------------
    2
    原因：try中的return语句调用先于finally中调用的函数执行，也就是说return语句先执行，finally语句后执行，所以结果是2。
    try中的return 1;执行后，将返回结果保存到方法的方法栈中，此时方法并不是立即返回，还有执行finally语句后才真正开始返回。
}
public class Test{
    public static void main(String[] args){
        System.out.println(new Test().test());
    }
    int test(){
        try{
            return func1();
        }finally{
            return func2();
        }
    }
    int func1(){
        System.out.println("func1");
        return 1;
    }
    int func2(){
        System.out.println("func2");
        return 2;
    }
    ----------执行结果-----------
    func1
    func2
    2 结论：finally 中的代码比return 和break 语句后执行
}
```
### 30.设计模式【10+】
[设计模式也可以这么简单](https://javadoop.com/post/design-pattern)
[设计模式之禅读书笔记-22个设计模式](https://www.cnblogs.com/floor/archive/2004/01/13/12961398.html)
[一次代码优化的实践（模板方法+策略+工厂方法模式）](https://www.cnblogs.com/jay-huaxiao/p/13716072.html)
#### 1.熟悉的设计模式
```markdown
**创建型**在创建对象的同时隐藏创建逻辑，不使用new直接实例化对象，程序在判断需要创建哪些对象时更灵活。
    包括工厂/抽象工厂/单例/建造者/原型模式。
**结构型**通过类和接口间的继承和引用实现创建复杂结构的对象。
    包括适配器/桥接模式/过滤器/组合/装饰器/外观/享元/代理模式。
**行为型**通过类之间不同通信方式实现不同行为。
    包括责任链/命名/解释器/迭代器/中介者/备忘录/观察者/状态/策略/模板/访问者模式。
```
#### 2.单例模式【1+】
[【极客思考】设计模式：你确定你真的理解了单例模式吗？](https://www.cnblogs.com/huaweiyun/p/12973585.html)
[对于单例模式面试官会怎样提问呢？你又该如何回答呢？](https://www.cnblogs.com/Ccwwlx/p/13053922.html)
```markdown
单例模式属于创建型模式，一个单例类在任何情况下都只存在一个实例，构造方法必须是私有的、由自己创建一个静态变量存储实例，对外提供一个静态公有方法获取实例。
    优点是内存中只有一个实例，减少了开销，尤其是频繁创建和销毁实例的情况下并且可以避免对资源的多重占用。
    缺点是没有抽象层，难以扩展，与单一职责原则冲突。
Spring的ApplicationContext创建的Bean实例都是单例对象，还有ServletContext、数据库连接池等也都是单例模式。
/饿汉式，类加载时就实例化一个对象，能快速创一个单例对象，而且线程安全(只有类加载时初始化)，缺点是不支持延迟加载，不管要不要都会直接创一个对象
public class Singleton {
   private static final Singleton instance = new Singleton();
   private Singleton() {}
   public staticSingleton getInstance() {
     return instance;
   }
}
//懒汉式单例，只有在调用getInstance时才会实例化一个单例对象,优点是支持延迟加载，缺点是调用方***频繁加锁释放锁，并发度比较低
public class Singleton {
    public static Singleton instance = null;
    private Singleton(){}
    public static synchronized Singleton getInstance(){
      if(instance==null){       //step 1.
         instance = new Singleton();  //step 2
       }
    return instance;
    }
}
//双重检测，支持延迟加载和高并发。只要 instance 被创建之后，再调用 getInstance() 函数都不会进入到加锁逻辑中
public class Singleton {
  private static volatile Singleton instance = null;
  private Singleton() {}
  public static Singleton getInstance() {
    if (instance == null) {
      synchronized(Singleton.class) { // 此处为类级别的锁
        if (instance == null) {
          instance = new Singleton();
        }
      }
    }
    return instance;
  }
}
```
#### 3.代理模式有什么用？应用场景是什么？【5+】
```markdown
代理（Proxy）模式是结构型的设计模式之一，它可以为其他对象提供一种代理（Proxy）以控制对这个对象的访问。
所谓代理，是指具有与被代理的对象具有相同的接口的类，客户端必须通过代理与被代理的目标类交互。
应用场景：
     需要控制对目标对象的访问。
     需要对目标对象进行方法增强。如：添加日志记录，计算耗时等。
     需要延迟加载目标对象。
    SpringAOP Hibernate数据查询，测试框架的后端mock，rpc,Java注释对象获取等等。
实现动态代理的两种方式：JDK动态代理和Gglib动态代理
     JDK动态代理是实现了被代理对象的接口，Cglib是继承了被代理对象。
     JDK和Cglib都是在运行期生成字节码，JDK是直接写Class字节码，Cglib使用ASM框架写Class字节码，Cglib代理实现更复杂，生成代理类比JDK效率低。
     JDK调用代理方法，是通过反射机制调用，Cglib是通过FastClass机制直接调用方法，Cglib执行效率更高。
动态代理是什么？与静态代理的区别在于？
    Java中的静态代理要求代理主题 (ProxySubject)和真实主题(RealSubject)都实现同一个接口(Subject)。静态代理中代理类在编译期就已经确定，
    而动态代理则是JVM运行时动态生成，静态代理的效率相对动态代理来说相对高一些，但是静态代理代码冗余大，一但需要修改接口，代理类和委托类都需要修改。
```
#### 4.简单工厂和抽象工厂有什么区别？【5+】
```markdown
简单工厂模式指由一个工厂对象来创建实例，客户端不需要关注创建逻辑，只需提供传入工厂的参数。
    适用于工厂类负责创建对象较少的情况，缺点是如果要增加新产品，就需要修改工厂类的判断逻辑，违背开闭原则，且产品多的话会使工厂类比较复杂。
    Calendar抽象类的 getInstance方法，调用createCalendar方法根据不同的地区参数创建不同的日历对象。
    Spring中的BeanFactory使用简单工厂模式，根据传入一个唯一的标识来获得Bean对象。
工厂方法模式指定义一个创建对象的接口，让接口的实现类决定创建哪种对象，让类的实例化推迟到子类中进行。
    客户端只需关心对应工厂而无需关心创建细节，主要解决了产品扩展的问题，在简单工厂模式中如果产品种类变多，工厂的职责会越来越多，不便于维护。
    Collection接口这个抽象工厂中定义了一个抽象的iterator工厂方法，返回一个Iterator类的抽象产品。该方法通过ArrayList、HashMap等具体工厂实现，返回Itr、KeyIterator等具体产品。
    Spring的FactoryBean接口的getObject方法也是工厂方法。
抽象工厂模式指提供一个创建一系列相关或相互依赖对象的接口，无需指定它们的具体类。
    客户端不依赖于产品类实例如何被创建和实现的细节，主要用于系统的产品有多于一个的产品族，而系统只消费其中某一个产品族产品的情况。抽象工厂模式的缺点是不方便扩展产品族，并且增加了系统的抽象性和理解难度。
    java.sql.Connection接口就是一个抽象工厂，其中包括很多抽象产品如Statement、Blob、Savepoint等。
```
#### 5.装饰者模式和适配器模式以及代理模式的区别？
```markdown
装饰器模式属于结构型模式，在不改变原有对象的基础上将功能附加到对象，相比继承可以更加灵活地扩展原有对象的功能。
    装饰器模式适合的场景：在不想增加很多子类的前提下扩展一个类的功能。
    java.io 包中，InputStream 字节输入流通过装饰器 BufferedInputStream 增强为缓冲字节输入流。
装饰者和代理模式的区别
 装饰者模式关注的是对象的动态添加功能。代理模式关注的是对对象的控制访问，对它的用户隐藏对象的具体信息。
适配器模式属于结构型模式，它作为两个不兼容接口之间的桥梁，结合了两个独立接口的功能，将一个类的接口转换成另外一个接口使得原本由于接口不兼容而不能一起工作的类可以一起工作。
    缺点是过多使用适配器会让系统非常混乱，不易整体把握。
    java.io 包中，InputStream字节输入流通过适配器InputStreamReader转换为Reader字符输入流。
    Spring MVC中的HandlerAdapter，由于handler有很多种形式，包括Controller、HttpRequestHandler、Servlet等，但调用方式又是确定的，因此需要适配器来进行处理，根据适配规则调用handle方法。
    Arrays.asList方法，将数组转换为对应的集合（注意不能使用修改集合的方法，因为返回的 ArrayList 是 Arrays 的一个内部类）。
     装饰者模式和被装饰的类要实现同一个接口，或者装饰类是被装饰的类的子类。适配器模式和被适配的类具有不同的接口。
     适配器模式被用于桥接两个接口，而装饰模式的目的是在不修改类的情况下给类增加新的功能。
```
#### 6.建造者模式及在jdk中的体现，建造者模式和工厂模式区别
[建造者模式及在jdk中的体现，建造者模式和工厂模式区别](https://www.cnblogs.com/lifegoeson/p/13500365.html)
```markdown
java.lang.StringBuilder类，也就是常用的可变字符串类，用到的就是建造者模式。以其中的常用方法append方法为例看源码。
```
#### 7.模板方法模式
[模板方法模式——看看JDK和Spring是如何优雅复用代码的](https://mp.weixin.qq.com/s?__biz=MzU4Mjk0MjkxNA==&mid=2247487305&idx=2&sn=598a6e1ceede39894ae8f8a783397b27&chksm=fdb1e6e4cac66ff270b7e4ac596aab4dabd5980009972e1001d024f675adff5e6d637cc25064&mpshare=1&scene=23&srcid=0908dGnDbqBXsZsSPCjkHjq9&sharer_sharetime=1599540445765&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
```markdown
模板模式属于行为型模式，使子类可以在不改变算法结构的情况下重新定义算法的某些步骤，适用于抽取子类重复代码到公共父类。
优点：1、封装不变的部分，扩展可变的部分。2、提取公共代码，便于维护。3、行为由父类控制，子类实现。
缺点：每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。
HttpServlet定义了一套处理HTTP请求的模板，service方法为模板方法，定义了处理HTTP请求的基本流程，doXXX等方法为基本方法，根据请求方法的类型做相应的处理，子类可重写这些方法。
```
#### 8.策略模式
```markdown
策略模式属于行为型模式，定义了一系列算法并封装起来，之间可以互相替换。策略模式主要解决在有多种算法相似的情况下，使用if/else所带来的难以维护
优点是算法可以自由切换，可以避免使用多重条件判断并且扩展性良好，缺点是策略类会增多并且所有策略类都需要对外暴露。
在集合框架中，经常需要通过构造方法传入一个比较器Comparator进行比较排序。Comparator就是一个抽象策略，一个类通过实现该接口并重写compare方法成为具体策略类。
创建线程池时，需要传入拒绝策略，当创建新线程使当前运行的线程数超过 maximumPoolSize 时会使用相应的拒绝策略处理。
```
#### 9.观察者模式
```markdown
观察者模式属于行为型模式，也叫发布订阅模式，定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
    主要解决一个对象状态改变给其他对象通知的问题，缺点是如果被观察者对象有很多的直接和间接观察者的话通知很耗时，
    如果存在循环依赖的话可能导致系统崩溃，另外观察者无法知道目标对象具体是怎么发生变化的。
ServletContextListener能够监听ServletContext对象的生命周期，实际上就是监听Web应用。当Servlet容器启动Web应用时调用contextInitialized方法，终止时调用contextDestroyed方法。
```
### 31.生产者消费者模式
[生产者消费者模型在项目中的实际应用](https://www.cnblogs.com/0813lichenyu/p/11599421.html)
[java多线程：线程间通信——生产者消费者模型](https://www.cnblogs.com/lifegoeson/p/13528098.html)
### 32.jdk1.8新特性【5+】
[关于Java8的精心总结](https://www.cnblogs.com/yychuyu/p/13332293.html)
[感受lambda之美](https://juejin.im/post/6844903849753329678)
[Java基础系列-Lambda](https://www.cnblogs.com/V1haoge/p/10755338.html)
[Java如何支持函数式编程？](https://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==&mid=2247499667&idx=1&sn=9348d819d9175bc7cb2f7c7697e2e3d3&chksm=e92ac29cde5d4b8a866fc3a36775feb6065aea69c035f6021d7e1694a18d540dab7c37ca0e6c&mpshare=1&scene=23&srcid=0922w7nbW81acbeipn6uUUDR&sharer_sharetime=1600735391080&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
[快速掌握Java8 Stream函数式编程技巧](https://www.cnblogs.com/hujunzheng/p/13835146.html)
```markdown
新特性：
    **lambda表达式**允许把函数作为参数传递到方法，简化匿名内部类代码。
    **函数式接口**使用 @FunctionalInterface 标识，有且仅有一个抽象方法，可被隐式转换为lambda表达式。
    **方法引用**可以引用已有类或对象的方法和构造方法，进一步简化lambda表达式。
    **接口**接口可以定义 default 修饰的默认方法，降低了接口升级的复杂性，还可以定义静态方法。
    **注解**引入重复注解机制，相同注解在同地方可以声明多次。注解作用范围也进行了扩展，可作用于局部变量、泛型、方法异常等。
    **类型推测**加强了类型推测机制，使代码更加简洁。
    **Optional类**处理空指针异常，提高代码可读性。
    **Stream类**引入函数式编程风格，提供了很多功能，使代码更加简洁。方法包括forEach遍历、count 统计个数、filter 按条件过滤、limit 取前 n 个元素、skip 跳过前 n 个元素、map 映射加工、concat 合并 stream 流等。
    **日期**增强了日期和时间 API，新的 java.time 包主要包含了处理日期、时间、日期/时间、时区、时刻和时钟等操作。
    **JavaScript**提供了一个新的JavaScript引擎，允许在JVM上运行特定JavaScript应用。
方法函数变化：    
    Hashmap 红黑树，扩容
    concurrentHashmap(分段锁->CAS+synchronized)，进一步减少锁的粒度
    Jvm常量池的变化，字符常量池在jdk1.7从方法区脱离放入堆中，方法区则在jdk1.8中变成元空间。
```
### JDK15新特性
```markdown
1.密封类和接口
    使用sealed关键字，表示类和接口只允许哪些类和接口继承或者实现
    public sealed class Person permits Teacher,Student,Worker{} //人
    final class Teacher extends Person{} //final表示类不能被继承或接口不能被实现
    sealed class Student extends Person permits MidStudent,GredStudent{} //sealed表示类可以被继承或接口可以被实现，必须要指定要实现的类
    non-sealed class Worker extends Person{} //non-sealed表示类或者接口可以被任意继承或者实现 
2.隐藏类
3.instanceof模式匹配
4.ZGC功能转正（ZGC是在Java 11中引入的新的垃圾回收器），默认的GC还是G1
5.文本块功能转正
6.Records
    public record Customer(String name,Customer partner){} //可以省略实体对象中的代码，包括对象属性描述，get，set，hashCode
1.EdDSA数字签名算法
2.重新实现DataGramSocket API
3.禁用偏向锁定
4.Shenandoah垃圾回收算法转正（只有在Open JDK中使用） -XX:+UseShenandoahGC命令行参数打开
5.外部存储器访问API
6.https://www.bilibili.com/video/BV1LK411s7RX
```
### 33.内部类【5+】
[Java内部类的四种分类以及作用](https://www.cnblogs.com/hackerstd/p/12547503.html)
>> java内部类的区别(成员内部类、静态嵌套类、方法内部类、匿名内部类 )
>>内部类的定义：在Java中，可以将一个类的定义放在另外一个类的定义内部，这就是内部类。内部类本身就是类的一个属性，与其他属性定义方式一致。
内部类的最大优点是：可以方便的访问外部类的私有操作反之，外部类也可以通过内部类对象访问内部类的私有属性，
    使用static定义内部类，一定不可能受到外部类的实例化控制，相当于一个外部类。内部类可以在方法中定义。
内部类的分类有哪些:内部类可以分为四种：成员内部类、局部内部类、匿名内部类和静态内部类。
#### 1.成员内部类
```markdown
成员内部类:定义在类内部，成员位置上的非静态类，就是成员内部类。
    public class Outer {
        private static  int radius = 1;
        private int count =2;
         class Inner {
            public void visit() {
                System.out.println("visit outer static  variable:" + radius);
                System.out.println("visit outer   variable:" + count);
            }
        }
    }
    **成员内部类可以访问外部类所有的变量和方法，包括静态和非静态，私有和公有**。
    成员内部类依赖于外部类的实例，它的创建方式外部类实例.new内部类()，如下：
        Outer outer = new Outer();
        Outer.Inner inner = outer.new Inner();
        inner.visit();
（1）该类像是外部类的一个成员，可以无条件的访问外部类的所有成员属性和成员方法（包括private成员和静态成员）；
（2）成员内部类拥有与外部类同名的成员变量时，会发生隐藏现象，即默认情况下访问的是成员内部类中的成员。
    如果要访问外部类中的成员，需要以下形式访问：【外部类.this.成员变量或 外部类.this.成员方法】；
（3）在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问；
（4）成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象；
（5）内部类可以拥有private访问权限、protected访问权限、public访问权限及包访问权限。如果成员内部类用private修饰，则只能在外部类的内部访问；
    如果用public修饰，则任何地方都能访问；如果用protected修饰，则只能在同一个包下或者继承外部类的情况下访问；
    如果是默认访问权限，则只能在同一个包下访问。外部类只能被public和包访问两种权限修饰。
```
#### 2.局部内部类
```markdown
局部内部类:定义在方法中的内部类，就是局部内部类。
    public class Outer {
        private  int out_a = 1;
        private static int STATIC_b = 2;
        public void testFunctionClass(){
            int inner_c =3;
            class Inner {//实例方法中的局部内部类,可以访问外部类的所有变量和方法
                private void fun(){
                    System.out.println(out_a);
                    System.out.println(STATIC_b);
                    System.out.println(inner_c);
                }
            }
            Inner  inner = new Inner();
            inner.fun();
        }
        public static void testStaticFunctionClass(){
            int d =3;
            class Inner {//静态方法中的局部内部类只能访问外部类的静态变量和方法
                private void fun(){
                    // System.out.println(out_a); 编译错误，定义在静态方法中的局部类不可以访问外部类的实例变量
                    System.out.println(STATIC_b);
                    System.out.println(d);
                }
            }
            Inner  inner = new Inner();
            inner.fun();
        }
    }
    **定义在实例方法中的局部内部类可以访问外部类的所有变量和方法，定义在静态方法中的局部内部类只能访问外部类的静态变量和方法。**
    局部内部类的创建方式，在对应方法内，new 内部类()，如下：
         public static void testStaticFunctionClass(){
            class Inner {}
            Inner  inner = new Inner();
         }
（1）局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内；
（2）局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。
```
#### 3.匿名内部类
[用匿名内部类实现 Java 同步回调](https://www.cnblogs.com/zzzz76/p/13889869.html)
```markdown
匿名内部类:匿名内部类就是没有名字的内部类，日常开发中使用的比较多。
    public class Outer {
        private void test(final int i) {
            new Service() {
                public void method() {
                    for (int j = 0; j < i; j++) {
                        System.out.println("匿名内部类" );
                    }
                }
            }.method();
        }
     }
     //**匿名内部类必须继承或实现一个已有的接口**
     interface Service{
        void method();
    }
    除了没有名字，匿名内部类还有以下特点：
        - 匿名内部类必须继承一个抽象类或者实现一个接口。
        - 匿名内部类不能定义任何静态成员和静态方法。
        - 当所在的方法的形参需要被匿名内部类使用时，必须声明为final。
        - 匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。
（1）一般使用匿名内部类的方法来编写事件监听代码；
（2）匿名内部类是不能有访问修饰符和static修饰符的；
（3）匿名内部类是唯一一种没有构造器的类；
（4）匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。
```
#### 4.静态内部类
```markdown
静态内部类:定义在类内部的静态类，就是静态内部类。
    public class Outer {
        private static int radius = 1;
        static class StaticInner {
            public void visit() {
                System.out.println("visit outer static  variable:" + radius);
            }
        }
    }
    **静态内部类可以访问外部类所有的静态变量，而不可访问外部类的非静态变量**；
    静态内部类的创建方式,new外部类.静态内部类()，如下：
        Outer.StaticInner inner = new Outer.StaticInner();
        inner.visit();
（1）静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似；
（2）不能使用外部类的非static成员变量或者方法。
```
### 34.克隆&深拷⻉和浅拷⻉【5+】
```markdown
克隆：克隆的对象可能包含一些已经修改过的属性，而new出来的对象的属性还是初始化时候的值，所以需要一个新的对象来保存当前对象的状态就需要克隆。
克隆的实现方式：
    1.实现Cloneable接口并重写Object类的clone()方法
    2.实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。
Person p=new Person(“张三”);
    浅拷贝:复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化。
        只复制它本身和其中包含的值的成员变量，而引用类型的成员变量没有复制。
        对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝。
    深拷贝:将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变。
        处了复制对象本身之外，对象所包含的所有成员变量业务将复制。
        对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容。
```    
### 35.说下枚举类型，底层实现原理【5+】
[Java枚举解读](https://www.cnblogs.com/doondo/p/13663679.html)
```markdown
一个类的对象是有限个，确定的，我们称此为枚举类。
当需要定义和维护一组常量时，强烈建议使用枚举类。
如果一个枚举类中只有一个对象，则可以作为单例模式的实现方式。
```
### 36.Object中的方法【5+】
[Java面试系列第2篇-Object类中的方法](https://www.cnblogs.com/extjs4/p/12772027.html)
```markdown
（1）构造函数
（2）hashCode() 和 equals() 函数用来判断对象是否相同
（3）wait()、wait(long)、wait(long,int)、notify()、notifyAll() 线程等待和唤醒
（4）toString() 返回该对象的字符串表示
（5）getClass() 返回引用中存储的实际对象类型
（5）clone() 实现对象的浅复制，只有实现了Cloneable接口才能调用此方法，否则抛出CloneNotSupportedException。
（6）finalize() 用于在垃圾回收。
```
### 38.switch【5+】
>> switch是否能作用在byte上，是否能作用在long上，是否能作用在String上？
```markdown
在Java5以前，switch(expr)中，expr只能是byte、short、char、int。
    从Java5开始，Java中引入了枚举类型，expr也可以是enum类型，
    从Java7开始，expr还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。
**switch支持的类型**：**byte、short、char、int、String**
java7以后，switch语句可以用在string类型上，从本质上讲switch对字符串的支持，其实底层也是int类型的匹配。它的原理如下：
    通过对case后面的string对象调用hashcode()方法，得到一个int类型的hash值，然后用这个hash值来唯一标识这个case。
    在匹配的时候，首先调用这个字符串的hashcode方法，得到一个hash值(int型)，用这个hash值来匹配所有的case。
    如果没有匹配成功，说明不存在；如果匹配成功了，接着会调用字符串的equals()方法来进行匹配。
    由此看出，string变量不能是null，同时，switch的case子句中使用的字符串也不能为null。
    这种方法可以使用string类型的变量也就是我们常说的语法糖。
```
### 39.this和super关键字的用法
```markdown
this是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。
this的用法在java中大体可以分为3种：
    1.普通的直接引用，this相当于是指向当前对象本身。
    2.形参与成员名字重名，用this来区分：
        public Person(String name, int age) {
            this.name = name;
            this.age = age;
        }
    3.引用本类的构造函数
        class Person{
            private String name;
            private int age;
            public Person() {
            }
            public Person(String name) {
                this.name = name;
            }
            public Person(String name, int age) {
                this(name);
                this.age = age;
            }
        }
super可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。
super也有三种用法：
    1.普通的直接引用
        与this类似，super相当于是指向当前对象的父类的引用，这样就可以用super.xxx来引用父类的成员。
    2.子类中的成员变量或方法与父类中的成员变量或方法同名时，用super进行区分
        class Person{
            protected String name;
            public Person(String name) {
                this.name = name;
            }
        }
        class Student extends Person{
            private String name;
            public Student(String name, String name1) {
                super(name);
                this.name = name1;
            }
            public void getInfo(){
                System.out.println(this.name);      //Child
                System.out.println(super.name);     //Father
            }
        }
        public class Test {
            public static void main(String[] args) {
               Student s1 = new Student("Father","Child");
               s1.getInfo();
            }
        }
    3、引用父类构造函数
        super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。
        this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。
```
### 40.面向对象五大基本原则【5+】
```markdown
1.单一职责原则SRP(Single Responsibility Principle)
    软件模块应该只有一个被修改的理由。在大多数情况下，编写Java代码时都会将单一职责原则应用于类。
    单一职责原则可被视为使封装工作达到最佳状态的良好实践。更改的理由是：需要修改代码。
    单一原则，类、方法只干一件事。
2.开放封闭原则OCP(Open－Close Principle)
    模块、类和函数应该对扩展开放，对修改关闭。
    通过继承和多态扩展来添加新功能。开闭原则是最重要的设计原则之一，是大多数设计模式的基础。
    软件建设一个复杂的结构，当我们完成其中的一部分，就应该不要修改它，而是在其基础上继续建设。
3.里式替换原则LSP(the Liskov Substitution Principle LSP)
    在设计模块和类时，必须确保派生类型从行为的角度来看是可替代的。
    使用父类的地方都可以用子类替代。
        父类最好为抽象类。
        子类可实现父类的非抽象方法，尽量不要覆盖重写已实现的方法。
        子类可写自身的方法，有自身的特性，在父类的基础上扩建。
        子类覆盖重写父类方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松，后置条件（返回值）要更严格。
4.依赖倒置原则DIP(the Dependency Inversion Principle DIP)
    高级模块不应该依赖低级模块，两者都应该依赖抽象。
    抽象不应该依赖于细节，细节应该依赖于抽象。
5.接口分离原则ISP(the Interface Segregation Principle ISP)
    减少了代码耦合，使软件更健壮，更易于维护和扩展。
    客户端不应该依赖它所不需要的接口。
迪米特法则：又叫最少知识法则，这个法则主张一个类要尽可能少地知道其他类地细节，并且尽可能少地和其他类进行通信交互，只和于自己有密切关系地类进行交互。
合成服用原则：合成服用原则又称为组合/聚合服用原则（Composite/Aggregate Reuse Principle）：尽量采用组合(contains-a)、聚合(has-a)的方式而不是继承(is-a)的关系来达到软件的复用目的。
```
### 41.Java中的关键字
```markdown
Java中一共有48个关键字，2个保留字和三个直接量
访问控制：private、protected、public；
类,方法和变量修饰符：abstract、class、extends、final、implements、interface、native、new、static、strictfp、synchronized、transient、volatile；
程序控制:break、continue、return、do、while、if、else、for、instanceof、switch、case、default；
错误处理：try、catch、throw、throws、finally；
包相关：import、package；
基本类型：boolean、byte、char、double、float、int、long、short、null、true、false；
变量引用：super、this、void；
保留字：goto、const；
直接量：true、false、null。
重要关键字说明：
    native： 用来声明一个方法是由与机器相关的语言(如C/C++/FORTRAN语言)实现的；
    strictfp：用来声明FP-strict(双精度或单精度浮点数)表达式；
    transient：声明不用序列化的属性；
    volatile：表明两个或多个变量必须同步地发生变化。
```
### 42.Java静态绑定与动态绑定【3+】
[Java静态绑定与动态绑定](https://blog.csdn.net/zhangjk1993/article/details/24066085)
```markdown
程序绑定的概念：
    绑定指的是一个方法的调用与方法所在的类(方法主体)关联起来。对java来说，绑定分为静态绑定和动态绑定；或者叫做前期绑定和后期绑定.
静态绑定：
    在程序执行前方法已经被绑定（也就是说在编译过程中就已经知道这个方法到底是哪个类中的方法），此时由编译器或其它连接程序实现。例如：C。
    针对java简单的可以理解为程序编译期的绑定；这里特别说明一点，java当中的方法只有final，static，private和构造方法是前期绑定
动态绑定：
    后期绑定：在运行时根据具体对象的类型进行绑定。
    若一种语言实现了后期绑定，同时必须提供一些机制，可在运行期间判断对象的类型，并分别调用适当的方法。
    也就是说，编译器此时依然不知道对象的类型，但方法调用机制能自己去调查，找到正确的方法主体。不同的语言对后期绑定的实现方法是有所区别的。
    但我们至少可以这样认为：它们都要在对象中安插某些特殊类型的信息。
    动态绑定的过程：
        1.虚拟机提取对象的实际类型的方法表；
        2.虚拟机搜索方法签名；
        3.调用方法。
```
### 43.for while替换【1+】
```markdown
for循环适用于已知循环次数，while循环适用于未知循环次数。
    那么在已知循环次数时，最好选择for循环；
    如果循环次数是未知的。最好选择while循环。
从内存角度考虑：
    局部变量在栈内存中存在,当for循环语句结束,那么变量会及时被gc(垃圾回收器)及时的释放掉,不浪费空间；
    如果使用循环之后还想去访问循环语句中控制那个变量,使用while循环。
```
### 44.Java注解？什么是元注解？
[面试官：注解五问你怕了吗？](https://www.cnblogs.com/viyoung/p/13917798.html)
[自定义注解！绝对是程序员装逼的利器！！](https://www.cnblogs.com/hollischuang/p/13952270.html)
[Java注解（入门级）](https://www.cnblogs.com/zhangqingwang/p/13946505.html)
[java注解的使用](https://www.cnblogs.com/chentang/p/13959831.html)
```markdown
注解是一种标记，使类或接口附加额外信息，帮助编译器和JVM完成一些特定功能，例如@Override标识一个方法是重写方法。
元注解是自定义注解的注解，例如：
    @Target：约束作用位置，值是ElementType枚举常量，包括METHOD方法、VARIABLE变量、TYPE类/接口、PARAMETER方法参数、CONSTRUCTORS构造方法和LOACL_VARIABLE局部变量等。
    @Rentention：约束生命周期，值是RetentionPolicy枚举常量，包括SOURCE源码、CLASS字节码和RUNTIME运行时。
    @Documented：表明这个注解应该被javadoc记录。
```
### 45.public static void main(String[] args)声明的作用
```markdown
public static void main(String[] args){}方法是Java查询运行时调用的第一个方法，是Java程序的入口。
    public:因为它必须对Java环境可见，JVM 就可以轻松的访问执行它。所以可见性设置为public。
    static:Java平台调用这个方法时不需要创建这个类的实例，因此这个方法必须声明为static
    void:main()方法是没有返回值的。因为main返回任何值对程序都没任何意义，所以设计成void，意味着main不会有任何值返回。
    String是命令行传进参数的类型，args是指命令行传进的字符串数组。
如果JVM找不到main方法就抛出NoSuchMethodError:main异常，例如：如果你运行命令：java HelloWrold，
    JVM就会在HelloWorld.class文件中搜索 public static void main (String[] args) 方法。
main 方法在 Java 可以像其他方法一样被重载，但是 JVM 只会调用上面这种签名规范的 main 方法。
```
### [1.如何判断一个元素在亿级数据中是否存在？](https://www.cnblogs.com/crossoverJie/p/10018231.html)【2+】
[如何从亿量级中判断一个数是否存在？](https://www.cnblogs.com/kubidemanong/p/10147685.html)
```markdown
1.非常大的一个数据量，无法完全放进内存，或没有必要放进内存，造成系统性能消耗。
    1.大多数想到的都是用HashMap来存放数据，因为它的写入查询的效率都比较高。
    写入和判断元素是否存在都有对应的API，所以实现起来也比较简单。会造成内存溢出。
    2.Bloom Filter：用于解决判断一个元素是否在一个集合中，但它的优势是只需要占用很小的内存空间以及有着高效的查询效率。
    因为只是需要判断数据是否存在，也不是需要把数据查询出来，所以完全没有必要将真正的数据存放进去。
    3.bitmap：采用一个二进制位来存储数据的方法。
```
### [2.面试问题---JAVA程序CPU占用过高怎么定位](https://www.cnblogs.com/nijunyang/p/13040511.html)
```markdown
结合Linux和JDK命令一起分析
    1.先用top命令找到CPU占用最高的 top |grep java  或者 jps指令找到java进程的pid（6167）
    2.ps -ef 或者jps 进一步定位，得知是一个怎么样的后台程序 top -H -p pid:以线程的形式查看该进程 top -H -p 6167
    3.定位到具体线程或者代码 ps -mp 进程 -o THREAD,tid,time
            -m 显示所有线程
            -p pid进程使用cpu的时间
            -o 该参数后面是用户自定义格式
    4.将需要的线程ID转换为16进制格式(英文小写格式)
    5.jstack 进程 ID | grep tid(16进制线程ID小写英文) -A60  jstack 6167 >threadInfo.txt   信息输出到文件 然后查看。
性能监控工具
    jps(虚拟机进程状况工具) 
    jinfo(Java配置信息工具)
    jmap(内存映射工具)
    jstat(统计信息监控工具)
```
### 3.面试题：&和&&的区别， | 和|| 的区别？
```markdown
&和| 是位运算符 ，&&和||是逻辑运算符，不能用于位运算。
&：所有的条件都要判断， && 当前一个判断为false时后面不用判断直接返回false
|：所有的条件都要判断， || 当前一个判断为true时，后面一个不用判断直接返回true
```
### Java中符号>>和>>>有什么区别？
```markdown
java中有三种移位运算符
<<      :     左移运算符，num << 1,相当于num乘以2
>>      :     右移运算符，num >> 1,相当于num除以2
>>>    :     无符号右移，忽略符号位，空位都以0补齐
```
## 二、Java I/O
[还没毕业的大学生能够把IO讲的这么好？](https://www.cnblogs.com/cxuanBlog/p/13624862.html)
[「网络IO套路」当时就靠它追到女友](https://mp.weixin.qq.com/s?__biz=Mzg2MjEwMjI1Mg==&mid=2247502575&idx=3&sn=21775b9b94299b64ff64e4e66967af4a&chksm=ce0e7d6cf979f47a17140f35a9e6fcb2f300adfb3d544ba96d833968cb7838ae8da411130a07&mpshare=1&scene=23&srcid=0929o0f8Q1di5agnCReq0VdN&sharer_sharetime=1601376289012&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
[IO那些事](https://www.cnblogs.com/floor/p/13789402.html)
### Java IO简介
```markdown
按照流的流向分，可以分为输入流和输出流；              字节流             字符流
    输入流：从磁盘或者其它设备中将数据输入到进程中    InputStream        Reader
    输出流：将进程中的数据输出到磁盘或其它设备上保存   OutputStream       Writer
根据处理数据的基本单位不同分类，可以划分为字节流和字符流；字符流一般用于文本文件，字节流一般用于图像或其他文件。
    字节流：以字节（8 bit）为单位做数据的传输
    字符流：以字符为单位（1字符 = 2字节）做数据的传输
    字符流只针对字符数据进行传输，所以如果是文本数据，优先采用字符流传输；除此之外，其它类型的数据（图片、音频等），最好还是以字节流传输。
按照流的角色划分为节点流和处理流。按照流是否直接与特定的地方（如磁盘、内存、设备等）相连，分为节点流和处理流两类。
    节点流：节点流是真正传输数据的流对象，用于向特定的一个地方（节点）读写数据，称为节点流。例如 FileInputStream
    处理流：处理流是对节点流的封装，使用外层的处理流读写数据，本质上是利用节点流的功能，外层的处理流可以提供额外的功能。处理流的基类都是以 Filter 开头。
Java Io流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系，
    JavaI0流的40多个类都是从如下4个抽象类基类中派生出来的。
        InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。
        OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。
JAVA常用的节点流：
    文 件 FileInputStream FileOutputStrean FileReader FileWriter 文件进行处理的节点流。
    字符串 StringReader StringWriter 对字符串进行处理的节点流。
    数 组 ByteArrayInputStream ByteArrayOutputStreamCharArrayReader CharArrayWriter 对数组进行处理的节点流（对应的不再是文件，而是内存中的一个数组）。
    管 道 PipedInputStream PipedOutputStream PipedReaderPipedWriter对管道进行处理的节点流。
常用处理流（关闭处理流使用关闭里面的节点流）
    缓冲流：BufferedInputStrean BufferedOutputStream BufferedReader BufferedWriter  增加缓冲功能，避免频繁读写硬盘。
    转换流：InputStreamReader OutputStreamReader 实现字节流和字符流之间的转换。
    数据流 DataInputStream DataOutputStream  等-提供将基础数据类型写入到文件中，或者读取出来.
流的关闭顺序
    一般情况下是：先打开的后关闭，后打开的先关闭
    另一种情况：看依赖关系，如果流a依赖流b，应该先关闭流a，再关闭流b。例如，处理流a依赖节点流b，应该先关闭处理流a，再关闭节点流b
    可以只关闭处理流，不用关闭节点流。处理流关闭的时候，会调用其处理的节点流的关闭方法。
IO 流读写数据的特点：
    顺序读写。读写数据时，大部分情况下都是按照顺序读写，读取时从文件开头的第一个字节到最后一个字节，写出时也是也如此（RandomAccessFile可以实现随机读写）
    字节数组。读写数据时本质上都是对字节数组做读取和写出操作，即使是字符流，也是在字节流基础上转化为一个个字符，所以字节数组是IO流读写数据的本质。
```
### 按操作方式分类结构图
![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9teS1ibG9nLXRvLXVzZS5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vMjAxOS02L0lPLSVFNiU5MyU4RCVFNCVCRCU5QyVFNiU5NiVCOSVFNSVCQyU4RiVFNSU4OCU4NiVFNyVCMSVCQi5wbmc?x-oss-process=image/format,png)
### 按操作对象分类结构图
![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9teS1ibG9nLXRvLXVzZS5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vMjAxOS02L0lPLSVFNiU5MyU4RCVFNCVCRCU5QyVFNSVBRiVCOSVFOCVCMSVBMSVFNSU4OCU4NiVFNyVCMSVCQi5wbmc?x-oss-process=image/format,png)
### 同步/异步/阻塞/非阻塞 IO 的区别？
[谈谈对不同I/O模型的理解 (阻塞/非阻塞IO，同步/异步IO)](https://www.cnblogs.com/xiaoxiongcanguan/p/13938877.html)
```markdown
同步和异步是通信机制，阻塞和非阻塞是调用状态。
1.同步IO是用户线程发起IO请求后需要等待或轮询内核IO操作完成后才能继续执行。
2.异步IO是用户线程发起IO请求后可以继续执行，当内核IO操作完成后会通知用户线程，或调用用户线程注册的回调函数。
3.阻塞IO是IO操作需要彻底完成后才能返回用户空间。
4.非阻塞IO是IO操作调用后立即返回一个状态值，无需等IO操作彻底完成。
```
### BIO,NIO,AIO有什么区别?【5+】
```markdown
在使用阻塞IO的时候，应用程序会被无情的挂起，等待内核完成操作，因为此时的内核可能将CPU时间切换到了其他需要的进程中，应用程序阻塞了。
当使用非阻塞函数的时候，和阻塞IO类比，内核会立即返回，返回后获得足够的CPU时间继续做其他的事情。
BIO：Block IO同步阻塞式IO，就是我们平常使用的传统IO，它的特点是模式简单使用方便，并发处理能力低。
NIO：Non IO同步非阻塞IO，是传统IO的升级，客户端和服务器端通过Channel（通道）通讯，实现了多路复用。
AIO：AsynchronousIO是NIO的升级，也叫NIO2，实现了异步非堵塞IO ，异步IO的操作基于事件和回调机制。
BIO (Blocking I/O): 同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。
    在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的I/O并且编程模型简单，也不用过多考虑系统的过载、限流等问题。
    线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的BIO模型是无能为力的。
    因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。
NIO (New I/O): NIO是一种同步非阻塞的I/O模型，在Java1.4中引入了NIO框架，对应java.nio包，提供了Channel,Selector,Buffer等抽象。
    NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。
    NIO提供了与传统BIO模型中的Socket和ServerSocket相对应的SocketChannel和ServerSocketChannel两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。
    阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；
    对于高负载、高并发的（网络）应用，应使用NIO的非阻塞模式来开发
    核心组件：
        1.Selector：多路复用器，轮询检查多个Channel的状态，判断注册事件是否发生，即判断Channel是否处于可读或可写状态。
            使用前需要将Channel注册到Selector，注册后会得到一个SelectionKey，通过SelectionKey获取Channel和Selector相关信息。
        2.Channel：双向通道，替换了BIO中的Stream流，不能直接访问数据，要通过Buffer来读写数据，也可以和其他Channel交互。
        3.Buffer：缓冲区，本质是一块可读写数据的内存，用来简化数据读写。Buffer三个重要属性：position下次读写数据的位置，limit 本次读写的极限位置，capacity 最大容量。
            3.1.flip 将写转为读，底层实现原理把position置0，并把limit设为当前的position值。
            3.2.clear 将读转为写模式（用于读完全部数据的情况，把position置0，limit设为capacity）。
            3.3.compact 将读转为写模式（用于存在未读数据的情况，让position指向未读数据的下一个）。
            3.4.通道方向和Buffer方向相反，读数据相当于向Buffer写，写数据相当于从Buffer读。
        使用步骤：向Buffer写数据，调用flip方法转为读模式，从Buffer中读数据，调用clear或compact方法清空缓冲区。
AIO (Asynchronous I/O): AIO也就是NIO2。在Java7中引入了NIO的改进版NIO2，是异步非阻塞的IO模型。
    异步IO是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。
    AIO是异步IO的缩写，虽然NIO在网络操作中，提供了非阻塞的方法，但是NIO的IO行为还是同步的。
    对于NIO来说，我们的业务线程是在IO操作准备好时，得到通知，接着就由这个线程自行进行IO操作，IO操作本身是同步的。
```
### Java IO 的核心类 File
```markdown
Java提供了File类，它指向计算机操作系统中的文件和目录，通过该类只能访问文件和目录，无法访问内容。它内部主要提供了 3 种操作：
    访问文件的属性：绝对路径、相对路径、文件名······
        String getAbsolutePath()	返回该文件处于系统中的绝对路径名
        String getPath()	返回该文件的相对路径，通常与 new File() 传入的路径相同
        String getName()	返回该文件的文件名
    文件检测：是否文件、是否目录、文件是否存在、文件的读/写/执行权限······
        boolean isFIle()	校验该路径指向是否一个文件
        boolean isDirectory()	校验该路径指向是否一个目录
        boolean isExist()	校验该路径指向的文件/目录是否存在
        boolean canWrite()	校验该文件是否可写
        boolean canRead()	校验该文件是否可读
        boolean canExecute()	校验该文件/目录是否可以被执行
    操作文件：创建目录、创建文件、删除文件······
        mkdirs()	递归创建多个文件夹，路径中间有可能某些文件夹不存在
        createNewFile()	创建新文件，它是一个原子操作，有两步：检查文件是否存在、创建新文件
        delete()	删除文件或目录，删除目录时必须保证该目录为空
```
### Files的常用方法都有哪些？
```markdown
Files.exists()：检测文件路径是否存在。
Files.createFile()：创建文件。
Files.createDirectory()：创建文件夹。
Files.delete()：删除一个文件或目录。
Files.copy()：复制文件。
Files.move()：移动文件。
Files.size()：查看文件个数。
Files.read()：读取文件。
Files.write()：写入文件。
```
### InputStream,FileInputStream
```markdown
InputStream是字节输入流的抽象基类，提供了通用的读方法，让子类使用或重写它们。
    public abstract int read()	从输入流中读取下一个字节，读到尾部时返回 -1
    public int read(byte b[])	从输入流中读取长度为 b.length 个字节放入字节数组 b 中
    public int read(byte b[], int off, int len)	从输入流中读取指定范围的字节数据放入字节数组 b 中
    public void close()	关闭此输入流并释放与该输入流相关的所有资源
    ByteArrayInputStream内部包含一个buf字节数组缓冲区，该缓冲区可以从流中读取的字节数，
        使用pos指针指向读取下一个字节的下标位置，内部还维护了一个count 属性，代表能够读取 count 个字节。
FileInputStream文件输入流，从文件中读入字节，通常对文件的拷贝、移动等操作，可以使用该输入流把文件的字节读入内存中，然后再利用输出流输出到指定的位置上。
PipedInputStream管道输入流，它与PipedOutputStream成对出现，可以实现多线程中的管道通信。PipedOutputStream中指定与特定的PipedInputStream连接，
    PipedInputStream也需要指定特定的PipedOutputStream连接，之后输出流不断地往输入流的buffer缓冲区写数据，而输入流可以从缓冲区中读取数据。
ObjectInputStream对象输入流，用于对象的反序列化，将读入的字节数据反序列化为一个对象，实现对象的持久化存储。
PushBackInputStream它是 FilterInputStream 的子类，是一个处理流，它内部维护了一个缓冲数组buf。
    在读入字节的过程中可以将读取到的字节数据回退给缓冲区中保存，下次可以再次从缓冲区中读出该字节数据。
    所以PushBackInputStream允许多次读取输入流的字节数据，只要将读到的字节放回缓冲区即可。
```
### OutputStream
```markdown
OutputStream 是字节输出流的抽象基类，提供了通用的写方法，让继承的子类重写和复用。
    public abstract void write(int b)	将指定的字节写出到输出流，写入的字节是参数 b 的低 8 位
    public void write(byte b[])	将指定字节数组中的所有字节写入到输出流当中
    public void write(byte b[], int off, int len)	指定写入的起始位置 offer，字节数为 len 的字节数组写入到输出流当中
    public void flush()	刷新此输出流，并强制写出所有缓冲的输出字节到指定位置，每次写完都要调用
    public void close()	关闭此输出流并释放与此流关联的所有系统资源
OutputStream 是所有输出字节流的抽象基类
ByteArrayOutputStream 和 FileOutputStream 是两种基本的节点流，它们分别向字节数组和本地文件写出数据
DataOutputStream、BufferedOutputStream是处理流，前者可以将字节数据转换成基本数据类型写出到文件中；后者是缓冲字节数组，只有在缓冲区满时，才会将所有的字节写出到目的地，减少了IO次数。
PipedOutputStream 用于多线程通信，可以和其它线程共用一个管道，向管道中写入数据
ObjectOutputStream 用于对象的序列化，将对象转换成字节数组后，将所有的字节都写入到指定位置中
PrintStream 在 OutputStream 基础之上提供了增强的功能，即可以方便地输出各种类型的数据（而不仅限于byte型）的格式化表示形式，
    且PrintStream的方法从不抛出IOEception，其原理是写出时将各个数据类型的数据统一转换为 String 类型，我会在讲解完
```
### Reader&Writer
```markdown
Reader 是字符输入流的抽象基类，它内部的重要方法如下所示。
    public int read(java.nio.CharBuffer target)	将读入的字符存入指定的字符缓冲区中
    public int read()	读取一个字符
    public int read(char cbuf[])	读入字符放入整个字符数组中
    abstract public int read(char cbuf[], int off, int len)	将字符读入字符数组中的指定范围中
    Reader 是所有字符输入流的抽象基类
    CharArrayReader 和 StringReader 是两种基本的节点流，它们分别从读取 字符数组 和 字符串 数据，StringReader 内部是一个 String 变量值，通过遍历该变量的字符，实现读取字符串，本质上也是在读取字符数组
    PipedReader 用于多线程中的通信，从共用地管道中读取字符数据
    BufferedReader 是字符输入缓冲流，将读入的数据放入字符缓冲区中，实现高效地读取字符
    InputStreamReader 是一种转换流，可以实现从字节流转换为字符流，将字节数据转换为字符
Writer是字符输出流的抽象基类，它内部的重要方法如下所示。
    public void write(char cbuf[])	将 cbuf 字符数组写出到输出流
    abstract public void write(char cbuf[], int off, int len)	将指定范围的 cbuf 字符数组写出到输出流
    public void write(String str)	将字符串 str 写出到输出流，str 内部也是字符数组
    public void write(String str, int off, int len)	将字符串 str 的某一部分写出到输出流
    abstract public void flush()	刷新，如果数据保存在缓冲区，调用该方法才会真正写出到指定位置
    abstract public void close()	关闭流对象，每次 IO 执行完毕后都需要关闭流对象，释放系统资源
    Writer 是所有的输出字符流的抽象基类
    CharArrayWriter、StringWriter 是两种基本的节点流，它们分别向Char 数组、字符串中写入数据。StringWriter 内部保存了 StringBuffer 对象，可以实现字符串的动态增长
    PipedWriter 可以向共用的管道中写入字符数据，给其它线程读取。
    BufferedWriter 是缓冲输出流，可以将写出的数据缓存起来，缓冲区满时再调用 flush() 写出数据，减少 IO 次数。
    PrintWriter 和 PrintStream 类似，功能和使用也非常相似，只是写出的数据是字符而不是字节。
    OutputStreamWriter 将字符流转换为字节流，将字符写出到指定位置
```
### 字节流与字符流的转换
```markdown
InputStreamReader：从字节流转换为字符流，将字节数据转换为字符数据读入到内存
OutputStreamWriter：从字符流转换为字节流，将字符数据转换为字节数据写出到指定位置
```
### 缓冲区（Buffer）
```markdown
缓冲区是存储数据的区域，在Java中，缓冲区就是数组，为了可以操作不同数据类型的数据，Java提供了许多不同类型的缓冲区，除了布尔类型以外，其它基本数据类型都有对应的缓冲区数组对象。
    缓冲区	        解释
    ByteBuffer	存储字节数据的缓冲区
    CharBuffer	存储字符数据的缓冲区
    ShortBuffer	存储短整型数据的缓冲区
    IntBuffer	存储整型数据的缓冲区
    LongBuffer	存储长整型数据的缓冲区
    FloatBuffer	存储单精度浮点型数据的缓冲区
    DoubleBuffer	存储双精度浮点型数据的缓冲区
缓冲区读写数据的两个核心方法：
    put()：将数据写入到缓冲区中
    get()：从缓冲区中读取数据
缓冲区的重要属性：
    capacity：缓冲区中最大存储数据的容量，一旦声明则无法改变
    limit：表示缓冲区中可以操作数据的大小，limit 之后的数据无法进行读写。必须满足 limit <= capacity
    position：当前缓冲区中正在操作数据的下标位置，必须满足 position <= limit
    mark：标记位置，调用 reset() 将 position 位置调整到 mark 属性指向的下标位置，实现多次读取数据
```
### 通道（Channel）
```markdown
通道是可以双向读写的，传统的 BIO 需要使用输入/输出流表示数据的流向，在 NIO 中可以减少通道资源的消耗。
    文件 IO	FileChannel（用于文件读写、操作文件的通道）
    TCP 网络 IO	SocketChannel（用于读写数据的 TCP 通道）、ServerSocketChannel（监听客户端的连接）
    UDP 网络 IO	DatagramChannel（收发 UDP 数据报的通道）
```
### Java IO里面的设计模式【5+】
```markdown
JDK的I/O包中就主要使用到了两种设计模式：Adatper(适配器)模式和Decorator(装饰者)模式
1、适配器模式->字节流与字符流之间的转换
    //file 为已定义好的文件流 
    FileInputStream fileInput = new FileInputStream(file); 
    InputStreamReader inputStreamReader = new InputStreamReader(fileInput);
    以上就是适配器模式的体现，FileInputStream是字节流，而并没有字符流读取字符的一些api，
    因此通过InputStreamReader将其转为Reader子类，因此有了可以操作文本的文件方法。
    换句话说，就是将FileInputStream读取一个字节流的方法扩展转换为InputStreamReader读取一个字符流的功能。
2、装饰者模式->字符流包装为缓冲字符流
    BufferedReader bufferedReader=new BufferedReader(inputStreamReader);
    构造了缓冲字符流，将FileInputStream字节流包装为BufferedReader过程就是装饰的过程，
    刚开始的字节流FileInputStream只有read一个字节的方法，包装为inputStreamReader后，就有了读取一个字符的功能，
    在包装为BufferedReader后，就拥有了read一行字符的功能。
```
### Java读取大文件
[Java极速读取超大文件(附源代码)](https://blog.csdn.net/Justnow_/article/details/95505899)
```markdown
思路一：文件流边读边用，使用文件流的read()方法每次读取指定长度的数据到内存中，具体样板代码如下。
//BufferedReader类同
BufferedInputStream reader = new BufferedInputStream(new FileInputStream("big.txt"), 8192);
int bytes = -1;
do {
    byte[] tmpArray = new byte[8192];
    bytes = reader.read(tmpArray);
    if (bytes != -1) {
        //做事情
    }
} while(bytes > 0);
reader.close();
//思路二：对大文件建立NIO的FileChannel，每次调用read()方法时会先将文件数据读取到已分配固定长度的java.nio.ByteBuffer中，接着从中获取读取的数据。
这种用NIO通道的方法比传统文件流读取理论上要快一点，具体样板代码如下。
FileInputStream fileIn = new FileInputStream("big.txt");
ByteBuffer byteBuf = ByteBuffer.allocate(65535);
FileChannel fileChannel = fileIn.getChannel();
int bytes = -1;
do {
    bytes = fileChannel.read(byteBuf);
    if (bytes != -1) {
        byte[] array = new byte[bytes];
        byteBuf.flip();
        byteBuf.get(array);
        byteBuf.clear();
        //拿array做事情
        System.out.println(new String(array));
    }
} while (bytes > 0);
byteBuf.clear();
fileChannel.close();
fileIn.close();
思路三：内存文件映射，就是把文件内容映射到虚拟内存的一块区域中，从而可以直接操作内存当中的数据而无需每次都通过I/O去物理硬盘读取文件，这种方式可以提高速度，具体样板代码如下。
FileInputStream fileIn = new FileInputStream("big.txt");
FileChannel fileChannel = fileIn.getChannel();
MappedByteBuffer mappedBuf = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0, fileChannel.size());
boolean end = false;
do {
    int limit = mappedBuf.limit();
    int position = mappedBuf.position();
    if (position >= limit) {
        end = true;
    }
    int maxSize = 2048;
    if (limit - position < maxSize) {
        maxSize = limit - position;
    }
    byte[] array = new byte[maxSize];
    mappedBuf.get(array);
    //拿array搞事情
    System.out.println(new String(array));
} while (!end);
mappedBuf.clear();
fileChannel.close();
fileIn.close();
```
### Java 按行读取文件
```markdown
FileInputStream 是以流的方式读取文件的。
 java.io.BufferedReader和java.io.BufferedWriter类各拥有8192字符的缓冲区。当BufferedReader在读取文本文件时，会先尽量从文件中读入字符数据并置入缓冲区，
而之后若使用read()方法，会先从缓冲区中进行读取。如果缓冲区数据不足，才会再从文件中读取，使用BufferedWriter时，写入的数据并不会先输出到目的地，而是先存储至缓冲区中。
如果缓冲区中的数据满了，才会一次对目的地进行写出。
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
public class Main {
	public static void main(String[] args) throws IOException{
		//BufferedReader是可以按行读取文件
		FileInputStream inputStream = new FileInputStream("d://a.txt");
		BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));
		String str = null;
		while((str = bufferedReader.readLine()) != null)
		{
			System.out.println(str);
		}
		//close
		inputStream.close();
		bufferedReader.close();
	}
}
```
###
[java安全编码指南之:文件IO操作](https://www.cnblogs.com/flydean/p/13883593.html)
##