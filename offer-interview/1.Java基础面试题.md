# 面试题总结
[一份超级详细的Java面试题【大厂面试真题+Java学习指南】](https://github.com/whx123/JavaHome)

[TOC]


## 一、Java基础
### 1.Java有哪些数据类型，分别占多少个字节？【3+】
```markdown
byte/8     Byte
char/16    Character
short/16   Short
int/32  - 2^32 ~ 2^32 -1   Integer
float/32   Float
long/64    Long
double/64  Double
boolean/~  Boolean
    boolean 只有两个值：true、false，可以使用1bit 来存储，但是具体大小没有明确规定。
    JVM会在编译时期将 boolean 类型的数据转换为int，使用1来表示true，0表示false。
    JVM支持boolean数组，但是是通过读写byte数组来实现的。
包装类型:基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。
缓存池:new Integer(123) 与 Integer.valueOf(123) 的区别在于：    
    new Integer(123) 每次都会新建一个对象；
    Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。
    valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。
    在 Java 8 中，Integer缓存池的大小默认为 -128~127。
float与double：Java不能隐式执行向下转型，因为这会使得精度降低。浮点型表示不能精确的表示小数。
相互转换
    int i1 = 0; 
    Integer integer1 = new Integer(i);
    Integer integer2 = new Integer(0); 
    int i2 = integer2.intValue(); 
    Boolean booleanObj1 = new Boolean(false);
    boolean baseBool1 = booleanObj.booleanValue();
    boolean baseBool2 = false;
    Boolean booleanObj2 = new Boolean(baseBool2);
```
### 2.Java访问权限控制【1+】
```markdown
private default protected public
```
### 3.抽象类和接口的区别？普通类和抽象类有哪些区别？【5+】
```markdown
抽象类和普通类的唯一区别就在于是否实例化。
抽象类必须要有抽象方法吗？抽象类能使用final修饰吗？
     抽象类中可以有普通方法，也可以有抽象方法
     但是有抽象方法的类一定是抽象类，但是抽象类中不一定有抽象方法。
     abstract和final不共存，final不能继承
     abstract和static不共存 ，因为abstract不能修饰属性
接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。
接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final。
抽象类和接口的区别
    1.接口的方法默认是public，所有方法在接口中不能有实现(Java8开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。
    2.接口方法默认修饰符是public，抽象方法可以有public、protected和default这些修饰符（抽象方法就是为了被重写所以不能使用private关键字修饰！）。
    3.抽象类中可以有普通成员变量，接口中没有普通成员变量（static或者final修饰）。
    4.一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过extends关键字扩展多个接口。
    5.抽象类可以有构造方法，接口中不能有构造方法，抽象类中可以包含静态方法，接口中不能包含静态方法。  
    6.从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。
    接⼝可以继承接⼝。抽象类可以实现(implements)接⼝，抽象类可继承具体类。抽象类中可以有静态的main⽅法。
```
### 4.值传递和引用传递的区别是什么？【2+】
```markdown
值传递：在方法的调用过程中，实参把它的实际值传递给形参，此传递过程就是将实参的值复制一份传递到函数中，
    这样如果在函数中对该值（形参的值）进行了操作将不会影响实参的值。因为是直接复制，所以这种方式在传递大量数据时，运行效率会特别低下。
引用传递：弥补了值传递的不足，如果传递的数据量很大，直接复过去的话，会占用大量的内存空间，而引用传递就是将对象的地址值传递过去，
    函数接收的是原始值的首地址值。在方法的执行过程中，形参和实参的内容相同，指向同一块内存地址，
    也就是说操作的其实都是源数据，所以方法的执行将会影响到实际对象。
```
### 5.JAVA三大特性封装、继承和多态【2+】
```markdown
封装:利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，
    只保留一些对外的接口使其与外部发生联系。用户无需关心对象内部的细节，但可以通过对象对外提供的接口来访问该对象。
    优点：
        减少耦合：可以独立地开发、测试、优化、使用、理解和修改
        减轻维护的负担：可以更容易被程序员理解，并且在调试的时候可以不影响其他模块
        有效地调节性能：可以通过剖析来确定哪些模块影响了系统的性能
        提高软件的可重用性
        降低了构建大型系统的风险：即使整个系统不可用，但是这些独立的模块却有可能是可用的
继承:
    继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。
    Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为 向上转型 。
    继承的好处：
        1、继承的出现提高了代码的复用性，提高软件开发效率。
        2、继承的出现让类与类之间产生了关系，提供了多态的前提。
    继承的注意事项
         1、在Java中，类只支持单继承，不允许多继承，也就是说一个类只能有一个直接父类。
         2、多个类可以继承一个父类。
         3、在Java中，多层继承是可以的，即一个类的父类可以再去继承另外的父类。
           4、在Java中，子类和父类是一种相对概念，也就是说一个类是某个类父类的同时，也可以是另一个类的子类。
多态:Java中多态的代码体现在一个子类对象(实现类对象)既可以给这个子类(实现类对象)引用变量赋值，又可以给这个子类(实现类对象)的父类(接口)变量赋值。
    最终多态体现为父类引用变量可以指向子类对象。
    多态的前提是必须有子父类关系或者类实现接口关系，否则无法完成多态。
    在使用多态后的父类引用变量调用方法时，会调用子类重写后的方法。
    多态分为编译时多态和运行时多态：
    编译时多态主要指方法的重载
    运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定，即方法的重写。
    运行时多态有三个条件：
        继承
        覆盖（重写）
        向上转型
[为何说要多用组合少用继承？如何决定该用组合还是继承？](https://www.cnblogs.com/appsucc/p/13117618.html)
    尽管我们鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。在实际的项目开发中，我们还是要根据具体的情况，来选择该用继承还是组合。
    如果类之间的继承结构稳定，层次比较浅，关系不复杂，我们就可以大胆地使用继承。反之，我们就尽量使用组合来替代继承。
    除此之外，还有一些设计模式、特殊的应用场景，会固定使用继承或者组合。
[java抽象类、多态、接口](https://www.cnblogs.com/Young111/p/10033484.html)
抽象类、抽象方法的定义:
    抽象类定义的格式：abstract class 类名 {}
    抽象方法定义的格式：public abstract 返回值类型 方法名(参数);
    抽象类的特点
        1、抽象类和抽象方法都需要被abstract修饰。抽象方法一定要定义在抽象类中。
        2、抽象类不可以直接创建对象，原因：调用抽象方法没有意义。
        3、只有覆盖了抽象类中所有的抽象方法后，其子类才可以创建对象。否则该子类还是一个抽象类。
```
### 6.Java中==与equals区别比较【6+】
```markdown
[听说你还搞不定java中的==和equals？](https://www.cnblogs.com/yichunguo/p/12383853.html)
==的作用是判断两个对象的值是否相等，即判断两个对象是不是同一个对象。
    基础数据类型==比较的是值，引用对象类型==比较的是内存地址。
equals()的作用也是判断两个对象是否相等，但是一般有两种情况：
    情况1：类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于==。
    情况2：类覆盖了equals()方法，用来比较对象的内容是否相等。
```
[为什么阿里巴巴Java开发手册中强制要求整型包装类对象值用equals方法比较？]( https://www.cnblogs.com/wupeixuan/p/11759459.html )
```java
public class test1 {
    public static void main(String[] args) {
        String a = new String("ab"); // a 为⼀个引⽤
        String b = new String("ab"); // b为另⼀个引⽤,对象的内容⼀样
        String aa = "ab"; // 放在常量池中
        String bb = "ab"; // 从常量池中查找
        if (aa == bb) // true
        System.out.println("aa==bb");
        if (a == b) // false，⾮同⼀对象
        System.out.println("a==b");
        if (a.equals(b)) // true
        System.out.println("aEQb");
        if (42 == 42.0) { // true
            System.out.println("true");
        }
    }
}
```
#### 1.1 所有整型包装类对象之间值的比较，全部使用equals方法比较。【阿里巴巴Java开发手册】
```markdown
在-128至127之间的赋值,Integer对象是在IntegerCache.cache产生，会复用已有对象，这个区间内的Integer值可以直接使用==进行判断，
    但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用equals方法进行判断。
```
#### 1.2 浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用equals来判断。
### 7.为什么重写equals时必须重写hashCode方法【6+】
```markdown
[HashCode()与equals()深入理解](https://www.cnblogs.com/moershiwei/p/12643626.html)
[听说你还搞不定java中的==和equals？](https://www.cnblogs.com/yichunguo/p/12383853.html)
HashCode()的作用是确定该对象在哈希表中的索引位置。
    1、如果两个对象equals为true ，他们的hashcode一定相等。
    2、如果两个对象equals为false，他们的hashcode有可能相等。
    3、如果两个对象hashcode相等，equals不一定为true。
    4、如果两个对象hashcode不相等，equals一定为false。
**hashCode()能否重写**
能否重写是取决于方法是否有final关键字,查看object源码看下hashcode方法和getclass方法就知道了为啥hashcode可以getclass不行了;
```
### 8.重载overload和重写override【3+】
```markdown
重写override是子类对父类的允许访问的方法的实现过程进行重新编写,发生在子类中，方法名、参数列表必须相同，
    返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。
    另外，如果父类方法访问修饰符为private则子类就不能重写该方法。也就是说方法提供的行为改变，而方法的外貌并没有改变。
重载overload:发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。
```
### 9.拆箱和装箱分别是什么？分别应用在什么场景？
```markdown
拆箱和装箱：拆箱是把包装类型变成基本类型；装箱是把基本类型变成包装类型。
自动装箱都是通过包装类的valueOf()方法来实现的;自动拆箱都是通过包装类对象的xxxValue()来实现的（如booleanValue()、longValue()等）。
应用场景：当==两边是基本类型和包装类型的时候，包装类型会拆箱，然后==会比较基本类型的两个值；
当equals方法的参数是基本类型的时候，基本类型会装箱，然后equals方法会先比较两个包装类型的类型，在比较值。
```
#### 在使用三目运算符的过程中，可能会进行自动拆箱而导致NPE问题。【Java开发手册】
[我去，这么简单的条件表达式竟然也有这么多坑](https://www.cnblogs.com/goodAndyxublog/p/13047617.html)
```markdown
 boolean flag = true;
 boolean simpleBoolean = false;
 Boolean nullBoolean = null;
 boolean x = flag ? nullBoolean.booleanValue() : simpleBoolean;
反编译后的代码的最后一行，编译器帮我们做了一次自动拆箱，而就是因为这次自动拆箱，导致代码出现对于一个null对象nullBoolean.booleanValue()的调用，导致了NPE。
三目运算符当第二位和第三位操作数的类型相同时，则三目运算符表达式的结果和这两位操作数的类型相同。
当第二，第三位操作数分别为基本类型和该基本类型对应的包装类型时，那么该表达式的结果的类型要求是基本类型。
所以，Java开发手册中提到要高度注意第二位和第三位表达式的类型对齐过程中由于自动拆箱发生的NPE问题，
其实还需要注意使用三目运算符表达式给变量赋值的时候由于自动拆箱导致的NPE问题。
Boolean b = Boolean.valueOf(maps == null ? false : ((Boolean)maps.get("Hollis")).booleanValue());
```
### 10.抽象类和接口有什么区别
```markdown
- 抽象类要被子类继承，接口要被子类实现。
- 抽象类可以有构造方法，接口中不能有构造方法。
- 抽象类中可以有普通成员变量，接口中没有普通成员变量，它的变量只能是公共的静态的常量
- 一个类可以实现多个接口，但是只能继承一个父类，这个父类可以是抽象类。
- 接口只能做方法声明，抽象类中可以作方法声明，也可以做方法实现。
- 抽象级别（从高到低）：接口>抽象类>实现类。
- 抽象类主要是用来抽象类别，接口主要是用来抽象方法功能。
- 抽象类的关键字是abstract，接口的关键字是interface
```
### 11.String为什么不可变？
[Java源码之String](https://www.cnblogs.com/chentang/p/13067765.html)
```markdown
当然在Java平台类库中，包含许多不可变类，例如String , 基本类型的包装类，BigInteger, BigDecimal 等等。
类本身是final修饰的；所有的域几乎都是私有final的；不会对外暴露可以修改对象属性的方法。
String类并没有提供任何可以改变其值的方法。
使用什么方式可以改变String类的不可变性：**反射**
            String str = "chen";
            System.out.println(str);
            Field field = String.class.getDeclaredField("value");
            field.setAccessible(true);
            char[] value = (char[]) field.get(str);
            value[1] = 'a';
            System.out.println(str);
```
[String求求你别秀了](https://www.cnblogs.com/zhuoqingsen/p/String.html)
```markdown
String类有如下这些特点
    1.String类是final类，也即意味着String类不能被继承，并且它的成员方法都默认为final方法。
    2.String类其实是通过char数组来保存字符串的。
    3.String对象一旦被创建就是固定不变的了，对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象。
字符串常量池:
    1.每当我们创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么就直接返回常量池中的实例引用。
    如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中。由于String字符串的不可变性我们可以十分肯定常量池中一定不存在两个相同的字符串。
    2.字符串池的出现避免了相同内容的字符串的创建，节省了内存，省去了创建相同字符串的时间，同时提升了性能；
    另一方面，字符串池的缺点就是牺牲了JVM在常量池中遍历对象所需要的时间，不过其时间成本相比而言比较低。
1.单独使用""引号创建的字符串都是常量,编译期就已经确定存储到String Pool中；
2.使用new String("")创建的对象会存储到heap中,是运行期新创建的；
3.使用只包含常量的字符串连接符如"aa" + "aa"创建的也是常量,编译期就能确定,已经确定存储到String Pool中；
4.使用包含变量(引用)的字符串连接符如"aa" + s1创建的对象是运行期才创建的,存储在heap中；
5.但是如果s1是被final修饰的话，则s1是属于常量。结果存在String Pool，但是 final修饰的是一个方法返回的值也是在编译器确定。
String str1 = "aaa";
String str2 = "aaa";
System.out.println(str1 == str2);// true 因为String有常量池
String str3 = new String("aaa");
String str4 = new String("aaa");
System.out.println(str3 == str4);// false 可以看出用new的方式是生成不同的对象,比较堆上的
System.out.println(str3.equals(str4)); // true equals()比较值
String s0="helloworld";  
String s1="helloworld";  
String s2="hello"+"world";  
System.out.println(s0==s1); //true 可以看出s0跟s1是指向同一个对象   
System.out.println(s0==s2); //true 可以看出s0跟s2是指向同一个对象   
String st0="helloworld";   
String st1=new String("helloworld");   
String st2="hello" + new String("world");   
System.out.println( st0==st1 ); //false    用new String() 创建的字符串不是常量，不能在编译期就确定
System.out.println( st0==st2 ); //false   st2地址存在堆中，不可能相同
System.out.println( st1==st2 ); //false  
String stri1="abc";     
String stri2="def";     
String stri3=stri1+stri2;  
System.out.println(stri3=="abcdef"); //false    变量相+是在的堆内存中创建
String strin0 = "a1";   
String strin1 = "a" + 1;   //这种不是变量，是常量
System.out.println((strin0 == strin1)); //result = true    
String strin4 = "a3.4";   
String strin5 = "a" + 3.4;   
System.out.println((strin4 == strin5)); //result = true  
String string0 = "ab";   
String string1 = "b";   
String string2 = "a" + string1;   
System.out.println((string0 == string2)); //result = false  在字符串的"+"连接中，有字符串引用存在，而引用的值在程序编译期是无法确定的
```
### 12.String str="abc" 与 String str=new String (“abc”) 一样吗？为什么？
```markdown
1.使用String直接赋值：String str= “abc”：可能创建一个或者不创建对象。如果”abc”在字符串常量池中不存在，会在java字符串池中创建一个String对象（”abc”），
然后str指向这个内存地址，无论以后用这种方式创建多少个值为”abc” 的字符串对象，始终只有一个内存地址被分配；如果 “abc” 在字符串池中存在，str直接指向这个内存地址。
2.使用new String创建字符串：String str = new String(“abc”)：至少会创建一个对象，也有可能创建两个。因为用到new关键字，肯定会在堆中创建一个String对象，
如果字符池中已经存在”abc”, 则不会在字符串池中创建一个String对象，如果不存在，则会在字符串常量池中也创建一个对象。注意，此时二者地址不相同。
3.String拼接字符串：字符串拼接又分为变量拼接和已知字符串拼接。只要拼接内容存在变量，那么该拼接后的新变量就是在堆内存中新建的一个对象实体。但是不会在字符常量池中创建新对象。
4.String.intern()：当调用intern方法时，如果常量池已经包含一个等于此String对象的字符串（用equals(Object)方法确定），则返回池中的字符串。
否则，将此String对象添加到常量池中，并返回此String对象的引用。
String str=“abc” 和 String str=new String(“abc”); 产生几个对象？String str = new String("hello")+new String("123");产生了几个对象？
前者 1 或 0， 后者 2 或 1，最后一个是 3 或 4 或 5
先看字符串常量池，如果字符串常量池中没有，都在常量池中创建一个，如果有，前者直接引用，后者在堆内存中还需创建一个 “abc” 实例对象。
字符常量池的位置？字符常量池存储的内容？
字符串常量池的位置，jdk1.7从方法区移至堆中。
字符串常量池存储的是字符串字面量（注意，这里的字面量指的就是String的对象，因为String本身是一个类，而字符常量池在jdk8放在堆中，所以存储的内容全都是对象）
```
### 13.String，Stringbuffer，StringBuilder的区别【3+】
[一篇与众不同的String、StringBuilder和StringBuffer详解](https://www.cnblogs.com/cxuanBlog/p/13053615.html)
```markdown
String：
    String是final类，不能被继承。String类是一个不可变的类，一旦创建就不可以修改。每次修改都会创建新的String对象。
    String实现了equals()方法和hashCode()方法。
    String类的对象是不可变的，也就可以理解为常量，线程安全。
StringBuffer：
    继承自AbstractStringBuilder，是可变类。
    StringBuffer是线程安全的，对方法加了同步锁或者对调用的方法加了同步锁。(synchronized)
    可以通过append方法动态构造数据。执行效率比StringBuffer低。
StringBuilder：
    继承自AbstractStringBuilder，是可变类。
    StringBuilder是非线性安全的。
    执行效率比StringBuffer高。
【为什么StringBuilder的执行效率比StringBuffer高？】
[用大白话的方式讲明白Java的StringBuilder、StringBuffer的扩容机制](https://www.cnblogs.com/DMingO/p/13407303.html)
    StringBuffer和StringBuilder,都是继承了AbstractStringBuilder，它们的底层char数组value默认的初始化容量是16，
    扩容只需要修改底层的char数组，两者的扩容最终都会调用到AbstractStringBuilder类相同的方法：
        扩容的步骤：
        1.新的字符串的长度超过了底层原char数组value的大小，才需要进行扩容
        2.先尝试默认扩容，将新容量变成 (value.length << 1) + 2 ，也就是两倍的原数组长度再加二
        3.若默认扩充后的值还是小于至少容量的值，直接扩充到当前需要的至少容量大小；
        4.经过前两步骤确定的新数组大小，若大于Interger.MAX_VALUE,则报异常，若小于等于0，则新数组大小改为Interger.MAX_VALUE -8
        5.确定了新数组的值后，通过Arrays.copy(value,newCapactity)进行复制。最终给value数组完成扩容。
```
### 14.给定三个变量：i1、i2、i3。Integer i1= 120；Integer i2=120；int i3=120；i1和i2一样吗？i1和i3 呢？为什么？如果把120换成130呢，i1,12,i3的关系又如何，为什么？
```markdown
integer包装类和其他包装类不同之处，对于范围在-128到127之间的整数，integer创建对象的时候是直接从缓存读取的，这个时候直接从缓存得的的内容地址是保持一致的，
所以两个integer对象地址是相同的，但是不在这个范围的时候，地址就不在相同的。
对于integer变量和int变量，通过==比较，符合拆箱应用场景，integer会直接拆箱，所以无论什么范围，integer和int，都是直接比较值的。
1.两个基本类型的只能用 ==
2.基本型和封装型用==，封装型将会自动拆箱变为基本型后再进行比较
3.用==来比较两个封装类的话，比较的是地址。(其中-127到127之间的Integer地址相同，超出这个范围则不同)
4.至少有一个封装型的建议使用.equals。用==对基本型和封装性比较必须保证封装型不为null。如果为null则不能转化为基本型就会报错。
5.两个封装型进行equals()比较，首先equals()会比较类型，如果类型相同，则继续比较值，如果值也相同，返回true
6.封装类型调用equals(),但是参数是基本类型，这时候，先会进行自动装箱，基本型转换为其封装类型,若类型不同返回false,若装箱后类型相同，则比较值，如果值相同，则返回true
```
### 15.关键字static【2+】
>>  如果你答出static修饰变量、修饰方法我会认为你合格，答出静态块，我会认为你不错，
    答出静态内部类我会认为你很好，答出静态导包我会对你很满意，满意的原因是能看出你确实非常热衷研究技术。
```markdown
static是Java中非常重要的关键字，static表示的概念是静态的，在Java中，static主要用来
    static修饰变量，static修饰的变量称为静态变量、也称为类变量，类变量属于类所有，对于不同的类来说，static变量只有一份，
        static修饰的变量位于**方法区**中；static 修饰的变量能够直接通过 类名.变量名来进行访问，不用通过实例化类再进行使用。
        一旦属性定义上使用了static之后，只要一个对象修改了属性的内容，那么所有的对象的static属性的内容都将一起修改，
        也就是说static属性变成了一个公共属性，是全局数据区。
        （static声明的属性与普通属性的最大区别是保存的内存区域的不同，还有就是static属性在没有实例化的情况下可以使用）
    static修饰方法，static修饰的方法被称为静态方法，静态方法能够直接通过类名.方法名来使用，在静态方法内部不能使用非静态属性和方法。
        静态方法不需要创建对象就可以调用。
        static方法不能直接访问非static属性或者方法（必须要产生对象后才能调用），非static方法可以直接访问static属性或者方法
    static修饰代码块，主要分为两种，一种直接定义在类中，使用static{}，这种被称为静态代码块，一种是在类中定义静态内部类，使用static class xxx来进行定义。
         静态代码块在非静态代码块之前执行(静态代码块—>非静态代码块—>构造方法)。 该类不管创建多少对象，**静态代码块只执行一次**.
    static用于静态导包，通过使用 import static xxx 来实现，这种方式一般不推荐使用
    static和单例模式一起使用，通过双重检查锁来实现线程安全的单例模式。

```
### 16.关键字final【2+】
[我去，你竟然还不会用 Java final 关键字](https://www.cnblogs.com/qing-gee/p/13092011.html)
```markdown
final修饰类：如果一个类使用了final关键字修饰，那么它就无法被继承。类中的所有成员方法都会被隐式地指定为final方法。
final修饰方法：被final修饰的方法不能被重写。
final修饰变量：被final修饰的变量无法重新赋值。
    1）final修饰的基本数据类型，对于基本数据类型来说，final修饰的变量，其值不能被改变。
    2）final修饰的引用类型，则在对其初始化之后便不能再让其指向另一个对象。  
    3）final修饰的字段，一种是static的，另外一种是没有static的。
        非static的final字段必须有一个默认值，否则编译器将会提醒没有初始化。
        static的final字段也叫常量，它的名字应该为大写，可以在声明的时候初始化，也可以通过static代码块初始化。
    4) final修饰的参数
        final关键字还可以修饰参数，它意味着参数在方法体内不能被再修改。
使⽤final关键字修饰⼀个变量时，是指引⽤变量不能变，引⽤变量所指向的对象中的内容还是可以改变的。
    final StringBuffer a=new StringBuffer("immutable");
    a=new StringBuffer("");//编译期错误
    a.append(" broken!");//可以通过编译
```
### 17.什么是反射？反射的应用场景？
[反射那些基础-Class](https://www.cnblogs.com/homejim/p/10140928.html)
```markdown
JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；
    这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。所有反射的入口都是java.lang.Class。
因为Java中规定了java.lang.reflect包下的所有类的构造函数都不为public，因此，需要获得这些类的对象都需要调用Class类中适当的的方法。
    获取类对象的三种方式：
       通过object类的getClass()函数，由于object是根类，每一个类都有这个函数。Object.getClass()
       每一个类（包括基本数据类型，注意这里基本数据类型不用转成包装类）都有一个class属性，静态属性，通过类名直接访问。类.class;
       通过Class类的静态方法forName(String className)。Class.forName("java.lang.System");
       通过包装类的TYPE成员。对于基本数据类型，除了以上的.class方法之外，对应包装类的TYPE成员变量来获取Class对象。Double.TYPE;
    应用：
       反射是很多框架的基础
       通过反射运行配置文件
       通过反射越过泛型检查
Class里面存储了对应类的所有信息，因此，我们可以获得类相关的信息。突破私有字段的保护机制，访问并修改对象的私有字段。
反射中，Class.forName()和ClassLoader.loadClass()区别？
 Class.forName()执行的是类加载过程的链接和初始化。需要整个类完全加载到内存中，以获取该类的信息。
 ClassLoader.loadClass()执行的只是类加载过程中的第一步，加载过程。loadClass方法是在双亲委派中调用，此时判断类由哪一个类加载器加载，因此类还未加载到内存中。
```
### 18.什么是java序列化？什么情况下需要序列化？如何避免序列化对象中的属性序列化？【1+】
[序列化的几种方式](https://www.jianshu.com/p/7298f0c559dc)
```markdown
内存中的数据对象只有转换为二进制流才可以进行数据持久化和网络传输。将数据对象转换为二进制流的过程称为对象的序列化（Serialization）。
1.在Java中，我们可以通过多种方式来创建对象，并且只要对象没有被回收我们都可以复用此对象。
    但是，创建出来的这些对象都存在于JVM中的堆（stack）内存中，只有JVM处于运行状态的时候，这些对象才可能存在。
    一旦JVM停止，这些对象也就随之消失；但是在真实的应用场景中，我们需要将这些对象持久化下来，
    并且在需要的时候将对象重新读取出来，Java的序列化可以帮助我们实现该功能。
2.对象序列化机制（object serialization）是java语言内建的一种对象持久化方式，
    通过对象序列化，可以将对象的状态信息保存为字节数组，并且可以在有需要的时候将这个
    字节数组通过反序列化的方式转换成对象，对象的序列化可以很容易的在JVM中的活动对象和字节数组（流）之间进行转换。
3.Java类通过实现java.io.Serializable接口来启用序列化功能，未实现此接口的类将无法将其任何状态或者信息进行序列化或者反序列化。
    可序列化类的所有子类型都是可以序列化的。序列化接口没有方法或者字段，仅用于标识可序列化的语义。
    在JAVA中，对象的序列化和反序列化被广泛的应用到RMI（远程方法调用）及网络传输中。
属性避免序列化：
1.静态数据不能被序列化，因为静态数据不在堆内存中，而是在静态方法区中
2.将不需要序列化的属性前添加关键字 transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。
```
### 19.类的实例化顺序【1+】
```markdown
类实例化顺序为：父类静态代码块/静态域->子类静态代码块/静态域 -> 父类非静态代码块 -> 父类构造器 -> 子类非静态代码块 -> 子类构造器
```
### 20.Java泛型【3+】
[用了这么多年的 Java 泛型，你对它到底有多了解？](https://www.cnblogs.com/goodAndyxublog/p/12934938.html)
[如何在运行时(Runtime)获得泛型的真正类型](https://www.cnblogs.com/xiaoheike/p/9867060.html)
[面试官：十问泛型，你能扛住吗？](https://www.cnblogs.com/viyoung/p/13175128.html)
```markdown
Java 泛型实现方式：Java采用类型擦除（Type erasure generics）的方式实现泛型。
    用大白话讲就是这个泛型只存在源码中，编译器将源码编译成字节码之时，就会把泛型『擦除』，所以字节码中并不存在泛型。
    并不是每一个泛型参数被擦除类型后都会变成Object类，如果泛型类型为T extends String这种方式，最终泛型擦除之后将会变成String。
类型擦除带来的缺陷：
    1.不支持基本数据类型,但是Java是可以向上转型的。查看字节码，泛型参数被擦除之后，强制变成了Object类型。
    2.Java类型擦除式泛型实现方式无论使用效果与运行效率全面落后于C#的具现化式泛型。
    3.由于编译之后，泛型就被擦除，所以在代码运行期间，Java 虚拟机无法获取泛型的实际类型。
Java 泛型发展史：
    1.Java泛型最早是在JDK5的时候才被引入，但是泛型思想最早来自来自C++模板（template）。
```
### 21.Java创建对象的过程【1+】
```markdown
User user = new User();
1.类加载检查：虚拟机遇到一条new指令时，首先去检查这个指令能否在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类
    是否被加载过、解析过和初始化过。如果没有，那必须先执行相应的类加载过程。
2.分配内存：在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便确认了，为对象分配空间的任务
    等同于把一块确定大小的内存从Java堆中划分出来。分配方式有指针碰撞和空闲列表。
    虚拟机采用两种方式保证线程安全：CAS+失败重试，TLAB。
3.初始化零值：保证对象的实例字段在Java代码中可以不赋初始值就直接使用。
4.设置对象头：对象的元数据信息，对象的哈希码，对象的GC分代年龄等等信息放在对象头中。
5.执行init方法：执行new指令之后会接着执行<init>方式，把对象按照意愿进行初始化。
```
### 22.Java创建对象有几种方式【1+】
```markdown
Java创建对象有5种方式
    用new语句创建对象。（要求该Class对象对应的类有默认的空构造器）
    使用反射，使用Class.newInstance()创建对象/调用类对象的构造方法——Constructor
    调用对象的clone()方法。
    运用反序列化手段，调用java.io.ObjectInputStream对象的readObject()方法。
    使用Unsafe
```
### 23.Java中的异常处理机制的简单原理和应⽤
```markdown
Java对异常进⾏了分类，不同类型的异常分别⽤不同的Java类表示，所有异常的根类为java.lang.Throwable，
Throwable下⾯⼜派⽣了两个⼦类：Error和Exception，Error 表示应⽤程序本身⽆法克服和恢复的⼀种严重问题，程序只有死的份了，
例如，说内存溢出和线程死锁等系统问题。
Exception表示程序还能够克服和恢复的问题，其中⼜分为系统异常和普通异常，系统异常是软件本身缺陷所导致的问题，也就是软件开发⼈员考虑不周所导致的问题，
软件使⽤者⽆法克服和恢复这种问题，但在这种问题下还可以让软件系统继续运⾏或者让软件死掉，
例如，数组脚本越界（ArrayIndexOutOfBoundsException），空指针异常（NullPointerException）、类转换异常（ClassCastException）；
普通异常是运⾏环境的变化或异常所导致的问题，是⽤户能够克服的问题，例如，⽹络断线，硬盘空间不够，发⽣这样的异常后，程序不应该死掉。
```
### 24.throw和throws的区别？
```markdown
throws声明：
    如果一个方法内部的代码会抛出检查异常(checked exception)而方法自己又没有完全处理掉，则javac保证你必须在方法的签名上使用throws关键字声明这些可能抛出的异常，否则编译不通过。
    throws是另一种处理异常的方式，它不同于 try…catch…finally，throws仅仅是将函数中可能出现的异常向调用者声明，而自己则不具体处理。
throw异常抛出语句：
    程序员也可以通过throw语句手动显式的抛出一个异常。throw语句的后面必须是一个异常对象。
    throw语句必须写在函数中，执行throw语句的地方就是一个异常抛出点，它和由 JRE自动形成的异常抛出点没有任何差别。
    在异常处理中，try语句要捕获的是一个异常对象，那么此异常对象也可以自己抛出。
    try-catch-finally 中哪个部分可以省略？finally 可以省略，其他都不可以省略
    try-catch-finally中，如果catch中return了，finally 还会执行吗？
在try块中即便有return，break，continue等改变执行流的语句，finally也会执行。try…catch…finally中的return只要能执行，就都执行了，他们共同向同一个内存地址
（假设地址是 0×80）写入返回值，后执行的将覆盖先执行的数据，而真正被调用者取的返回值就是最后一次写入的。finally中的return会覆盖try或者catch中的返回值。
finally中的return和方法的return不能共存，因为finally是异常处理的最后执行的部分，finally必定执行，内部的return跟方法最后的return存在冲突。
```
### 25.常见的异常类有哪些？java异常的执行流程？
```markdown
error错误类：NoClassDefFoundError、StackOverFlowError、OutOfMemoryError。
exception类：IOException（FileNotFindException）、RuntimeException（NullPointException）
在Java应用程序中，异常处理机制为：抛出异常，捕捉异常。
抛出异常：当一个方法出现错误引发异常时，方法创建异常对象并交付运行时系统，异常对象中包含了异常类型和异常出现时的程序状态等异常信息。
运行时系统负责寻找处置异常的代码并执行。
捕捉异常：在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器（exceptionhandler）。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。
当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适的异常处理器。运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常
处理器的方法并执行。当运行时系统遍历调用栈而未找到合适的异常处理器，则运行时系统终止。同时，意味着Java程序的终止。
```
### 26.NoClassDefFoundError和ClassNotFoundException区别【1+】
[聊聊面试-NoClassDefFoundError和ClassNotFoundException区别](https://www.cnblogs.com/xiao2shiqi/p/11740563.html)
```markdown
当应用程序运行的过程中尝试使用类加载器去加载Class文件的时候，如果没有在classpath中查找到指定的类，就会抛出ClassNotFoundException。
当JVM在加载一个类的时候，如果这个类在编译时是可用的，但是在运行时找不到这个类的定义的时候，JVM就会抛出一个NoClassDefFoundError错误。
比如当我们在new一个类的实例的时候，如果在运行是类找不到，则会抛出一个NoClassDefFoundError的错误。（这个情况是我们的class文件被删除了）
总结：当动态加载Class的时候找不到类会抛出异常，当编译后找不到类的时候，会抛error
```
### 27.Error和Exception的区别【2+】
```markdown
Throwable是Java语言中所有错误或异常的超类。下一层分为Error和Exception。
Error和Exception都是继承Throwable类，它们体现Java设计者在对异常的不同情况所进行的分类处理，
在Java中只有Throwable类的实例才能被try/catch捕获或者声明抛出。
Error在大多数情况下代表程序出现了致命并且不可恢复的错误，它们大多都是不可预测的错误，不需要也不能捕获和抛出，
    例如常见的OutOfMemeryError，StackOverFlowError，还有本文提到的 NoClassDefFoundError，他们都是Error的子类。
Exception属于程序错误，大多是人为编码所导致的，它们大多都可以预测，也可以通过程序处理让程序正常流程，所以是需要进行捕获（try/catch）或者声明抛出（throw）的，
    Exception还分两种情况，可检查异常checked exception（编译期异常），非检查异常unchecked exception（运行期异常）
常见的RuntimeException异常：
    - NullPointerException 空指针异常
    - ArithmeticException 出现异常的运算条件时，抛出此异常
    - IndexOutOfBoundsException 数组索引越界异常
    - ClassNotFoundException 找不到类异常
    - IllegalArgumentException(非法参数异常)
常见的 Checked Exception 异常：
    - IOException (操作输入流和输出流时可能出现的异常)
    - ClassCastException(类型转换异常类)
```
### 28.final, finally, finalize的区别【2+】
```markdown
final用于修饰属性,方法和类, 分别表示属性不能被重新赋值, 方法不可被覆盖, 类不可被继承。
    内部类要访问局部变量，局部变量必须定义成final类型。
finally是异常处理语句结构的一部分，一般以ty-catch-finally出现，finally代码块表示总是被执行。
finalize是Object类的一个方法，该方法一般由垃圾回收器来调用，当我们调用System.gc()方法的时候，
    由垃圾回收器调用finalize()方法，回收垃圾，JVM并不保证此方法总被调用。
```
### 29.try-catch-finally 语法块的执行顺序等问题【1+】
>>  [try、catch、finally语句中有return的各类情况](https://www.cnblogs.com/yychuyu/p/13199329.html)
```markdown
return语句已经执行了再去执行finally语句，不过并没有直接返回，而是等finally语句执行完了再返回结果
```
### 30.设计模式
#### 1.熟悉的设计模式
>> 单例模式，工厂模式，代理模式
#### 2.单例模式【1+】
[【极客思考】设计模式：你确定你真的理解了单例模式吗？](https://www.cnblogs.com/huaweiyun/p/12973585.html)
```markdown
一个类只能创建一个实例，并提供一个访问它的全局访问点。
一、双重校验锁（DCL） 1.如果不用volatile修饰会怎么样？2.volatile作用是啥？
二、静态内部类
三、枚举
单例模式真的有那么好吗？
    优点：
    1.提供了唯一实例的受控访问。
    2.因为只有一个实例，节约了系统资源，提高系统性能。
    缺点：
    1.单例模式没有抽象层，扩展比较困难。
    2.单例类的职责过重，违背了“单一职责原则”。
四、通过Spring实现的单例。
设计模式的单例是在整个Java应用中只有一个实例，而Spring中的单例是在一个IOC容器中就只有一个单例。
但对于web应用来说，web容器（Jetty或tomcat）对用户的每个请求都会创建一个单独的servlet线程去处理请求，
Spring框架下的接口每个action也都是单例的，那么其实就保证了我们使用的是一个实例。
同时Spring也支持我们通过注解或者xml进行lazy-init，也可以指定scope确定其是否为全局单例，又或者是多个实例，对于程序来说有了更多的选择。
/饿汉式，类加载时就实例化一个对象，能快速创一个单例对象，而且线程安全(只有类加载时初始化)，缺点是不支持延迟加载，不管要不要都会直接创一个对象
public class Id {
   private static final Id instance = new Id();
   private Id() {}
   public static Id getInstance() {
     return instance;
   }
}
//懒汉式单例，只有在调用getInstance时才会实例化一个单例对象,优点是支持延迟加载，缺点是调用方***频繁加锁释放锁，并发度比较低
public class Id {
    public static Id instance;
    private Id(){}
    public static synchronized Id getInstance(){
      if(instance==null){       //step 1.
         instance = new Id();  //step 2
       }
    return instance;
    }
}
//双重检测，支持延迟加载和高并发。只要 instance 被创建之后，再调用 getInstance() 函数都不会进入到加锁逻辑中
public class Id {
  private static volatile Id instance;
  private Id() {}
  public static Id getInstance() {
    if (instance == null) {
      synchronized(Id.class) { // 此处为类级别的锁
        if (instance == null) {
          instance = new IdG();
        }
      }
    }
    return instance;
  }
}
```
[对于单例模式面试官会怎样提问呢？你又该如何回答呢？](https://www.cnblogs.com/Ccwwlx/p/13053922.html)
#### 3.代理模式有什么用？应用场景是什么？【2+】
```markdown
代理（Proxy）模式是结构型的设计模式之一，它可以为其他对象提供一种代理（Proxy）以控制对这个对象的访问。
所谓代理，是指具有与被代理的对象具有相同的接口的类，客户端必须通过代理与被代理的目标类交互。
应用场景：
     需要控制对目标对象的访问。
     需要对目标对象进行方法增强。如：添加日志记录，计算耗时等。
     需要延迟加载目标对象。
实现动态代理的两种方式：JDK动态代理和Gglib动态代理
     JDK动态代理是实现了被代理对象的接口，Cglib是继承了被代理对象。
     JDK和Cglib都是在运行期生成字节码，JDK是直接写Class字节码，Cglib使用ASM框架写Class字节码，Cglib代理实现更复杂，生成代理类比JDK效率低。
     JDK调用代理方法，是通过反射机制调用，Cglib是通过FastClass机制直接调用方法，Cglib执行效率更高。
动态代理是什么？与静态代理的区别在于？
Java中的静态代理要求代理主题 (ProxySubject)和真实主题(RealSubject)都实现同一个接口(Subject)。静态代理中代理类在编译期就已经确定，
而动态代理则是JVM运行时动态生成，静态代理的效率相对动态代理来说相对高一些，但是静态代理代码冗余大，一但需要修改接口，代理类和委托类都需要修改。
```
#### 4.简单工厂和抽象工厂有什么区别？
```markdown
工厂模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类
抽象工厂模式：为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类
```
#### 5.装饰者模式和适配器模式以及代理模式的区别？
```markdown
装饰者和代理模式的区别
 装饰者模式关注的是对象的动态添加功能。代理模式关注的是对对象的控制访问，对它的用户隐藏对象的具体信息。
装饰者模式和适配器模式
 装饰者模式和被装饰的类要实现同一个接口，或者装饰类是被装饰的类的子类。适配器模式和被适配的类具有不同的接口。
 适配器模式被用于桥接两个接口，而装饰模式的目的是在不修改类的情况下给类增加新的功能。
```
#### 6.JDK库中使用的设计模式？
```markdown
装饰器设计模式（Decorator design pattern）被用于多个Java IO类中。
单例模式（Singleton pattern）用于Runtime，Calendar 和其他的一些类中。
工厂模式（Factory pattern）被用于各种不可变的类如Boolean，像Boolean.valueOf，
观察者模式（Observer pattern）被用于Swing和很多的事件监听中。
```
[谈谈Java常用类库中的设计模式 - Part Ⅰ](https://www.cnblogs.com/notayeser/p/12917516.html)
```markdown

```
### 31.生产者消费者模式
[生产者消费者模型在项目中的实际应用](https://www.cnblogs.com/0813lichenyu/p/11599421.html)
### 32.jdk1.8新增的变化
[关于Java8的精心总结](https://www.cnblogs.com/yychuyu/p/13332293.html)
```markdown
新特性：
    接口增强，使用default与static在接口中定义方法
    lambda表达式
    方法引用
    内建函数式接口
方法函数变化：    
    Hashmap 红黑树，扩容
    concurrentHashmap 红黑树，进一步减少锁的粒度
    Jvm常量池的变化，字符常量池在jdk1.7从方法区脱离放入堆中，方法区则在jdk1.8中变成元空间。
```
### 33.内部类
[InnerDemo1:Java内部类的四种分类以及作用](https://www.cnblogs.com/hackerstd/p/12547503.html)
```markdown
内部类的定义：在一个类的内部定义了其他的类，内部类的最大优点是：可以方便的访问外部类的私有操作
反之，外部类也可以通过内部类对象访问内部类的私有属性，
使用static定义内部类，一定不可能受到外部类的实例化控制，相当于一个外部类。内部类可以在方法中定义
```

## 七、其他
### [1.如何判断一个元素在亿级数据中是否存在？](https://www.cnblogs.com/crossoverJie/p/10018231.html)【2+】
[如何从亿量级中判断一个数是否存在？](https://www.cnblogs.com/kubidemanong/p/10147685.html)
```markdown
1.非常大的一个数据量，无法完全放进内存，或没有必要放进内存，造成系统性能消耗。
    1.大多数想到的都是用HashMap来存放数据，因为它的写入查询的效率都比较高。
    写入和判断元素是否存在都有对应的API，所以实现起来也比较简单。会造成内存溢出。
    2.Bloom Filter：用于解决判断一个元素是否在一个集合中，但它的优势是只需要占用很小的内存空间以及有着高效的查询效率。
    因为只是需要判断数据是否存在，也不是需要把数据查询出来，所以完全没有必要将真正的数据存放进去。
    3.bitmap：采用一个二进制位来存储数据的方法。
```
### [2.面试问题---JAVA程序CPU占用过高怎么定位](https://www.cnblogs.com/nijunyang/p/13040511.html)
>> 假如生产环境出现CPU占用过高，谈一谈分析思路和定位
```markdown
结合Linux和JDK命令一起分析
    1.先用top命令找到CPU占用最高的 top |grep java  或者 jps指令找到java进程的pid（6167）
    2.ps -ef 或者jps 进一步定位，得知是一个怎么样的后台程序 top -H -p pid:以线程的形式查看该进程 top -H -p 6167
    3.定位到具体线程或者代码 ps -mp 进程 -o THREAD,tid,time
            -m 显示所有线程
            -p pid进程使用cpu的时间
            -o 该参数后面是用户自定义格式
    4.将需要的线程ID转换为16进制格式(英文小写格式)
    5.jstack 进程 ID | grep tid(16进制线程ID小写英文) -A60  jstack 6167 >threadInfo.txt   信息输出到文件 然后查看。
性能监控工具
    jps(虚拟机进程状况工具) 
    jinfo(Java配置信息工具)
    jmap(内存映射工具)
    jstat(统计信息监控工具)
```
### 3.面试题：&和&&的区别， | 和|| 的区别？
```markdown
&和| 是位运算符 ，&&和||是逻辑运算符，不能用于位运算。
&：所有的条件都要判断， && 当前一个判断为false时后面不用判断直接返回false
|：所有的条件都要判断， || 当前一个判断为true时，后面一个不用判断直接返回true
```
## 4.如何生成一个有上亿个无序不重复随机数的文件
```markdown
我：用不同区间的随机函数和HashSet生成
面试官：这会整体有序，怎么解决
我：整体再shuffle一下
面试官：有更好的办法吗？    无。。。
6. 还是上个问题，如何对这个文件中的数据排序？
我：分治思想，分成小段排序然后归并
面试官：怎么归并？
我：两两归并。说完就知道错了，然后没想出来。。
```
##
[一份热乎乎的腾讯后端面试真题](https://www.cnblogs.com/jay-huaxiao/p/12776714.html)
[Java面试系列第2篇-Object类中的方法](https://www.cnblogs.com/extjs4/p/12772027.html)
[Java岗结束春招，总结面经回馈牛客，祝大家都能得偿所愿~](https://www.nowcoder.com/discuss/416945?type=2)
[各大公司面试题分类整理](https://www.cnblogs.com/lvmengtian/p/12796820.html)
[Java 基础知识面试题大集合](https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247489209&idx=3&sn=7b7a91570b32390645c83a4f32a5e2f0&chksm=fa0e7938cd79f02ee9807b7122bcae0c406a3903e01d07991b356da1b102dae759689fdee918&mpshare=1&scene=23&srcid=&sharer_sharetime=1590987905222&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
[Java面试全解析](https://my.oschina.net/u/2539475?tab=newest&catalogId=6934862)



## 面试题总结
java基础
为什么String定义为final。
描述下java集合，项目中用到哪些。
StringBuilder和StringBuffer的区别。
HashMap中常用的方法有哪些，什么时候会触发树化，jdk1.7和1.8实现的差异，1.7的实现为什么会出现死锁，画图说明下。HashMap和TreeMap的区别。
说下枚举类型，底层实现原理，项目中是如何使用的。
详细描述Error和Exception(运行期和编译期)的区别。
创建线程的方式，线程的生命周期。
ThrealLocal实现原理，为什么会出现内存泄漏。
volatile关键字原理，项目中是如何使用的。
synchronized和lock的区别，底层实现原理。AQS队列实现原理，用了哪些设计模式。公平锁和非公平锁、独占锁和共享锁、读写锁分别是如何实现的，为什么说非公平锁比公平锁性能高。
序列化和反序列化。
深拷贝和浅拷贝区别。
java内部类的区别(成员内部类、静态嵌套类、方法内部类、匿名内部类 )。
java线程池参数描述，线程池工作原理，线程池如何调优。
主线程到达一个条件，需要多个子线程去执行任务，等子任务都执行完后再往下走，如何编写代码(CountDownLatch)。
写个程序，两个线程交叉打印1到100的数字，需要多种实现方式。
JVM
JVM运行时数据区域和内存模型描述，jdk8为什么移除方法区。
垃圾回收算法和垃圾回收器描述，在工作中，新生代和老年代分别用的什么垃圾回收器。
新生代和老年代什么时候会触发GC。
四种引用区别。
CMS垃圾回收过程描述，CMS有哪些缺点，对比G1。
GC调优步骤，有实操过吗。
描述下JVM类加载过程，如何自定义类加载器。
描述下双亲委派模型，为什么需要双亲委派模型。
泛型是如何实现的，逃逸分析知道吗，说下。
OOM、内存泄漏如何排查，用到哪些工具，如果不用工具如何进行定位。
机器负载变高如何排查，如果发现是jvm进程引起的，如何定位到代码行。

MySQL
事务描述，ACID讲解。
事务隔离级别描述，脏读、不可重复读、幻读区别，MVCC机制讲解。
Innodb如何解决幻读，间隙锁实现详细描述。
left join和inner join的区别，嵌套子查询如何优化。
如果线上出现慢sql，如何定位和解决，有实际动手优化过慢sql吗。
binlog机制描述，binlog日志格式有哪些。
MySQL主从架构(读写分离)，主从数据复制过程，数据复制过程丢失如何处理。
分库分表如何实现，用过哪些分库分表插件，底层原理是怎样的。
索引有哪些种类，建立索引的原则，聚簇索引和非聚簇索引实现区别，联合索引如何使用。
mysql写入数据的时候，是先把数据写到缓冲区，然后再flush到磁盘的，如何在flush过程中发生了宕机，数据如何恢复。
Redis
redis数据类型，说下跳跃表是如何实现的，可以用什么数据结构替换。
删除过期key策略有哪些，内存淘汰策略有哪些，分别什么时候触发。
redis线程模型和内存模型。
redis持久化机制。
redis集群方案。
让你设计一个redis，你会怎么做，有看过redis源码吗。
了解一致性hash算法吗，描述下。
用redis实现一个分布式锁。
缓存穿透、缓存击穿、缓存雪崩区别和解决方案。
布隆过滤器知道吗，说下原理。
Dubbo
描述一下rpc调用过程。
让你实现一个rpc框架，你会怎么做。
链路跟踪和熔断机制了解吗，框架层如何实现的。
了解哪些序列化协议，有什么区别，项目中用的是什么协议。
说下Netty，bio、nio、aio区别，select、poll、epoll区别，什么是零拷贝机制。
Kafka
Kafka、RabbitMQ、RocketMQ区别，为什么RabbitMQ时延最低，知道事务消息吗。
Kafka生产者、消费者、协调者、服务端工作机制，描述数据从生产端到消费端到过程。
如果出现数据丢失或者数据重复消费如何处理。
Kafka为什么高吞吐量。
Kafka是如何实现exactly once语义的。
让你设计一个消息队列，你会怎么设计。
Zookeeper
zookeeper节点类型、服务器角色，watch机制。
描述下ZAB协议。
应用场景。
使用zookeeper实现分布式锁和读写锁。
算法编程
无重复字符的最长子串
二叉树的直径
二叉树最大宽度
寻找旋转排序数组中的最小值
旋转链表
LRU缓存机制
数据流的中位数
搜索旋转排序数组
设计模式
单例模式：多种实现方式，double check实现原理，枚举类实现(枚举类为什么不能被反射)
模版方法设计模式：工程中的应用
静态代理和动态代理设计模式
装饰器模式
适配器模式
工程方法模式
责任链模式
[如何短时间内快速通过Java面试](https://www.cnblogs.com/javazhiyin/p/13023668.html)
[Java 最常见的 200+ 面试题汇总:没有答案](https://www.cnblogs.com/over/p/10468747.html)
[【2019春招准备：总目录】](https://blog.csdn.net/qq_33907408/article/details/84477343)
[Java面试题：在Java中，如何跳出当前的多重嵌套循环？](https://www.breakyizhan.com/javamianshiti/2361.html)

Java基础
1.HashMap的源码，实现原理，JDK8中对HashMap做了怎样的优化。
2.HaspMap扩容是怎样扩容的，为什么都是2的N次幂的大小。
3.HashMap，HashTable，ConcurrentHashMap的区别。
4.极高并发下HashTable和ConcurrentHashMap哪个性能更好，为什么，如何实现的。
5.HashMap在高并发下如果没有处理线程安全会有怎样的安全隐患，具体表现是什么。
6.java中四种修饰符的限制范围。
7.Object类中的方法。
8.接口和抽象类的区别，注意JDK8的接口可以有实现。
9.动态代理的两种方式，以及区别。
10.Java序列化的方式。
11.传值和传引用的区别，Java是怎么样的，有没有传值引用。
12.一个ArrayList在循环过程中删除，会不会出问题，为什么。
13.@transactional注解在什么情况下会失效，为什么。
数据结构和算法
1.B+树
2.快速排序，堆排序，插入排序（其实八大排序算法都应该了解
3.一致性Hash算法，一致性Hash算法的应用
JVM
1.JVM的内存结构。
2.JVM方法栈的工作过程，方法栈和本地方法栈有什么区别。
3.JVM的栈中引用如何和堆中的对象产生关联。
4.可以了解一下逃逸分析技术。
5.GC的常见算法，CMS以及G1的垃圾回收过程，CMS的各个阶段哪两个是Stop the world的，CMS会不会产生碎片，G1的优势。
6.标记清除和标记整理算法的理解以及优缺点。
7.eden survivor区的比例，为什么是这个比例，eden survivor的工作过程。
8.JVM如何判断一个对象是否该被GC，可以视为root的都有哪几种类型。
9.强软弱虚引用的区别以及GC对他们执行怎样的操作。
10.Java是否可以GC直接内存。
11.Java类加载的过程。
12.双亲委派模型的过程以及优势。
13.常用的JVM调优参数。
14.dump文件的分析。
15.Java有没有主动触发GC的方式（没有）。
多线程
1.Java实现多线程有哪几种方式。
2.Callable和Future的了解。
3.线程池的参数有哪些，在线程池创建一个线程的过程。
4.volitile关键字的作用，原理。
5.synchronized关键字的用法，优缺点。
6.Lock接口有哪些实现类，使用场景是什么。
7.可重入锁的用处及实现原理，写时复制的过程，读写锁，分段锁（ConcurrentHashMap中的segment）
8.悲观锁，乐观锁，优缺点，CAS有什么缺陷，该如何解决。
9.ABC三个线程如何保证顺序执行。
10.线程的状态都有哪些。
11.sleep和wait的区别。
12.notify和notifyall的区别。
13.ThreadLocal的了解，实现原理。
数据库相关
1.常见的数据库优化手段

2.索引的优缺点，什么字段上建立索引

3.数据库连接池。

4.durid的常用配置。


计算机网络

1.TCP，UDP区别。

2.三次握手，四次挥手，为什么要四次挥手。

3.长连接和短连接。

4.连接池适合长连接还是短连接。


设计模式

1.观察者模式

2.代理模式

3.单例模式，有五种写法，可以参考文章单例模式的五种实现方式

4.可以考Spring中使用了哪些设计模式


分布式相关

1.分布式事务的控制。

2.分布式锁如何设计。

3.分布式session如何设计。

4.dubbo的组件有哪些，各有什么作用。

5.zookeeper的负载均衡算法有哪些。

6.dubbo是如何利用接口就可以通信的。


缓存相关
    1.redis和memcached的区别。
    2.redis支持哪些数据结构。
    3.redis是单线程的么，所有的工作都是单线程么。
    4.redis如何存储一个String的。
    5.redis的部署方式，主从，集群。
    6.redis的哨兵模式，一个key值如何在redis集群中找到存储在哪里。
    7.redis持久化策略。

框架相关
    1.SpringMVC的Controller是如何将参数和前端传来的数据一一对应的。
    2.Mybatis如何找到指定的Mapper的，如何完成查询的。
    3.Quartz是如何完成定时任务的。
    4.自定义注解的实现。
    5.Spring使用了哪些设计模式。
    6.Spring的IOC有什么优势。
    7.Spring如何维护它拥有的bean。

一些较新的东西
    1.JDK8的新特性，流的概念及优势，为什么有这种优势。
    2.区块链了解
    3.如何设计双11交易总额面板，要做到高并发高可用。