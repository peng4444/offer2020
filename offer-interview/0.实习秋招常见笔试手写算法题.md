# 实习秋招常见笔试手写算法题

## 基础
```
循环队列的相关条件和公式：  
队尾指针是rear,队头是front，其中QueueSize为循环队列的最大长度  
1.队空条件：rear==front  
2.队满条件：(rear+1) %QueueSIze==front  
3.计算队列长度：（rear-front+QueueSize）%QueueSize  
4.入队：（rear+1）%QueueSize  
5.出队：（front+1）%QueueSize

二维数组排序
    Array.sort(arr,(a,b)->(a[0]-b[0]));//递增排序
    Array.sort(arr,(a,b)->(a[1]-a[2]));//递减排序
// 使用大堆顶-从大到小排序
        PriorityQueue<Integer> heap = new PriorityQueue<>((n1, n2) -> n2 - n1);
// 使用小堆顶-从小到大排序
        PriorityQueue<Integer> heap = new PriorityQueue<>((n1, n2) -> n1 - n2);
HashMap迭代
    //entrySet方法遍历
    Set<Map.Entry<String,Student>> set = map.entrySet();
            for (Iterator<Map.Entry<String, Student>> i = set.iterator(); i.hasNext();) {
                System.out.println(i.next().getValue());
    
            }
     //keySet方法遍历
    Set<String> set = map.keySet();
            for (Iterator<String> i = set.iterator(); i.hasNext();) {
                System.out.println(map.get(i.next()));
            }
    //values方法遍历
    Collection c = map.values();
            for (Iterator<Student> i = c.iterator(); i.hasNext();) {
                System.out.println(i.next());
            }
HashMap排序
    Map<String, Integer> map = new HashMap<String, Integer>();
    //1.按key排序
    Set set=phone.keySet();
            Object[] arr=set.toArray();
            Arrays.sort(arr);
            for(Object key:arr){
                System.out.println(key);
            }
    //2.按value排序
            Collections.sort(list, new Comparator<Map.Entry<String, Integer>>() {
               @Override
               public int compare(Map.Entry<String, Integer> o1, Map.Entry<String, Integer> o2) {
                   return o2.getValue().compareTo(o1.getValue());
               }
           });

```

## 我经历的笔试
### 20200820-4399-
    Linux统计出现IP次数最多的
#### 1.最长不重复子串 LeetCode3,剑指 Offer48.最长不含重复字符的子字符串
```markdown

```
#### 2.IP TOP-K
### 20200823-安恒-10:00
#### 1.YYYY-MM-DD 计算是一年中的第第几天【ri-闰年怎么判断都不知道】
```markdown
public class Main {
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int Y = sc.nextInt();
        int M = sc.nextInt();
        int D = sc.nextInt();
        System.out.println(help(Y,M)+D);
    }
    private static int help(int y,int m){
        int sum = 0;
        int[] months;
        if(checkY(y)){
            months = new int[]{31,29,31,30,31,30,31,31,30,31,30,31};
        }else{
            months = new int[]{31,28,31,30,31,30,31,31,30,31,30,31};
        }
        for(int i = 0;i<m-1;i++){
            sum+=months[i];
        }
        return sum;
    }
    private static boolean checkY(int y){
        if((y%4==0&&y%100!=0)||(y%400==0)) return true;
        else return false;
    }
}
```
#### 回文素数判断【第一次做出笔试题】
```markdown
//判断一个数即是回文数又是素数
```
### 20200823-爱奇艺-15:00【全部LeetCode原题-cao】
#### 1.n的阶乘末尾0 LeetCode172
```markdown
//1.n的阶乘的末尾0-计算乘法因子里面有多少个5 - leetcode-172. 阶乘后的零
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int ans = 0;
        while(n>=5){
            ans +=n/5;
            n = n/5;
        }
        return ans;
    }
}
```
#### 2.路径是否相交 LeetCode 1496.判断路径是否相交
```markdown
//2.路径是否相交 -leetcode 1496. 判断路径是否相交
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        Stirng paths = sc.nextLine();
        Set<String> set = new HashSet<>();
        int x = 0;
        int y = 0;
        set.add(x+","+y);
        for(int i = 0;i<paths.length();i++){
            char ch = paths.charAt(i);
            if('N'==ch){ y++;}
            if('S'==ch){ y--;}
            if('E'==ch){ x++;}
            if('W'==ch){ x--;}
            if(set.contains(x+","+y)) return true;
            else set.add(x+","+y);
        }
        return false;
    }
}
```
#### 3.判断字符串括号是否匹配 LeetCode20
```markdown
// leetcode -20. 有效的括号
//建立一个新的栈，然后遍历字符串的字符，进行比较
    public boolean isValid3(String s) {
        Stack<Character> stack = new Stack<>();
        for (char c : s.toCharArray()) {
            if(c=='(') stack.push(')');
            else if(c=='[') stack.push(']');
            else if(c=='{') stack.push('}');
            else if(stack.isEmpty()||c!=stack.pop()) return false;
        }
        return stack.isEmpty();
    }
```
### 20200825-完美世界
#### 1.0-1背包
```markdown
输入背包容量 15
几个分别背包容量    5  3  4 6
几个背包对应的值    20 12 10 30
输出 62
public int zeroOnePackOpt(int V, int[] C, int[] W) { 
    // 防止无效输入
    if ((V <= 0) || (C.length != W.length)) {
        return 0;
    }
    int n = C.length;
    int[] dp = new int[V + 1];
    // 背包空的情况下，价值为 0
    dp[0] = 0;
    for (int i = 0; i < n; ++i) {
        for (int j = V; j >= C[i]; --j) {
            dp[j] = Math.max(dp[j], dp[j - C[i]] + W[i]);
        }
    }
    return dp[V];
}
```
## 常见的面试手写
### 查找排序
![](https://img2020.cnblogs.com/blog/1176183/202004/1176183-20200402212157028-1769221183.png)
#### 二分查找-有序
```markdown
//迭代
    int binarySearch(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1; // 注意
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target)
                return mid;
            else if (nums[mid] < target)
                left = mid + 1; // 注意
            else if (nums[mid] > target)
                right = mid - 1; // 注意
        }
        return -1;
    }
    //寻找左侧边界的二分搜索
    int left_bound(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid - 1;
            } else if (nums[mid] == target) {
                // 别返回，锁定左侧边界
                right = mid - 1;
            }
        }
        // 最后要检查 left 越界的情况
        if (left >= nums.length || nums[left] != target)
            return -1;
        return left;
    }
    //寻找右侧边界的二分查找   ​
    int right_bound(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid - 1;
            } else if (nums[mid] == target) {
                // 别返回，锁定右侧边界
                left = mid + 1;
            }
        }
        // 最后要检查 right 越界的情况
        if (right < 0 || nums[right] != target)
            return -1;
        return right;
    }

```
#### 有序数组的二分查找--查找元素第一次和最后一次出现的位置
[有序数组的二分查找---查找元素第一次和最后一次出现的位置](https://blog.csdn.net/u014067137/article/details/80335588)
```markdown
//第一次出现的位置
private static int first(int[] a, int key) {
		// TODO Auto-generated method stub
		int min=0,max=a.length-1;
		int mid=0;
		while(min<=max){
			mid=(max+min)/2;
			if (key>a[mid]) {
				min=mid+1;
			}else {
				max=mid;
			}
			if (max==min) {
				break;
			}
		}
		if (a[min]!=key) {//当查找元素不存在时，返回-1
			return -1;
		}else {
			return min;
		}
	}
//最后一次出现的位置
private static int last(int[] a, int key) {
		int min=0,max=a.length-1;
		int mid=0;
		while(min<=max){
			mid=(max+min+1)/2;
			if (key>=a[mid]) {
				min=mid;
			}else {
				max=mid-1;
			}
			if (max==min) {
				break;
			}
		}
		if (a[max]!=key) {//当查找元素不存在时，返回-1
			return -1;
		}else {
			return max;
		}
	}

```
#### 选择排序 时间复杂度O(n^2) 不稳定排序
```markdown
//第一个跟后面的所有数相比，如果小于（或小于）第一个数的时候，暂存较小数的下标，
   *   第一趟结束后，将第一个数，与暂存的那个最小数进行交换，第一个数就是最小（或最大的数）
   *   下标移到第二位，第二个数跟后面的所有数相比，一趟下来，确定第二小（或第二大）的数
   *   重复以上步骤，直到指针移到倒数第二位，确定倒数第二小（或倒数第二大）的数，那么最后一位也就确定了，排序完成。
public int[] chanceSort(int[] array) {
        if (null == array || array.length == 0) {
            throw new RuntimeException("数组为null或长度为0");
        }
        int[] arr = Arrays.copyOf(array,array.length);
        for (int i = 0; i < arr.length; i++) {
            int min = i;
            for (int j = i + 1; j < arr.length; j++) {
                if (arr[j] < arr[min]) {
                    min = j;
                }
            }
            if (i != min) {
                int temp = arr[i];
                arr[i] = arr[min];
                arr[min] = temp;
            }
        }
        return arr;
    }
```
#### 插入排序 时间复杂度O(n^2)
```markdown
//第一位数已经有序从第二位开始遍历，当前数（第一趟是第二位数）与前面的数依次比较，如果前面的数大于当前数，则将这个数放在当前数的位置上，当前数的下标-1，
   * 重复以上步骤，直到当前数不大于前面的某一个数为止，这时，将当前数，放到这个位置。
   * 1-3步就是保证当前数的前面的数都是有序的，内层循环的目的就是将当前数插入到前面的有序序列里
   * 重复以上3步，直到遍历到最后一位数，并将最后一位数插入到合适的位置，插入排序结束。
public int[] insertSort(int[] num) {
        if (null == num || num.length == 0) {
            throw new RuntimeException("数组为null或长度为0");
        }
        for (int i = 1, j, current; i < num.length; i++) {
            current = num[i];
            for (j = i - 1; j >= 0 && num[j] > current; j--) {
                num[j + 1] = num[j];
            }
            num[j + 1] = current;
        }
        return num;
    }
```
#### 冒泡排序 时间复杂度O(n^2)
```markdown
//把相邻的元素两两比较，当一个元素大于右侧相邻元素时，交换它们的位置；当一个元素小于或等于右侧相邻元素时，位置不变。
//冒泡排序
    public static void MaopaoSort(int[] array) {
        if (null == array || array.length == 0) {
            throw new RuntimeException("数组为null或长度为0");
        }
        //外循环是趟数，每一趟都会将未排序中最大的数放到尾端
        for (int i = 0; i < array.length - 1; i++) {
            //内循环是从第一个元素开始，依次比较相邻元素，
            // 比较次数随着趟数减少，因为每一趟都排好了一个元素
            for (int j = 0; j < array.length - i - 1; j++) {
                int temp = 0;
                if (array[j] > array[j + 1]) {
                    temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                }
            }
        }
    }
    //优化1：在最后一次交换开始之前，已经有序，就提前终止循环排序
    public static void MaopaoSort2(int array[]) {
        if (null == array || array.length == 0) {
            throw new RuntimeException("数组为null或长度为0");
        }
        for (int i = 0; i < array.length; i++) {
            //有序标记，每一轮的初始值都是true，假设每一趟开始前都假设已经有序
            boolean sortFlag = true;
            for (int j = 0; j < array.length - i - 1; j++) {
                int temp = 0;
                if (array[j] > array[j + 1]) {
                    temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                    //因为有元素进行交换，所以不是有序的，标记为false
                    sortFlag = false;
                }
            }
            if (sortFlag) {
                break;//如果某一轮有序标记为true，说明当前已有序，可以终止循环
            }
        }
    }
    //优化2：我们可以在每一轮排序后，记录下来最后一次元素交换的位置，该位置即为有序无序数列的边界，再往后就是有序区了
    public static void MaopaoSort3(int array[]) {
        if (null == array || array.length == 0) {
            throw new RuntimeException("数组为null或长度为0");
        }
        //记录最后一次交换的位置
        int lastExchangeIndex = 0;
        //当前趟无序数列的边界，每次比较只需要比到这里为止
        int sortBorder = array.length - 1;
        for (int i = 0; i < array.length; i++) {
            //有序标记，每一轮的初始值都是true，假设每一趟开始前都假设已经有序
            boolean sortFlag = true;
            for (int j = 0; j < array.length - i - 1; j++) {
                int temp = 0;
                if (array[j] > array[j + 1]) {
                    temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                    //因为有元素进行交换，所以不是有序的，标记为false
                    sortFlag = false;
                    lastExchangeIndex = j;
                }
            }
            sortBorder = lastExchangeIndex;
            if (sortFlag) {
                break;//如果某一轮有序标记为true，说明当前已有序，可以终止循环
            }
        }
        // 还可以进一步优化， 有兴趣的可以去看看鸡尾酒排序
    }
```
#### 快速排序 时间复杂度是O(nlogn) 不稳定排序
```markdown
//选一个数作为基数（这里我选的是第一个数），大于这个基数的放到右边，小于这个基数的放到左边，
      等于这个基数的数可以放到左边或右边，一趟结束后，将基数放到中间分隔的位置，
      第二趟将数组从基数的位置分成两半，分割后的两个的数组继续重复以上步骤，
public class QuickSort {
    private  void quickSortC(int[] a, int l, int r) {
        if (l >= r) {
            return;
        }
        int p = partition(a, l, r);
        quickSortC(a, l, p - 1);
        quickSortC(a, p + 1, r);
    }
    //空间浪费比较多的分区函数可以将小于分界点存一段，大于分界点存一段，再合并
    public  int partition(int[] a, int l, int r) {
        int pivot = a[r];
        int i = l;
        for (int j = l; j < r; j++) {
            if (a[j] < pivot) {
                swap(a, i, j);
                i = i + 1;
            }
        }
        swap(a, i, r);
        return i;
    }
    public static void swap(int[] a,int l,int r){
        int temp=a[l];
        a[l]=a[r];
        a[r]=temp;
    }
}
```
#### 堆排序 时间复杂度是O(nlogn) 不稳定排序
```markdown
//把无序数组构建成二叉堆。需要从小到大排序，则构建成最大堆；需要从大到小排序，则构建成最小堆。
  循环删除堆顶元素，替换到二叉堆的末尾，调整堆产生新的堆顶。
    /*** “下沉”调整
     * @param array 待调整的堆
     * @param parentIndex “下沉”的父节点
     * @param length 堆的有效大小
     */
    public static void downAdjust(int[] array, int parentIndex, int length) {
        // temp 保存父节点值，用于最后的赋值
        int temp = array[parentIndex];
        int childIndex = 2 * parentIndex + 1;
        while (childIndex < length) {
            // 如果有右孩子，且右孩子大于左孩子的值，则定位到右孩子
            if (childIndex + 1 < length && array[childIndex +1]> array[childIndex]) {
                childIndex++;
            }
            // 如果父节点大于任何一个孩子的值，则直接跳出
            if (temp >= array[childIndex]) break;
            //无须真正交换，单向赋值即可
            array[parentIndex] = array[childIndex];
            parentIndex = childIndex;
            childIndex = 2 * childIndex + 1;
        }
        array[parentIndex] = temp;
    }
    /*** 堆排序（升序）* @param array 待调整的堆*/
    public static void heapSort(int[] array) {
        // 1. 把无序数组构建成最大堆
        for (int i = (array.length - 2) / 2; i >= 0; i--) {
            downAdjust(array, i, array.length);
        }
        System.out.println(Arrays.toString(array));
        // 2. 循环删除堆顶元素，移到集合尾部，调整堆产生新的堆顶
        for (int i = array.length - 1; i > 0; i--) {
            // 最后1个元素和第1个元素进行交换
            int temp = array[i];
            array[i] = array[0];
            array[0] = temp;
            // “下沉”调整最大堆
            downAdjust(array, 0, i);
        }
    }
```
#### 归并排序 时间复杂度O(nlogn)
```markdown
//归并排序就是先将要排序的数组递归地分成两半分别排序，然后将结果归并起来。
   * 1.  向上归并排序的时候，需要一个暂存数组用来排序，
   * 2.  将待合并的两个数组，从第一位开始比较，小的放到暂存数组，指针向后移，
   * 3.  直到一个数组空，这时，不用判断哪个数组空了，直接将两个数组剩下的元素追加到暂存数组里，
   * 4.  再将暂存数组排序后的元素放到原数组里，两个数组合成一个，这一趟结束。
public static void mergeSort(int[] arr, int lo, int hi) {
        if(lo==hi){
            return;
        }
        int mid = ((hi-lo)>>1)+lo;
        mergeSort(arr, lo, hi);
        mergeSort(arr,mid+1,hi);
        merge(arr,lo,mid,hi);
    }
    //二路归并的实现
    public static void merge(int[] arr, int lo, int mid, int hi) {
        int[] temp = arr.clone();
        int k = lo, i = lo, j = mid + 1;
        while (k <= hi) {
            if (i > mid) {
                arr[k++] = temp[j++];
            } else if (j > hi) {
                arr[k++] = temp[i++];
            } else if (temp[j] < temp[i]) {
                arr[k++] = temp[j++];
            } else {
                arr[k++] = temp[i++];
            }
        }
    }
```
#### 计数排序和桶排序 时间复杂度O(n)


### LeetCode Top100
#### [LeetCode3.无重复字符的最长子串]https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)
```markdown
public int lengthOfLongestSubstring(String s) {
        //暴力
        // int len = s.length(),i =0,j,k,max = 0;
        // char[] cs = s.toCharArray();
        // for(j = 0;j<len;j++){
        //     for(k = i;k<j;k++){
        //         if(cs[k]==cs[j]){
        //             i = k + 1;
        //             break;
        //         }
        //     }
        //     if(j-i+1>max) max = j-i+1;
        // }
        // return max;
        int len = s.length();
        int ans = 0;
        Map<Character,Integer> map = new HashMap<>();
        for(int i=0,j=0;j<len;j++){
            if(map.containsKey(s.charAt(j))){
                i = Math.max(map.get(s.charAt(j)),i);
            }
            ans = Math.max(ans,j-i+1);
            map.put(s.charAt(j),j+1);
        }
        return ans;
    }
```
#### [LeetCode459.重复的子字符串](https://leetcode-cn.com/problems/repeated-substring-pattern/solution/zhong-fu-de-zi-zi-fu-chuan-by-leetcode-solution/)
>>相似题：LeetCode 1044. 最长重复子串
```markdown
//暴力求解-枚举出现的子串
public boolean repeatedSubstringPattern(String s){
    int n = s.length();
    for(int i = 1;i*2<=n;i++){
        if(n%i==0){
            boolean match = true;
            for(int j = i;j<n;j++){
                if(s.charAt(j)!=s.charAt(j-i)){ 
                    match = false;
                    break;
                }
            }
            if(match) return true;
        }
    }
    return false;
}
//KMP
 public boolean repeatedSubstringPattern(String s){
        int n = s.length();
        char[] p = (" " + s).toCharArray();
        int[] ne = new int[n + 1];
        //求解KMP next数组
        for(int i = 0, j = 2; j <= n; j++){
            while (i != 0 && p[i + 1] != p[j]) i = ne[i];
            if(p[i + 1] == p[j]) i++;
            ne[j] = i;
        }
        char[] ss = (s + s).toCharArray();
        for(int i = 0, j = 1; j < ss.length; j++){
            while (i != 0 && p[i + 1] != ss[j]) i = ne[i];
            if(p[i + 1] == ss[j]) i++;
            if(i == n && j != ss.length - 1) {  //j 不能是最后一个字符
                return true;
            }
        }
        return false;
    }
```
#### [491. 递增子序列](https://leetcode-cn.com/problems/increasing-subsequences/)
```markdown
public List<List<Integer>> findSubsequences(int[] nums) {
        List<List<Integer>> ans = new ArrayList<>();
        List<Integer> list = new ArrayList<>();
        dfs(ans,list,nums,0 );
        return ans;
    }
    private void dfs(List<List<Integer>> ans,List<Integer> list,int[] nums,int curr){
        if(list.size()>1) ans.add(new ArrayList<>(list));
        Set<Integer> set = new HashSet<>();
        for(int i = curr;i<nums.length;i++){
            if(set.contains(nums[i])) continue;
            if(list.size()==0||nums[i]>=list.get(list.size()-1)){
                set.add(nums[i]);
                list.add(nums[i]);
                dfs(ans,list,nums,i+1);
                list.remove(list.size()-1);
            }
        }
    }
```
#### [LeetCode718.最长重复子数组]()
```markdown
public int findLength(int[] A, int[] B) {
        if(A.length==0||B.length==0) return 0;
        int[][] dp = new int[A.length+1][B.length+1];
        int res = 0;
        for(int i = 1;i<=A.length;i++){
            for(int j = 1;j<=B.length;j++){
                if(A[i-1]==B[j-1]){
                    dp[i][j] = dp[i-1][j-1] + 1;
                    res = Math.max(res,dp[i][j]);
                }
            }
        }
        return res;
    }
```

#### 股票买卖系列
```markdown
//[LeetCode 121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)
//一次买卖
public int maxProfit(int[] prices) {
        if(prices.length<=1) return 0;
        int min = prices[0],max = 0;
        for(int i = 1;i<prices.length;i++){
            max = Math.max(max,prices[i]-min);
            min = Math.min(min,prices[i]);
        }
        return max;
    }
```
#### 零钱兑换系列
```markdown
LeetCode322.零钱兑换-给定不同面额的硬币coins和一个总金额amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。
 public int coinChange(int[] coins, int amount) {
        int max = amount+1;
        int[] dp = new int[amount+1];
        Arrays.fill(dp,max);
        dp[0] = 0;
        for(int i = 0;i<=amount;i++){
            for(int j = 0;j<coins.length;j++){
                if(coins[j]<=i){
                    dp[i] = Math.min(dp[i],dp[i-coins[j]]+1);
                }
            }
        }
        return dp[amount]>amount?-1:dp[amount];
    }
LeetCode-518.零钱兑换II-给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 
public int change(int amount, int[] coins) {
        int[] dp= new int[amount+1];
        dp[0] = 1;
        for(int coin:coins){
            for(int j = 1;j<=amount;j++){
                if(j>=coin){
                    dp[j] = dp[j]+dp[j-coin];
                }
            }
        }
        return dp[amount];
    }
LeetCode983. 最低票价
    public int mincostTickets(int[] days, int[] costs) {
        int[] dp = new int[days.length];
        dp[0] = Math.min(costs[0],Math.min(costs[1],costs[2]));
        for(int i = 1;i<days.length;i++){
            int c1,c2,c3;
            c1 = dp[i-1]+costs[0];
            int j;
            for(j=i-1;j>=0;j--) if(days[i]-days[j]>=7) break;
            c2 = j>=0?dp[j]+costs[1]:costs[1];
            for(j=i-1;j>=0;j--) if(days[i]-days[j]>=30) break;
            c3 = j>=0?dp[j]+costs[2]:costs[2];
            dp[i] = Math.min(c1,Math.min(c2,c3));
        }
        return dp[dp.length-1];
    }
LeetCode860. 柠檬水找零
    public boolean lemonadeChange(int[] bills) {
        if(bills==null||bills.length==0) return true;
        int five = 0;
        int ten = 0;
        for(int i:bills){
            if(i==5) five++;
            else if(i==10) {five--;ten++;}
            else if(ten>0) {ten--;five--;}
            else five-=3;
            if(five<0) return false;
        }
        return true;
    }
```
#### 组合总和系列
```markdown
LeetCode39.组合总和-找出candidates中所有可以使数字和为target的组合。candidates中的数字可以无限制重复被选取。
public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> ans = new ArrayList<>();
        help(ans,new ArrayList<>(),candidates,target,0);
        return ans;
    }
    private void help(List<List<Integer>> ans,List<Integer> list,int[] candidates,int target,int start){
        if(target<0) return;
        if(target==0) ans.add(new ArrayList<>(list));
        else {
            for(int i = start;i<candidates.length;i++){
                list.add(candidates[i]);
                help(ans,list,candidates,target-candidates[i],i);
                list.remove(list.size()-1);
            }
        }
    }
LeetCode40.组合总和II--找出candidates中所有可以使数字和为target的组合。candidates中的数字只能用一次。
public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        List<List<Integer>> ans = new ArrayList<>();
        Arrays.sort(candidates);
        int[] visited = new int[candidates.length];
        help(ans,new ArrayList<>(),candidates,target,0);
        return ans;
    }
    private void help(List<List<Integer>> ans,List<Integer> list,int[] candidates,int target,int start){
        if(target<0) return;
        if(target==0) ans.add(new ArrayList<>(list));
        else {
            for(int i = start;i<candidates.length;i++){
                if (i > start && candidates[i] == candidates[i - 1]) {
                    continue;
                }
                list.add(candidates[i]);
                help(ans,list,candidates,target-candidates[i],i+1);
                list.remove(list.size()-1);
            }
        }
    }
LeetCode216.组合总和III-找出所有相加之和为n的k个数的组合。组合中只允许含有1-9的正整数，并且每种组合中不存在重复的数字。
    List<Integer> list;
    List<List<Integer>> res;
    public List<List<Integer>> combinationSum3(int k, int n) {
        list = new ArrayList<>();
        res = new ArrayList<>();
        dfs(1,n,k);
        return res;
    }
    public void dfs(int u,int n,int k){
        if(k==0&&n==0){
            res.add(new ArrayList<>(list));
            return;
        }
        if(n<=0||k<=0) return;
        for(int i = u;i<=9;i++){
            list.add(i);
            dfs(i+1,n-i,k-1);
            list.remove(list.size()-1);
        }
    }
LeetCode-377.组合总和Ⅳ-由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。
public int combinationSum4(int[] nums, int target) {
        int[] dp = new int[target+1];
        dp[0] = 1;
        for(int i = 1;i<=target;i++){
            for(int n:nums){
                if(i>=n){
                    dp[i]+=dp[i-n];
                }
            }
        }
        return dp[target];
    }
```
#### 全排列系列
```markdown
LeetCode46. 全排列
    public List<List<Integer>> permute(int[] nums) {
      List<List<Integer>> ans = new ArrayList<>();
      List<Integer> list = new ArrayList<>();
      reaback(ans,list,nums);
      return ans;  
    }
    private void reaback(List<List<Integer>> ans,List<Integer> list,int[] nums){
        if(list.size()==nums.length){
            ans.add(new ArrayList<>(list));
            return;
        }
        for(int num:nums){
            if(!list.contains(num)){
                list.add(num);
                reaback(ans,list,nums);
                list.remove(list.size()-1);
            }
        }
    }
LeetCode47. 全排列 II
    public List<List<Integer>> permuteUnique(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> ans = new ArrayList<>();
        int[] visited = new int[nums.length];
        backtrack(ans,nums,new ArrayList<Integer>(),visited);
        return ans;
    }
    void backtrack(List<List<Integer>> ans,int[] nums,List<Integer> list,int[] visited){
        if(list.size()==nums.length){
            ans.add(new ArrayList<>(list));
            return;
        }
        int lastVisited = Integer.MIN_VALUE;
        for(int i = 0;i<nums.length;i++){
            if(visited[i]==0&&nums[i]!=lastVisited) {
                visited[i] = 1;
                list.add(nums[i]);
                backtrack(ans,nums,list,visited);
                lastVisited = nums[i];
                visited[i] = 0;
                list.remove(list.size()-1);
            }
        }
    }
LeetCode31. 下一个排列
    public void nextPermutation(int[] nums) {
        int len = nums.length;
            for (int i = len - 1; i >= 0; i--) {
                if (i == 0) {
                    Arrays.sort(nums);
                    return;
                } else {
                    if (nums[i] > nums[i - 1]) {
                        Arrays.sort(nums, i, len);
                        for (int j = i; j <len; j++) {
                            if (nums[j] > nums[i - 1]) {
                                int temp = nums[j];
                                nums[j] = nums[i - 1];
                                nums[i - 1] = temp;
                                return;
                            }
                        }
                    }
                }
            }
    }
LeetCode-60. 第k个排列
public String getPermutation(int n, int k) {
         StringBuilder sb = new StringBuilder();
            // 候选数字
            List<Integer> candidates = new ArrayList<>();
            // 分母的阶乘数
            int[] factorials = new int[n+1];
            factorials[0] = 1;
            int fact = 1;
            for(int i = 1; i <= n; ++i) {
                candidates.add(i);
                fact *= i;
                factorials[i] = fact;
            }
            k -= 1;
            for(int i = n-1; i >= 0; --i) {
                // 计算候选数字的index
                int index = k / factorials[i];
                sb.append(candidates.remove(index));
                k -= index*factorials[i];
            }
            return sb.toString();                           
    }
LeetCode-77. 组合
    public List<List<Integer>> combine(int n, int k) {
        List<List<Integer>> ans = new ArrayList<>();
        help(ans,new ArrayList<Integer>(),1,n,k);
        return ans;
    }
    private void help(List<List<Integer>> ans,List<Integer> list,int start,int n,int k){
        if(list.size()==k){
            ans.add(new ArrayList<>(list));
            return;
        }
        for(int i = start;i<n+1;i++){
            list.add(i);
            help(ans,list,i+1,n,k);
            list.remove(list.size()-1);
        }
    }
```
### 剑指Offer
#### [剑指Offer38.字符串的排列](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/)
```markdown
 Set<String> res = new HashSet<>();
    public String[] permutation(String s) {
        if(s==null) return new String[]{};
        boolean[] visited = new boolean[s.length()];
        process(s,"",visited);
        return res.toArray(new String[res.size()]);
    }
    private void process(String s,String letter,boolean[] visited){
        if(s.length()==letter.length()){
            res.add(letter);
            return;
        }
        for(int i = 0;i<s.length();i++){
            char temp = s.charAt(i);
            if(visited[i]){
                continue;
            }
            visited[i] = true;
            process(s,letter+String.valueOf(temp),visited);
            visited[i] = false;
        }
    }
```
### 程序员面试经典

