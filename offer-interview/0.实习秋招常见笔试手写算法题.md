# 实习秋招常见笔试手写算法题
```
循环队列的相关条件和公式：  
队尾指针是rear,队头是front，其中QueueSize为循环队列的最大长度  
1.队空条件：rear==front  
2.队满条件：(rear+1) %QueueSIze==front  
3.计算队列长度：（rear-front+QueueSize）%QueueSize  
4.入队：（rear+1）%QueueSize  
5.出队：（front+1）%QueueSize

二维数组排序
    Array.sort(arr,(a,b)->(a[0]-b[0]));//递增排序
    Array.sort(arr,(a,b)->(a[1]-a[2]));//递减排序
// 使用大堆顶-从大到小排序
        PriorityQueue<Integer> heap = new PriorityQueue<>((n1, n2) -> n2 - n1);
// 使用小堆顶-从小到大排序
        PriorityQueue<Integer> heap = new PriorityQueue<>((n1, n2) -> n1 - n2);
HashMap迭代
    //entrySet方法遍历
    Set<Map.Entry<String,Student>> set = map.entrySet();
            for (Iterator<Map.Entry<String, Student>> i = set.iterator(); i.hasNext();) {
                System.out.println(i.next().getValue());
    
            }
     //keySet方法遍历
    Set<String> set = map.keySet();
            for (Iterator<String> i = set.iterator(); i.hasNext();) {
                System.out.println(map.get(i.next()));
            }
    //values方法遍历
    Collection c = map.values();
            for (Iterator<Student> i = c.iterator(); i.hasNext();) {
                System.out.println(i.next());
            }
HashMap排序
    Map<String, Integer> map = new HashMap<String, Integer>();
    //1.按key排序
    Set set=phone.keySet();
            Object[] arr=set.toArray();
            Arrays.sort(arr);
            for(Object key:arr){
                System.out.println(key);
            }
    //2.按value排序
            Collections.sort(list, new Comparator<Map.Entry<String, Integer>>() {
               @Override
               public int compare(Map.Entry<String, Integer> o1, Map.Entry<String, Integer> o2) {
                   return o2.getValue().compareTo(o1.getValue());
               }
           });

```

## 我经历的笔试
### 20200820-4399-
    Linux统计出现IP次数最多的
#### 1.最长不重复子串 LeetCode3,剑指 Offer48.最长不含重复字符的子字符串
```markdown

```
#### 2.IP TOP-K
### 20200823-安恒-10:00
#### 1.YYYY-MM-DD 计算是一年中的第第几天【ri-闰年怎么判断都不知道】
```markdown
public class Main {
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int Y = sc.nextInt();
        int M = sc.nextInt();
        int D = sc.nextInt();
        System.out.println(help(Y,M)+D);
    }
    private static int help(int y,int m){
        int sum = 0;
        int[] months;
        if(checkY(y)){
            months = new int[]{31,29,31,30,31,30,31,31,30,31,30,31};
        }else{
            months = new int[]{31,28,31,30,31,30,31,31,30,31,30,31};
        }
        for(int i = 0;i<m-1;i++){
            sum+=months[i];
        }
        return sum;
    }
    private static boolean checkY(int y){
        if((y%4==0&&y%100!=0)||(y%400==0)) return true;
        else return false;
    }
}
```
#### 回文素数判断【第一次做出笔试题】
```markdown
//判断一个数即是回文数又是素数
```
### 20200823-爱奇艺-15:00【全部LeetCode原题-cao】
#### 1.n的阶乘末尾0 LeetCode172
```markdown
//1.n的阶乘的末尾0-计算乘法因子里面有多少个5 - leetcode-172. 阶乘后的零
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int ans = 0;
        while(n>=5){
            ans +=n/5;
            n = n/5;
        }
        return ans;
    }
}
```
#### 2.路径是否相交 LeetCode 1496.判断路径是否相交
```markdown
//2.路径是否相交 -leetcode 1496. 判断路径是否相交
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        Stirng paths = sc.nextLine();
        Set<String> set = new HashSet<>();
        int x = 0;
        int y = 0;
        set.add(x+","+y);
        for(int i = 0;i<paths.length();i++){
            char ch = paths.charAt(i);
            if('N'==ch){ y++;}
            if('S'==ch){ y--;}
            if('E'==ch){ x++;}
            if('W'==ch){ x--;}
            if(set.contains(x+","+y)) return true;
            else set.add(x+","+y);
        }
        return false;
    }
}
```
#### 3.判断字符串括号是否匹配 LeetCode20
```markdown
// leetcode -20. 有效的括号
//建立一个新的栈，然后遍历字符串的字符，进行比较
    public boolean isValid3(String s) {
        Stack<Character> stack = new Stack<>();
        for (char c : s.toCharArray()) {
            if(c=='(') stack.push(')');
            else if(c=='[') stack.push(']');
            else if(c=='{') stack.push('}');
            else if(stack.isEmpty()||c!=stack.pop()) return false;
        }
        return stack.isEmpty();
    }
```
### 20200825-完美世界
#### 1.背包
```markdown
输入背包容量 15
几个分别背包容量    5  3  4 6
几个背包对应的值    20 12 10 30
输出 62
public int zeroOnePackOpt(int V, int[] C, int[] W) { 
    // 防止无效输入
    if ((V <= 0) || (C.length != W.length)) {
        return 0;
    }
    int n = C.length;
    int[] dp = new int[V + 1];
    // 背包空的情况下，价值为 0
    dp[0] = 0;
    for (int i = 0; i < n; ++i) {
        for (int j = V; j >= C[i]; --j) {
            dp[j] = Math.max(dp[j], dp[j - C[i]] + W[i]);
        }
    }
    return dp[V];
}
```
## 常见的笔试题

### LeetCode Top100
#### [LeetCode3.无重复字符的最长子串]https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)
```markdown
public int lengthOfLongestSubstring(String s) {
        //暴力
        // int len = s.length(),i =0,j,k,max = 0;
        // char[] cs = s.toCharArray();
        // for(j = 0;j<len;j++){
        //     for(k = i;k<j;k++){
        //         if(cs[k]==cs[j]){
        //             i = k + 1;
        //             break;
        //         }
        //     }
        //     if(j-i+1>max) max = j-i+1;
        // }
        // return max;
        int len = s.length();
        int ans = 0;
        Map<Character,Integer> map = new HashMap<>();
        for(int i=0,j=0;j<len;j++){
            if(map.containsKey(s.charAt(j))){
                i = Math.max(map.get(s.charAt(j)),i);
            }
            ans = Math.max(ans,j-i+1);
            map.put(s.charAt(j),j+1);
        }
        return ans;
    }
```
#### [LeetCode459.重复的子字符串](https://leetcode-cn.com/problems/repeated-substring-pattern/solution/zhong-fu-de-zi-zi-fu-chuan-by-leetcode-solution/)
>>相似题：LeetCode 1044. 最长重复子串
```markdown
//暴力求解-枚举出现的子串
public boolean repeatedSubstringPattern(String s){
    int n = s.length();
    for(int i = 1;i*2<=n;i++){
        if(n%i==0){
            boolean match = true;
            for(int j = i;j<n;j++){
                if(s.charAt(j)!=s.charAt(j-i)){ 
                    match = false;
                    break;
                }
            }
            if(match) return true;
        }
    }
    return false;
}
//KMP
 public boolean repeatedSubstringPattern(String s){
        int n = s.length();
        char[] p = (" " + s).toCharArray();
        int[] ne = new int[n + 1];
        //求解KMP next数组
        for(int i = 0, j = 2; j <= n; j++){
            while (i != 0 && p[i + 1] != p[j]) i = ne[i];
            if(p[i + 1] == p[j]) i++;
            ne[j] = i;
        }
        char[] ss = (s + s).toCharArray();
        for(int i = 0, j = 1; j < ss.length; j++){
            while (i != 0 && p[i + 1] != ss[j]) i = ne[i];
            if(p[i + 1] == ss[j]) i++;
            if(i == n && j != ss.length - 1) {  //j 不能是最后一个字符
                return true;
            }
        }
        return false;
    }
```
#### [491. 递增子序列](https://leetcode-cn.com/problems/increasing-subsequences/)
```markdown
public List<List<Integer>> findSubsequences(int[] nums) {
        List<List<Integer>> ans = new ArrayList<>();
        List<Integer> list = new ArrayList<>();
        dfs(ans,list,nums,0 );
        return ans;
    }
    private void dfs(List<List<Integer>> ans,List<Integer> list,int[] nums,int curr){
        if(list.size()>1) ans.add(new ArrayList<>(list));
        Set<Integer> set = new HashSet<>();
        for(int i = curr;i<nums.length;i++){
            if(set.contains(nums[i])) continue;
            if(list.size()==0||nums[i]>=list.get(list.size()-1)){
                set.add(nums[i]);
                list.add(nums[i]);
                dfs(ans,list,nums,i+1);
                list.remove(list.size()-1);
            }
        }
    }
```
#### [LeetCode718.最长重复子数组]()
```markdown
public int findLength(int[] A, int[] B) {
        if(A.length==0||B.length==0) return 0;
        int[][] dp = new int[A.length+1][B.length+1];
        int res = 0;
        for(int i = 1;i<=A.length;i++){
            for(int j = 1;j<=B.length;j++){
                if(A[i-1]==B[j-1]){
                    dp[i][j] = dp[i-1][j-1] + 1;
                    res = Math.max(res,dp[i][j]);
                }
            }
        }
        return res;
    }
```

#### 股票买卖
```markdown
//[LeetCode 121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)
//一次买卖
public int maxProfit(int[] prices) {
        if(prices.length<=1) return 0;
        int min = prices[0],max = 0;
        for(int i = 1;i<prices.length;i++){
            max = Math.max(max,prices[i]-min);
            min = Math.min(min,prices[i]);
        }
        return max;
    }
```
### 剑指Offer
#### [剑指Offer38.字符串的排列](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/)
```markdown
 Set<String> res = new HashSet<>();
    public String[] permutation(String s) {
        if(s==null) return new String[]{};
        boolean[] visited = new boolean[s.length()];
        process(s,"",visited);
        return res.toArray(new String[res.size()]);
    }
    private void process(String s,String letter,boolean[] visited){
        if(s.length()==letter.length()){
            res.add(letter);
            return;
        }
        for(int i = 0;i<s.length();i++){
            char temp = s.charAt(i);
            if(visited[i]){
                continue;
            }
            visited[i] = true;
            process(s,letter+String.valueOf(temp),visited);
            visited[i] = false;
        }
    }
```
### 程序员面试经典

