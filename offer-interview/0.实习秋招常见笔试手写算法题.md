# 实习秋招常见笔试手写算法题
```
循环队列的相关条件和公式：  
队尾指针是rear,队头是front，其中QueueSize为循环队列的最大长度  
1.队空条件：rear==front  
2.队满条件：(rear+1) %QueueSIze==front  
3.计算队列长度：（rear-front+QueueSize）%QueueSize  
4.入队：（rear+1）%QueueSize  
5.出队：（front+1）%QueueSize

二维数组排序
    Array.sort(arr,(a,b)->(a[0]-b[0]));//递增排序
    Array.sort(arr,(a,b)->(a[1]-a[2]));//递减排序
// 使用大堆顶-从大到小排序
        PriorityQueue<Integer> heap = new PriorityQueue<>((n1, n2) -> n2 - n1);
// 使用小堆顶-从小到大排序
        PriorityQueue<Integer> heap = new PriorityQueue<>((n1, n2) -> n1 - n2);
HashMap迭代
    //entrySet方法遍历
    Set<Map.Entry<String,Student>> set = map.entrySet();
            for (Iterator<Map.Entry<String, Student>> i = set.iterator(); i.hasNext();) {
                System.out.println(i.next().getValue());
    
            }
     //keySet方法遍历
    Set<String> set = map.keySet();
            for (Iterator<String> i = set.iterator(); i.hasNext();) {
                System.out.println(map.get(i.next()));
            }
    //values方法遍历
    Collection c = map.values();
            for (Iterator<Student> i = c.iterator(); i.hasNext();) {
                System.out.println(i.next());
            }
HashMap排序
    Map<String, Integer> map = new HashMap<String, Integer>();
    //1.按key排序
    Set set=phone.keySet();
            Object[] arr=set.toArray();
            Arrays.sort(arr);
            for(Object key:arr){
                System.out.println(key);
            }
    //2.按value排序
            Collections.sort(list, new Comparator<Map.Entry<String, Integer>>() {
               @Override
               public int compare(Map.Entry<String, Integer> o1, Map.Entry<String, Integer> o2) {
                   return o2.getValue().compareTo(o1.getValue());
               }
           });

```

## 我经历的笔试
### 20200820-4399-
    Linux统计出现IP次数最多的
#### 1.最长不重复子串 LeetCode3,剑指 Offer48.最长不含重复字符的子字符串
```markdown

```
#### 2.IP TOP-K
### 20200823-安恒-10:00
#### 1.YYYY-MM-DD 计算是一年中的第第几天【ri-闰年怎么判断都不知道】
```markdown
public class Main {
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int Y = sc.nextInt();
        int M = sc.nextInt();
        int D = sc.nextInt();
        System.out.println(help(Y,M)+D);
    }
    private static int help(int y,int m){
        int sum = 0;
        int[] months;
        if(checkY(y)){
            months = new int[]{31,29,31,30,31,30,31,31,30,31,30,31};
        }else{
            months = new int[]{31,28,31,30,31,30,31,31,30,31,30,31};
        }
        for(int i = 0;i<m-1;i++){
            sum+=months[i];
        }
        return sum;
    }
    private static boolean checkY(int y){
        if((y%4==0&&y%100!=0)||(y%400==0)) return true;
        else return false;
    }
}
```
#### 回文素数判断【第一次做出笔试题】
```markdown
//判断一个数即是回文数又是素数
```
### 20200823-爱奇艺-15:00【全部LeetCode原题-cao】
#### 1.n的阶乘末尾0 LeetCode172
```markdown
//1.n的阶乘的末尾0-计算乘法因子里面有多少个5 - leetcode-172. 阶乘后的零
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int ans = 0;
        while(n>=5){
            ans +=n/5;
            n = n/5;
        }
        return ans;
    }
}
```
#### 2.路径是否相交 LeetCode 1496.判断路径是否相交
```markdown
//2.路径是否相交 -leetcode 1496. 判断路径是否相交
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        Stirng paths = sc.nextLine();
        Set<String> set = new HashSet<>();
        int x = 0;
        int y = 0;
        set.add(x+","+y);
        for(int i = 0;i<paths.length();i++){
            char ch = paths.charAt(i);
            if('N'==ch){ y++;}
            if('S'==ch){ y--;}
            if('E'==ch){ x++;}
            if('W'==ch){ x--;}
            if(set.contains(x+","+y)) return true;
            else set.add(x+","+y);
        }
        return false;
    }
}
```
#### 3.判断字符串括号是否匹配 LeetCode20
```markdown
// leetcode -20. 有效的括号
//建立一个新的栈，然后遍历字符串的字符，进行比较
    public boolean isValid3(String s) {
        Stack<Character> stack = new Stack<>();
        for (char c : s.toCharArray()) {
            if(c=='(') stack.push(')');
            else if(c=='[') stack.push(']');
            else if(c=='{') stack.push('}');
            else if(stack.isEmpty()||c!=stack.pop()) return false;
        }
        return stack.isEmpty();
    }
```
### 20200825-完美世界
#### 1.0-1背包
```markdown
输入背包容量 15
几个分别背包容量    5  3  4 6
几个背包对应的值    20 12 10 30
输出 62
public int zeroOnePackOpt(int V, int[] C, int[] W) { 
    // 防止无效输入
    if ((V <= 0) || (C.length != W.length)) {
        return 0;
    }
    int n = C.length;
    int[] dp = new int[V + 1];
    // 背包空的情况下，价值为 0
    dp[0] = 0;
    for (int i = 0; i < n; ++i) {
        for (int j = V; j >= C[i]; --j) {
            dp[j] = Math.max(dp[j], dp[j - C[i]] + W[i]);
        }
    }
    return dp[V];
}
```
## 常见的笔试题

### LeetCode Top100
#### [LeetCode3.无重复字符的最长子串]https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)
```markdown
public int lengthOfLongestSubstring(String s) {
        //暴力
        // int len = s.length(),i =0,j,k,max = 0;
        // char[] cs = s.toCharArray();
        // for(j = 0;j<len;j++){
        //     for(k = i;k<j;k++){
        //         if(cs[k]==cs[j]){
        //             i = k + 1;
        //             break;
        //         }
        //     }
        //     if(j-i+1>max) max = j-i+1;
        // }
        // return max;
        int len = s.length();
        int ans = 0;
        Map<Character,Integer> map = new HashMap<>();
        for(int i=0,j=0;j<len;j++){
            if(map.containsKey(s.charAt(j))){
                i = Math.max(map.get(s.charAt(j)),i);
            }
            ans = Math.max(ans,j-i+1);
            map.put(s.charAt(j),j+1);
        }
        return ans;
    }
```
#### [LeetCode459.重复的子字符串](https://leetcode-cn.com/problems/repeated-substring-pattern/solution/zhong-fu-de-zi-zi-fu-chuan-by-leetcode-solution/)
>>相似题：LeetCode 1044. 最长重复子串
```markdown
//暴力求解-枚举出现的子串
public boolean repeatedSubstringPattern(String s){
    int n = s.length();
    for(int i = 1;i*2<=n;i++){
        if(n%i==0){
            boolean match = true;
            for(int j = i;j<n;j++){
                if(s.charAt(j)!=s.charAt(j-i)){ 
                    match = false;
                    break;
                }
            }
            if(match) return true;
        }
    }
    return false;
}
//KMP
 public boolean repeatedSubstringPattern(String s){
        int n = s.length();
        char[] p = (" " + s).toCharArray();
        int[] ne = new int[n + 1];
        //求解KMP next数组
        for(int i = 0, j = 2; j <= n; j++){
            while (i != 0 && p[i + 1] != p[j]) i = ne[i];
            if(p[i + 1] == p[j]) i++;
            ne[j] = i;
        }
        char[] ss = (s + s).toCharArray();
        for(int i = 0, j = 1; j < ss.length; j++){
            while (i != 0 && p[i + 1] != ss[j]) i = ne[i];
            if(p[i + 1] == ss[j]) i++;
            if(i == n && j != ss.length - 1) {  //j 不能是最后一个字符
                return true;
            }
        }
        return false;
    }
```
#### [491. 递增子序列](https://leetcode-cn.com/problems/increasing-subsequences/)
```markdown
public List<List<Integer>> findSubsequences(int[] nums) {
        List<List<Integer>> ans = new ArrayList<>();
        List<Integer> list = new ArrayList<>();
        dfs(ans,list,nums,0 );
        return ans;
    }
    private void dfs(List<List<Integer>> ans,List<Integer> list,int[] nums,int curr){
        if(list.size()>1) ans.add(new ArrayList<>(list));
        Set<Integer> set = new HashSet<>();
        for(int i = curr;i<nums.length;i++){
            if(set.contains(nums[i])) continue;
            if(list.size()==0||nums[i]>=list.get(list.size()-1)){
                set.add(nums[i]);
                list.add(nums[i]);
                dfs(ans,list,nums,i+1);
                list.remove(list.size()-1);
            }
        }
    }
```
#### [LeetCode718.最长重复子数组]()
```markdown
public int findLength(int[] A, int[] B) {
        if(A.length==0||B.length==0) return 0;
        int[][] dp = new int[A.length+1][B.length+1];
        int res = 0;
        for(int i = 1;i<=A.length;i++){
            for(int j = 1;j<=B.length;j++){
                if(A[i-1]==B[j-1]){
                    dp[i][j] = dp[i-1][j-1] + 1;
                    res = Math.max(res,dp[i][j]);
                }
            }
        }
        return res;
    }
```

#### 股票买卖系列
```markdown
//[LeetCode 121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)
//一次买卖
public int maxProfit(int[] prices) {
        if(prices.length<=1) return 0;
        int min = prices[0],max = 0;
        for(int i = 1;i<prices.length;i++){
            max = Math.max(max,prices[i]-min);
            min = Math.min(min,prices[i]);
        }
        return max;
    }
```
#### 零钱兑换系列
```markdown
LeetCode322.零钱兑换-给定不同面额的硬币coins和一个总金额amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。
 public int coinChange(int[] coins, int amount) {
        int max = amount+1;
        int[] dp = new int[amount+1];
        Arrays.fill(dp,max);
        dp[0] = 0;
        for(int i = 0;i<=amount;i++){
            for(int j = 0;j<coins.length;j++){
                if(coins[j]<=i){
                    dp[i] = Math.min(dp[i],dp[i-coins[j]]+1);
                }
            }
        }
        return dp[amount]>amount?-1:dp[amount];
    }
LeetCode-518.零钱兑换II-给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 
public int change(int amount, int[] coins) {
        int[] dp= new int[amount+1];
        dp[0] = 1;
        for(int coin:coins){
            for(int j = 1;j<=amount;j++){
                if(j>=coin){
                    dp[j] = dp[j]+dp[j-coin];
                }
            }
        }
        return dp[amount];
    }
LeetCode983. 最低票价
    public int mincostTickets(int[] days, int[] costs) {
        int[] dp = new int[days.length];
        dp[0] = Math.min(costs[0],Math.min(costs[1],costs[2]));
        for(int i = 1;i<days.length;i++){
            int c1,c2,c3;
            c1 = dp[i-1]+costs[0];
            int j;
            for(j=i-1;j>=0;j--) if(days[i]-days[j]>=7) break;
            c2 = j>=0?dp[j]+costs[1]:costs[1];
            for(j=i-1;j>=0;j--) if(days[i]-days[j]>=30) break;
            c3 = j>=0?dp[j]+costs[2]:costs[2];
            dp[i] = Math.min(c1,Math.min(c2,c3));
        }
        return dp[dp.length-1];
    }
LeetCode860. 柠檬水找零
    public boolean lemonadeChange(int[] bills) {
        if(bills==null||bills.length==0) return true;
        int five = 0;
        int ten = 0;
        for(int i:bills){
            if(i==5) five++;
            else if(i==10) {five--;ten++;}
            else if(ten>0) {ten--;five--;}
            else five-=3;
            if(five<0) return false;
        }
        return true;
    }
```
#### 组合总和系列
```markdown
LeetCode39.组合总和-找出candidates中所有可以使数字和为target的组合。candidates中的数字可以无限制重复被选取。
public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> ans = new ArrayList<>();
        help(ans,new ArrayList<>(),candidates,target,0);
        return ans;
    }
    private void help(List<List<Integer>> ans,List<Integer> list,int[] candidates,int target,int start){
        if(target<0) return;
        if(target==0) ans.add(new ArrayList<>(list));
        else {
            for(int i = start;i<candidates.length;i++){
                list.add(candidates[i]);
                help(ans,list,candidates,target-candidates[i],i);
                list.remove(list.size()-1);
            }
        }
    }
LeetCode40.组合总和II--找出candidates中所有可以使数字和为target的组合。candidates中的数字只能用一次。
public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        List<List<Integer>> ans = new ArrayList<>();
        Arrays.sort(candidates);
        int[] visited = new int[candidates.length];
        help(ans,new ArrayList<>(),candidates,target,0);
        return ans;
    }
    private void help(List<List<Integer>> ans,List<Integer> list,int[] candidates,int target,int start){
        if(target<0) return;
        if(target==0) ans.add(new ArrayList<>(list));
        else {
            for(int i = start;i<candidates.length;i++){
                if (i > start && candidates[i] == candidates[i - 1]) {
                    continue;
                }
                list.add(candidates[i]);
                help(ans,list,candidates,target-candidates[i],i+1);
                list.remove(list.size()-1);
            }
        }
    }
LeetCode216.组合总和III-找出所有相加之和为n的k个数的组合。组合中只允许含有1-9的正整数，并且每种组合中不存在重复的数字。
    List<Integer> list;
    List<List<Integer>> res;
    public List<List<Integer>> combinationSum3(int k, int n) {
        list = new ArrayList<>();
        res = new ArrayList<>();
        dfs(1,n,k);
        return res;
    }
    public void dfs(int u,int n,int k){
        if(k==0&&n==0){
            res.add(new ArrayList<>(list));
            return;
        }
        if(n<=0||k<=0) return;
        for(int i = u;i<=9;i++){
            list.add(i);
            dfs(i+1,n-i,k-1);
            list.remove(list.size()-1);
        }
    }
LeetCode-377.组合总和Ⅳ-由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。
public int combinationSum4(int[] nums, int target) {
        int[] dp = new int[target+1];
        dp[0] = 1;
        for(int i = 1;i<=target;i++){
            for(int n:nums){
                if(i>=n){
                    dp[i]+=dp[i-n];
                }
            }
        }
        return dp[target];
    }
```
#### 全排列系列
```markdown
LeetCode46. 全排列
    public List<List<Integer>> permute(int[] nums) {
      List<List<Integer>> ans = new ArrayList<>();
      List<Integer> list = new ArrayList<>();
      reaback(ans,list,nums);
      return ans;  
    }
    private void reaback(List<List<Integer>> ans,List<Integer> list,int[] nums){
        if(list.size()==nums.length){
            ans.add(new ArrayList<>(list));
            return;
        }
        for(int num:nums){
            if(!list.contains(num)){
                list.add(num);
                reaback(ans,list,nums);
                list.remove(list.size()-1);
            }
        }
    }
LeetCode47. 全排列 II
    public List<List<Integer>> permuteUnique(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> ans = new ArrayList<>();
        int[] visited = new int[nums.length];
        backtrack(ans,nums,new ArrayList<Integer>(),visited);
        return ans;
    }
    void backtrack(List<List<Integer>> ans,int[] nums,List<Integer> list,int[] visited){
        if(list.size()==nums.length){
            ans.add(new ArrayList<>(list));
            return;
        }
        int lastVisited = Integer.MIN_VALUE;
        for(int i = 0;i<nums.length;i++){
            if(visited[i]==0&&nums[i]!=lastVisited) {
                visited[i] = 1;
                list.add(nums[i]);
                backtrack(ans,nums,list,visited);
                lastVisited = nums[i];
                visited[i] = 0;
                list.remove(list.size()-1);
            }
        }
    }
LeetCode31. 下一个排列
    public void nextPermutation(int[] nums) {
        int len = nums.length;
            for (int i = len - 1; i >= 0; i--) {
                if (i == 0) {
                    Arrays.sort(nums);
                    return;
                } else {
                    if (nums[i] > nums[i - 1]) {
                        Arrays.sort(nums, i, len);
                        for (int j = i; j <len; j++) {
                            if (nums[j] > nums[i - 1]) {
                                int temp = nums[j];
                                nums[j] = nums[i - 1];
                                nums[i - 1] = temp;
                                return;
                            }
                        }
                    }
                }
            }
    }
LeetCode-60. 第k个排列
public String getPermutation(int n, int k) {
         StringBuilder sb = new StringBuilder();
            // 候选数字
            List<Integer> candidates = new ArrayList<>();
            // 分母的阶乘数
            int[] factorials = new int[n+1];
            factorials[0] = 1;
            int fact = 1;
            for(int i = 1; i <= n; ++i) {
                candidates.add(i);
                fact *= i;
                factorials[i] = fact;
            }
            k -= 1;
            for(int i = n-1; i >= 0; --i) {
                // 计算候选数字的index
                int index = k / factorials[i];
                sb.append(candidates.remove(index));
                k -= index*factorials[i];
            }
            return sb.toString();                           
    }
LeetCode-77. 组合
    public List<List<Integer>> combine(int n, int k) {
        List<List<Integer>> ans = new ArrayList<>();
        help(ans,new ArrayList<Integer>(),1,n,k);
        return ans;
    }
    private void help(List<List<Integer>> ans,List<Integer> list,int start,int n,int k){
        if(list.size()==k){
            ans.add(new ArrayList<>(list));
            return;
        }
        for(int i = start;i<n+1;i++){
            list.add(i);
            help(ans,list,i+1,n,k);
            list.remove(list.size()-1);
        }
    }
```
### 剑指Offer
#### [剑指Offer38.字符串的排列](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/)
```markdown
 Set<String> res = new HashSet<>();
    public String[] permutation(String s) {
        if(s==null) return new String[]{};
        boolean[] visited = new boolean[s.length()];
        process(s,"",visited);
        return res.toArray(new String[res.size()]);
    }
    private void process(String s,String letter,boolean[] visited){
        if(s.length()==letter.length()){
            res.add(letter);
            return;
        }
        for(int i = 0;i<s.length();i++){
            char temp = s.charAt(i);
            if(visited[i]){
                continue;
            }
            visited[i] = true;
            process(s,letter+String.valueOf(temp),visited);
            visited[i] = false;
        }
    }
```
### 程序员面试经典

