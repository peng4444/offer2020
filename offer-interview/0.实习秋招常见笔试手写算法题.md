# 实习秋招常见笔试手写算法题

## 我经历的笔试
### 20200820-4399-
    Linux统计出现IP次数最多的
#### 1.最长不重复子串 LeetCode3,剑指 Offer48.最长不含重复字符的子字符串
```markdown

```
#### 2.IP TOP-K
### 20200823-安恒-10:00
#### 1.YYYY-MM-DD 计算是一年中的第第几天【ri-闰年怎么判断都不知道】
```markdown
public class Main {
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int Y = sc.nextInt();
        int M = sc.nextInt();
        int D = sc.nextInt();
        System.out.println(help(Y,M)+D);
    }
    private static int help(int y,int m){
        int sum = 0;
        int[] months;
        if(checkY(y)){
            months = new int[]{31,29,31,30,31,30,31,31,30,31,30,31};
        }else{
            months = new int[]{31,28,31,30,31,30,31,31,30,31,30,31};
        }
        for(int i = 0;i<m-1;i++){
            sum+=months[i];
        }
        return sum;
    }
    private static boolean checkY(int y){
        if((y%4==0&&y%100!=0)||(y%400==0)) return true;
        else return false;
    }
}
```
#### 回文素数判断【第一次做出笔试题】
```markdown
//判断一个数即是回文数又是素数
```
### 20200823-爱奇艺-15:00【全部LeetCode原题-cao】
#### 1.n的阶乘末尾0 LeetCode172
```markdown
//1.n的阶乘的末尾0-计算乘法因子里面有多少个5 - leetcode-172. 阶乘后的零
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int ans = 0;
        while(n>=5){
            ans +=n/5;
            n = n/5;
        }
        return ans;
    }
}
```
#### 2.路径是否相交 LeetCode 1496.判断路径是否相交
```markdown
//2.路径是否相交 -leetcode 1496. 判断路径是否相交
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        Stirng paths = sc.nextLine();
        Set<String> set = new HashSet<>();
        int x = 0;
        int y = 0;
        set.add(x+","+y);
        for(int i = 0;i<paths.length();i++){
            char ch = paths.charAt(i);
            if('N'==ch){ y++;}
            if('S'==ch){ y--;}
            if('E'==ch){ x++;}
            if('W'==ch){ x--;}
            if(set.contains(x+","+y)) return true;
            else set.add(x+","+y);
        }
        return false;
    }
}
```
#### 3.判断字符串括号是否匹配 LeetCode20
```markdown
// leetcode -20. 有效的括号
//建立一个新的栈，然后遍历字符串的字符，进行比较
    public boolean isValid3(String s) {
        Stack<Character> stack = new Stack<>();
        for (char c : s.toCharArray()) {
            if(c=='(') stack.push(')');
            else if(c=='[') stack.push(']');
            else if(c=='{') stack.push('}');
            else if(stack.isEmpty()||c!=stack.pop()) return false;
        }
        return stack.isEmpty();
    }
```

## 常见的笔试题

### LeetCode Top100
#### [LeetCode3.无重复字符的最长子串]https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)
```markdown
public int lengthOfLongestSubstring(String s) {
        //暴力
        // int len = s.length(),i =0,j,k,max = 0;
        // char[] cs = s.toCharArray();
        // for(j = 0;j<len;j++){
        //     for(k = i;k<j;k++){
        //         if(cs[k]==cs[j]){
        //             i = k + 1;
        //             break;
        //         }
        //     }
        //     if(j-i+1>max) max = j-i+1;
        // }
        // return max;
        int len = s.length();
        int ans = 0;
        Map<Character,Integer> map = new HashMap<>();
        for(int i=0,j=0;j<len;j++){
            if(map.containsKey(s.charAt(j))){
                i = Math.max(map.get(s.charAt(j)),i);
            }
            ans = Math.max(ans,j-i+1);
            map.put(s.charAt(j),j+1);
        }
        return ans;
    }
```
#### [LeetCode459.重复的子字符串](https://leetcode-cn.com/problems/repeated-substring-pattern/solution/zhong-fu-de-zi-zi-fu-chuan-by-leetcode-solution/)
>>相似题：LeetCode 1044. 最长重复子串
```markdown
//暴力求解-枚举出现的子串
public boolean repeatedSubstringPattern(String s){
    int n = s.length();
    for(int i = 1;i*2<=n;i++){
        if(n%i==0){
            boolean match = true;
            for(int j = i;j<n;j++){
                if(s.charAt(j)!=s.charAt(j-i)){ 
                    match = false;
                    break;
                }
            }
            if(match) return true;
        }
    }
    return false;
}
//KMP
 public boolean repeatedSubstringPattern(String s){
        int n = s.length();
        char[] p = (" " + s).toCharArray();
        int[] ne = new int[n + 1];
        //求解KMP next数组
        for(int i = 0, j = 2; j <= n; j++){
            while (i != 0 && p[i + 1] != p[j]) i = ne[i];
            if(p[i + 1] == p[j]) i++;
            ne[j] = i;
        }
        char[] ss = (s + s).toCharArray();
        for(int i = 0, j = 1; j < ss.length; j++){
            while (i != 0 && p[i + 1] != ss[j]) i = ne[i];
            if(p[i + 1] == ss[j]) i++;
            if(i == n && j != ss.length - 1) {  //j 不能是最后一个字符
                return true;
            }
        }
        return false;
    }
```
#### [LeetCode718.最长重复子数组]()
```markdown
public int findLength(int[] A, int[] B) {
        if(A.length==0||B.length==0) return 0;
        int[][] dp = new int[A.length+1][B.length+1];
        int res = 0;
        for(int i = 1;i<=A.length;i++){
            for(int j = 1;j<=B.length;j++){
                if(A[i-1]==B[j-1]){
                    dp[i][j] = dp[i-1][j-1] + 1;
                    res = Math.max(res,dp[i][j]);
                }
            }
        }
        return res;
    }
```
### 

