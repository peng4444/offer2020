# 实习秋招常见笔试手写算法题
[2W字总结面试套路14问](https://www.cnblogs.com/wmyskxz/p/13679165.html#_label1_3)
[只要我跑的够快，内卷它就卷不到我](https://www.cnblogs.com/daimzh/p/13698952.html)
[如何准备Java面试？如何把面试官的提问引导到自己准备好的范围内？](https://www.cnblogs.com/JavaArchitect/p/12298114.html)
[【get】【2021秋招】Java 面试知识点【精华背诵版】](https://blog.csdn.net/qq_41112238/article/details/107168748)
[各大公司面试题分类整理](https://www.cnblogs.com/lvmengtian/p/12796820.html)
[Java面试全解析](https://my.oschina.net/u/2539475?tab=newest&catalogId=6934862)
[如何短时间内快速通过Java面试](https://www.cnblogs.com/javazhiyin/p/13023668.html)
[Java 最常见的 200+ 面试题汇总:没有答案](https://www.cnblogs.com/over/p/10468747.html)
[【2019春招准备：总目录】](https://blog.csdn.net/qq_33907408/article/details/84477343)

[labuladong 的算法小抄](https://labuladong.gitbook.io/algo/)
[Java工程师成神之路](http://hollischuang.gitee.io/tobetopjavaer/#/menu)
[BAT大厂面试题与全栈知识体系结合](https://www.pdai.tech/md/outline/x-outline.html)
[cyc2018大佬](https://cyc2018.github.io/CS-Notes/#/README)
[敖丙](https://github.com/AobingJava/JavaFamily)

## 面经
```markdown
[【实习】字节跳动+阿里+腾讯+美团+CVTE 实习面经](https://www.nowcoder.com/discuss/391046?type=2)
[【实习】日常实习面经分享 ](https://www.nowcoder.com/discuss/471514)
[【实习】2020java开发面试经验，实习秋招全记录(40家公司) ](https://www.nowcoder.com/discuss/428065)
[【实习】新年阿里腾讯13面面经 ](https://www.nowcoder.com/discuss/391690)
[【提前批】秋招到现在的一些面筋整理 ](https://www.nowcoder.com/discuss/497119)
[【秋招】Java面试后端经验分享](https://www.nowcoder.com/discuss/421353)
[【秋招】秋招上岸，个人历程和面经总结](https://www.nowcoder.com/discuss/532896)
[【秋招】秋招面经总结 ](https://www.nowcoder.com/discuss/512216)
[【春秋招】Java后端春秋招之旅](https://www.nowcoder.com/discuss/511499)
[面经（已经意向）+ 很多tcp的总结](https://www.nowcoder.com/discuss/530380)
```
## 基础
```markdown
循环队列的相关条件和公式：  
队尾指针是rear,队头是front，其中QueueSize为循环队列的最大长度  
1.队空条件：rear==front  
2.队满条件：(rear+1) %QueueSIze==front  
3.计算队列长度：（rear-front+QueueSize）%QueueSize  
4.入队：（rear+1）%QueueSize  
5.出队：（front+1）%QueueSize

二维数组排序
    Array.sort(arr,(a,b)->(a[0]-b[0]));//递增排序
    Array.sort(arr,(a,b)->(a[1]-a[2]));//递减排序
// 使用大堆顶-从大到小排序
        PriorityQueue<Integer> heap = new PriorityQueue<>((n1, n2) -> n2 - n1);
// 使用小堆顶-从小到大排序
        PriorityQueue<Integer> heap = new PriorityQueue<>((n1, n2) -> n1 - n2);
HashMap迭代
    //entrySet方法遍历
    Set<Map.Entry<String,Student>> set = map.entrySet();
            for (Iterator<Map.Entry<String, Student>> i = set.iterator(); i.hasNext();) {
                System.out.println(i.next().getValue());
            }
     //keySet方法遍历
    Set<String> set = map.keySet();
            for (Iterator<String> i = set.iterator(); i.hasNext();) {
                System.out.println(map.get(i.next()));
            }
    //values方法遍历
    Collection c = map.values();
            for (Iterator<Student> i = c.iterator(); i.hasNext();) {
                System.out.println(i.next());
            }
HashMap排序
    Map<String, Integer> map = new HashMap<String, Integer>();
    //1.按key排序
    Set set=phone.keySet();
            Object[] arr=set.toArray();
            Arrays.sort(arr);
            for(Object key:arr){
                System.out.println(key);
            }
    //2.按value排序
            Collections.sort(list, new Comparator<Map.Entry<String, Integer>>() {
               @Override
               public int compare(Map.Entry<String, Integer> o1, Map.Entry<String, Integer> o2) {
                   return o2.getValue().compareTo(o1.getValue());
               }
           });

```
## 常见智力题
[程序员常见智力题30道 ](https://www.nowcoder.com/discuss/414594)
[面试常问智力题40道（逻辑题）+ 参考答案](https://www.nowcoder.com/discuss/526897)
[面试智力题，字节面试爱问，分享一下](https://www.nowcoder.com/discuss/510567)
### 一个装了10L水的桶，一个7L的空桶，一个3L的空桶，怎样变成2个5L
```markdown
初始时为10，0，0。
第二步7，0，3。
然后7，3，0。
然后4，3，3。
然后4，6，0。
然后1，6，3。
然后1，7，2。
然后8，0，2。
然后8，2，0。
然后5，2，3。
然后5，5，0。
```
### 如果你有无穷多的水，一个3夸脱的和一个5夸脱的提桶，你如何准确称出 4夸脱的水？
```markdown
初始时0，5
然后3，2
然后0，2
然后2，0
然后2，5
然后1，4
```
### 有25匹马和5条赛道，赛马过程无法进行计时，只能知道相对快慢。问最少需要几场赛马可以知道前3名。
```markdown
先把 25 匹马分成 5 组，进行 5 场赛马，得到每组的排名。再将每组的第 1 名选出，进行 1 场赛马，按照这场的排名将 5 组先后标为 A、B、C、D、E。
可以知道，A 组的第 1 名就是所有 25 匹马的第 1 名。而第 2、3 名只可能在 A 组的 2、3 名，B 组的第 1、2 名，和 C 组的第 1 名，
总共 5 匹马，让这 5 匹马再进行 1 场赛马，前两名就是第 2、3 名。所以总共是 5+1+1=7 场赛马。
A 组：1，2，3，4，5
B 组：1，2，3，4，5
C 组：1，2，3，4，5
D 组：1，2，3，4，5
E 组：1，2，3，4，5
```
### 给定两条绳子，每条绳子烧完正好一个小时，并且绳子是不均匀的。问要怎么准确测量 15分钟。
```markdown
点燃第一条绳子 R1 两头的同时，点燃第二条绳子 R2 的一头；
当 R1 烧完，正好过去 30 分钟，而 R2 还可以再烧 30 分钟；
点燃 R2 的另一头，15 分钟后，R2 将全部烧完。
```
## 我经历的笔试
### 20200820-4399-
    Linux统计出现IP次数最多的
#### 1.最长不重复子串 LeetCode3,剑指 Offer48.最长不含重复字符的子字符串
```markdown

```
#### 2.IP TOP-K
### 20200823-安恒-10:00
#### 1.YYYY-MM-DD 计算是一年中的第第几天【ri-闰年怎么判断都不知道】
```markdown
public class Main {
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int Y = sc.nextInt();
        int M = sc.nextInt();
        int D = sc.nextInt();
        System.out.println(help(Y,M)+D);
    }
    private static int help(int y,int m){
        int sum = 0;
        int[] months;
        if(checkY(y)){
            months = new int[]{31,29,31,30,31,30,31,31,30,31,30,31};
        }else{
            months = new int[]{31,28,31,30,31,30,31,31,30,31,30,31};
        }
        for(int i = 0;i<m-1;i++){
            sum+=months[i];
        }
        return sum;
    }
    private static boolean checkY(int y){
        if((y%4==0&&y%100!=0)||(y%400==0)) return true;
        else return false;
    }
}
```
#### 回文素数判断【第一次做出笔试题】
```markdown
//判断一个数即是回文数又是素数
```
### 20200823-爱奇艺-15:00【全部LeetCode原题-cao】
#### 1.n的阶乘末尾0 LeetCode172
```markdown
//1.n的阶乘的末尾0-计算乘法因子里面有多少个5 - leetcode-172. 阶乘后的零
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int ans = 0;
        while(n>=5){
            ans +=n/5;
            n = n/5;
        }
        return ans;
    }
}
```
#### 2.路径是否相交 LeetCode 1496.判断路径是否相交
```markdown
//2.路径是否相交 -leetcode 1496. 判断路径是否相交
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        Stirng paths = sc.nextLine();
        Set<String> set = new HashSet<>();
        int x = 0;
        int y = 0;
        set.add(x+","+y);
        for(int i = 0;i<paths.length();i++){
            char ch = paths.charAt(i);
            if('N'==ch){ y++;}
            if('S'==ch){ y--;}
            if('E'==ch){ x++;}
            if('W'==ch){ x--;}
            if(set.contains(x+","+y)) return true;
            else set.add(x+","+y);
        }
        return false;
    }
}
```
#### 3.判断字符串括号是否匹配 LeetCode20
```markdown
// leetcode -20. 有效的括号
//建立一个新的栈，然后遍历字符串的字符，进行比较
    public boolean isValid3(String s) {
        Stack<Character> stack = new Stack<>();
        for (char c : s.toCharArray()) {
            if(c=='(') stack.push(')');
            else if(c=='[') stack.push(']');
            else if(c=='{') stack.push('}');
            else if(stack.isEmpty()||c!=stack.pop()) return false;
        }
        return stack.isEmpty();
    }
```
### 20200825-完美世界
#### 1.0-1背包
```markdown
输入背包容量 15
几个分别背包容量    5  3  4 6
几个背包对应的值    20 12 10 30
输出 62
public int zeroOnePackOpt(int V, int[] C, int[] W) { 
    // 防止无效输入
    if ((V <= 0) || (C.length != W.length)) {
        return 0;
    }
    int n = C.length;
    int[] dp = new int[V + 1];
    // 背包空的情况下，价值为 0
    dp[0] = 0;
    for (int i = 0; i < n; ++i) {
        for (int j = V; j >= C[i]; --j) {
            dp[j] = Math.max(dp[j], dp[j - C[i]] + W[i]);
        }
    }
    return dp[V];
}
```
### 20200908-小米-18:00-19:30
>> 密码生成器，LeetCode79.单词搜索
### 

## 常见的面试手写
### 查找排序
[八大排序算法详解（动图演示 思路分析 实例代码java 复杂度分析 适用场景）](https://www.cnblogs.com/l199616j/p/10742603.html)
[面试官爱问的 10 大经典排序算法，20+张图来搞定](https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247494031&idx=1&sn=182c2badfd59c4e284e36894582fc825&chksm=fa0d860ecd7a0f1804441d6cae01b36783071b573192f3534d83147d0290c3fc2acc728179fb&mpshare=1&scene=23&srcid=0929rym4Yga8TK1U23T6eCvO&sharer_sharetime=1601376076183&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
![](https://img2020.cnblogs.com/blog/1176183/202004/1176183-20200402212157028-1769221183.png)
#### 二分查找-有序
[二分查找及其变种算法](https://www.cnblogs.com/kalton/p/13671294.html)
```markdown
//迭代
    int binarySearch(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1; // 注意
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target)
                return mid;
            else if (nums[mid] < target)
                left = mid + 1; // 注意
            else if (nums[mid] > target)
                right = mid - 1; // 注意
        }
        return -1;
    }
    /**
     * 递归法
     * @param arr
     * @param value
     * @return
     */
    public static int binarySerach2(int[] arr, int  value){
        return bsearch(arr,0,arr.length -1,value);
    }
    private static int bsearch(int[] arr, int low, int high, int value) {
        if (low > high) return -1;
        int mid =  low + ((high - low) >> 1);
        if (arr[mid] == value) {
            return mid;
        } else if (arr[mid] > value) {
            return bsearch(arr, low, mid-1, value);
        } else {
            return bsearch(arr, mid+1, high, value);
        }
    }
//寻找左侧边界的二分搜索 - 查找第一个值等于给定值的元素
    int left_bound(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid - 1;
            } else if (nums[mid] == target) {
                // 别返回，锁定左侧边界
                right = mid - 1;
            }
        }
        // 最后要检查 left 越界的情况
        if (left >= nums.length || nums[left] != target)
            return -1;
        return left;
    }
//寻找右侧边界的二分查找 - 查找最后一个值等于给定值的元素
    int right_bound(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid - 1;
            } else if (nums[mid] == target) {
                // 别返回，锁定右侧边界
                left = mid + 1;
            }
        }
        // 最后要检查 right 越界的情况
        if (right < 0 || nums[right] != target)
            return -1;
        return right;
    }
//查找第一个大于等于给定值的元素
    /**
     * 变种三: 查找第一个大于等于给定值的元素
     * @param arr
     * @param value
     * @return
     */
    public static int binarySerach3(int[] arr, int value) {
        int low = 0;
        int high = arr.length - 1;
        while (low <= high) {
            int mid =  low + ((high - low) >> 1);
            if (arr[mid] >= value) {
                if ((mid == 0) || (arr[mid - 1] < value)) return mid;
                else high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        return -1;
    }
//查找最后一个小于等于给定值的元素
    /**
     * 变种四: 查找第一个大于等于给定值的元素
     * @param arr
     * @param value
     * @return
     */
    public static int binarySerach4(int[] arr, int value) {
        int low = 0;
        int high = arr.length - 1;
        while (low <= high) {
            int mid =  low + ((high - low) >> 1);
            if (arr[mid] > value) {
                high = mid - 1;
            } else {
                if ((mid == arr.length - 1) || (arr[mid + 1] > value)) return mid;
                else low = mid + 1;
            }
        }
        return -1;
    }
```
#### 选择排序 时间复杂度O(n^2) 不稳定排序
```markdown
//第一个跟后面的所有数相比，如果小于（或小于）第一个数的时候，暂存较小数的下标，
   *   第一趟结束后，将第一个数，与暂存的那个最小数进行交换，第一个数就是最小（或最大的数）
   *   下标移到第二位，第二个数跟后面的所有数相比，一趟下来，确定第二小（或第二大）的数
   *   重复以上步骤，直到指针移到倒数第二位，确定倒数第二小（或倒数第二大）的数，那么最后一位也就确定了，排序完成。
public int[] chanceSort(int[] array) {
        if (null == array || array.length == 0) {
            throw new RuntimeException("数组为null或长度为0");
        }
        int[] arr = Arrays.copyOf(array,array.length);
        for (int i = 0; i < arr.length; i++) {
            int min = i;
            for (int j = i + 1; j < arr.length; j++) {
                if (arr[j] < arr[min]) {
                    min = j;
                }
            }
            if (i != min) {
                int temp = arr[i];
                arr[i] = arr[min];
                arr[min] = temp;
            }
        }
        return arr;
    }
```
#### 插入排序 时间复杂度O(n^2)
```markdown
//第一位数已经有序从第二位开始遍历，当前数（第一趟是第二位数）与前面的数依次比较，如果前面的数大于当前数，则将这个数放在当前数的位置上，当前数的下标-1，
   * 重复以上步骤，直到当前数不大于前面的某一个数为止，这时，将当前数，放到这个位置。
   * 1-3步就是保证当前数的前面的数都是有序的，内层循环的目的就是将当前数插入到前面的有序序列里
   * 重复以上3步，直到遍历到最后一位数，并将最后一位数插入到合适的位置，插入排序结束。
public int[] insertSort(int[] num) {
        if (null == num || num.length == 0) {
            throw new RuntimeException("数组为null或长度为0");
        }
        for (int i = 1, j, current; i < num.length; i++) {
            current = num[i];
            for (j = i - 1; j >= 0 && num[j] > current; j--) {
                num[j + 1] = num[j];
            }
            num[j + 1] = current;
        }
        return num;
    }
```
#### 冒泡排序 时间复杂度O(n^2)
```markdown
//把相邻的元素两两比较，当一个元素大于右侧相邻元素时，交换它们的位置；当一个元素小于或等于右侧相邻元素时，位置不变。
//冒泡排序
    public static void MaopaoSort(int[] array) {
        if (null == array || array.length == 0) {
            throw new RuntimeException("数组为null或长度为0");
        }
        //外循环是趟数，每一趟都会将未排序中最大的数放到尾端
        for (int i = 0; i < array.length - 1; i++) {
            //内循环是从第一个元素开始，依次比较相邻元素，
            // 比较次数随着趟数减少，因为每一趟都排好了一个元素
            for (int j = 0; j < array.length - i - 1; j++) {
                int temp = 0;
                if (array[j] > array[j + 1]) {
                    temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                }
            }
        }
    }
    //优化1：在最后一次交换开始之前，已经有序，就提前终止循环排序
    public static void MaopaoSort2(int array[]) {
        if (null == array || array.length == 0) {
            throw new RuntimeException("数组为null或长度为0");
        }
        for (int i = 0; i < array.length; i++) {
            //有序标记，每一轮的初始值都是true，假设每一趟开始前都假设已经有序
            boolean sortFlag = true;
            for (int j = 0; j < array.length - i - 1; j++) {
                int temp = 0;
                if (array[j] > array[j + 1]) {
                    temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                    //因为有元素进行交换，所以不是有序的，标记为false
                    sortFlag = false;
                }
            }
            if (sortFlag) {
                break;//如果某一轮有序标记为true，说明当前已有序，可以终止循环
            }
        }
    }
    //优化2：我们可以在每一轮排序后，记录下来最后一次元素交换的位置，该位置即为有序无序数列的边界，再往后就是有序区了
    public static void MaopaoSort3(int array[]) {
        if (null == array || array.length == 0) {
            throw new RuntimeException("数组为null或长度为0");
        }
        //记录最后一次交换的位置
        int lastExchangeIndex = 0;
        //当前趟无序数列的边界，每次比较只需要比到这里为止
        int sortBorder = array.length - 1;
        for (int i = 0; i < array.length; i++) {
            //有序标记，每一轮的初始值都是true，假设每一趟开始前都假设已经有序
            boolean sortFlag = true;
            for (int j = 0; j < array.length - i - 1; j++) {
                int temp = 0;
                if (array[j] > array[j + 1]) {
                    temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                    //因为有元素进行交换，所以不是有序的，标记为false
                    sortFlag = false;
                    lastExchangeIndex = j;
                }
            }
            sortBorder = lastExchangeIndex;
            if (sortFlag) {
                break;//如果某一轮有序标记为true，说明当前已有序，可以终止循环
            }
        }
        // 还可以进一步优化， 有兴趣的可以去看看鸡尾酒排序
    }
```
#### 快速排序 时间复杂度是O(nlogn) 不稳定排序
```markdown
//选一个数作为基数（这里我选的是第一个数），大于这个基数的放到右边，小于这个基数的放到左边，
      等于这个基数的数可以放到左边或右边，一趟结束后，将基数放到中间分隔的位置，
      第二趟将数组从基数的位置分成两半，分割后的两个的数组继续重复以上步骤，
public class QuickSort {
    private  void quickSortC(int[] a, int l, int r) {
        if (l >= r) {
            return;
        }
        int p = partition(a, l, r);
        quickSortC(a, l, p - 1);
        quickSortC(a, p + 1, r);
    }
    //空间浪费比较多的分区函数可以将小于分界点存一段，大于分界点存一段，再合并
    public  int partition(int[] a, int l, int r) {
        int pivot = a[r];
        int i = l;
        for (int j = l; j < r; j++) {
            if (a[j] < pivot) {
                swap(a, i, j);
                i = i + 1;
            }
        }
        swap(a, i, r);
        return i;
    }
    public static void swap(int[] a,int l,int r){
        int temp=a[l];
        a[l]=a[r];
        a[r]=temp;
    }
}
```
#### 堆排序 时间复杂度是O(nlogn) 不稳定排序
```markdown
//堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。
将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了
    /*** “下沉”调整
     * @param array 待调整的堆
     * @param parentIndex “下沉”的父节点
     * @param length 堆的有效大小
     */
    public static void downAdjust(int[] array, int parentIndex, int length) {
        // temp 保存父节点值，用于最后的赋值
        int temp = array[parentIndex];
        int childIndex = 2 * parentIndex + 1;
        while (childIndex < length) {
            // 如果有右孩子，且右孩子大于左孩子的值，则定位到右孩子
            if (childIndex + 1 < length && array[childIndex +1]> array[childIndex]) {
                childIndex++;
            }
            // 如果父节点大于任何一个孩子的值，则直接跳出
            if (temp >= array[childIndex]) break;
            //无须真正交换，单向赋值即可
            array[parentIndex] = array[childIndex];
            parentIndex = childIndex;
            childIndex = 2 * childIndex + 1;
        }
        array[parentIndex] = temp;
    }
    /*** 堆排序（升序）* @param array 待调整的堆*/
    public static void heapSort(int[] array) {
        // 1. 把无序数组构建成最大堆
        for (int i = (array.length - 2) / 2; i >= 0; i--) {
            downAdjust(array, i, array.length);
        }
        System.out.println(Arrays.toString(array));
        // 2. 循环删除堆顶元素，移到集合尾部，调整堆产生新的堆顶
        for (int i = array.length - 1; i > 0; i--) {
            // 最后1个元素和第1个元素进行交换
            int temp = array[i];
            array[i] = array[0];
            array[0] = temp;
            // “下沉”调整最大堆
            downAdjust(array, 0, i);
        }
    }
```
#### 归并排序 时间复杂度O(nlogn)
```markdown
//归并排序就是先将要排序的数组递归地分成两半分别排序，然后将结果归并起来。
   * 1.  向上归并排序的时候，需要一个暂存数组用来排序，
   * 2.  将待合并的两个数组，从第一位开始比较，小的放到暂存数组，指针向后移，
   * 3.  直到一个数组空，这时，不用判断哪个数组空了，直接将两个数组剩下的元素追加到暂存数组里，
   * 4.  再将暂存数组排序后的元素放到原数组里，两个数组合成一个，这一趟结束。
public static void mergeSort(int[] arr, int lo, int hi) {
        if(lo==hi){
            return;
        }
        int mid = ((hi-lo)>>1)+lo;
        mergeSort(arr, lo, mid);
        mergeSort(arr,mid+1,hi);
        merge(arr,lo,mid,hi);
    }
    //二路归并的实现
    public static void merge(int[] arr, int lo, int mid, int hi) {
        int[] temp = arr.clone();
        int k = lo, i = lo, j = mid + 1;
        while (k <= hi) {
            if (i > mid) {
                arr[k++] = temp[j++];
            } else if (j > hi) {
                arr[k++] = temp[i++];
            } else if (temp[j] < temp[i]) {
                arr[k++] = temp[j++];
            } else {
                arr[k++] = temp[i++];
            }
        }
    }
```
#### 基数排序和桶排序 时间复杂度O(n)
```markdown

```
### 手写单例模式【2+】
[设计模式：单例模式介绍及8种写法（饿汉式、懒汉式、Double-Check、静态内部类、枚举）](https://www.cnblogs.com/lifegoeson/p/13474269.html)
>> 单例模式使用的场景是：需要频繁创建和销毁的对象、创建对象耗时过多或耗资源太多（重型对象）、工具类对象、频繁访问数据库或者文件的对象（数据源、session工厂等），都应用单例模式去实现。
>> 单例模式有哪些实现方式？双重检查锁怎么实现，为什么用volatile，序列化破坏单例了解吗，怎么避免？
饿汉式（静态变量）,饿汉式（静态代码块）,懒汉式（线程不安全）,懒汉式（线程安全）,懒汉式（同步代码块）,双重检查锁,静态内部类,枚举。
#### 1.饿汉式（静态变量）
```markdown
class Singleton{
    //1私有化构造方法 （防止用new来得到对象实例）
    private Singleton(){}
    //2创建对象实例
    private final static Singleton instance = new Singleton();
    //3对外提供公有静态方法
    public static Singleton getInstance(){
        return instance;
    }
}
//获取对象就不能通过new的方式，而要通过Singleton.getInstance()；并且多次获取到的都是同一个对象。
优点：
    简单，类装载的时候就完成了实例化，避免了多线程同步的问题。
缺点：
    类装载的时候完成实例化，没有达到Lazy Loading（懒加载）的效果，如果从始至终都没用过这个实例呢？那就会造成内存的浪费。
    （大多数的时候，调用getInstance方法然后类装载，是没问题的，但是导致类装载的原因有很多，可能有其他的方式或者静态方法导致类装载）
```
#### 2.饿汉式（静态代码块）
```markdown
class Singleton{
    //1同样私有化构造方法
    private Singleton(){}
    //2创建对象实例
    private static Singleton instance;
    //在静态代码块里进行单例对象的创建
    static {
        instance = new Singleton();
    }
    //3提供静态方法返回实例对象
    public static Singleton getInstance() {
        return instance;
    }
}
优缺点：和上一种静态常量的方式一样；
原因：实现本来就是和上面的一样，因为类装载的时候一样马上会执行静态代码块中的代码。
```
#### 3.懒汉式（线程不安全）
```markdown
class Singleton{
    private static Singleton instance;
    private Singleton(){}
    //提供静态公有方法，使用的时候才创建instance
    public static Singleton getInstance(){
        if(instance == null){
            instance = new Singleton();
        }
        return  instance;
    }
}
优点：
    起到了Lazy Loading 的作用
缺点：
    但是只能在单线程下使用。如果一个线程进入了if判断，但是没来得及向下执行的时候，另一个线程也通过了这个if语句，
    这时候就会产生多个实例，所以多线程环境下不能使用这种方式。
```
#### 4.懒汉式（线程安全）
```markdown
class Singleton{
    private static Singleton instance;
    private Singleton(){}
    //使用的时候才创建instance,同时加入synchronized同步代码，解决线程不安全问题
    public static synchronized Singleton getInstance(){
        if(instance == null){
            instance = new Singleton();
        }
        return  instance;
    }
}
优点：
    保留了单例的性质的情况下，解决了线程不安全的问题
缺点：
    效率太差了，每个线程想要获得类的实例的时候都调用getInstance方法，就要进行同步。
    然而这个方法本身执行一次实例化代码就够了，后面的想要获得实例，就应该直接return，而不是进行同步。
```
#### 5.懒汉式（同步代码块）
```markdown
class Singleton{
    private static Singleton instance;
    private Singleton(){}
    public static Singleton getInstance(){
        if(instance == null){
            synchronized( Singleton.class){
                instance = new Singleton();
            }
        }
        return  instance;
    }
}
会导致可能别的线程同样进入if语句，回到了第三种的问题，所以来不及同步就会产生线程不安全的问题。
```
#### 6.双重检查锁【推荐开发使用】
```markdown
class Singleton{
    private static volatile Singleton instance;
    private Singleton(){}
    //双重检查
    public static Singleton getInstance(){
        //第一次检查
        if(instance == null){
            synchronized (Singleton.class){
                //第二次检查
                if(instance == null){
                    instance = new Singleton();
                }
            }
        }
        return  instance;
    }
}
优点：double-check是多线程开发里经常用到的，满足了我们需要的线程安全&&避免反复进行同步的效率差&&lazy loading。
```
#### 7.静态内部类
```markdown
class Singleton{
    //构造器私有化
    private Singleton(){}
    //一个静态内部类，里面有一个静态属性，就是实例
    private static class SingletonInstance{
        private static final Singleton instance = new Singleton();
    }
    //静态的公有方法
    public static Singleton getInstance(){
        return SingletonInstance.instance;
    }
}
静态内部类：用static修饰的内部类，称为静态内部类，完全属于外部类本身，不属于外部类某一个对象，外部类不可以定义为静态类，Java中静态类只有一种，那就是静态内部类。
核心：
    1.静态内部类在外部类装载的时候并不会执行，也就是满足了lazy loading；
    2.调用getInstance的时候会取属性，此时才加载静态内部类，而jvm底层的类装载机制是线程安全的，所以利用jvm达到了我们要的线程安全；
    3.类的静态属性保证了实例化也只会进行一次，满足单例。
```
#### 8.枚举
```markdown
enum Singleton{
    instance;
    public void sayOk(){
        System.out.println("ok");
    }
}
调用的时候也不用new，直接用Singleton.instance，拿到这个属性。（一般INSTANCE写成大写）
优点：
    满足单例模式要的特点，同时还能够避免反序列化重新创建新的对象。这种方法是effective java作者提供的方式。
```
#### 9.JDK中的单例模式
```markdown
untime类就是一个单例模式的类，并且可以看到，他是采用饿汉式（静态常量的方式）
    1.私有构造器；
    2.静态常量，类的内部直接将类实例化；
    3.提供公有的静态方法。
```
### 手写工厂模式【2+】
[设计模式：工厂设计模式介绍及3种写法（简单工厂、工厂方法、抽象工厂）](https://www.cnblogs.com/lifegoeson/p/13474404.html)
### 手写生产者消费者模型
#### 生产者消费者模型简介
[多线程必考的「生产者 - 消费者」模型](https://www.cnblogs.com/nycsde/p/13664781.html)
```markdown
生产者消费者模型是由两类线程构成：
    - 生产者线程：“生产”产品，并把产品放到一个队列里；
    - 消费者线程：“消费”产品。
    - 队列：数据缓存区。
生产者就只需要关注生产，而不用管消费者的消费行为，更不用等待消费者线程执行完；消费者也只管消费，不用管生产者是怎么生产的，更不用等着生产者生产。
生产者和消费者之间的联系：
    - 如果队列里的产品已经满了，生产者就不能继续生产；
    - 如果队列里的产品从无到有，生产者就得通知一下消费者，告诉它可以来消费了；
    - 如果队列里已经没有产品了，消费者也无法继续消费；
    - 如果队列里的产品从满到不满，消费者也得去通知下生产者，说你可以来生产了。
最经典的就是使用Object类里自带的wait()和notify()或者notifyAll()的消息通知机制。
模型实现了生产者和消费者之间的解藕和异步，平衡速度差异。
1.创建一个用来生产和消费的产品
    public class Product  {
        private String name;
        public Product(String name) {
            this.name = name;
        }
        public String getName() {
            return name;
        }
        public void setName(String name) {
            this.name = name;
        }
    }
2.生产者消费者主线程测试
    public class Test {
        public static void main(String[] args) {
            Queue<Product> queue = new ArrayDeque<>();
            for (int i = 0; i < 100; i++) {
                new Thread(new Producer(queue, 100)).start();
                new Thread(new Consumer(queue, 100)).start();
            }
        }
    }
3.生产者线程
    public class Producer implements Runnable{
        private Queue<Product> queue;
        private int maxCapacity;
        public Producer(Queue queue, int maxCapacity) {
            this.queue = queue;
            this.maxCapacity = maxCapacity;
        }
        @Override
        public void run() {
            synchronized (queue) {
                while (queue.size() == maxCapacity) { //一定要用 while，而不是 if，下文解释
                    try {
                        System.out.println("生产者" + Thread.currentThread().getName() + "等待中... Queue 已达到最大容量，无法生产");
                        wait();
                        System.out.println("生产者" + Thread.currentThread().getName() + "退出等待");
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                if (queue.size() == 0) { //队列里的产品从无到有，需要通知在等待的消费者
                    queue.notifyAll();
                }
                Random random = new Random();
                Integer i = random.nextInt();
                queue.offer(new Product("产品"  + i.toString()));
                System.out.println("生产者" + Thread.currentThread().getName() + "生产了产品：" + i.toString());
            }
        }
    }
4.消费者线程
    public class Consumer implements Runnable{
        private Queue<Product> queue;
        private int maxCapacity;
        public Consumer(Queue queue, int maxCapacity) {
            this.queue = queue;
            this.maxCapacity = maxCapacity;
        }
        @Override
        public void run() {
            synchronized (queue) {
                while (queue.isEmpty()) {
                    try {
                        System.out.println("消费者" + Thread.currentThread().getName() + "等待中... Queue 已缺货，无法消费");
                        wait();
                        System.out.println("消费者" + Thread.currentThread().getName() + "退出等待");
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                if (queue.size() == maxCapacity) {
                    queue.notifyAll();
                }
                Product product = queue.poll();
                System.out.println("消费者" + Thread.currentThread().getName() + "消费了：" + product.getName());
            }
        }
    }
```
#### 用ArrayBlockingQueue实现的生产者消费者模型
```markdown
public class ArrayBlockingQueueDemo {
    private ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue(3, true);
    public static void main(String[] args) {
        ArrayBlockingQueueDemo test = new ArrayBlockingQueueDemo();
        Consumer c1 = test.new Consumer();//内部非静态类实例化方式
        Producer p1 = test.new Producer();
        ExecutorService service = Executors.newCachedThreadPool();
        service.execute(p1);
        service.execute(c1);
        //new Thread(p1).start();
        //new Thread(c1).start();
    }
    class Consumer extends Thread {
        @Override
        public void run() {
            try {
                while (true) {
                    System.out.println("消费" + blockingQueue.take());
                    if (blockingQueue.size() == 0) {
                        System.out.println("队列为空，阻塞");
                    }
                }
            } catch (InterruptedException e1) {
                System.out.println("消费者等待时被打断");
                e1.printStackTrace();
            }
        }
    }
    class Producer extends Thread {
        private int element = 0;
        @Override
        public void run() {
            try {
                while (element < 20) {
                    System.out.println("生产" + element);
                    blockingQueue.put(element++);
                }
                if (blockingQueue.size() == 20) {
                    System.out.println("队列满，阻塞");
                }
            } catch (InterruptedException e) {
                System.out.println("生产者等空闲时被打断");
                e.printStackTrace();
            }
            System.out.println("终止生产");
        }
    }
}
```
#### 用ReentrantLock写生产者消费者模型
>> 手写一个生产者消费者模式，用的ReentrantLock，为什么判断当前count是否满足生产或者消费时用while
```markdown
public class ProducerAndConsumer {
    private int number = 0;
    private final int MAX = 10;
    private final int MIN = 0;
    private Lock lock = new ReentrantLock();
    private Condition condition = lock.newCondition();
    public static void main(String args[]) {
        ProducerAndConsumer test = new ProducerAndConsumer();
        Consumer c1 = test.new Consumer();
        Producer p1 = test.new Producer();
        ExecutorService service = Executors.newCachedThreadPool();
        for (int i = 0; i < 10; i++) {
            service.execute(p1);
        }
        for (int i = 0; i < 5; i++) {
            service.execute(c1);
        }
    }
    class Producer extends Thread {
        public void run() {
            try {
                lock.lock();
                while (number >= MAX) {//不用if是因为可能有错误唤醒的线程，while可以进行多次判断
                    System.err.println("产品已满");
                    condition.await();
                }
                number++;
                System.out.println("生产了一个产品，现在有：" + number + "个产品");
                condition.signalAll();
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        }
    }
    class Consumer extends Thread {
        public void run() {
            try {
                lock.lock();
                while (number <= MIN) {
                    condition.await();
                }
                number--;
                System.out.println("消费了一个，现在有" + number);
                condition.signalAll();
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        }
    }
}
```
### LRU【3+】
#### 基于LinkedhashMap实现的LRU算法 LeetCode146
```java
class LRUCache {
    private int cap;
    private Map<Integer,Integer> map = new LinkedHashMap<>();
    public LRUCache(int capacity) {
        this.cap = capacity;
    }
    
    public int get(int key) {
        if(map.keySet().contains(key)){
            int val = map.get(key);
            map.remove(key);
            map.put(key,val);
            return val;
        }
        return -1;
    }
    
    public void put(int key, int value) {
        if(map.keySet().contains(key)){
            map.remove(key);
        }else if(map.size()==cap){
            Iterator<Map.Entry<Integer,Integer>> iterator = map.entrySet().iterator();
            iterator.next();
            iterator.remove();
        }
        map.put(key,value);
    }
}
```
### 栈和队列
[基于链表、数组实现队列、循环队列](https://blog.csdn.net/u012922219/article/details/52626039)
```markdown

```
### LeetCode Top100
#### [LeetCode3.无重复字符的最长子串]https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)
```markdown
public int lengthOfLongestSubstring(String s) {
        //暴力
        // int len = s.length(),i =0,j,k,max = 0;
        // char[] cs = s.toCharArray();
        // for(j = 0;j<len;j++){
        //     for(k = i;k<j;k++){
        //         if(cs[k]==cs[j]){
        //             i = k + 1;
        //             break;
        //         }
        //     }
        //     if(j-i+1>max) max = j-i+1;
        // }
        // return max;
        int len = s.length();
        int ans = 0;
        Map<Character,Integer> map = new HashMap<>();
        for(int i=0,j=0;j<len;j++){
            if(map.containsKey(s.charAt(j))){
                i = Math.max(map.get(s.charAt(j)),i);
            }
            ans = Math.max(ans,j-i+1);
            map.put(s.charAt(j),j+1);
        }
        return ans;
    }
```
#### [LeetCode459.重复的子字符串](https://leetcode-cn.com/problems/repeated-substring-pattern/solution/zhong-fu-de-zi-zi-fu-chuan-by-leetcode-solution/)
>>相似题：LeetCode 1044. 最长重复子串
```markdown
//暴力求解-枚举出现的子串
public boolean repeatedSubstringPattern(String s){
    int n = s.length();
    for(int i = 1;i*2<=n;i++){
        if(n%i==0){
            boolean match = true;
            for(int j = i;j<n;j++){
                if(s.charAt(j)!=s.charAt(j-i)){ 
                    match = false;
                    break;
                }
            }
            if(match) return true;
        }
    }
    return false;
}
//KMP
 public boolean repeatedSubstringPattern(String s){
        int n = s.length();
        char[] p = (" " + s).toCharArray();
        int[] ne = new int[n + 1];
        //求解KMP next数组
        for(int i = 0, j = 2; j <= n; j++){
            while (i != 0 && p[i + 1] != p[j]) i = ne[i];
            if(p[i + 1] == p[j]) i++;
            ne[j] = i;
        }
        char[] ss = (s + s).toCharArray();
        for(int i = 0, j = 1; j < ss.length; j++){
            while (i != 0 && p[i + 1] != ss[j]) i = ne[i];
            if(p[i + 1] == ss[j]) i++;
            if(i == n && j != ss.length - 1) {  //j 不能是最后一个字符
                return true;
            }
        }
        return false;
    }
```
#### [491. 递增子序列](https://leetcode-cn.com/problems/increasing-subsequences/)
```markdown
public List<List<Integer>> findSubsequences(int[] nums) {
        List<List<Integer>> ans = new ArrayList<>();
        List<Integer> list = new ArrayList<>();
        dfs(ans,list,nums,0 );
        return ans;
    }
    private void dfs(List<List<Integer>> ans,List<Integer> list,int[] nums,int curr){
        if(list.size()>1) ans.add(new ArrayList<>(list));
        Set<Integer> set = new HashSet<>();
        for(int i = curr;i<nums.length;i++){
            if(set.contains(nums[i])) continue;
            if(list.size()==0||nums[i]>=list.get(list.size()-1)){
                set.add(nums[i]);
                list.add(nums[i]);
                dfs(ans,list,nums,i+1);
                list.remove(list.size()-1);
            }
        }
    }
```
#### [LeetCode718.最长重复子数组]()
```markdown
public int findLength(int[] A, int[] B) {
        if(A.length==0||B.length==0) return 0;
        int[][] dp = new int[A.length+1][B.length+1];
        int res = 0;
        for(int i = 1;i<=A.length;i++){
            for(int j = 1;j<=B.length;j++){
                if(A[i-1]==B[j-1]){
                    dp[i][j] = dp[i-1][j-1] + 1;
                    res = Math.max(res,dp[i][j]);
                }
            }
        }
        return res;
    }
```
#### LeetCode5. 最长回文子串
```markdown
public int getLongestPalindrome(String A, int n) {
        if(n==0) return 0;
        int max = 1;
        char[] arr = A.toCharArray();
        boolean[][] dp = new boolean[n][n];
        dp[0][0] = true;
        for(int i = 1;i<n;i++){
            dp[i][i] = true;
            dp[i][i-1] = true;
        }
        for(int i = 1;i<n;i++){
            for(int j = 0;j<i;j++){
                if(dp[j+1][i-1]&&arr[i]==arr[j]){
                    dp[j][i] = true;
                    if(max<i-j+1){
                        max = i-j+1;
                    }
                }else{
                    dp[j][i] = false;
                }
            }
        }
        return max;
    }
```
#### LeetCode53. 最大子序和
```markdown
public int maxsumofSubarray (int[] arr) {
        if(arr==null||arr.length==0) return 0;
        int len = arr.length;
        int[] dp = new int[len];
        dp[0] = arr[0];
        int res  = dp[0];
        for(int i = 1;i<len;i++){
            dp[i] = Math.max(dp[i-1],0)+arr[i];
            res = Math.max(res,dp[i]);
        }
        return res;
    }
```
#### 股票买卖系列
```markdown
//[LeetCode 121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)
//一次买卖
public int maxProfit(int[] prices) {
        if(prices.length<=1) return 0;
        int min = prices[0],max = 0;
        for(int i = 1;i<prices.length;i++){
            max = Math.max(max,prices[i]-min);
            min = Math.min(min,prices[i]);
        }
        return max;
    }
```
#### 零钱兑换系列
```markdown
LeetCode322.零钱兑换-给定不同面额的硬币coins和一个总金额amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。
 public int coinChange(int[] coins, int amount) {
        int max = amount+1;
        int[] dp = new int[amount+1];
        Arrays.fill(dp,max);
        dp[0] = 0;
        for(int i = 0;i<=amount;i++){
            for(int j = 0;j<coins.length;j++){
                if(coins[j]<=i){
                    dp[i] = Math.min(dp[i],dp[i-coins[j]]+1);
                }
            }
        }
        return dp[amount]>amount?-1:dp[amount];
    }
LeetCode-518.零钱兑换II-给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 
public int change(int amount, int[] coins) {
        int[] dp= new int[amount+1];
        dp[0] = 1;
        for(int coin:coins){
            for(int j = 1;j<=amount;j++){
                if(j>=coin){
                    dp[j] = dp[j]+dp[j-coin];
                }
            }
        }
        return dp[amount];
    }
LeetCode983. 最低票价
    public int mincostTickets(int[] days, int[] costs) {
        int[] dp = new int[days.length];
        dp[0] = Math.min(costs[0],Math.min(costs[1],costs[2]));
        for(int i = 1;i<days.length;i++){
            int c1,c2,c3;
            c1 = dp[i-1]+costs[0];
            int j;
            for(j=i-1;j>=0;j--) if(days[i]-days[j]>=7) break;
            c2 = j>=0?dp[j]+costs[1]:costs[1];
            for(j=i-1;j>=0;j--) if(days[i]-days[j]>=30) break;
            c3 = j>=0?dp[j]+costs[2]:costs[2];
            dp[i] = Math.min(c1,Math.min(c2,c3));
        }
        return dp[dp.length-1];
    }
LeetCode860. 柠檬水找零
    public boolean lemonadeChange(int[] bills) {
        if(bills==null||bills.length==0) return true;
        int five = 0;
        int ten = 0;
        for(int i:bills){
            if(i==5) five++;
            else if(i==10) {five--;ten++;}
            else if(ten>0) {ten--;five--;}
            else five-=3;
            if(five<0) return false;
        }
        return true;
    }
```
#### 组合总和系列
```markdown
LeetCode39.组合总和-找出candidates中所有可以使数字和为target的组合。candidates中的数字可以无限制重复被选取。
public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> ans = new ArrayList<>();
        help(ans,new ArrayList<>(),candidates,target,0);
        return ans;
    }
    private void help(List<List<Integer>> ans,List<Integer> list,int[] candidates,int target,int start){
        if(target<0) return;
        if(target==0) ans.add(new ArrayList<>(list));
        else {
            for(int i = start;i<candidates.length;i++){
                list.add(candidates[i]);
                help(ans,list,candidates,target-candidates[i],i);
                list.remove(list.size()-1);
            }
        }
    }
LeetCode40.组合总和II--找出candidates中所有可以使数字和为target的组合。candidates中的数字只能用一次。
public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        List<List<Integer>> ans = new ArrayList<>();
        Arrays.sort(candidates);
        int[] visited = new int[candidates.length];
        help(ans,new ArrayList<>(),candidates,target,0);
        return ans;
    }
    private void help(List<List<Integer>> ans,List<Integer> list,int[] candidates,int target,int start){
        if(target<0) return;
        if(target==0) ans.add(new ArrayList<>(list));
        else {
            for(int i = start;i<candidates.length;i++){
                if (i > start && candidates[i] == candidates[i - 1]) {
                    continue;
                }
                list.add(candidates[i]);
                help(ans,list,candidates,target-candidates[i],i+1);
                list.remove(list.size()-1);
            }
        }
    }
LeetCode216.组合总和III-找出所有相加之和为n的k个数的组合。组合中只允许含有1-9的正整数，并且每种组合中不存在重复的数字。
    List<Integer> list;
    List<List<Integer>> res;
    public List<List<Integer>> combinationSum3(int k, int n) {
        list = new ArrayList<>();
        res = new ArrayList<>();
        dfs(1,n,k);
        return res;
    }
    public void dfs(int u,int n,int k){
        if(k==0&&n==0){
            res.add(new ArrayList<>(list));
            return;
        }
        if(n<=0||k<=0) return;
        for(int i = u;i<=9;i++){
            list.add(i);
            dfs(i+1,n-i,k-1);
            list.remove(list.size()-1);
        }
    }
LeetCode-377.组合总和Ⅳ-由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。
public int combinationSum4(int[] nums, int target) {
        int[] dp = new int[target+1];
        dp[0] = 1;
        for(int i = 1;i<=target;i++){
            for(int n:nums){
                if(i>=n){
                    dp[i]+=dp[i-n];
                }
            }
        }
        return dp[target];
    }
```
#### 全排列系列
```markdown
LeetCode46. 全排列
    public List<List<Integer>> permute(int[] nums) {
      List<List<Integer>> ans = new ArrayList<>();
      List<Integer> list = new ArrayList<>();
      reaback(ans,list,nums);
      return ans;  
    }
    private void reaback(List<List<Integer>> ans,List<Integer> list,int[] nums){
        if(list.size()==nums.length){
            ans.add(new ArrayList<>(list));
            return;
        }
        for(int num:nums){
            if(!list.contains(num)){
                list.add(num);
                reaback(ans,list,nums);
                list.remove(list.size()-1);
            }
        }
    }
LeetCode47. 全排列 II
    public List<List<Integer>> permuteUnique(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> ans = new ArrayList<>();
        int[] visited = new int[nums.length];
        backtrack(ans,nums,new ArrayList<Integer>(),visited);
        return ans;
    }
    void backtrack(List<List<Integer>> ans,int[] nums,List<Integer> list,int[] visited){
        if(list.size()==nums.length){
            ans.add(new ArrayList<>(list));
            return;
        }
        int lastVisited = Integer.MIN_VALUE;
        for(int i = 0;i<nums.length;i++){
            if(visited[i]==0&&nums[i]!=lastVisited) {
                visited[i] = 1;
                list.add(nums[i]);
                backtrack(ans,nums,list,visited);
                lastVisited = nums[i];
                visited[i] = 0;
                list.remove(list.size()-1);
            }
        }
    }
LeetCode31. 下一个排列
    public void nextPermutation(int[] nums) {
        int len = nums.length;
            for (int i = len - 1; i >= 0; i--) {
                if (i == 0) {
                    Arrays.sort(nums);
                    return;
                } else {
                    if (nums[i] > nums[i - 1]) {
                        Arrays.sort(nums, i, len);
                        for (int j = i; j <len; j++) {
                            if (nums[j] > nums[i - 1]) {
                                int temp = nums[j];
                                nums[j] = nums[i - 1];
                                nums[i - 1] = temp;
                                return;
                            }
                        }
                    }
                }
            }
    }
LeetCode-60. 第k个排列
public String getPermutation(int n, int k) {
         StringBuilder sb = new StringBuilder();
            // 候选数字
            List<Integer> candidates = new ArrayList<>();
            // 分母的阶乘数
            int[] factorials = new int[n+1];
            factorials[0] = 1;
            int fact = 1;
            for(int i = 1; i <= n; ++i) {
                candidates.add(i);
                fact *= i;
                factorials[i] = fact;
            }
            k -= 1;
            for(int i = n-1; i >= 0; --i) {
                // 计算候选数字的index
                int index = k / factorials[i];
                sb.append(candidates.remove(index));
                k -= index*factorials[i];
            }
            return sb.toString();                           
    }
LeetCode-77. 组合
    public List<List<Integer>> combine(int n, int k) {
        List<List<Integer>> ans = new ArrayList<>();
        help(ans,new ArrayList<Integer>(),1,n,k);
        return ans;
    }
    private void help(List<List<Integer>> ans,List<Integer> list,int start,int n,int k){
        if(list.size()==k){
            ans.add(new ArrayList<>(list));
            return;
        }
        for(int i = start;i<n+1;i++){
            list.add(i);
            help(ans,list,i+1,n,k);
            list.remove(list.size()-1);
        }
    }
```
### 剑指Offer
[剑指offer 汇总版](https://www.nowcoder.com/discuss/497935)
#### [剑指Offer38.字符串的排列](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/)
```markdown
 Set<String> res = new HashSet<>();
    public String[] permutation(String s) {
        if(s==null) return new String[]{};
        boolean[] visited = new boolean[s.length()];
        process(s,"",visited);
        return res.toArray(new String[res.size()]);
    }
    private void process(String s,String letter,boolean[] visited){
        if(s.length()==letter.length()){
            res.add(letter);
            return;
        }
        for(int i = 0;i<s.length();i++){
            char temp = s.charAt(i);
            if(visited[i]){
                continue;
            }
            visited[i] = true;
            process(s,letter+String.valueOf(temp),visited);
            visited[i] = false;
        }
    }
```
### 程序员面试经典

## 客观题
###  1、100亿黑名单URL，每个64B，问这个黑名单要怎么存？判断一个URL是否在黑名单中
```markdown
​ 散列表：
​ 如果把黑名单看成一个集合，将其存在 hashmap 中，貌似太大了，需要 640G，明显不科学。
​ 布隆过滤器：
​ 它实际上是一个很长的二进制矢量和一系列随机映射函数。
​ 它可以用来判断一个元素是否在一个集合中。它的优势是只需要占用很小的内存空间以及有着高效的查询效率。对于布隆过滤器而言，它的本质是一个位数组：位数组就是数组的每个元素都只占用 1 bit ，并且每个元素只能是 0 或者 1。
​ 在数组中的每一位都是二进制位。布隆过滤器除了一个位数组，还有 K 个哈希函数。当一个元素加入布隆过滤器中的时候，会进行如下操作：
使用 K 个哈希函数对元素值进行 K 次计算，得到 K 个哈希值。
根据得到的哈希值，在位数组中把对应下标的值置为 1。
```
### 2、2GB内存在20亿整数中找到出现次数最多的数
```markdown
通常做法是使用哈希表对出现的每一个数做词频统计，哈希表的key是某个整数，value记录整数出现的次数。
本题的数据量是20亿，有可能一个数出现20亿次，则为了避免溢出，哈希表的key是32位（4B）,value也是 32位（4B），那么一条哈希表的记录就需要占用8B。
​当哈希表记录数为2亿个时，需要16亿个字节数（8*2亿），需要至少1.6GB内存(16亿/2^30,1GB== 2 ^30个字节 == 10亿)。则20亿个记录，至少需要16GB的内存，不符合题目要求。
​解决办法是将20亿个数的大文件利用哈希函数分成16个小文件，根据哈希函数可以把20亿条数据均匀分布到16个文件上，同一种数不可能被哈希函数分到不同的小文件上，假设哈希函数够好。
然后对每一个小文件用哈希函数来统计其中每种数出现的次数，这样我们就得到16个文件中出现次数最多的数，接着从16个数中选出次数最大的那个key即可。
```
### 3、40亿个非负整数中找到没有出现的数
```markdown
​对于原问题，如果使用哈希表来保存出现过的数，那么最坏情况下是40亿个数都不相同，那么哈希表则需要保存40亿条数据，一个32位整数需要4B，那么40亿*4B = 160亿个字节，
一般大概10亿个字节的数据需要1G的空间，那么大概需要16G的空间，这不符合要求。
我们换一种方式，申请一个bit数组，数组大小为4294967295，大概为40亿bit，40亿/8 = 5亿字节，那么需要0.5G空间， bit数组的每个位置有两种状态0和1，
那么怎么使用这个bit数组呢？呵呵，数组的长度刚好满足我们整数的个数范围，那么数组的每个下标值对应4294967295中的一个数，逐个遍历40亿个无符号数，
例如，遇到20，则bitArray[20] = 1；遇到666，则bitArray[666] = 1,遍历完所有的数，将数组相应位置变为1。
```
### 4、40亿个非负整数中找到一个没有出现的数，内存限制10MB
```markdown
 本题将内存空间缩小为10MB，对于40亿个数据来说那是明显不够用的，那么我们只有将数据分块处理，分块应该怎么分，分多少块合理呢？根据我做过的题经验来看，10亿个字节的数据大概需要1GB空间处理(如果这个结论不正确欢迎读者指出)，那么10MB内存换算过来就是可以处理1千万字节的数据，也就是8千万bit，对于40亿非负整数如果申请bit数组的话，40亿bit / 0.8亿bit = 50，那么这样最少也得分50块来处理，处理每块数据的时候几乎用完了内存空间，这样也不太好。看书上解说是分成了64块，至于为什么是64我目前也不是很了解，我只知道最少50块。所以下面就以64块来进行分析解答吧。
　　首先，将0 - 4294967259这个范围平均分成64个区间，每个区间是67108864个数，为了定位更加准确一些，我们先开辟一个大小为64的整型数组intArray，将40亿个数进行区间划分，第0区间（0-67108863）、第一区间（67108864-134217728）、第i区间（67108864i-67108864(i+1)-1）,......，第63区间（4227858432 - 4294967259）。intArray分别记录每个区间出现的数的个数，肯定至少有一个区间上的计数少于67108864.利用这一点可以快速找出一个没有出现过的数。
​ 第一次遍历时，先申请长度为64的整型数组countArr[0..63]，countArr[i]用来统计区间i 上的数有多少。遍历40亿个数，根据当前数是多少来决定哪一个区间上的计数增加。例如，如果当前数是3422552090，3422552090/67108864=51，所以第51区间上的计数增加countArr[51]++。遍历完40亿个数之后，遍历countArr，必然会有某一个位置上的值(countArr[i])小于67108864，表示第i 区间上至少有一个数没出现过。我们肯定会至少找到一个这样的区间。此时使用的内存就是countArr的大小（64×4B），是非常小的。
假设我们找到第37区间上的计数小于67108864，以下为第二次遍历的过程：
1．申请长度为67108864的bit map，这占用大约8MB的空间，记为bitArr[0..67108863]；
2．再遍历一次40亿个数，此时的遍历只关注落在第37区间上的数，记为num（num/67108864==37），其他区间的数全部忽略。
3．如果步骤2的num在第37区间上，将bitArr[num - 67108864*37]的值设置为1，也就是只做第37区间上的数的bitArr映射。
4．遍历完40亿个数之后，在bitArr上必然存在没被设置成1的位置，假设第i 个位置上的值没设置成1，那么67108864×37+i 这个数就是一个没出现过的数。
总结一下进阶的解法：
    1．根据10MB的内存限制，确定统计区间的大小，就是第二次遍历时的bitArr大小。
    2．利用区间计数的方式，找到那个计数不足的区间，这个区间上肯定有没出现的数。
    3．对这个区间上的数做bit map映射，再遍历bit map，找到一个没出现的数即可。
```
### 5、找到100亿个URL中重复的URL
```markdown
​原问题的解法使用解决大数据问题的一种常规方法：把大文件通过哈希函数分配到机器，或者通过哈希函数把大文件拆成小文件。
一直进行这种划分，直到划分的结果满足资源限制的要求。首先，你要向面试官询问在资源上的限制有哪些，包括内存、计算时间等要求。在明确了限制要求之后，
可以将每条URL通过哈希函数分配到若干机器或者拆分成若干小文件，这里的“若干”由具体的资源限制来计算出精确的数量。
​例如，将100亿字节的大文件通过哈希函数分配到100台机器上，然后每一台机器分别统计分给自己的URL中是否有重复的URL，
**同时哈希函数的性质决定了同一条URL不可能分给不同的机器；**或者在单机上将大文件通过哈希函数拆成1000个小文件，
对每一个小文件再利用哈希表遍历，找出重复的URL；或者在分给机器或拆完文件之后，进行排序，排序过后再看是否有重复的URL出现。
总之，牢记一点，很多大数据问题都离不开分流，要么是哈希函数把大文件的内容分配给不同的机器，要么是哈希函数把大文件拆成小文件，然后处理每一个小数量的集合。
```
### 6、海量搜索词汇，找到最热TOP100词汇的方法
```markdown
最开始还是用哈希分流的思路来处理，把包含百亿数据量的词汇文件分流到不同的机器上，具体多少台机器由面试官规定或者由更多的限制来决定。
对每一台机器来说，如果分到的数据量依然很大，比如，内存不够或其他问题，可以再用哈希函数把每台机器的分流文件拆成更小的文件处理。
​ 处理每一个小文件的时候，哈希表统计每种词及其词频，哈希表记录建立完成后，再遍历哈希表，遍历哈希表的过程中使用大小为100的小根堆来选出每一个小文件的top 100（整体未排序的top 100）。
每一个小文件都有自己词频的小根堆（整体未排序的top 100），将小根堆里的词按照词频排序，就得到了每个小文件的排序后top 100。然后把各个小文件排序后的top 100进行外排序或者继续利用小根堆，就可以选出每台机器上的top 100。
不同机器之间的top100再进行外排序或者继续利用小根堆，最终求出整个百亿数据量中的top 100。对于top K 的问题，除哈希函数分流和用哈希表做词频统计之外，还经常用堆结构和外排序的手段进行处理。
```
### 7、40亿个无符号整数，1GB内存，找到所有出现两次的数
```markdown
​ 对于原问题，可以用bit map的方式来表示数出现的情况。具体地说，是申请一个长度为4294967295×2的bit类型的数组bitArr，用2个位置表示一个数出现的词频，1B占用8个bit，
所以长度为4294967295×2的bit类型的数组占用1GB空间。怎么使用这个bitArr数组呢？遍历这40亿个无符号数，如果初次遇到num，就把bitArr[num2 + 1]和bitArr[num2]设置为01，
如果第二次遇到num，就把bitArr[num2+1]和bitArr[num2]设置为10，如果第三次遇到num，就把bitArr[num2+1]和bitArr[num2]设置为11。以后再遇到num，发现此时bitArr[num2+1]和bitArr[num2]已经被设置为11，就不再做任何设置。
遍历完成后，再依次遍历bitArr，如果发现bitArr[i2+1]和bitArr[i2]设置为10，那么i 就是出现了两次的数。
```
### 8、10MB内存，找到40亿整数的中位数
```markdown
①内存够：内存够还慌什么啊，直接把100亿个全部排序了，你用冒泡都可以...然后找到中间那个就可以了。但是你以为面试官会给你内存？？
②内存不够：题目说是整数，我们认为是带符号的int,所以4字节，占32位。
假设100亿个数字保存在一个大文件中，依次读一部分文件到内存(不超过内存的限制)，将每个数字用二进制表示，比较二进制的最高位(第32位，符号位，0是正，1是负)，如果数字的最高位为0，则将这个数字写入 file_0文件中；如果最高位为 1，则将该数字写入file_1文件中。
从而将100亿个数字分成了两个文件，假设 file_0文件中有 60亿 个数字，file_1文件中有 40亿 个数字。那么中位数就在 file_0 文件中，并且是 file_0 文件中所有数字排序之后的第 10亿 个数字。（file_1中的数都是负数，file_0中的数都是正数，也即这里一共只有40亿个负数，那么排序之后的第50亿个数一定位于file_0中）
现在，我们只需要处理 file_0 文件了（不需要再考虑file_1文件）。对于 file_0 文件，同样采取上面的措施处理：将file_0文件依次读一部分到内存(不超内存限制)，将每个数字用二进制表示，比较二进制的 次高位（第31位），如果数字的次高位为0，写入file_0_0文件中；如果次高位为1，写入file_0_1文件 中。
现假设 file_0_0文件中有30亿个数字，file_0_1中也有30亿个数字，则中位数就是：file_0_0文件中的数字从小到大排序之后的第10亿个数字。
抛弃file_0_1文件，继续对 file_0_0文件 根据 次次高位(第30位) 划分，假设此次划分的两个文件为：file_0_0_0中有5亿个数字，file_0_0_1中有25亿个数字，那么中位数就是 file_0_0_1文件中的所有数字排序之后的 第 5亿 个数。
按照上述思路，直到划分的文件可直接加载进内存时，就可以直接对数字进行快速排序，找出中位数了。
```
### 9、设计短域名系统，将长URL转化成短的URL
```markdown
（1）利用放号器，初始值为0，对于每一个短链接生成请求，都递增放号器的值，再将此值转换为62进制（a-zA-Z0-9），比如第一次请求时放号器的值为0，对应62进制为a，第二次请求时放号器的值为1，对应62进制为b，第10001次请求时放号器的值为10000，对应62进制为sBc。
（2）将短链接服务器域名与放号器的62进制值进行字符串连接，即为短链接的URL，比如：t.cn/sBc。
（3）重定向过程：生成短链接之后，需要存储短链接到长链接的映射关系，即sBc -> URL，浏览器访问短链接服务器时，根据URL Path取到原始的链接，然后进行302重定向。映射关系可使用K-V存储，比如Redis或Memcache。
```
### 10、让你系统的设计一个高并发的架构，你会从哪几个方面考虑？
```markdown
系统拆分
​ 将一个系统拆分为多个子系统，用 dubbo 来搞。然后每个系统连一个数据库， 这样本来就一个库，现在多个数据库，不也可以扛高并发么。
缓存
​ 缓存，必须得用缓存。大部分的高并发场景，都是读多写少，那你完全可以在数 据库和缓存里都写一份，然后读的时候大量走缓存不就得了。毕竟人家 redis 轻 轻松松单机几万的并发。所以你可以考虑考虑你的项目里，那些承载主要请求的 读场景，怎么用缓存来抗高并发。
MQ
​ MQ，必须得用 MQ。可能你还是会出现高并发写的场景，比如说一个业务操作 里要频繁搞数据库几十次，增删改增删改，疯了。那高并发绝对搞挂你的系统， 你要是用 redis 来承载写那肯定不行，人家是缓存，数据随时就被 LRU 了，数 据格式还无比简单，没有事务支持。所以该用 mysql 还得用 mysql 啊。那你 咋办？用 MQ 吧，大量的写请求灌入 MQ 里，排队慢慢玩儿，后边系统消费 后慢慢写，控制在 mysql 承载范围之内。所以你得考虑考虑你的项目里，那些 承载复杂写业务逻辑的场景里，如何用 MQ 来异步写，提升并发性。MQ 单机 抗几万并发也是 ok 的，这个之前还特意说过。
分库分表
​ 分库分表，可能到了最后数据库层面还是免不了抗高并发的要求，好吧，那么就 将一个数据库拆分为多个库，多个库来扛更高的并发；然后将一个表拆分为多个 表，每个表的数据量保持少一点，提高 sql 跑的性能。
读写分离
​ 读写分离，这个就是说大部分时候数据库可能也是读多写少，没必要所有请求都 集中在一个库上吧，可以搞个主从架构，主库写入，从库读取，搞一个读写分离。 读流量太多的时候，还可以加更多的从库。
ElasticSearch
​ Elasticsearch，简称 es。es 是分布式的，可以随便扩容，分布式天然就可以支 撑高并发，因为动不动就可以扩容加机器来扛更高的并发。那么一些比较简单的 查询、统计类的操作，可以考虑用 es 来承载，还有一些全文搜索类的操作，也 可以考虑用 es 来承载。
11、假设有这么一个场景，有一条新闻，新闻的评论量可能很大，如何设计评论的读和写
可以进行读写分离、加载到缓存
12、显示网站的用户在线数的解决思路
维护在线用户表
使用Redis统计
```
### 海量日志数据，提取出某日访问百度次数最多的那个IP
```markdown
算法思想：分而治之+Hash
1.IP地址最多有2^32=4G种取值情况，所以不能完全加载到内存中处理；
2.可以考虑采用“分而治之”的思想，按照IP地址的hash(ip)%1024,把海量IP日志分别存储到1024个小文件中。这样，每个小文件最多包含4MB个IP地址；
3.对于每个小文件，可以构建一个ip为key，出现次数为value的Hash_map，同时记录当前出现次数最多的那个ip地址；
4.可以得到1024个小文件中的出现次数最多的ip，再依据常规的排序算法得到总体上出现次数最多的ip；
```
### 有一亿个数字，其中两个重复，快速找到它，时间和空间最优
### 有100亿个词，找出使用频率最高的十个
##

