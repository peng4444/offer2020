# Java容器集合总结及面试题

[TOC]

## Java容器集合
### 1.Java容器集合简介
[java集合详解](https://www.cnblogs.com/yanzezhong/p/12808089.html)
```markdown
数组 - > 链表 ->类集  ：类集就是Java数据结构的实现，类集就是动态对象数组   源码
    Collection接口  继承了Iterable接口，不提供该接口的具体实现
    添加方法：add(E e) / addAll(Collection<? extends E> var1)
    删除方法：remove(Object var1) / removeAll(Collection<?> var1)
    查找方法：contains(Object var1) / containsAll(Collection<?> var1);
    查询集合自身信息：size() / isEmpty()
        List接口（有序，可重复集合，对象按插入顺序排列，通过索引访问指定位置的元素）
            AbstractList:
                AbstractSequentialList:抽象类继承了AbstractList，在原基础上限制了访问元素的顺序只能够按照顺序访问，而不支持随机访问。
            ArrayList:基于动态数组实现，支持随机访问，访问元素的效率较高。线程不安全。容量为10。扩容为1.5倍。
            LinkedList:基于双向链表(JDK1.6以前为循环链表，JDK1.7取消了)实现，增删快、查询慢。线程不安全。
            Vector:和ArrayList类似，是线程安全的(synchronized锁)，效率低，过时。
                在线程安全的情况下，不需要选用Vector，而是ArrayList；在并发环境下使用CopyOnWriteArrayList，Vector完全被弃用了。
                Stack：继承了Vector类。后入先出（LIFO）型的集合容器。
                    提供了栈顶的压入元素操作（push）和弹出元素操作（pop），以及查看栈顶元素的方法（peek）等等
                    使用Deque接口，及实现ArrayDeque替代。
        Set接口（无序，不可重复集合，对象排列顺序不一，Set至多只能存储一个NULL值元素）
            AbstractSet抽象类（重写所有set相同的hashCode()和equals()方法）
                HashSet:查找的时间复杂度为 O(1)，TreeSet则为O(logN)。采用数组+链表+红黑树实现，线程不安全。
                    基于哈希表实现，支持快速查找，但不支持有序性操作。
                    并且失去了元素的插入顺序信息，也就是说使用Iterator遍历HashSet得到的结果是不确定的。
                    LinkedHashSet:继承了HashSet，具有HashSet的查找效率，且内部使用双向链表维护元素的插入顺序。线程不安全。
            SortedSet接口（有序）
                TreeSet:基于数组+红黑树实现，支持有序性操作，线程不安全。
                TreeSet默认按照自然排序，如果需要定制排序，需要传入Comparator。
        Queue接口（队列容器，其特性与List相同，但只能从队头和队尾操作元素）
            LinkedList:可以用它来实现双向队列。
            PriorityQueue:基于堆结构实现，可以用它来实现优先队列，堆是采用数组实现。
            Deque:双端队列。提供了针对队列的头结点和尾结点操作的方法，而插入、删除方法同样也提供了两套不同的失败策略。
                ArrayDeque:使用数组实现的双端队列，是无界的双端队列，最小的容量是8（JDK1.8）。在JDK11看到它默认容量是16。
            Queue中提供了两套增加、删除元素的API，当插入或删除元素失败时，会有两种不同的失败处理策略。
                方法及失败策略	插入方法	 删除方法	  查找方法
                抛出异常	        add()	 remove()	  get()
                返回失败默认值	offer()	 poll()	      peek()
            AbstractQueue抽象类
    Map接口(<key,value>组成的集合，由key映射到唯一的value，所以Map不能包含重复的key，每个键至多映射一个值。)
        Map定位元素的时间复杂度优化到O(1)
        AbsractMap：（定义了普通的Map集合具有的通用行为）
            HashMap：（数组+链表+红黑树，非线程安全）
                是一个最通用的利用哈希表存储元素的集合，将元素放入HashMap时，将key的哈希值转换为数组的索引下标确定存放位置，
                    查找时，根据key的哈希地址转换成数组的索引下标确定查找位置。
                发送哈希冲突时，HashMap 的解决方法是将相同映射地址的元素连成一条链表，
                    当链表长度超过8时，将链表转换为红黑树，链表长度低于6，就把红黑树转回链表，以减少搜索时间。
                Poperties
            HashTable：（存储结构是数组+链表，线程安全(synchronized锁)），（默认长度为11，负载因子为0.75F，扩容为原长度2倍）
                意味着同一时刻多个线程可以同时写入HashTable并且不会导致数据不一致。
                可以使用ConcurrentHashMap来支持线程安全，并且ConcurrentHashMap的效率会更高，因为ConcurrentHashMap引入了分段锁。 
            LinkedHashMap：（继承HashMap实现Map接口，非线程安全）
                使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。
                LinkedHashMap可实现LRU缓存淘汰策略，其原理是通过设置accessOrder为true并重写removeEldestEntry方法定义淘汰元素时需满足的条件
        SortedMap接口（定义了该类Map具有排序行为）
            TreeMap：基于数组+红黑树实现，非线程安全。
                每一个键值对<key, value>都是一个结点，默认情况下按照key自然排序，另一种是可以通过传入定制的Comparator进行自定义规则排序。          
                自然排序：要求key必须实现Comparable接口。由于Integer类实现了Comparable接口，按照自然排序规则是按照key从小到大排序。
                定制排序：在初始化TreeMap时传入新的Comparator，不要求key实现Comparable接口。
        WeakHashMap：（数组+链表实现，在WeakHashMap内部维护了一个引用队列queue，key随时会被回收掉，所以不能确保某次访问元素一定存在）
            基于普通的Map实现的，而里面Entry中的键在每一次的垃圾回收都会被清除掉，
            WeakHashMap通常作为缓存使用，所以非常适合用于短暂访问、仅访问一次的元素，缓存在WeakHashMap中，并尽早地把它回收掉。
    集合输出 Iterator,ListIterator(双向集合输出),Enumeration,foreach,Enumeration只有在Vector接口中使用
    Map遍历的两种方式
         keyset和entryset，前者是获得key的集合，后者是获得key-value的集合，返回的都是set视图，利用set有迭代器iterator，通过iterator.next来遍历。
         推荐使用entrySet()方法，效率较高。对于keySet其实是遍历了2次，一次是转为iterator，一次就是从HashMap中取出key所对于的value。
            而entryset只是遍历了第一次，它把key和value都放到了entry中，所以快了。    
```
### Iterator,Iterable和ListIterator的区别是什么？【2+】
```markdown
ListIterator实现了Iterator接⼝，并包含其他的功能，⽐如：增加元素，替换元素，获取前⼀个和后⼀个元素的索引等等。
Iterator可⽤来遍历，移除Set和List集合，但是ListIterator只能⽤来遍历List。
Iterator对集合只能是单向遍历，ListIterator遍历List集合时可以从任意索引下标开始遍历，而且支持双向遍历。
Iterable接口实现了Iterator接口，实现了Iterable接口的集合依旧可以使用迭代器遍历和操作集合中的对象。
    JDK1.8中，Iterable提供了一个新的方法forEach()，能够使用增强for循环遍历对象。（本质上还是使用Iterator去遍历）
```
### 2.[不可错过的java面试博客之java集合篇](https://www.cnblogs.com/jichi/p/12834238.html)
#### 2.1 List【2+】
```markdown
1.List是无序的Collection，List一共三个实现类：分别是ArrayList、Vector和LinkedList
    1.1：ArrayList通过数组实现的，允许对元素进行快速随机访问。缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，
        就要将已经有数组的数据复制到新的存储空间中。当从中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。
        适合随机查找和遍历，不适合插入和删除。排列有序，可重复，容量不够的时候，当前容量*1.5倍。(默认容量为10)
    1.2：Vector也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，
        但实现同步需要很高的花费(synchronized锁)，因此，访问它比访问ArrayList慢。(默认容量为10)默认的*2倍容量。
    1.3：LinkedList是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。还提供了List接口中没有定义的方法，
        专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。底层使用双向循环链表数据结构。线程不安全。
        将LinkedList替换成ConcurrentLinkedQueue实现线程安全。
```
#### 2.2 Set
```markdown
1.Set是存储有序(存入和取出的顺序不一定相同)元素，值不能重复。
    1.1：HashSet（Hash表）value值为一个相同的object对象的HashMap，值存入HashMap的key。
    1.2:TreeSet（二叉树） 有序存储 每增加一个对象都会进行排序
    1.3:LinkHashSet（HashSet+LinkedHashMap）
Set⾥的元素是不能重复的，元素重复与否是使⽤equals()⽅法进⾏判断的。
HashSet和TreeSet有什么区别？
    HashSet是由⼀个hash表来实现的，因此，它的元素是⽆序的。add()，remove()，contains()
    TreeSet是由⼀个树形的结构来实现的，它⾥⾯的元素是有序的。因此，add()，remove()，contains()⽅法的时间复杂度是O(logn)。
```
#### 2.3 Map
```markdown
1.Map
    1.1：HashMap（数组+链表+红黑树）根据键的hashCode值存储数据,大多数情况下可以直接定位到它的值，具有很快的访问速度，
          但遍历顺序却是不确定的。HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全。  
          可以用Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。默认大小是16。扩容是2的指数倍。
    1.2：ConcurrentHashMap和HashMap思路是差不多的，但是因为它支持并发操作，线程安全。分段锁Segment继承ReentrantLock加锁
        ConcurrentHashMap是多个Segment数组，Segment通过继承ReentrantLock来进行加锁，所以每次需要加锁的操作锁住的是一个segment，
        这样只要保证每个Segment是线程安全的，也就实现了全局的线程安全。默认大小是16。
    1.3：HashTable（线程安全synchronized锁）是遗留类，并发性不如ConcurrentHashMap。
        HashTable不允许<键,值>有空值，HashMap允许<键,值>有空值。HashTable使用Enumeration，HashMap使用Iterator。
    1.4：TreeMap（可排序）实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序。
    1.5：LinkHashMap（记录插入顺序）是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历
         LinkedHashMap如何保证有序性:继承自HashMap，内部增加了head tail 和access order。
    1.6：HashTable中hash数组的默认大小是11，增加方式的old*2+1，HashMap中hash数组的默认大小是16，增长方式一定是2的指数倍。
        父类不同：HashMap继承了AbstractMap类，而HashTable继承了Dictionary类
```
#### 2.4 Queue
```markdown
Queue->Deque->ArrayDeque
     ->LinkedList
     ->PriorityQueue
ArrayDeque是一个可扩容的数组，LinkedList是链表结构；
ArrayDequ里不可以存null值，但是LinkedList可以；
ArrayDeque在操作头尾端的增删操作时更高效，但是LinkedList只有在当要移除中间某个元素且已经找到了这个元素后的移除才是O(1)的；
ArrayDeque在内存使用方面更高效。
所以，只要不是必须要存null值，就选择ArrayDeque吧！
在Queue中poll()和remove()有什么区别？
 poll()和remove()都将移除并且返回对头，但是在poll()在队列为空时返回null，而remove()会抛出NoSuchElementException异常。
 peek()和element()都将在不移除的情况下返回队头，但是peek()方法在队列为空时返回null，调用element()方法会抛出NoSuchElementException 异常。
 add()和offer()都是向队列中添加一个元素。但是如果想在一个满的队列中加入一个新元素，调用add()方法就会抛出一个unchecked异常，而调用offer()方法会返回false。
```
#### 2.5 hashmap的实现原理【1+】
[HashMap解析（主要JDK1.8，附带1.7出现的问题以及区别）](https://www.cnblogs.com/dmzna/p/13055232.html)
[HashMap是如何工作的](https://www.cnblogs.com/homejim/p/10029796.html)
```markdown
HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。
当我们给put()方法传递键和值时，先对键调用hashCode()方法，计算并返回的hashCode是用于找到Map数组的bucket位置来储存Node对象。
关键点在于，HashMap是在bucket中储存键对象和值对象，作为Map.Node。
以下是具体的put过程（JDK1.8版）
    1.对Key求Hash值，然后再计算下标
    2.如果没有碰撞，直接放入桶中（碰撞的意思是计算得到的Hash值相同，需要放到同一个bucket中）
    3.如果碰撞了，则调用equals() 比较value，相同则替换旧值，不同则以链表的方式链接到后面
    4.如果链表长度超过阀值(REEIFY THRESHOLD==8)，就把链表转成红黑树，链表长度低于6，就把红黑树转回链表
    5.如果桶满了(容量16*加载因子0.75)，就需要resize（扩容2倍后重排）
以下是具体get过程(考虑特殊情况如果两个键的hashcode相同，你如何获取值对象？)
    当我们调用get()方法，HashMap会使用键对象的hashcode找到bucket位置，找到bucket位置之后，
    会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。
resize()方法何时进行扩容？
    HashMap使用的是懒加载，构造完HashMap对象后，只要不进行put 方法插入元素之前，HashMap并不会去初始化或者扩容table。
    当首次调用put方法时，HashMap会发现table为空然后调用resize方法进行初始化
    ，当添加完元素后，如果HashMap发现size（元素总数）大于threshold（阈值），则会调用resize方法进行扩容。
    其实主要就是两步：1.创建新的数组 2.复制元素。
```
#### 2.4 HashMap扩容机制算法【1+】
```markdown
HashMap的初始容量16，加载因子为0.75，扩容增量是原容量的1倍。如果HashMap的容量为16，一次扩容后容量为32。
HashMap扩容是指元素个数（包括数组和链表+红黑树中）超过了16*0.75=12（容量×加载因子）之后开始扩容。
HashMap有扩容机制，就是当达到扩容条件时会进行扩容。
HashMap的扩容条件就是当HashMap中的元素个数（size）超过临界值（threshold）时就会自动扩容。
在HashMap中，threshold=loadFactor*capacity。非常影响性能的。
在Jdk1.7和Jdk1.8中，HashMap初始化这个容量的时机不同。
jdk1.8中，在调用HashMap的构造函数定义HashMap的时候，就会进行容量的设定。而在Jdk1.7中，要等到第一次put操作时才进行这一操作。
```
#### 2.6 拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？
```markdown
选择红黑树是为了解决二叉查找树的缺陷，二叉查找树在特殊情况下会变成一条线性结构遍历查找会非常慢。
而红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，引入红黑树就是为了查找数据快，解决链表查询深度的问题，
红黑树属于平衡二叉树，为了保持“平衡”是需要付出代价的，但是该代价所损耗的资源要比遍历线性链表要少，
所以当长度大于8的时候，会使用红黑树，如果链表长度很短的话，根本不需要引入红黑树，引入反而会慢。
```
#### 2.7 解决hash碰撞还有那些办法？
```markdown
HashMap：如何有效减少碰撞
    扰动函数：促使元素位置分布均匀，减少碰撞概率。
    使用final对象，并且采用合适的equals()和hashCode()方法。
开放定址法
    当冲突发生时，使用某种探查技术在散列表中形成一个探查(测)序列。沿此序列逐个单元地查找，直到找到给定的地址。
    按照形成探查序列的方法不同，可将开放定址法区分为线性探查法、二次探查法、双重散列法等。
再哈希法
    Hi = RHi（key），i=1,2,...k,RHi均是不同的哈希函数，即在同义词产生地址冲突时计算另一个哈希函数地址，直到不发生冲突为止。
    这种方法不易产生聚集，但是增加了计算时间。
    缺点：增加了计算时间。
建立一个公共溢出区
    假设哈希函数的值域为[0,m-1]，则设向量HashTable[0...m-1]为基本表，每个分量存放一个记录，另设立向量OverTable[0....v]为溢出表。
    所有关键字和基本表中关键字为同义词的记录，不管他们由哈希函数得到的哈希地址是什么，一旦发生冲突，都填入溢出表。
    简单地说就是搞个新表存冲突的元素。
链地址法（拉链法）
    将所有关键字为同义词的记录存储在同一线性链表中，也就是把冲突位置的元素构造成链表。
```
#### 2.8 Comparable和Comparator的区别?【1+】
```markdown
Comparable&Comparator都是用来实现集合中元素的比较、排序的，
    只是Comparable是在集合内部定义的方法实现的排序，Comparator是在集合外部实现的排序，
    所以，如想实现排序，就需要在集合外定义Comparator接口的方法或在集合内实现Comparable接口的方法。
    如果在定义类时，就实现了Comparable接口，直接在里面重写compareTo()方法，
    如果没实现，后面在业务开发中需要有比较排序的功能，就再单独写一个类实现Comparator接口，在里面重写compare()方法，
    然后这个类需要作为参数传入到工具类Collections.sort和Arrays.sort方法中。
最主要的区别就是一个一开始就实现，一个是后期实现。
Comparator位于包java.util下，而Comparable位于包java.lang下。
```
### 2.Collection和Collections有什么区别？
```markdown
 Collection是集合接口，是List和Set的根接口; Collections是工具类，提供处理集合的各种方法
如何决定使用HashMap还是TreeMap？
     HashMap效率高，存取数据快，但是数据无序
     TreeMap效率低，但是存储数据是排序的，可以取到最大和最小值
ArrayList和LinkedList的区别是什么？
     ArrayList动态数组，索引方便，插入不方便
     LinkedList链表，索引不方便，插入方便
ArrayList和Vector的区别是什么？
     ArrayList 线程不安全，扩容*1.5
     Vector方法使用synchronized关键字。线程安全，扩容*2，效率比ArrayList低，适合存大数据并且要求线程安全
Iterator和ListIterator有什么区别？
     Iterator是List和Set的迭代器
     ListIterator是List的迭代器
     Iterator单向，ListIterator双向，ListIterator继承自Iterator，并且实现了更多功能，添加替换等。
```
### 3.Java容器集合源码
#### 3.1[ArrayList详解-源码分析](https://www.cnblogs.com/strive-for-life/p/12923608.html)
```markdown
* ArrayList是基于数组实现的集合列表
* 支持任意性的访问（可根据索引直接得到你想要的元素）
* 线程不安全
* 支持动态扩容
* 查询快，增删慢
默认默认容量大小为10，新数组的容量大小为旧数组容量的1.5倍，2^n。
详细讲解ArrayList的部分源码。
```
#### 3.2[LinkedList详解-源码分析](https://www.cnblogs.com/strive-for-life/p/12932845.html)
```markdown
* 基于双向链表实现
* 便于插入和删除，不便于遍历
* 非线程安全
* 有序（链表维护顺序）
transient关键字标识变量不会被序列化。节点都被transient修饰。
LinkedList是基于双向链表实现的，即每一个节点都保存了上一个节点和下一个节点的信息。
LinkedList根据索引获取元素效率低的原因是因为它需要一个节点一个节点的遍历，获取首节点和尾节点很快。
LinkedList实现了Deque接口，具有双向队列的性质，可以实现数据结构中的堆栈。
```
### 4.ArrayList不是线程安全的 & CopyOnWriteArrayList解决【2+】
[浅析CopyOnWriteArrayList](https://www.cnblogs.com/zengcongcong/p/12754067.html)
#### 4.1代码演示ArrayList线程不安全
```java
public class ArrayListDemo{
    public static void main(String[] args){
        List<String> list = new ArrayList<>();
        List<String> vector = new Vector<>();
        List<String> synchronizedList = Collections.synchronizedList(new ArrayList<>());
        List<String> copyOnWriteArrayList = new CopyOnWriteArrayList<>();
        
        //多个线程调用list 出现java.util.ConcurrentModificationException
        for(int i = 1;i<=30;i++){
            new Thread(()->{
                list.add((UUID).randomUUID().toString().substring(0,8));
                System.out.println(list);
            },String.valueOf(i)).start();
        }
    }
    
    //1.故障现象：java.util.ConcurrentModificationException
    //2.导致原因：
    //3.解决方案：
        //1.使用Vector类，Vector的add方法被synchronized修饰,不介意使用。
        //2.使用Collections.synchronizedList(new ArrayList<>());
        //3.CopyOnWriteArrayList类,写时复制。读写分离的思想。
    //4.优化建议：
}
```
#### 4.2ArrayList线程不安全原因和解决方式。
```markdown
1.为什么ArrayList不是线程安全的？
    并发争抢修改导致，参考花名册签到情况。
    一个人正在写入，另外一个同学过来抢夺，导致数据不一致异常。并发修改异常。
    所有的java.util包中的集合类都被设计为fail-fast，由于fail-fast机制的存在，抛出了modcount修改异常的错误ConcurrentModificationException 
    (modcount是ArrayList源码中的一个变量，用来表示修改的次数，因为ArrayList不是为并发情况而设计的集合类）
2.解决办法：
    1.可以使用Vector集合，Vector集合是线程安全版的ArrayList，其方法都上了一层synchronized进行修饰，
    采取jvm内置锁来保证其并发情况下的原子性、可见性、有序性。但同时也带来了性能问题，因为synchronized一旦膨胀到重量级锁，
    存在用户态到和心态的一个转变，多线程的上下文切换会带来开销。另一个问题是Vector集合的扩容没有ArrayList的策略好。
    2.使用Collections.synchronizedList()，在更新操作中使用了同步锁。
    3.采用JUC提供的并发容器，CopyOnWriteArrayList。
3.CopyOnWriteArrayList
    和ArrayList一样，其底层数据结构也是数组，加上transient不让其被序列化，加上volatile修饰来保证多线程下的其可见性和有序性。
    CopyOnWriteArrayList在更新操作中不仅使用了可重入锁，而且还需要进行数组的复制。
    CopyOnWriteArrayList适合于多线程场景下使用，其采用读写分离的思想，读操作不上锁，写操作上锁，且写操作效率较低。
    CopyOnWriteArrayList基于fail-safe机制，每次修改都会在原先基础上复制一份，修改完毕后在进行替换。
    CopyOnWriteArrayList的add()方法采用的是ReentrantLock进行上锁。
```
#### 4.3HashSet和HashMap线程不安全
```markdown
原理同ArrayList;
HashSet解决方案:Collections.synchronizedSet()，CopyOnWriteHashSet
HashMap解决方案：Collections.sychronizedMap()，ConcurrentHashMap。
```
### 5.HashMap知识总结【必考点 重点】
[HashMap面试必问的数据结构相关知识总结](https://www.cnblogs.com/Young111/p/11519952.html)
[【两万字】面试官：听说你很懂集合源码，接我二十道问题！](https://www.cnblogs.com/viyoung/p/13208296.html)
```markdown
1：HashMap的数据结构？
哈希表结构（链表散列：数组+链表）实现，结合数组和链表的优点。当链表长度超过8时，链表转换为红黑树。transient Node<K,V>[] table;
2：HashMap的工作原理？
HashMap底层是hash数组和单向链表实现，数组中的每个元素都是链表，由Node内部类（实现 Map.Entry<K,V>接口）实现，HashMap通过put&get方法存储和获取。
存储对象时，将K/V键值传给put()方法：
　　①、调用 hash(K)方法计算K的hash值，然后结合数组长度，计算得数组下标；
　　②、调整数组大小（当容器中的元素个数大于capacity*loadfactor时，容器会进行扩容resize为 2n）；
　　③、i.如果K的hash值在HashMap中不存在，则执行插入，若存在，则发生碰撞；
　　　　ii.如果K的hash值在HashMap中存在，且它们两者equals返回true，则更新键值对；
　　　　iii. 如果K的hash值在HashMap中存在，且它们两者equals返回false，则插入链表的尾部（尾插法）或者红黑树中（树的添加方式）。
（JDK1.7之前使用头插法、JDK1.8使用尾插法）（注意：当碰撞导致链表大于TREEIFY_THRESHOLD=8时，就把链表转换成红黑树）
获取对象时，将K传给get()方法：①、调用hash(K)方法（计算K的hash值）从而获取该键值所在链表的数组下标；②、顺序遍历链表，equals()方法查找相同Node链表中K值对应的V值。
hashCode是定位的，存储位置；equals是定性的，比较两者是否相等。
3.当两个对象的hashCode相同会发生什么？
因为hashCode相同，不一定就是相等的（equals方法比较），所以两个对象所在数组的下标相同，"碰撞"就此发生。又因为HashMap使用链表存储对象，这个Node会存储到链表中。
4.你知道hash的实现吗？为什么要这样实现？
JDK1.8中，是通过hashCode()的高16位异或低16位实现的：(h=k.hashCode())^(h>>>16)，主要是从速度，功效和质量来考虑的，减少系统的开销，
也不会造成因为高位没有参与下标的计算，从而引起的碰撞。
5.为什么要用异或运算符？
　　保证了对象的hashCode的32位值只要有一位发生改变，整个hash()返回值就会改变。尽可能的减少碰撞。
6.HashMap的table的容量如何确定？loadFactor是什么？ 该容量如何变化？这种变化会带来什么问题？
　　①、table数组大小是由capacity这个参数确定的，默认是16，也可以构造时传入，最大限制是1<<30；
　　②、loadFactor是装载因子，主要目的是用来确认table数组是否需要动态扩展，默认值是0.75，比如table数组大小为16，装载因子为0.75时，threshold就是12，当table的实际大小超过12时，table就需要动态扩容；
　　③、扩容时，调用resize()方法，将table长度变为原来的两倍（注意是table长度，而不是threshold）
　　④、如果数据很大的情况下，扩展时将会带来性能的损失，在性能要求很高的地方，这种损失很可能很致命。
7.HashMap中put方法的过程？
    答：“调用哈希函数获取Key对应的hash值，再计算其数组下标；
    如果没有出现哈希冲突，则直接放入数组；如果出现哈希冲突，则以链表的方式放在链表后面；
    如果链表长度超过阀值( TREEIFY THRESHOLD==8)，就把链表转成红黑树，链表长度低于6，就把红黑树转回链表;
    如果结点的key已经存在，则替换其value即可；
    如果集合中的键值对大于12，调用resize方法进行数组扩容。”
8.数组扩容的过程？
创建一个新的数组，其容量为旧数组的两倍，并重新计算旧数组中结点的存储位置。结点在新数组中的位置只有两种，原下标位置或原下标+旧数组的大小。
9.拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？
之所以选择红黑树是为了解决二叉查找树的缺陷，二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成很深的问题），遍历查找会非常慢。
而红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，引入红黑树就是为了查找数据快，解决链表查询深度的问题，我们知道红黑树属于平衡二叉树，
但是为了保持“平衡”是需要付出代价的，但是该代价所损耗的资源要比遍历线性链表要少，所以当长度大于8的时候，会使用红黑树，如果链表长度很短的话，根本不需要引入红黑树，引入反而会慢。
10.说说你对红黑树的见解？
    1、每个节点非红即黑
    2、根节点总是黑色的
    3、如果节点是红色的，则它的子节点必须是黑色的（反之不一定）
    4、每个叶子节点都是黑色的空节点（NIL节点）
    5、从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）
11.jdk8中对HashMap做了哪些改变？
在java1.8中，如果链表的长度超过了8，那么链表将转换为红黑树。（桶的数量必须大于64，小于64的时候只会扩容）
发生hash碰撞时，java1.7会在链表的头部插入，而java1.8会在链表的尾部插入,在java1.8中，Entry被Node替代(换了一个马甲)。
12.HashMap，LinkedHashMap，TreeMap 有什么区别？
　　HashMap参考其他问题；
　　LinkedHashMap保存了记录的插入顺序，在用Iterator遍历时，先取到的记录肯定是先插入的；遍历比HashMap慢；
　　TreeMap实现SortMap接口，能够把它保存的记录根据键排序（默认按键值升序排序，也可以指定排序的比较器）
13.HashMap&TreeMap&LinkedHashMap使用场景？
　　一般情况下，使用最多的是HashMap。
　　HashMap：在Map中插入、删除和定位元素时；
　　TreeMap：在需要按自然顺序或自定义顺序遍历键的情况下；
　　LinkedHashMap：在需要输出的顺序和输入的顺序相同的情况下。
14.HashMap和HashTable有什么区别？
　　①、HashMap是线程不安全的，HashTable是线程安全的；
　　②、由于线程安全，所以HashTable的效率比不上HashMap；
　　③、HashMap最多只允许一条记录的键为null，允许多条记录的值为null，而 HashTable不允许；
　　④、HashMap默认初始化数组的大小为16，HashTable为11，前者扩容时，扩大两倍，后者扩大两倍+1；
　　⑤、HashMap需要重新计算hash值，而HashTable直接使用对象的hashCode
15.Java中的另一个线程安全的与HashMap极其类似的类是什么？同样是线程安全，它与HashTable在线程同步上有什么不同？
　　ConcurrentHashMap类（是Java并发包java.util.concurrent中提供的一个线程安全且高效的HashMap实现）。
　　HashTable是使用synchronize关键字加锁的原理（就是对对象加锁）；
　　而针对ConcurrentHashMap，在JDK 1.7中采用 分段锁的方式；JDK 1.8中直接采用了CAS（无锁算法）+ synchronized。
16.HashMap&ConcurrentHashMap的区别？
　　除了加锁，原理上无太大区别。另外，HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。
17.为什么ConcurrentHashMap比HashTable效率要高？
　　HashTable使用一把锁（锁住整个链表结构）处理并发问题，多个线程竞争一把锁，容易阻塞；
　　ConcurrentHashMap 
JDK1.7中使用分段锁（ReentrantLock+Segment+HashEntry），相当于把一个HashMap分成多个段，每段分配一把锁，这样支持多线程访问。锁粒度：基于Segment，包含多个HashEntry。
JDK1.8中使用CAS+synchronized+Node+红黑树。锁粒度：Node（首结点）（实现 Map.Entry<K,V>）。锁粒度降低了。
18.针对ConcurrentHashMap锁机制具体分析（JDK 1.7 VS JDK 1.8）？
　　JDK 1.7 中，采用分段锁的机制，实现并发的更新操作，底层采用数组+链表的存储结构，包括两个核心静态内部类Segment和HashEntry。
　　　　①、Segment 继承 ReentrantLock（重入锁） 用来充当锁的角色，每个 Segment 对象守护每个散列映射表的若干个桶；
　　　　②、HashEntry 用来封装映射表的键-值对；
　　　　③、每个桶是由若干个 HashEntry 对象链接起来的链表
　　JDK1.8中，采用Node+CAS+Synchronized来保证并发安全。取消类Segment，直接用table数组存储键值对；
    当HashEntry对象组成的链表长度超过TREEIFY_THRESHOLD时，链表转换为红黑树，提升性能。底层变更为数组+链表+红黑树。
19.ConcurrentHashMap 在 JDK 1.8 中，为什么要使用内置锁 synchronized 来代替重入锁 ReentrantLock？
　　①、粒度降低了；
　　②、JVM 开发团队没有放弃 synchronized，而且基于 JVM 的 synchronized 优化空间更大，更加自然。
　　③、在大量的数据操作下，对于 JVM 的内存压力，基于 API 的 ReentrantLock 会开销更多的内存。
20.ConcurrentHashMap 简单介绍？
①、重要的常量：
　　private transient volatile int sizeCtl;
　　当为负数时，-1 表示正在初始化，-N 表示 N - 1 个线程正在进行扩容；
　　当为 0 时，表示 table 还没有初始化；
　　当为其他正数时，表示初始化或者下一次进行扩容的大小。
②、数据结构：
　　Node 是存储结构的基本单元，继承 HashMap 中的 Entry，用于存储数据；
　　TreeNode 继承 Node，但是数据结构换成了二叉树结构，是红黑树的存储结构，用于红黑树中存储数据；
　　TreeBin 是封装 TreeNode 的容器，提供转换红黑树的一些条件和锁的控制。
③、存储对象时（put() 方法）：
　　1.如果没有初始化，就调用 initTable() 方法来进行初始化；
　　2.如果没有 hash 冲突就直接 CAS 无锁插入；
　　3.如果需要扩容，就先进行扩容；
　　4.如果存在 hash 冲突，就加锁来保证线程安全，两种情况：一种是链表形式就直接遍历到尾端插入，一种是红黑树就按照红黑树结构插入；
　　5.如果该链表的数量大于阀值 8，就要先转换成红黑树的结构，break 再一次进入循环
　　6.如果添加成功就调用 addCount() 方法统计 size，并且检查是否需要扩容。
④、扩容方法 transfer()：默认容量为 16，扩容时，容量变为原来的两倍。
　　helpTransfer()：调用多个工作线程一起帮助进行扩容，这样的效率就会更高。
⑤、获取对象时（get()方法）：
　　1.计算 hash 值，定位到该 table 索引位置，如果是首结点符合就返回；
　　2.如果遇到扩容时，会调用标记正在扩容结点 ForwardingNode.find()方法，查找该结点，匹配就返回；
　　3.以上都不符合的话，就往下遍历结点，匹配就返回，否则最后就返回 null。
21.ConcurrentHashMap 的并发度是什么？
　　程序运行时能够同时更新ConccurentHashMap且不产生锁竞争的最大线程数。默认为16，且可以在构造函数中设置。
   当用户设置并发度时，ConcurrentHashMap 会使用大于等于该值的最小2幂指数作为实际并发度（假如用户设置并发度为17，实际并发度则为32）
```
### 6.Java7/8中的HashMap和ConcurrentHashMap全解析【2+】
[Java7/8中的HashMap和ConcurrentHashMap全解析](https://mp.weixin.qq.com/s?__biz=MzA4OTk2MjU1MQ==&mid=2650552196&idx=1&sn=c2c10f6226950d12eb86e0f7d375bc8d&chksm=881a76dcbf6dffca738314dceea6e710e02f54250371e9ca813b2b7ce196c212073693957a36&mpshare=1&scene=23&srcid=&sharer_sharetime=1578061630556&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
>> Java7 HashMap -> Java7 ConcurrentHashMap -> Java8 HashMap -> Java8 ConcurrentHashMap
```markdown
1.- Java7 HashMap
    capacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。
    loadFactor：负载因子，默认为 0.75。
    threshold：扩容的阈值，等于capacity * loadFactor
    JDK1.7中，HashMap采用位桶+链表的实现，即使用链表来处理冲突，同一hash值的链表都存储在一个数组中。
2.- Java7 ConcurrentHashMap
    ConcurrentHashMap和HashMap思路是差不多的，但是因为它支持并发操作，所以要复杂一些。
    整个ConcurrentHashMap由一个个Segment数组和HashEntry数组组成，Segment代表”部分“或”一段“的意思，所以很多地方都会将其描述为分段锁。
    Segment通过继承ReentrantLock来进行加锁，所以每次需要加锁的操作锁住的是一个segment，是一种可重入锁，扮演锁的角色，HashEntry用于存储键值对数据。
    这样只要保证每个Segment是线程安全的，也就实现了全局的线程安全。当一个线程占用锁访问其中一个数据时，其他段的数据也能被其他线程访问。
3.- Java8 HashMap
    Java8对HashMap进行了一些修改，最大的不同就是利用了红黑树，所以其由 数组+链表+红黑树 组成。
    在Java8中，当链表中的元素达到了8个时(寻址时间复杂度为O(N))，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为O(logN)。
    resize()方法用于初始化数组或数组扩容，每次扩容后，容量为原来的2倍，并进行数据迁移。
4.- Java8 ConcurrentHashMap
    [深入了解ConcurrentHashMap](https://www.cnblogs.com/detectiveHLH/p/13029635.html)
    ConcurrentHashMap取消了Segment分段锁，采用CAS和synchronized来保证并发安全。synchronized只锁住当前链表或红黑树二叉树的首节点，
    这样只要hash不冲突，就不会产生并发，效率也提升了N倍。
```
### 7.掌握HashMap和ConcurrentHashMap
[透过面试题掌握HashMap和ConcurrentHashMap](https://www.cnblogs.com/notfound9/p/12893238.html)
```markdown
1.HashMap添加一个键值对的过程是怎么样的？
    1.初始化table;2.计算hash值;3.插入或更新节点;4.扩容。
2.ConcurrentHashMap添加一个键值对的过程是怎么样的？
    1.判断null值;2.计算hash;3.进入for循环，插入或更新元素;4.判断是否需要扩容。
3.HashMap与HashTable，ConcurrentHashMap的区别是什么？
    主要从底层数据结构，线程安全，执行效率，是否允许Null值，初始容量及扩容，hash值计算来进行分析。
    1.底层数据结构
        HashMap=数组+链表+红黑树
        Hashtable=数组+链表
        ConcurrentHashMap=数组+链表+红黑树
    2.线程安全
        HashMap非线程安全
        HashTable线程安全
        ConcurrentHashMap线程安全
    3.执行效率
        因为HashMap是非线程安全的，执行效率会高一些。
        其次是ConcurrentHashMap，因为HashTable在进行修改和访问时是对整个HashTable加synchronized锁，所以效率最低。
    4.是否允许null值出现
        HashMap的key和null都可以为null，如果key为null，那么计算的hash值会是0，最终计算得到的数组下标也会是0，
        所以key为null的键值对会存储在数组中的首元素的链表中。value为null的键值对也能正常插入，跟普通键值对插入过程一致。
        HashTable的键和值都不能为null，如果将HashTable的一个键值对的key设置为null，因为null值没法调用hashCode()方法获取哈希值，
        所以会抛出空指针异常。同样value为null时，在put方法中会进行判断，然后抛出空指针异常。
        ConcurrentHashMap的键和值都不能为null,在putVal方法中会进行判断，为null会抛出空指针异常。
    5.初始容量及扩容
        如果不指定初始容量，HashMap和ConcurrentHashMap默认会是16，HashTable的容量默认会是11。
        如果制定了初始容量，HashMap和ConcurrentHashMap的容量会是比初始容量稍微大一些的2的幂次方大小，HashTable会使用初始容量。
        扩容时，HashMap和ConcurrentHashMap扩容时会是原来长度的两倍，HashTable则是2倍加上1。
    6.hash值计算
        HashTable会扩容为2n+1，HashTable之所以容量取11，及扩容时是是2n+1，是为了保证 HashTable的长度是一个素数，因为数组的下标
        是用key的hashCode与数组的长度取模进行计算得到的，而当数组的长度是素数时，可以保证计算得到的数组下标分布得更加均匀。
4.HashMap扩容后是否需要rehash？
    在JDK1.8以后，不需要rehash，因为键值对的Hash值主要是根据key的hashCode()的高16位与低16位进行异或计算后得到，
    根据hash%length，计算得到数组的下标index，因为length是2的整数次幂，当扩容后length变为原来的两倍时，hash%(2*length)的计算结果
    结果差别在于第length位的值是1还是0，如果是0，那么在新数组中的index与旧数组的一直，如果是1，在新数组中的index会是旧数组中的数组中的index+length。
5.HashMap扩容是怎样扩容的，为什么都是2的N次幂的大小？
    在没有指定初始长度的情况下，HashMap数组的默认长度为16，在添加一个新的键值对时，会调用putVal()方法，在方法中，
    成功添加一个新的键值对以后，会判断当前的元素个数是否超过阀值(数组长度*负载因子0.75)，如果超过那么调用resize方法进行扩容。
    具体的扩容步骤如下：1.计算扩容后的长度；2.初始化新数组；3.迁移元素。
6.ConcurrentHashMap是怎么记录元素个数size的？
    HashMap默认是非线程安全的，可以认为每次只有一个线程来执行操作，所以hashMap就使用一个很简单的int类型的size变量来记录HashMap键值对数量就行。
7.为什么ConcurrentHashMap，HashTable不支持key，value为null?
    因为HashMap是非线程安全的，默认单线程环境中使用，如果get(key)为null，可以通过containsKey(key)方法来判断这个key的value为null，还是不存在这个key，
    而ConcurrentHashMap，HashTable是线程安全的，在多线程操作时，因为get(key)和containsKey(key)两个操作和在一起不是一个原子性操作，
    可能在执行中间，有其他线程修改了数据，所以无法区分value为null还是不存在key。
    至于ConcurrentHashMap，HashTable的key不能为null，主要是设计者的设计意图。
8.HashSet和HashMap的区别？
    HashMap主要是用于存储非重复键值对，HashSet存储非重复的对象。虽然HashMap是继承于AbstractMap，实现了Map接口，HashSet继承于AbstractSet，实现了Set接口。
    但是由于它们都有去重的需求，所以HashSet主要实现都是基于HashMap的（如果需要复用一个类，我们可以使用继承模式，也可以使用组合模式。
9.HashMap遍历时删除元素的有哪些实现方法？
    第1种方法 - for-each遍历HashMap.entrySet，使用HashMap.remove()删除(结果：抛出异常)。
    第2种方法-for-each遍历HashMap.keySet，使用HashMap.remove()删除(结果：抛出异常)。
    第3种方法-使用HashMap.entrySet().iterator()遍历删除(结果：正确删除)。
```
### 8.ConcurrentHashMap如何实现线程同步
```markdown
hashmap的线程安全版，引入segment，每一个segment都是线程安全的，相当于一个hashtable，因此ConcurrentHashMap也不允许出现 null。
这样就把整个类锁变成了局部锁，用哪一个segment就给哪一个segment加锁。减少竞争，提高效率。
对于 jdk1.8 的改进：
     取消的 segment，转而采用数组元素作为锁。把锁的粒度从多个 node 变成一个 node，进一步减少锁竞争
     链表大于 8 的时候转化为红黑树
实现线程同步：元素 Node，字段修饰为 final 和 volatile，采用乐观锁CAS，和分而治之的思想
     put 操作和初始化操作：
         volatile字段，标识位，表示当前是否有线程在初始化，volatile 字段保证了所有线程的可见。
         CAS机制，保证只有一个线程能够初始化
     size()/判断大小
         首先通过 CAS 机制，如果没有线程竞争，直接递增 count，
         失败就初始化桶，每一个桶并发的记录（同样是CAS机制，最大程度利用并发），如果桶计数频繁失败就扩容桶。
```
### 1.怎么确保一个集合不能被修改？
```markdown
方式一：final：
    final 修饰的类不能被继承，
    final 修饰的方法不能被重写，
    final 修饰的变量不能修改
   这里需要特别注意，变量是基本类型的时候，值不可修改，变量是对象的时候，引用不可修改。
   集合的值是可以不断添加，但是当引用改变的时候就会报错，所以使用final只能让集合的引用不可修改，而值还是可以修改和添加。
方式二：使用Collections.unmodifiableCollection(Collection c)方法来创建一个只读集合，
    这样改变集合的任何操作都会抛出Java.lang.UnsupportedOperationException异常。
```
### 3.[Java集合排序策略接口Comparator](https://www.cnblogs.com/felordcn/p/12921857.html)
```markdown
List<People> peoples = new ArrayList<>();
  // 中间省略
  // 按照年龄从小到大排序
peoples.sort(Comparator.comparing(People::getAge));
Comparator是一个函数式接口。它经常用于没有天然排序的集合进行排序，如 Collections.sort 或 Arrays.sort。
或者对于某些有序数据结构的排序规则进行声明，如TreeSet 、TreeMap。也就是该接口主要用来进行集合排序。
```
#### 3.Java容器中的设计模式
[设计模式 - 迭代器模式详解及其在ArrayList中的应用](https://www.cnblogs.com/songjilong/p/12807345.html)
```markdown
迭代器模式：Collection继承了Iterable接口，iterator()方法能够产生一个Iterator对象，通过这个对象就可以迭代遍历Collection中的元素。
            从 JDK1.5之后可以使用foreach方法来遍历实现了Iterable接口的聚合对象。
适配器模式：java.util.Arrays#asList()可以把数组类型转换为List类型。
            应该注意的是asList()的参数为泛型的变长参数，不能使用基本类型数组作为参数，只能使用相应的包装类型数组。
```
#### [面试：在面试中关于List（ArrayList、LinkedList）集合会怎么问呢](https://www.cnblogs.com/Ccwwlx/p/13124514.html)
>> ArrayList(1.8):是由动态再分配的Object[]数组作为底层结构，可设置null值，是非线程安全的。
    默认容量为10,扩容操作为当前容量*1.5倍。
>> LinkedList是一个继承于AbstractSequentialList的双向链表。它也可以被当做堆栈、队列或双端队列进行使用，而且LinkedList也为非线程安全，
jdk1.6使用的是一个带有header节头结点的双向循环链表，头结点不存储实际数据，在1.6之后，就变更使用两个节点first、last指向首尾节点。   
```markdown
区别：
    ArrayList是实现了基于动态数组的数据结构，LinkedList是基于链表结构。
    对于随机访问的get和set方法查询元素，ArrayList要优于LinkedList，因为LinkedList循环链表寻找元素。
    对于新增和删除操作add和remove，LinkedList比较高效，因为ArrayList要移动数据。
优缺点：
    对ArrayList和LinkedList而言，在末尾增加一个元素所花的开销都是固定的。对ArrayList而言，主要是在内部数组中增加一项，指向所添加的元素，
        偶尔可能会导致对数组重新进行分配；而对LinkedList而言，这个开销是 统一的，分配一个内部Entry对象。
    在ArrayList集合中添加或者删除一个元素时，当前的列表移动元素后面所有的元素都会被移动。而LinkedList集合中添加或者删除一个元素的开销是固定的。
    LinkedList集合不支持 高效的随机随机访问（RandomAccess），因为可能产生二次项的行为。
    ArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间
应用场景:
ArrayList使用在查询比较多，但是插入和删除比较少的情况，而LinkedList用在查询比较少而插入删除比较多的情况
```
#### [数据结构:用实例分析ArrayList与LinkedList的读写性能](https://www.cnblogs.com/zhuhuix/p/13042761.html)
```markdown
List使用首选ArrayList。对于个别插入删除非常多的可以使用LinkedList。
LinkedList，遍历建议使用Iterator迭代器，尤其是数据量较大时LinkedList避免使用get遍历。
```
### 4.modCount属性的作用？
```markdown
modCount属性代表为结构性修改（改变list的size大小、以其他方式改变他导致正在进行迭代时出现错误的结果）的次数，
该属性被Iterator以及ListIterator的实现类所使用，且很多非线程安全使用modCount属性。初始化迭代器时会给这个modCount赋值，如果在遍历的过程中，
一旦发现这个对象的modCount和迭代器存储的modCount不一样，Iterator或者ListIterator 将抛出ConcurrentModificationException异常，
这是jdk在面对迭代遍历的时候为了避免不确定性而采取的fail-fast（快速失败）原则：
在线程不安全的集合中，如果使用迭代器的过程中，发现集合被修改，会抛出ConcurrentModificationExceptions错误，这就是fail-fast机制。
对集合进行结构性修改时，modCount都会增加，在初始化迭代器时，modCount的值会赋给expectedModCount，在迭代的过程中，
只要modCount改变了，int expectedModCount=modCount等式就不成立了，迭代器检测到这一点，就会抛出错误：urrentModificationExceptions。
```
### 未阅读
[随笔分类 - Java提高篇](https://www.cnblogs.com/mfrank/category/1118474.html)

[Java集合框架——大量数据处理操作练习题](https://blog.csdn.net/ZQ_313/article/details/84797467)

[当前标签：集合源码](https://www.cnblogs.com/tong-yuan/tag/%E9%9B%86%E5%90%88/default.html?page=2)

[[面试必问之ArrayList](https://www.cnblogs.com/fsmly/p/11283921.html)]

[LinkedList集合解析及手写集合](https://www.cnblogs.com/hang-on/p/11469263.html)

[JAVA面试题 手写ArrayList的实现，在笔试中过关斩将?](https://www.cnblogs.com/marsitman/p/11204338.html)

[List集合根据存储对象的属性字段排序实现](https://blog.csdn.net/u013821825/article/details/61202287)

[HashMap常见面试题整理](https://www.cnblogs.com/zengcongcong/p/11295349.html)

[深入理解HashMap](https://www.cnblogs.com/fsmly/p/11235484.html)

[红黑树这个数据结构，让你又爱又恨？看了这篇，妥妥的征服它](https://www.cnblogs.com/wskwbog/p/11236136.html)

[[Java集合HashSet的原理及常用方法](https://www.cnblogs.com/LiaHon/p/11257805.html)]

[[TreeMap 还能排序？分析下源码就明白了](https://www.cnblogs.com/wskwbog/p/11245010.html)]

[[这 3 个 Set集合的实现有点简单，那来做个总结吧](https://www.cnblogs.com/wskwbog/p/11260056.html)]

[[HashMap、HashTable、ConcurrentHashMap](https://www.cnblogs.com/wudidamowang666/p/11286279.html)]

[[Java集合系列(四)：HashMap、Hashtable、LinkedHashMap、TreeMap的使用方法及区别](https://www.cnblogs.com/zwwhnly/p/11304627.html)]

[刨死你系列——HashMap(jdk1.8)](https://www.cnblogs.com/Young111/p/11471049.html)

[[HashMap 实现及原理](https://www.cnblogs.com/jay-wu/p/10773976.html)]

[[jdk1.8 HashMap底层数据结构：深入解析为什么jdk1.8 HashMap的容量一定要是2的n次幂](https://www.cnblogs.com/laipimei/p/11316140.html)]

[[Array List和Linked List实现分析](https://www.cnblogs.com/fenjyang/p/11480944.html)]

[[Java 迭代接口：Iterator、ListIterator 和 Spliterator](https://www.cnblogs.com/liululee/p/11416038.html)]

[Comparable接口的实现和使用](https://www.cnblogs.com/wl-centrinc/p/11872758.html)
[Java集合的Stack、Queue、Map的遍历](https://blog.csdn.net/m0_37204491/article/details/70208831)
### 4.Java集合容器博客
#### [1.口气带你踩完五个 List 的大坑，真的是处处坑啊！](https://www.cnblogs.com/goodAndyxublog/p/12758755.html)
```markdown
1.数组转List:Arrays.toList(arrays)：
        不支持增删元素，会抛出UnsupportedOperationException
        共享原始数组，修改原始数组，影响新集合；修改新集合，影响原始数组。
        返回结果为Arrays一个内部类，修复List<String> list = new ArrayList<>(Arrays.asList(arrays));
2.List.subList()：
        生成新集合也会与原始 List 互相影响。SubList持有原始List引用，导致原有List无法被释放
        ArrayList的subList结果不可强转成ArrayList。subList返回的是ArrayList的内部类SubList，并不是ArrayList而是
        ArrayList的一个视图，对于SubList子列表的所有操作最终会反映到原列表上。
3.foreach删除元素：
        foreach这种迭代方式实际就是Iterator迭代器实现方式 所以ArrayList可能报异常
        CopyOnWriteList写操作发生在快照上，不会发生异常。
        修复使用Iterator#remove删除元素，JDK1.8List#removeIf
4.不可变集合：
        不可变集合只能被读取，不能做任何修改，包括增加，删除，修改，从而保护不可变集合的安全。
        不可变集合仅仅是原集合的视图，原集合任何改动都会影响不可变集合。
        使用 JDK9 List#of 方法。使用 Guava immutable list两种方式防止上。
5.使用工具类Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的add/remove/clear方法会抛出
        UnsupportedOperationException异常。asList的返回对象是一个Arrays内部类，并没有实现集合的修改方法。
```
####[2.Map集合怎么也有这么多坑？一不小心又踩了好几个！](https://www.cnblogs.com/goodAndyxublog/p/12840460.html)
```markdown
1.不是所有的Map都能包含null
    HashMap只允许一个key为null,value允许为null;
    ConcurrentHashMap不允许key和value为null;
![](https://img2020.cnblogs.com/other/1419561/202005/1419561-20200507074454124-572637654.jpg) 
2.自定义对象为HashMap的key
    对象的相同属性值重复插入，不会被替代，会插入新的一对键值。
    所以如果需要使用自定义对象做为Map集合的key，那么一定记得重写hashCode与equals方法。
    使用lombok的EqualsAndHashCode自动重写hashCode与equals方法：
        当Map中置入自定义对象后，接着修改了商品金额。然后当我们想根据同一个对象取出Map中存的值时，却发现取不出来了。
        上面的问题主要是因为get方法是根据对象的hashcode计算产生的hash值取定位内部存储位置。
        当我们修改了对象属性后，导致对象hashcode产生的了变化，从而导致get方法无法获取到值。
3.错用ConcurrentHashMap导致线程不安全
    深入分析这个问题原因，实际上是因为第一步与第二步是一个组合逻辑，不是一个原子操作。
    ConcurrentHashMap只能保证这两步单的操作是个原子操作，线程安全。但是并不能保证两个组合逻辑线程安全，
    很有可能A线程刚通过get方法取到值，还未来得及加1，线程发生了切换，B线程也进来取到同样的值。
4.List集合这些坑，Map中也有
    Map 接口除了支持增删改查功能以外，还有三个特有的方法，能返回所有 key，返回所有的 value，返回所有 kv 键值对。
    // 返回 key 的 set 视图
    Set<K> keySet()；
    // 返回所有 value   Collection 视图
    Collection<V> values();
    // 返回 key-value 的 set 视图
    Set<Map.Entry<K, V>> entrySet();
    这三个方法创建返回新集合，底层其实都依赖的原有Map中数据，所以一旦Map中元素变动，就会同步影响返回的集合。
    另外这三个方法返回新集合，是不支持的新增以及修改操作的，但是却支持clear、remove 等操作。
    所以如果需要对外返回Map这三个方法产生的集合，建议再来个套娃。new ArrayList<>(map.values());
    最后再简单提一下，使用foreach方式遍历新增/删除Map中元素，也将会和List集合一样，抛出ConcurrentModificationException。
```
#### [3.还在用迭代器处理集合吗？试试Stream，真香](https://www.cnblogs.com/keatsCoder/p/12846233.html)
```markdown

```
#### [4.瞬间教你学会使用java中list的retainAll方法](https://www.cnblogs.com/jichi/p/12892150.html)
```markdown
当我们有两个list集合的时候，我们可以使用retainAll方法求得两个list集合的子集。
```
### 
[集合HashMap、HashTable，ConcourrentHashMap连环斩](https://www.cnblogs.com/zhuoqingsen/p/HashMap.html)
#### 红黑树和平衡二叉树的区别？为什么用红黑树不用其他的树？