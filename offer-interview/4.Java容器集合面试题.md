# Java容器集合总结及面试题

[TOC]

## Java容器集合
### 1.Java容器集合简介【10+】
[java集合详解](https://www.cnblogs.com/yanzezhong/p/12808089.html)
```markdown
数组 - > 链表 ->类集  ：类集就是Java数据结构的实现，类集就是动态对象数组   源码
    Collection接口  继承了Iterable接口，不提供该接口的具体实现
    添加方法：add(E e) / addAll(Collection<? extends E> var1)
    删除方法：remove(Object var1) / removeAll(Collection<?> var1)
    查找方法：contains(Object var1) / containsAll(Collection<?> var1);
    查询集合自身信息：size() / isEmpty()
        List接口（存储有序，可重复集合，对象按插入顺序排列，通过索引访问指定位置的元素）
            AbstractList:
                AbstractSequentialList:抽象类继承了AbstractList，在原基础上限制了访问元素的顺序只能够按照顺序访问，而不支持随机访问。
            ArrayList:基于动态数组实现，支持随机访问，访问元素的效率较高。线程不安全。容量为10。扩容为1.5倍。
            LinkedList:基于双向链表(JDK1.6以前为循环链表，JDK1.7取消了循环)实现，增删快、查询慢。线程不安全。
            Vector:和ArrayList类似，基于动态数组实现，是线程安全的(synchronized锁)，效率低，过时。
                在线程安全的情况下，不需要选用Vector，而是ArrayList；在并发环境下使用**CopyOnWriteArrayList**，Vector完全被弃用了。
                Stack：继承了Vector类。后入先出（LIFO）型的集合容器。
                    提供了栈顶的压入元素操作（push）和弹出元素操作（pop），以及查看栈顶元素的方法（peek）等等
                    使用Deque接口，及实现ArrayDeque替代。
        Set接口（存储无序，不可重复集合，对象排列顺序不一，Set至多只能存储一个NULL值元素）
            AbstractSet抽象类（重写所有set相同的hashCode()和equals()方法）
                HashSet:基于HashMap实现，采用数组+链表+红黑树实现，线程不安全。查找的时间复杂度为 O(1)，TreeSet则为O(logN)。
                    基于哈希表实现，支持快速查找，但不支持有序性操作。
                    并且失去了元素的插入顺序信息，也就是说使用Iterator遍历HashSet得到的结果是不确定的。
                    LinkedHashSet:继承了HashSet，具有HashSet的查找效率，且内部使用双向链表维护元素的插入顺序。线程不安全。
            SortedSet接口（有序）
                TreeSet:基于数组+红黑树实现，支持有序性操作，线程不安全。
                TreeSet默认按照自然排序，如果需要定制排序，需要传入Comparator。
        Queue接口（队列容器，其特性与List相同，但只能从队头和队尾操作元素）
            LinkedList:可以用它来实现双向队列。
            PriorityQueue:基于堆结构实现，可以用它来实现优先队列，堆是采用数组实现。
            Deque:双端队列。提供了针对队列的头结点和尾结点操作的方法，而插入、删除方法同样也提供了两套不同的失败策略。
                ArrayDeque:使用数组实现的双端队列，是无界的双端队列，最小的容量是8（JDK1.8）。在JDK11看到它默认容量是16。
            Queue中提供了两套增加、删除元素的API，当插入或删除元素失败时，会有两种不同的失败处理策略。
                方法及失败策略	插入方法	 删除方法	  查找方法
                抛出异常	        add()	 remove()	  get()
                返回失败默认值	offer()	 poll()	      peek()
            AbstractQueue抽象类
    Map接口(<key,value>组成的集合，由key映射到唯一的value，所以Map不能包含重复的key，每个键至多映射一个值。)
        Map定位元素的时间复杂度优化到O(1)
        AbsractMap：（定义了普通的Map集合具有的通用行为）
            HashMap：（数组+链表+红黑树，非线程安全，JDK1.8之前HashMap由数组+链表组成的）
                是一个最通用的利用哈希表存储元素的集合，将元素放入HashMap时，将key的哈希值转换为数组的索引下标确定存放位置，
                    查找时，根据key的哈希地址转换成数组的索引下标确定查找位置。
                发送哈希冲突时（“拉链法”解决冲突），HashMap 的解决方法是将相同映射地址的元素连成一条链表，
                    当链表长度超过8时，将链表转换为红黑树，链表长度低于6，就把红黑树转回链表，以减少搜索时间。
                Poperties
            HashTable：（存储结构是数组+链表，线程安全(synchronized锁)），（默认长度为11，负载因子为0.75F，扩容为原长度2倍）
                意味着同一时刻多个线程可以同时写入HashTable并且不会导致数据不一致。
                可以使用ConcurrentHashMap来支持线程安全，并且ConcurrentHashMap的效率会更高，因为ConcurrentHashMap引入了分段锁。 
            LinkedHashMap：（继承HashMap实现Map接口，非线程安全）
                使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。
                LinkedHashMap可实现LRU缓存淘汰策略，其原理是通过设置accessOrder为true并重写removeEldestEntry方法定义淘汰元素时需满足的条件
        SortedMap接口（定义了该类Map具有排序行为）
            TreeMap：基于数组+红黑树实现，非线程安全。
                每一个键值对<key, value>都是一个结点，默认情况下按照key自然排序，另一种是可以通过传入定制的Comparator进行自定义规则排序。          
                自然排序：要求key必须实现Comparable接口。由于Integer类实现了Comparable接口，按照自然排序规则是按照key从小到大排序。
                定制排序：在初始化TreeMap时传入新的Comparator，不要求key实现Comparable接口。
        WeakHashMap：（数组+链表实现，在WeakHashMap内部维护了一个引用队列queue，key随时会被回收掉，所以不能确保某次访问元素一定存在）
            基于普通的Map实现的，而里面Entry中的键在每一次的垃圾回收都会被清除掉，
            WeakHashMap通常作为缓存使用，所以非常适合用于短暂访问、仅访问一次的元素，缓存在WeakHashMap中，并尽早地把它回收掉。
    集合输出 Iterator,ListIterator(双向集合输出),Enumeration,foreach,Enumeration只有在Vector接口中使用
    Map遍历的两种方式
         keyset和entryset，前者是获得key的集合，后者是获得key-value的集合，返回的都是set视图，利用set有迭代器iterator，通过iterator.next来遍历。
         推荐使用entrySet()方法，效率较高。对于keySet其实是遍历了2次，一次是转为iterator，一次就是从HashMap中取出key所对于的value。
            而entryset只是遍历了第一次，它把key和value都放到了entry中，所以快了。    
```
### 2.Iterator,Iterable和ListIterator的区别是什么？【5+】
[[Java迭代接口：Iterator、ListIterator和Spliterator](https://www.cnblogs.com/liululee/p/11416038.html)]
[Java集合的Stack、Queue、Map的遍历](https://blog.csdn.net/m0_37204491/article/details/70208831)
```markdown
ListIterator实现了Iterator接⼝，并包含其他的功能，⽐如：增加元素，替换元素，获取前⼀个和后⼀个元素的索引等等。
Iterator可⽤来遍历，移除Set和List集合，但是ListIterator只能⽤来遍历List。
Iterator对集合只能是单向遍历，ListIterator遍历List集合时可以从任意索引下标开始遍历，而且支持双向遍历。
Iterable接口实现了Iterator接口，实现了Iterable接口的集合依旧可以使用迭代器遍历和操作集合中的对象。
    JDK1.8中，Iterable提供了一个新的方法forEach()，能够使用增强for循环遍历对象。（本质上还是使用Iterator去遍历）
HashMap迭代
    Iterator<Map.Entry<Integer, String>> iterator = map.entrySet().iterator();
    while (iterator.hasNext()) {
      Map.Entry<Integer, String> entry = iterator.next();
      System.out.println(entry.getKey() + entry.getValue());
    }
```
#### 1.Iterator()
```markdown
Iterator 接口用于迭代集合中的元素（List，Set或Map）。它用于逐个检索元素，并在需要时针对每个元素执行操作。
下面是用于遍历集合与执行操作的方法：
    .hasNext()：如果还没有到达集合的末尾，则返回true，否则返回false
    .next()：返回集合中的下一个元素
    .remove()：从集合中移除迭代器返回的最后一个元素
    .forEachRemaining()：按顺序为集合中剩下的每个元素执行给定的操作
List<String> avengers = new ArrayList<>();
// Now lets add some Avengers to the list
avengers.add("Ant-Man");
avengers.add("Black Widow");
avengers.add("Captain America");
avengers.add("Doctor Strange");
System.out.println("Simple loop example:\n");
for (int i = 0; i < avengers.size(); i++) {
    System.out.println(avengers.get(i));
}
System.out.println("\nIterator Example:\n");
Iterator<String> avengersIterator = avengers.iterator();
// And now we use .hasNext() and .next() to go through it
while (avengersIterator.hasNext()) {
    System.out.println(avengersIterator.next());
}
System.out.println("Simple loop example:\n");
for (int i = 0; i < avengers.size(); i++) {
    if (avengers.get(i).equals("Doctor Strange")) {
        avengers.remove(i);
    }
    System.out.println(avengers.get(i));//Exception in thread "main" java.lang.IndexOutOfBoundsException: Index: 3, Size: 3
}
System.out.println("Simple loop example:\n");
for (String avenger : avengers) {
    if (avenger.equals("Doctor Strange")) {
        avengers.remove(avenger);
    }
    System.out.println(avenger);//Exception in thread "main" java.util.ConcurrentModificationException
}
```
#### 2.ListIterator()
```markdown
ListIterator继承自Iterator接口。它只在List上进行使用，可以双向迭代，这意味着你可以从前到后或从后到前进行迭代。
    它也没有current元素，因为游标总是放在List的两个元素之间，所以我们用.previous()或.next()来访问元素。
可能会用到的方法：
    .add(E e)：向 List中添加元素。
    .remove()：从 List中删除 .next()或.previous()返回的最后一个元素。
    .set(E e)：使用指定元素来覆盖 List .next()或 .previous()返回的最后一个元素。
    .hasNext()：如果还没有到达List的末尾，则返回true，否则返回false。
    .next()：返回 List 中的下一个元素。
    .nextIndex()：返回下一元素的下标。
    .hasPrevious()：如果还没有到达List的开头，则返回true，否则返回false。
    .previous()：返回List的上一个元素。
    .previousIndex()：返回上一元素的下标。
```
#### 3.Spliterator()
```markdown
Spliterator接口在功能上与Iterator相同。你可能永远不需要直接使用Spliterator，但让我们继续讨论一些用例。
```
#### 4.Iterable()
### 2.[不可错过的java面试博客之java集合篇](https://www.cnblogs.com/jichi/p/12834238.html)
#### 2.1 List【5+】
```markdown
1.List是无序的Collection，List一共三个实现类：分别是ArrayList、Vector和LinkedList
    1.1：ArrayList通过**数组**实现的，允许对元素进行快速随机访问。缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，
        就要将已经有数组的数据复制到新的存储空间中。当从中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。
        适合随机查找和遍历，不适合插入和删除。排列有序，可重复，容量不够的时候，当前容量*1.5倍。(默认容量为10)
    1.2：Vector通过**数组**实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，
        但实现同步需要很高的花费(synchronized锁)，因此，访问它比访问ArrayList慢。(默认容量为10)默认的*2倍容量。
    1.3：LinkedList是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。还提供了List接口中没有定义的方法，
        专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。**底层使用双向循环链表数据结构**。线程不安全。
        将LinkedList替换成ConcurrentLinkedQueue实现线程安全。
```
#### 2.2 Set
```markdown
1.Set是存储有序(存入和取出的顺序不一定相同)元素，值不能重复。
    1.1:HashSet（Hash表）value值为一个相同的object对象的HashMap，值存入HashMap的key。
    1.2:TreeSet（二叉树） 有序存储 每增加一个对象都会进行排序
    1.3:LinkHashSet（HashSet+LinkedHashMap）
Set⾥的元素是不能重复的，元素重复与否是使⽤equals()⽅法进⾏判断的。
HashSet和TreeSet有什么区别？
    HashSet是由⼀个hash表来实现的，因此，它的元素是⽆序的。add()，remove()，contains()
    TreeSet是由⼀个树形的结构来实现的，它⾥⾯的元素是有序的。因此，add()，remove()，contains()⽅法的时间复杂度是O(logn)。
TreeSet和HashSet是怎么比较两个元素是否相等的？
```
#### 2.3 Map
```markdown
1.Map
    1.1：HashMap（数组+链表+红黑树）根据键的hashCode值存储数据,大多数情况下可以直接定位到它的值，具有很快的访问速度，
          但遍历顺序却是不确定的。HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全。  
          可以用Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。默认大小是16。扩容是2的指数倍。
    1.2：ConcurrentHashMap和HashMap思路是差不多的，但是因为它支持并发操作，线程安全。分段锁Segment继承ReentrantLock加锁
        ConcurrentHashMap是多个Segment数组，Segment通过继承ReentrantLock来进行加锁，所以每次需要加锁的操作锁住的是一个segment，
        这样只要保证每个Segment是线程安全的，也就实现了全局的线程安全。默认大小是16。
    1.3：HashTable（线程安全synchronized锁）是遗留类，并发性不如ConcurrentHashMap。
        HashTable不允许<键,值>有空值，HashMap允许<键,值>有空值。HashTable使用Enumeration，HashMap使用Iterator。
    1.4：TreeMap（可排序）实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序。
    1.5：LinkHashMap（记录插入顺序）是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历
         LinkedHashMap如何保证有序性:继承自HashMap，内部增加了head tail 和access order。
    1.6：HashTable中hash数组的默认大小是11，增加方式的old*2+1，HashMap中hash数组的默认大小是16，增长方式一定是2的指数倍。
        父类不同：HashMap继承了AbstractMap类，而HashTable继承了Dictionary类
```
#### 2.4 Queue
```markdown
Queue->Deque->ArrayDeque
     ->LinkedList
     ->PriorityQueue
ArrayDeque是一个可扩容的数组，LinkedList是链表结构；
ArrayDequ里不可以存null值，但是LinkedList可以；
ArrayDeque在操作头尾端的增删操作时更高效，但是LinkedList只有在当要移除中间某个元素且已经找到了这个元素后的移除才是O(1)的；
ArrayDeque在内存使用方面更高效。
所以，只要不是必须要存null值，就选择ArrayDeque吧！
在Queue中poll()和remove()有什么区别？
 poll()和remove()都将移除并且返回对头，但是在poll()在队列为空时返回null，而remove()会抛出NoSuchElementException异常。
 peek()和element()都将在不移除的情况下返回队头，但是peek()方法在队列为空时返回null，调用element()方法会抛出NoSuchElementException 异常。
 add()和offer()都是向队列中添加一个元素。但是如果想在一个满的队列中加入一个新元素，调用add()方法就会抛出一个unchecked异常，而调用offer()方法会返回false。
```
#### 2.5 hashmap的实现原理【1+】
[HashMap解析（主要JDK1.8，附带1.7出现的问题以及区别）](https://www.cnblogs.com/dmzna/p/13055232.html)
[HashMap是如何工作的](https://www.cnblogs.com/homejim/p/10029796.html)
```markdown
HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。
当我们给put()方法传递键和值时，先对键调用hashCode()方法，计算并返回的hashCode是用于找到Map数组的bucket位置来储存Node对象。
关键点在于，HashMap是在bucket中储存键对象和值对象，作为Map.Node。
以下是具体的put过程（JDK1.8版）
    1.对Key求Hash值，然后再计算下标
    2.如果没有碰撞，直接放入桶中（碰撞的意思是计算得到的Hash值相同，需要放到同一个bucket中）
    3.如果碰撞了，则调用equals() 比较value，相同则替换旧值，不同则以链表的方式链接到后面
    4.如果链表长度超过阀值(REEIFY THRESHOLD==8)，就把链表转成红黑树，链表长度低于6，就把红黑树转回链表
    5.如果桶满了(容量16*加载因子0.75)，就需要resize（扩容2倍后重排）
HashMap为什么用头插法？最近更新的更容易被访问。（JDK7）
以下是具体get过程(考虑特殊情况如果两个键的hashcode相同，你如何获取值对象？)
    当我们调用get()方法，HashMap会使用键对象的hashcode找到bucket位置，找到bucket位置之后，
    会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。
resize()方法何时进行扩容？
    HashMap使用的是懒加载，构造完HashMap对象后，只要不进行put 方法插入元素之前，HashMap并不会去初始化或者扩容table。
    当首次调用put方法时，HashMap会发现table为空然后调用resize方法进行初始化
    ，当添加完元素后，如果HashMap发现size（元素总数）大于threshold（阈值），则会调用resize方法进行扩容。
    其实主要就是两步：1.创建新的数组 2.复制元素。
```
#### 2.6 HashMap扩容机制算法【2+】
```markdown
HashMap的初始容量16，加载因子为0.75，扩容增量是原容量的1倍。如果HashMap的容量为16，一次扩容后容量为32。
    HashMap扩容是指元素个数（包括数组和链表+红黑树中）超过了16*0.75=12（容量×加载因子）之后开始扩容。
    HashMap有扩容机制，就是当达到扩容条件时会进行扩容。
    HashMap的扩容条件就是当HashMap中的元素个数（size）超过临界值（threshold）时就会自动扩容。
    在HashMap中，threshold=loadFactor*capacity。非常影响性能的。
    在Jdk1.7和Jdk1.8中，HashMap初始化这个容量的时机不同。
    jdk1.8中，在调用HashMap的构造函数定义HashMap的时候，就会进行容量的设定。
    而在Jdk1.7中，要等到第一次put操作时才进行这一操作。
```
#### 2.7 拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？
```markdown
选择红黑树是为了解决二叉查找树的缺陷，二叉查找树在特殊情况下会变成一条线性结构遍历查找会非常慢。
而红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，引入红黑树就是为了查找数据快，解决链表查询深度的问题，
红黑树属于平衡二叉树，为了保持“平衡”是需要付出代价的，但是该代价所损耗的资源要比遍历线性链表要少，
所以当长度大于8的时候，会使用红黑树，如果链表长度很短的话，根本不需要引入红黑树，引入反而会慢。
```
#### 2.8 解决hash碰撞还有那些办法？
```markdown
HashMap：如何有效减少碰撞
    扰动函数：促使元素位置分布均匀，减少碰撞概率。
    使用final对象，并且采用合适的equals()和hashCode()方法。
开放定址法
    当冲突发生时，使用某种探查技术在散列表中形成一个探查(测)序列。沿此序列逐个单元地查找，直到找到给定的地址。
    按照形成探查序列的方法不同，可将开放定址法区分为线性探查法、二次探查法、双重散列法等。
再哈希法
    Hi = RHi（key），i=1,2,...k,RHi均是不同的哈希函数，即在同义词产生地址冲突时计算另一个哈希函数地址，直到不发生冲突为止。
    这种方法不易产生聚集，但是增加了计算时间。
    缺点：增加了计算时间。
建立一个公共溢出区
    假设哈希函数的值域为[0,m-1]，则设向量HashTable[0...m-1]为基本表，每个分量存放一个记录，另设立向量OverTable[0....v]为溢出表。
    所有关键字和基本表中关键字为同义词的记录，不管他们由哈希函数得到的哈希地址是什么，一旦发生冲突，都填入溢出表。
    简单地说就是搞个新表存冲突的元素。
链地址法（拉链法）
    将所有关键字为同义词的记录存储在同一线性链表中，也就是把冲突位置的元素构造成链表。
```
#### 2.9 Comparable和Comparator的区别?【1+】
[Comparable接口的实现和使用](https://www.cnblogs.com/wl-centrinc/p/11872758.html)
```markdown
Comparable&Comparator都是用来实现集合中元素的比较、排序的，
    只是Comparable是在集合内部定义的方法实现的排序，Comparator是在集合外部实现的排序，
    comparable接口实际上是出自java.lang包它有一个compareTo(Object obj)方法用来排序
    comparator接口实际上是出自java.util包它有一个compare(Object obj1, Object obj2)方法用来排序
    所以，如想实现排序，就需要在集合外定义Comparator接口的方法或在集合内实现Comparable接口的方法。
    如果在定义类时，就实现了Comparable接口，直接在里面重写compareTo()方法，
    如果没实现，后面在业务开发中需要有比较排序的功能，就再单独写一个类实现Comparator接口，在里面重写compare()方法，
    然后这个类需要作为参数传入到工具类Collections.sort和Arrays.sort方法中。
最主要的区别就是一个一开始就实现，一个是后期实现。
Comparator位于包java.util下，而Comparable位于包java.lang下。
[Java集合排序策略接口Comparator](https://www.cnblogs.com/felordcn/p/12921857.html)
List<People> peoples = new ArrayList<>();
  // 中间省略
  // 按照年龄从小到大排序
peoples.sort(Comparator.comparing(People::getAge));
Comparator是一个函数式接口。它经常用于没有天然排序的集合进行排序，如 Collections.sort 或 Arrays.sort。
或者对于某些有序数据结构的排序规则进行声明，如TreeSet 、TreeMap。也就是该接口主要用来进行集合排序。
```
### 2.Collection和Collections有什么区别？【5+】
```markdown
 Collection是一个集合接口，提供了对集合对象进行基本操作的通用接口方法，所有集合都是它的子类，比如List和Set; 
 Collections是一个包装类，包含很多静态方法，不能被实例化，像一个工具类。提供处理集合的各种方法。比如排序方法Collections.sort(list);
```
### 3.Java容器集合源码
[当前标签：集合源码](https://www.cnblogs.com/tong-yuan/tag/%E9%9B%86%E5%90%88/default.html?page=2)
#### 3.1[ArrayList详解-源码分析](https://www.cnblogs.com/strive-for-life/p/12923608.html)
```markdown
* ArrayList是基于数组实现的集合列表
* 支持任意性的访问（可根据索引直接得到你想要的元素）
* 线程不安全
* 支持动态扩容
* 查询快，增删慢
默认默认容量大小为10，新数组的容量大小为旧数组容量的1.5倍，2^n。
详细讲解ArrayList的部分源码。
```
#### 3.2[LinkedList详解-源码分析](https://www.cnblogs.com/strive-for-life/p/12932845.html)
```markdown
* 基于双向链表实现
* 便于插入和删除，不便于遍历
* 非线程安全
* 有序（链表维护顺序）
transient关键字标识变量不会被序列化。节点都被transient修饰。
LinkedList是基于双向链表实现的，即每一个节点都保存了上一个节点和下一个节点的信息。
LinkedList根据索引获取元素效率低的原因是因为它需要一个节点一个节点的遍历，获取首节点和尾节点很快。
LinkedList实现了Deque接口，具有双向队列的性质，可以实现数据结构中的堆栈。
```
#### 3.3 HashMap
[深入理解HashMap源码](https://www.cnblogs.com/fsmly/p/11235484.html)
[HashMap：从源码分析到面试题 ](https://www.cnblogs.com/CryFace/p/13436598.html#/c/subject/p/13436598.html)
[刨死你系列——HashMap剖析(基于jdk1.8)](https://www.cnblogs.com/Young111/p/11471049.html)
### 4.ArrayList不是线程安全的 & CopyOnWriteArrayList解决【2+】
[浅析CopyOnWriteArrayList](https://www.cnblogs.com/zengcongcong/p/12754067.html)
#### 4.1代码演示ArrayList线程不安全
```java
public class ArrayListDemo{
    public static void main(String[] args){
        List<String> list = new ArrayList<>();
        List<String> vector = new Vector<>();
        List<String> synchronizedList = Collections.synchronizedList(new ArrayList<>());
        List<String> copyOnWriteArrayList = new CopyOnWriteArrayList<>();
        
        //多个线程调用list 出现java.util.ConcurrentModificationException
        for(int i = 1;i<=30;i++){
            new Thread(()->{
                list.add((UUID).randomUUID().toString().substring(0,8));
                System.out.println(list);
            },String.valueOf(i)).start();
        }
    }
    
    //1.故障现象：java.util.ConcurrentModificationException
    //2.导致原因：
    //3.解决方案：
        //1.使用Vector类，Vector的add方法被synchronized修饰,不介意使用。
        //2.使用Collections.synchronizedList(new ArrayList<>());
        //3.CopyOnWriteArrayList类,写时复制。读写分离的思想。
    //4.优化建议：
}
```
#### 4.2ArrayList线程不安全原因和解决方式。
```markdown
1.为什么ArrayList不是线程安全的？
    并发争抢修改导致，参考花名册签到情况。
    一个人正在写入，另外一个同学过来抢夺，导致数据不一致异常。并发修改异常。
    所有的java.util包中的集合类都被设计为fail-fast，由于fail-fast机制的存在，抛出了modcount修改异常的错误ConcurrentModificationException 
    (modcount是ArrayList源码中的一个变量，用来表示修改的次数，因为ArrayList不是为并发情况而设计的集合类）
2.解决办法：
    1.可以使用Vector集合，Vector集合是线程安全版的ArrayList，其方法都上了一层synchronized进行修饰，
    采取jvm内置锁来保证其并发情况下的原子性、可见性、有序性。但同时也带来了性能问题，因为synchronized一旦膨胀到重量级锁，
    存在用户态到和心态的一个转变，多线程的上下文切换会带来开销。另一个问题是Vector集合的扩容没有ArrayList的策略好。
    2.使用Collections.synchronizedList()，在更新操作中使用了同步锁。
    3.采用JUC提供的并发容器，CopyOnWriteArrayList。
3.CopyOnWriteArrayList
    和ArrayList一样，其底层数据结构也是数组，加上transient不让其被序列化，加上volatile修饰来保证多线程下的其可见性和有序性。
    CopyOnWriteArrayList在更新操作中不仅使用了可重入锁，而且还需要进行数组的复制。
    CopyOnWriteArrayList适合于多线程场景下使用，其采用读写分离的思想，读操作不上锁，写操作上锁，且写操作效率较低。
    CopyOnWriteArrayList基于fail-safe机制，每次修改都会在原先基础上复制一份，修改完毕后在进行替换。
    CopyOnWriteArrayList的add()方法采用的是ReentrantLock进行上锁。
```
#### 4.3HashSet和HashMap线程不安全
```markdown
原理同ArrayList;
HashSet解决方案:Collections.synchronizedSet()，CopyOnWriteHashSet
HashMap解决方案：Collections.sychronizedMap()，ConcurrentHashMap。
```
### 5.HashMap知识总结【必考点 重点10+】
[HashMap面试必问的数据结构相关知识总结](https://www.cnblogs.com/Young111/p/11519952.html)
[【两万字】面试官：听说你很懂集合源码，接我二十道问题！](https://www.cnblogs.com/viyoung/p/13208296.html)
#### 1：HashMap的特性和数据结构？
```markdown
特性：
    1.HashMap存储键值对实现快速存取，允许为null。key值不可重复，若key值重复则覆盖。
    2.非同步，线程不安全。
    3.底层是hash表，不保证有序(比如插入的顺序)
数据结构：
    哈希表结构（链表散列：数组+链表+红黑树）实现，结合数组和链表的优点。
        当链表长度超过8时，链表转换为红黑树。transient Node<K,V>[] table;
```
#### 2：HashMap的工作原理？【10+】
```markdown
HashMap的实现原理：
    HashMap基于Hash算法实现的，通过put(key,value)存储，get(key)获取。jdk8后采用数组+链表+红黑树的数据结构
    当传入key时，HashMap会根据key.hashCode()计算出hash值，根据hash值将value保存在bucket数组中的位置来存储Entry对象。
    当计算出的hash值相同时，出现hash冲突，HashMap的做法是使用链表和红黑树存储相同的hash值的value。
    当hash冲突的个数比较少时，使用链表否则使用红黑树。
    当获取对象时，通过get(key)获取到bucket的位置，再通过键对象的equals()方法找到正确的键值对，然后在返回值对象。
hashCode是定位的，存储位置；equals是定性的，比较两者是否相等。
（JDK1.7之前使用头插法、JDK1.8使用尾插法）（注意：当碰撞导致链表大于TREEIFY_THRESHOLD=8时，就把链表转换成红黑树）
```
#### 3.当两个对象的hashCode相同会发生什么？
```markdown
因为hashCode相同，不一定就是相等的（equals方法比较），所以两个对象所在数组的下标相同，"哈希碰撞"就此发生。
    又因为HashMap使用链表存储对象，这个Node会存储到链表中。
会产生哈希碰撞，若key值相同则替换旧值，不然链接到链表后面，链表长度超过阙值8就转为红黑树存储。
如果两个键的hashcode相同，你如何获取值对象？
    HashCode相同，通过equals比较内容获取值对象
```
#### 4.HashMap的hash函数的实现
```markdown
JDK1.8中是通过hashCode()的高16位异或低16位实现的：(h=k.hashCode())^(h>>>16)，
    主要是从速度，功效和质量来考虑的，减少系统的开销，也不会造成因为高位没有参与下标的计算，从而引起的碰撞。
其他的hash函数还有还有平方取中法，除留余数法，伪随机数法。
```
#### 5.为什么要用异或运算符？
```markdown
保证了对象的hashCode的32位值只要有一位发生改变，整个hash()返回值就会改变。尽可能的减少碰撞。
为什么不直接将key作为哈希值而是与高16位做异或运算？
    因为数组位置的确定用的是与运算，仅仅最后四位有效，设计者将key的哈希值与高16为做异或运算使得在做&运算确定数组的插入位置时，
    此时的低位实际是高位与低位的结合，增加了随机性，减少了哈希碰撞的次数。
```
#### 6.HashMap的table的容量如何确定？loadFactor是什么？该容量如何变化？这种变化会带来什么问题？【2+】
```markdown
HashMap默认初始化长度为16，并且每次自动扩展或者是手动初始化容量时，必须是2的幂。
①、table数组大小是由capacity这个参数确定的，默认是16，也可以构造时传入，最大限制是1<<30；
②、loadFactor是装载因子，主要目的是用来确认table数组是否需要动态扩展，默认值是0.75，
    比如table数组大小为16，装载因子为0.75时，threshold就是12，当table的实际大小超过12时，table就需要动态扩容；
③、扩容时，调用resize()方法，将table长度变为原来的两倍（注意是table长度，而不是threshold）
④、如果数据很大的情况下，扩展时将会带来性能的损失，在性能要求很高的地方，这种损失很可能很致命。
为什么是16？为什么必须是2的幂？如果输入值不是2的幂比如10会怎么样？
    1.为了数据的均匀分布，减少哈希碰撞。因为确定数组位置是用的位运算，若数据不是2的次幂则会增加哈希碰撞的次数和浪费数组空间。
        (PS:其实若不考虑效率，求余也可以就不用位运算了也不用长度必需为2的幂次)
    2.输入数据若不是2的幂，HashMap通过一通位移运算和或运算得到的肯定是2的幂次数，并且是离那个数最近的数字
如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？
    超过阙值会进行扩容操作，概括的讲就是扩容后的数组大小是原数组的2倍，将原来的元素重新hashing放入到新的散列表中去。
```
#### 7.HashMap中put、get方法的过程？
```markdown
put()方法实现：
    1.计算关于key的hashcode值（与Key.hashCode的高16位做异或运算）
    2.如果散列表为空时，调用resize()初始化散列表
    3.如果没有发生碰撞，直接添加元素到散列表中去
    4.如果发生了碰撞(hashCode值相同)，进行三种判断
        4.1:若key地址相同或者equals后内容相同，则替换旧值
        4.2:如果是红黑树结构，就调用树的插入方法
        4.3：链表结构，循环遍历直到链表中某个节点为空，尾插法进行插入，插入之后判断链表个数是否到达变成红黑树的阙值8；
            也可以遍历到有节点与插入元素的哈希值和内容相同，进行覆盖。
    5.如果桶满了大于阀值，则resize进行扩容
get()方法实现：对key的hashCode进行hashing，与运算计算下标获取bucket位置，如果在桶的首位上就可以找到就直接返回，
    否则在树中找或者链表中遍历找，如果有hash冲突，则利用equals方法去遍历链表查找节点。
使用HashMap时一般使用什么类型的元素作为Key？
    选择Integer，String这种不可变的类型，像对String的一切操作都是新建一个String对象，对新的对象进行拼接分割等，
    这些类已经很规范的覆写了hashCode()以及equals()方法。作为不可变类天生是线程安全的，
```
#### 8.hashMap中什么时候需要进行扩容，扩容resize()又是如何实现的？
```markdown
调用场景：
    1.初始化数组table
    2.当数组table的size达到阙值时即++size>load factor * capacity时，也是在putVal函数中
实现过程：(细讲)
    1.通过判断旧数组的容量是否大于0来判断数组是否初始化过
    否：进行初始化
    判断是否调用无参构造器，
        是:使用默认的大小和阙值
        否:使用构造函数中初始化的容量，当然这个容量是经过tableSizefor计算后的2的次幂数
            是，进行扩容，扩容成两倍(小于最大值的情况下)，之后在进行将元素重新进行与运算复制到新的散列表中
概括的讲：扩容需要重新分配一个新数组，新数组是老数组的2倍长，然后遍历整个老结构，把所有的元素挨个重新hash分配到新结构中去。
```
#### 9.拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？
```markdown
之所以选择红黑树是为了解决二叉查找树的缺陷，二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成很深的问题），
    遍历查找会非常慢。而红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，
    引入红黑树就是为了查找数据快，解决链表查询深度的问题，我们知道红黑树属于平衡二叉树，
    但是为了保持“平衡”是需要付出代价的，但是该代价所损耗的资源要比遍历线性链表要少，
    所以当长度大于8的时候，会使用红黑树，如果链表长度很短的话，根本不需要引入红黑树，引入反而会慢。
```
#### 10.说说你对红黑树的见解？
```markdown
1、每个节点非红即黑
2、根节点总是黑色的
3、如果节点是红色的，则它的子节点必须是黑色的（反之不一定）
4、每个叶子节点都是黑色的空节点（NIL节点）
5、从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）
```
#### 11.jdk8中对HashMap做了哪些改变？
```markdown
在JDK1.8中，如果链表的长度超过了8，那么链表将转换为红黑树。（桶的数量必须大于64，小于64的时候只会扩容）
发生hash碰撞时，java1.7会在链表的头部插入，而java1.8会在链表的尾部插入,在java1.8中，Entry被Node替代(换了一个马甲)。
JDK1.8以前HashMap的实现是 数组+链表，即使哈希函数取得再好，也很难达到元素百分百均匀分布。
    当HashMap中有大量的元素都存放到同一个桶中时，这个桶下有一条长长的链表，这个时候HashMap就相当于一个单链表，假如单链表有n个元素，
    遍历的时间复杂度就是O(n)，完全失去了它的优势。针对这种情况，JDK1.8中引入了 红黑树（查找时间复杂度为O(logn)）来优化这个问题。
```
#### 12.HashMap，LinkedHashMap，TreeMap有什么区别？【5+】
```markdown
HashMap参考其他问题；
LinkedHashMap保存了记录的插入顺序，在用Iterator遍历时，先取到的记录肯定是先插入的；遍历比HashMap慢；
TreeMap实现SortMap接口，能够把它保存的记录根据键排序（默认按键值升序排序，也可以指定排序的比较器）
    对Map进行插入，删除，查找一个元素时，HashMap是最好的选择，因为相对而言HashMap的插入会更快。
    如果要对一个key集合进行有序的遍历，TreeMap是更好的选择。
```
#### 13.HashMap&TreeMap&LinkedHashMap使用场景？
```markdown
一般情况下，使用最多的是HashMap。
HashMap：在Map中插入、删除和定位元素时；
TreeMap：在需要按自然顺序或自定义顺序遍历键的情况下；
LinkedHashMap：在需要输出的顺序和输入的顺序相同的情况下。
```
#### 14.HashMap和HashTable有什么区别？【5+】
```markdown
①、HashMap是线程不安全的，HashTable是线程安全的（synchronized）；
②、由于线程安全，所以HashTable的效率比不上HashMap；
③、HashMap最多只允许一条记录的键为null，允许多条记录的值为null，而HashTable不允许key-value为null；
④、HashMap默认初始化数组的大小为16，HashTable为11，前者扩容时，扩大两倍，后者扩大两倍+1；
⑤、添加key-value时，HashMap需要使用自定义的hash函数，而HashTable直接使用key的hashCode。
6.HashMap继承于AbstractMap类，hashTable继承与Dictionary类。
7.迭代器(Iterator)。HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。
    所以当迭代过程中有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException。
```
#### 15.ConcurrentHashMap与HashTable在线程同步上有什么不同？
```markdown
ConcurrentHashMap类（是Java并发包java.util.concurrent中提供的一个线程安全且高效的HashMap实现）。
　　HashTable是使用synchronized关键字加锁的原理（就是对对象加锁）；
　　而针对ConcurrentHashMap，在JDK1.7中采用 分段锁的方式；JDK1.8中直接采用了CAS（无锁算法）+synchronized。
```
#### 16.HashMap&ConcurrentHashMap的区别？
```markdown
除了加锁，原理上无太大区别。另外，HashMap的键值对允许有null，但是ConcurrentHashMap都不允许。
```
#### 17.为什么ConcurrentHashMap比HashTable效率要高？
```markdown
HashTable使用一把锁（锁住整个链表结构）处理并发问题，多个线程竞争一把锁，容易阻塞；
ConcurrentHashMap 
    JDK1.7中使用分段锁（ReentrantLock+Segment+HashEntry），相当于把一个HashMap分成多个段，每段分配一把锁，这样支持多线程访问。
        锁粒度：基于Segment，包含多个HashEntry。
    JDK1.8中使用CAS+synchronized+Node+红黑树。锁粒度：Node（首结点）（实现 Map.Entry<K,V>）。锁粒度降低了。
```
#### 18.针对ConcurrentHashMap锁机制具体分析（JDK1.7VSJDK1.8）？
```markdown
JDK1.7中，采用分段锁的机制，实现并发的更新操作，底层采用数组+链表的存储结构，包括两个核心静态内部类Segment和HashEntry。
　　　　①、Segment 继承 ReentrantLock（重入锁） 用来充当锁的角色，每个Segment对象守护每个散列映射表的若干个桶；
　　　　②、HashEntry用来封装映射表的键-值对；
　　　　③、每个桶是由若干个HashEntry对象链接起来的链表
JDK1.8中，采用Node+CAS+Synchronized来保证并发安全。取消类Segment，直接用table数组存储键值对；
当HashEntry对象组成的链表长度超过TREEIFY_THRESHOLD时，链表转换为红黑树，提升性能。底层变更为数组+链表+红黑树。
```
#### 19.ConcurrentHashMap在JDK1.8中，为什么要使用内置锁synchronized来代替重入锁ReentrantLock？
```markdown
①、粒度降低了；
②、JVM开发团队没有放弃synchronized，而且基于JVM的synchronized优化空间更大，更加自然。
③、在大量的数据操作下，对于JVM的内存压力，基于API的ReentrantLock会开销更多的内存。
```
#### 20.ConcurrentHashMap简单介绍？
```markdown
①、重要的常量：
　　private transient volatile int sizeCtl;
　　当为负数时，-1 表示正在初始化，-N 表示 N - 1 个线程正在进行扩容；
　　当为 0 时，表示 table 还没有初始化；
　　当为其他正数时，表示初始化或者下一次进行扩容的大小。
②、数据结构：
　　Node 是存储结构的基本单元，继承 HashMap 中的 Entry，用于存储数据；
　　TreeNode 继承 Node，但是数据结构换成了二叉树结构，是红黑树的存储结构，用于红黑树中存储数据；
　　TreeBin 是封装 TreeNode 的容器，提供转换红黑树的一些条件和锁的控制。
③、存储对象时（put() 方法）：
　　1.如果没有初始化，就调用 initTable() 方法来进行初始化；
　　2.如果没有 hash 冲突就直接 CAS 无锁插入；
　　3.如果需要扩容，就先进行扩容；
　　4.如果存在 hash 冲突，就加锁来保证线程安全，两种情况：一种是链表形式就直接遍历到尾端插入，一种是红黑树就按照红黑树结构插入；
　　5.如果该链表的数量大于阀值 8，就要先转换成红黑树的结构，break 再一次进入循环
　　6.如果添加成功就调用 addCount() 方法统计 size，并且检查是否需要扩容。
④、扩容方法 transfer()：默认容量为 16，扩容时，容量变为原来的两倍。
　　helpTransfer()：调用多个工作线程一起帮助进行扩容，这样的效率就会更高。
⑤、获取对象时（get()方法）：
　　1.计算 hash 值，定位到该 table 索引位置，如果是首结点符合就返回；
　　2.如果遇到扩容时，会调用标记正在扩容结点 ForwardingNode.find()方法，查找该结点，匹配就返回；
　　3.以上都不符合的话，就往下遍历结点，匹配就返回，否则最后就返回 null。
```
#### 21.ConcurrentHashMap的并发度是什么？
```markdown
程序运行时能够同时更新ConccurentHashMap且不产生锁竞争的最大线程数。默认为16，且可以在构造函数中设置。
当用户设置并发度时，ConcurrentHashMap会使用大于等于该值的最小2幂指数作为实际并发度（假如用户设置并发度为17，实际并发度则为32）
```
### 6.Java7/8中的HashMap和ConcurrentHashMap全解析【3+】
[Java7/8中的HashMap和ConcurrentHashMap全解析](https://mp.weixin.qq.com/s?__biz=MzA4OTk2MjU1MQ==&mid=2650552196&idx=1&sn=c2c10f6226950d12eb86e0f7d375bc8d&chksm=881a76dcbf6dffca738314dceea6e710e02f54250371e9ca813b2b7ce196c212073693957a36&mpshare=1&scene=23&srcid=&sharer_sharetime=1578061630556&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
>> Java7 HashMap -> Java7 ConcurrentHashMap -> Java8 HashMap -> Java8 ConcurrentHashMap
```markdown
1.- Java7 HashMap
    capacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。
    loadFactor：负载因子，默认为 0.75。
    threshold：扩容的阈值，等于capacity * loadFactor
    JDK1.7中，HashMap采用位桶+链表的实现，即使用链表来处理冲突，同一hash值的链表都存储在一个数组中。
2.- Java7 ConcurrentHashMap
    ConcurrentHashMap和HashMap思路是差不多的，但是因为它支持并发操作，所以要复杂一些。
    整个ConcurrentHashMap由一个个Segment数组和HashEntry数组组成，Segment代表”部分“或”一段“的意思，所以很多地方都会将其描述为分段锁。
    Segment通过继承ReentrantLock来进行加锁，所以每次需要加锁的操作锁住的是一个segment，是一种可重入锁，扮演锁的角色，HashEntry用于存储键值对数据。
    这样只要保证每个Segment是线程安全的，也就实现了全局的线程安全。当一个线程占用锁访问其中一个数据时，其他段的数据也能被其他线程访问。
3.- Java8 HashMap
    Java8对HashMap进行了一些修改，最大的不同就是利用了红黑树，所以其由 数组+链表+红黑树 组成。
    在Java8中，当链表中的元素达到了8个时(寻址时间复杂度为O(N))，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为O(logN)。
    resize()方法用于初始化数组或数组扩容，每次扩容后，容量为原来的2倍，并进行数据迁移。
4.- Java8 ConcurrentHashMap
    [深入了解ConcurrentHashMap](https://www.cnblogs.com/detectiveHLH/p/13029635.html)
    ConcurrentHashMap取消了Segment分段锁，采用CAS和synchronized来保证并发安全。synchronized只锁住当前链表或红黑树二叉树的首节点，
    这样只要hash不冲突，就不会产生并发，效率也提升了N倍。
```
### 7.掌握HashMap和ConcurrentHashMap
[透过面试题掌握HashMap和ConcurrentHashMap](https://www.cnblogs.com/notfound9/p/12893238.html)
```markdown
1.HashMap添加一个键值对的过程是怎么样的？
    1.初始化table;2.计算hash值;3.插入或更新节点;4.扩容。
2.ConcurrentHashMap添加一个键值对的过程是怎么样的？
    1.判断null值;2.计算hash;3.进入for循环，插入或更新元素;4.判断是否需要扩容。
3.HashMap与HashTable，ConcurrentHashMap的区别是什么？
    主要从底层数据结构，线程安全，执行效率，是否允许Null值，初始容量及扩容，hash值计算来进行分析。
    1.底层数据结构
        HashMap=数组+链表+红黑树
        Hashtable=数组+链表
        ConcurrentHashMap=数组+链表+红黑树
    2.线程安全
        HashMap非线程安全
        HashTable线程安全
        ConcurrentHashMap线程安全
    3.执行效率
        因为HashMap是非线程安全的，执行效率会高一些。
        其次是ConcurrentHashMap，因为HashTable在进行修改和访问时是对整个HashTable加synchronized锁，所以效率最低。
    4.是否允许null值出现
        HashMap的key和null都可以为null，如果key为null，那么计算的hash值会是0，最终计算得到的数组下标也会是0，
        所以key为null的键值对会存储在数组中的首元素的链表中。value为null的键值对也能正常插入，跟普通键值对插入过程一致。
        HashTable的键和值都不能为null，如果将HashTable的一个键值对的key设置为null，因为null值没法调用hashCode()方法获取哈希值，
        所以会抛出空指针异常。同样value为null时，在put方法中会进行判断，然后抛出空指针异常。
        ConcurrentHashMap的键和值都不能为null,在putVal方法中会进行判断，为null会抛出空指针异常。
    5.初始容量及扩容
        如果不指定初始容量，HashMap和ConcurrentHashMap默认会是16，HashTable的容量默认会是11。
        如果制定了初始容量，HashMap和ConcurrentHashMap的容量会是比初始容量稍微大一些的2的幂次方大小，HashTable会使用初始容量。
        扩容时，HashMap和ConcurrentHashMap扩容时会是原来长度的两倍，HashTable则是2倍加上1。
    6.hash值计算
        HashTable会扩容为2n+1，HashTable之所以容量取11，及扩容时是是2n+1，是为了保证 HashTable的长度是一个素数，因为数组的下标
        是用key的hashCode与数组的长度取模进行计算得到的，而当数组的长度是素数时，可以保证计算得到的数组下标分布得更加均匀。
4.HashMap扩容后是否需要rehash？
    在JDK1.8以后，不需要rehash，因为键值对的Hash值主要是根据key的hashCode()的高16位与低16位进行异或计算后得到，
    根据hash%length，计算得到数组的下标index，因为length是2的整数次幂，当扩容后length变为原来的两倍时，hash%(2*length)的计算结果
    结果差别在于第length位的值是1还是0，如果是0，那么在新数组中的index与旧数组的一直，如果是1，在新数组中的index会是旧数组中的数组中的index+length。
5.HashMap扩容是怎样扩容的，为什么都是2的N次幂的大小？
    在没有指定初始长度的情况下，HashMap数组的默认长度为16，在添加一个新的键值对时，会调用putVal()方法，在方法中，
    成功添加一个新的键值对以后，会判断当前的元素个数是否超过阀值(数组长度*负载因子0.75)，如果超过那么调用resize方法进行扩容。
    具体的扩容步骤如下：1.计算扩容后的长度；2.初始化新数组；3.迁移元素。
6.ConcurrentHashMap是怎么记录元素个数size的？
    HashMap默认是非线程安全的，可以认为每次只有一个线程来执行操作，所以hashMap就使用一个很简单的int类型的size变量来记录HashMap键值对数量就行。
7.为什么ConcurrentHashMap，HashTable不支持key，value为null?
    因为HashMap是非线程安全的，默认单线程环境中使用，如果get(key)为null，可以通过containsKey(key)方法来判断这个key的value为null，还是不存在这个key，
    而ConcurrentHashMap，HashTable是线程安全的，在多线程操作时，因为get(key)和containsKey(key)两个操作和在一起不是一个原子性操作，
    可能在执行中间，有其他线程修改了数据，所以无法区分value为null还是不存在key。
    至于ConcurrentHashMap，HashTable的key不能为null，主要是设计者的设计意图。
8.HashSet和HashMap的区别？
    HashMap主要是用于存储非重复键值对，HashSet存储非重复的对象。虽然HashMap是继承于AbstractMap，实现了Map接口，HashSet继承于AbstractSet，实现了Set接口。
    但是由于它们都有去重的需求，所以HashSet主要实现都是基于HashMap的（如果需要复用一个类，我们可以使用继承模式，也可以使用组合模式。
9.HashMap遍历时删除元素的有哪些实现方法？
    第1种方法 - for-each遍历HashMap.entrySet，使用HashMap.remove()删除(结果：抛出异常)。
    第2种方法-for-each遍历HashMap.keySet，使用HashMap.remove()删除(结果：抛出异常)。
    第3种方法-使用HashMap.entrySet().iterator()遍历删除(结果：正确删除)。
```
### 8.ConcurrentHashMap如何实现线程同步（保证线程安全）【3+】
```markdown
hashmap的线程安全版，引入segment，每一个segment都是线程安全的，相当于一个hashtable，因此ConcurrentHashMap也不允许出现 null。
这样就把整个类锁变成了局部锁，用哪一个segment就给哪一个segment加锁。减少竞争，提高效率。
对于jdk1.8的改进：
     取消的 segment，转而采用数组元素作为锁。把锁的粒度从多个 node 变成一个 node，进一步减少锁竞争
     链表大于 8 的时候转化为红黑树
实现线程同步：元素 Node，字段修饰为 final 和 volatile，采用乐观锁CAS，和分而治之的思想
     put 操作和初始化操作：
         volatile字段，标识位，表示当前是否有线程在初始化，volatile 字段保证了所有线程的可见。
         CAS机制，保证只有一个线程能够初始化
     size()/判断大小
         首先通过 CAS 机制，如果没有线程竞争，直接递增 count，
         失败就初始化桶，每一个桶并发的记录（同样是CAS机制，最大程度利用并发），如果桶计数频繁失败就扩容桶。
```
### 1.怎么确保一个集合不能被修改？【5+】
```markdown
方式一：final：
    final 修饰的类不能被继承，
    final 修饰的方法不能被重写，
    final 修饰的变量不能修改
   这里需要特别注意，变量是基本类型的时候，值不可修改，变量是对象的时候，引用不可修改。
   集合的值是可以不断添加，但是当引用改变的时候就会报错，所以使用final只能让集合的引用不可修改，而值还是可以修改和添加。
方式二：使用Collections.unmodifiableCollection(Collection c)方法来创建一个只读集合，
    这样改变集合的任何操作都会抛出Java.lang.UnsupportedOperationException异常。
    List<String> list = new ArrayList<>();
    list.add("x");
    Collection<String> clist = COllections.unmodfiableCOllection(list);
    clist.add("y");//运行时报错
    System.out.println(list.size());//1
```
### 2.Java容器中的设计模式
[设计模式 - 迭代器模式详解及其在ArrayList中的应用](https://www.cnblogs.com/songjilong/p/12807345.html)
```markdown
迭代器模式：Collection继承了Iterable接口，iterator()方法能够产生一个Iterator对象，通过这个对象就可以迭代遍历Collection中的元素。
            从 JDK1.5之后可以使用foreach方法来遍历实现了Iterable接口的聚合对象。
适配器模式：java.util.Arrays#asList()可以把数组类型转换为List类型。
            应该注意的是asList()的参数为泛型的变长参数，不能使用基本类型数组作为参数，只能使用相应的包装类型数组。
```
### 3.[面试：在面试中关于List（ArrayList、LinkedList）集合会怎么问呢](https://www.cnblogs.com/Ccwwlx/p/13124514.html)
>> ArrayList(1.8):是由动态再分配的Object[]数组作为底层结构，可设置null值，是非线程安全的。
    默认容量为10,扩容操作为当前容量*1.5倍。
>> LinkedList是一个继承于AbstractSequentialList的双向链表。它也可以被当做堆栈、队列或双端队列进行使用，而且LinkedList也为非线程安全，
jdk1.6使用的是一个带有header节头结点的双向循环链表，头结点不存储实际数据，在1.6之后，就变更使用两个节点first、last指向首尾节点。   
```markdown
区别：
    ArrayList是实现了基于动态数组的数据结构，LinkedList是基于链表结构。
    对于随机访问的get和set方法查询元素，ArrayList要优于LinkedList，因为LinkedList循环链表寻找元素。
    对于新增和删除操作add和remove，LinkedList比较高效，因为ArrayList要移动数据。
优缺点：
    对ArrayList和LinkedList而言，在末尾增加一个元素所花的开销都是固定的。对ArrayList而言，主要是在内部数组中增加一项，指向所添加的元素，
        偶尔可能会导致对数组重新进行分配；而对LinkedList而言，这个开销是 统一的，分配一个内部Entry对象。
    在ArrayList集合中添加或者删除一个元素时，当前的列表移动元素后面所有的元素都会被移动。而LinkedList集合中添加或者删除一个元素的开销是固定的。
    LinkedList集合不支持 高效的随机随机访问（RandomAccess），因为可能产生二次项的行为。
    ArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间
应用场景:
ArrayList使用在查询比较多，但是插入和删除比较少的情况，而LinkedList用在查询比较少而插入删除比较多的情况
[数据结构:用实例分析ArrayList与LinkedList的读写性能](https://www.cnblogs.com/zhuhuix/p/13042761.html)
1.List使用首选ArrayList。对于个别插入删除非常多的可以使用LinkedList。
2.LinkedList，遍历建议使用Iterator迭代器，尤其是数据量较大时LinkedList避免使用get遍历。
[面经手册 · 第8篇《LinkedList插入速度比ArrayList快？你确定吗？》](https://www.cnblogs.com/xiaofuge/p/13587826.html)
1.ArrayList与LinkedList都有自己的使用场景，如果你不能很好的确定，那么就使用ArrayList。
    但如果你能确定你会在集合的首位有大量的插入、删除以及获取操作，那么可以使用LinkedList，因为它都有相应的方法；
    addFirst、addLast、removeFirst、removeLast、getFirst、getLast，这些操作的时间复杂度都是O(1)，非常高效。
2.LinkedList的链表结构不一定会比ArrayList节省空间，首先它所占用的内存不是连续的，其次他还需要大量的实例化对象创造节点。
    虽然不一定节省空间，但链表结构也是非常优秀的数据结构，它能在你的程序设计中起着非常优秀的作用，
    例如可视化的链路追踪图，就是需要链表结构，并需要每个节点自旋一次，用于串联业务。
```
### 4.快速失败(fail-fast)，modCount属性，安全失败(fail-safe)？
```markdown
快速失败(fail-fast)是Java集合的一种错误检测机制。
    在使用迭代器对集合进行遍历的时候，我们在多线程下操作非安全失败(fail-safe)的集合类可能就会触发fail-fast机制，
    导致抛出ConcurrentModificationException异常。另外，在单线程下，如果在遍历过程中对集合对象的内容进行了修改的话也会触发fail-fast机制。
举个例子：多线程下，如果线程1正在对集合进行遍历，此时线程2对集合进行修改（增加、删除、修改），
    或者线程1在遍历过程中对集合进行修改，都会导致线程1抛出ConcurrentModificationException异常。
每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedModCount值，是的话就返回遍历；否则抛出异常，终止遍历。
如果我们在集合被遍历期间对其进行修改的话，就会改变modCount的值，进而导致modCount!=expectedModCount，进而抛出ConcurrentModificationException异常。

安全失败(fail-safe)：采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。
    所以，在遍历过程中对原集合所作的修改并不能被迭代器检测到，故不会抛ConcurrentModificationException异常。
    原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发ConcurrentModificationException。
    缺点：基于拷贝内容的优点是避免了ConcurrentModificationException，但同样地，迭代器并不能访问到修改后的内容，
        即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。
    场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。
    CopyOnWriteArrayList
```
### 5.同步容器所有的操作一定是线程安全的吗?
[面试官问我同步容器（如Vector）的所有操作一定是线程安全的吗？我懵了！](http://47.103.216.138/archives/3935)
```markdown
在Java中，同步容器主要包括2类：
    1、Vector、Stack、HashTable
    2、Collections类中提供的静态工厂方法创建的类
Vector这样的同步容器的所有公有方法全都是synchronized的，可以在多线程场景中放心的使用**单独**这些方法，因为这些方法本身的确是线程安全的。
    public Object deleteLast(Vector v){
        int lastIndex  = v.size()-1;
        v.remove(lastIndex);
    }
    如果多线程调用该方法的过程中，remove方法有可能抛出ArrayIndexOutOfBoundsException。
    Exception in thread "Thread-1" java.lang.ArrayIndexOutOfBoundsException: Array index out of range: 879
        at java.util.Vector.remove(Vector.java:834)
        at com.hollis.Test.deleteLast(EncodeTest.java:40)
        at com.hollis.Test$2.run(EncodeTest.java:28)
        at java.lang.Thread.run(Thread.java:748)
    因为removeLast方法，有可能被多个线程同时执行，当线程2通过index()获得索引值为10，
    在尝试通过remove()删除该索引位置的元素之前，线程1把该索引位置的值删除掉了，这时线程一在执行时便会抛出异常。    
为了避免出现类似问题，可以尝试加锁：    
    public void deleteLast() {
        synchronized (v) {
            int index = v.size() - 1;
            v.remove(index);
        }
    }
同步容器直接保证耽搁操作的线程安全性，但是无法保证复合操作的线程安全，遇到这种情况时，必须要通过主动加锁的方式来实现。
同步容易由于对其所有方法都加了锁，这就导致多个线程访问同一个容器的时候，只能进行顺序访问，即使是不同的操作，也要排队，如get和add要排队执行。这就大大的降低了容器的并发能力。
并发包中的CopyOnWriteArrayList和CopyOnWriteArraySet是Copy-On-Write的两种实现。
CopyOnWriteArrayList中add/remove等写方法是需要加锁的，而读方法是没有加锁的。
可以对CopyOnWrite容器进行并发的读，当然，这里读到的数据可能不是最新的。因为写时复制的思想是通过延时更新的策略来实现数据的最终一致性的，并非强一致性。
```
### 4.Java集合容器博客
#### [1.口气带你踩完五个 List 的大坑，真的是处处坑啊！](https://www.cnblogs.com/goodAndyxublog/p/12758755.html)
```markdown
1.数组转List:Arrays.toList(arrays)：
        不支持增删元素，会抛出UnsupportedOperationException
        共享原始数组，修改原始数组，影响新集合；修改新集合，影响原始数组。
        返回结果为Arrays一个内部类，修复List<String> list = new ArrayList<>(Arrays.asList(arrays));
2.List.subList()：
        生成新集合也会与原始 List 互相影响。SubList持有原始List引用，导致原有List无法被释放
        ArrayList的subList结果不可强转成ArrayList。subList返回的是ArrayList的内部类SubList，并不是ArrayList而是
        ArrayList的一个视图，对于SubList子列表的所有操作最终会反映到原列表上。
3.foreach删除元素：
        foreach这种迭代方式实际就是Iterator迭代器实现方式 所以ArrayList可能报异常
        CopyOnWriteList写操作发生在快照上，不会发生异常。
        修复使用Iterator#remove删除元素，JDK1.8List#removeIf
4.不可变集合：
        不可变集合只能被读取，不能做任何修改，包括增加，删除，修改，从而保护不可变集合的安全。
        不可变集合仅仅是原集合的视图，原集合任何改动都会影响不可变集合。
        使用 JDK9 List#of 方法。使用 Guava immutable list两种方式防止上。
5.使用工具类Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的add/remove/clear方法会抛出
        UnsupportedOperationException异常。asList的返回对象是一个Arrays内部类，并没有实现集合的修改方法。
```
####[2.Map集合怎么也有这么多坑？一不小心又踩了好几个！](https://www.cnblogs.com/goodAndyxublog/p/12840460.html)
![](https://img2020.cnblogs.com/other/1419561/202005/1419561-20200507074454124-572637654.jpg)
```markdown
1.不是所有的Map都能包含null
    HashMap只允许一个key为null,value允许为null;
    ConcurrentHashMap不允许key和value为null;
2.自定义对象为HashMap的key
    对象的相同属性值重复插入，不会被替代，会插入新的一对键值。
    所以如果需要使用自定义对象做为Map集合的key，那么一定记得重写hashCode与equals方法。
    使用lombok的EqualsAndHashCode自动重写hashCode与equals方法：
        当Map中置入自定义对象后，接着修改了商品金额。然后当我们想根据同一个对象取出Map中存的值时，却发现取不出来了。
        上面的问题主要是因为get方法是根据对象的hashcode计算产生的hash值取定位内部存储位置。
        当我们修改了对象属性后，导致对象hashcode产生的了变化，从而导致get方法无法获取到值。
3.错用ConcurrentHashMap导致线程不安全
    深入分析这个问题原因，实际上是因为第一步与第二步是一个组合逻辑，不是一个原子操作。
    ConcurrentHashMap只能保证这两步单的操作是个原子操作，线程安全。但是并不能保证两个组合逻辑线程安全，
    很有可能A线程刚通过get方法取到值，还未来得及加1，线程发生了切换，B线程也进来取到同样的值。
4.List集合这些坑，Map中也有
    Map 接口除了支持增删改查功能以外，还有三个特有的方法，能返回所有 key，返回所有的 value，返回所有 kv 键值对。
    // 返回 key 的 set 视图
    Set<K> keySet()；
    // 返回所有 value   Collection 视图
    Collection<V> values();
    // 返回 key-value 的 set 视图
    Set<Map.Entry<K, V>> entrySet();
    这三个方法创建返回新集合，底层其实都依赖的原有Map中数据，所以一旦Map中元素变动，就会同步影响返回的集合。
    另外这三个方法返回新集合，是不支持的新增以及修改操作的，但是却支持clear、remove 等操作。
    所以如果需要对外返回Map这三个方法产生的集合，建议再来个套娃。new ArrayList<>(map.values());
    最后再简单提一下，使用foreach方式遍历新增/删除Map中元素，也将会和List集合一样，抛出ConcurrentModificationException。
```
#### [3.还在用迭代器处理集合吗？试试Stream，真香](https://www.cnblogs.com/keatsCoder/p/12846233.html)
```markdown

```
#### [4.瞬间教你学会使用java中list的retainAll方法](https://www.cnblogs.com/jichi/p/12892150.html)
```markdown
当我们有两个list集合的时候，我们可以使用retainAll方法求得两个list集合的子集。
```
### 未阅读
[随笔分类 - Java提高篇](https://www.cnblogs.com/mfrank/category/1118474.html)
[Java集合框架——大量数据处理操作练习题](https://blog.csdn.net/ZQ_313/article/details/84797467)
[[面试必问之ArrayList](https://www.cnblogs.com/fsmly/p/11283921.html)]
[LinkedList集合解析及手写集合](https://www.cnblogs.com/hang-on/p/11469263.html)
[JAVA面试题手写ArrayList的实现，在笔试中过关斩将?](https://www.cnblogs.com/marsitman/p/11204338.html)
[List集合根据存储对象的属性字段排序实现](https://blog.csdn.net/u013821825/article/details/61202287)
[[Java集合HashSet的原理及常用方法](https://www.cnblogs.com/LiaHon/p/11257805.html)]
[[TreeMap 还能排序？分析下源码就明白了](https://www.cnblogs.com/wskwbog/p/11245010.html)
[[这3个Set集合的实现有点简单，那来做个总结吧](https://www.cnblogs.com/wskwbog/p/11260056.html)
[[HashMap、HashTable、ConcurrentHashMap](https://www.cnblogs.com/wudidamowang666/p/11286279.html)]
[[Java集合系列(四)：HashMap、Hashtable、LinkedHashMap、TreeMap的使用方法及区别](https://www.cnblogs.com/zwwhnly/p/11304627.html)]
[jdk1.8 HashMap底层数据结构：深入解析为什么jdk1.8 HashMap的容量一定要是2的n次幂](https://www.cnblogs.com/laipimei/p/11316140.html)
[ArrayList和LinkedList实现分析](https://www.cnblogs.com/fenjyang/p/11480944.html)
[集合HashMap、HashTable，ConcourrentHashMap连环斩](https://www.cnblogs.com/zhuoqingsen/p/HashMap.html)
### 红黑树和平衡二叉树的区别？为什么用红黑树不用其他的树？介绍红黑树，红黑树的特性，红黑树如何进行旋转
>>红黑树的特征
  为什么使用红黑树
  什么时候转成红黑树
  什么时候红黑树转成链表
  为什么在8的时候转红黑树
  8的意义是什么是hash冲突还是桶的个数
[30张图带你彻底理解红黑树](https://www.jianshu.com/p/e136ec79235c)
[红黑树这个数据结构，让你又爱又恨？看了这篇，妥妥的征服它](https://www.cnblogs.com/wskwbog/p/11236136.html)
[面经手册 · 第6篇《带着面试题学习红黑树操作原理，解析什么时候染色、怎么进行旋转、与2-3树有什么关联》](https://www.cnblogs.com/xiaofuge/p/13539425.html)
#### AVL树/平衡二叉树
[二叉树查找](https://www.cnblogs.com/afei-24/p/13525974.html)
[平衡查找树](https://www.cnblogs.com/afei-24/p/13563023.html)
[详细图文——AVL树/平衡二叉树](https://blog.csdn.net/qq_25343557/article/details/89110319)
```markdown
平衡二叉搜索树（Self-balancing binary search tree）又被称为AVL树（有别于AVL算法），且具有以下性质：
    它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。
添加节点：
    插入节点破坏平衡性有如下四种情况：
        - LL（右旋）：向左子树（L）的左孩子（L）中插入新节点后导致不平衡，需要右旋操作。
        - RR
        - LR
        - RL
删除节点：
       
/**
 * AVLTree是BST，所以节点值必须是可比较的
 */
public class AvlTree<E extends Comparable<E>>{
	private class Node{
		public E e;
		public Node left;
		public Node right;
		public int height;

		public Node(E e){
			this.e = e;
			this.left = null;
			this.right = null;
			this.height = 1;
		}
	}

	private Node root;
	private int size;

	public AvlTree(){
		root=null;
		size=0;
	}

	//获取某一结点的高度
	private int getHeight(Node node){
		if(node==null){
			return 0;
		}
		return node.height;
	}
	
	public int getSize(){
		return size;
	}

	public boolean isEmpty(){
		return size == 0;
	}
	
	/**
	 * 获取节点的平衡因子
	 * @param node
	 * @return
	 */
	private int getBalanceFactor(Node node){
		if(node==null){
			return 0;
		}
		return getHeight(node.left)-getHeight(node.right);
	}
	
	//判断树是否为平衡二叉树
	public boolean isBalanced(){
		return isBalanced(root);
	}

	private boolean isBalanced(Node node){
		if(node==null){
			return true;
		}
		int balanceFactory = Math.abs(getBalanceFactor(node));
		if(balanceFactory>1){
			return false;
		}
		return isBalanced(node.left)&&isBalanced(node.right);
	}

    /**
     * 右旋转
     */
    private Node rightRotate(Node y){
    	Node x = y.left;
    	Node t3 = x.right;
    	x.right = y;
    	y.left = t3;
    	//更新height
    	y.height = Math.max(getHeight(y.left),getHeight(y.right))+1;
    	x.height = Math.max(getHeight(x.left),getHeight(x.right))+1;
    	return x;
    }
    
    /**
     * 左旋转
     */
    private Node leftRotate(Node y){
    	Node x = y.right;
    	Node t2 = x.left;
    	x.left = y;
    	y.right = t2;
    	//更新height
    	y.height = Math.max(getHeight(y.left),getHeight(y.right))+1;
    	x.height = Math.max(getHeight(x.left),getHeight(x.right))+1;
    	return x;
    }

    // 向二分搜索树中添加新的元素(key, value)
    public void add(E e){
    	root = add(root, e);
    }
    
    // 向以node为根的二分搜索树中插入元素(key, value)，递归算法
    // 返回插入新节点后二分搜索树的根
    private Node add(Node node, E e){
    	if(node == null){
    		size ++;
    		return new Node(e);
    	}
    	if(e.compareTo(node.e) < 0)
    		node.left = add(node.left, e);
    	else if(e.compareTo(node.e) > 0)
    		node.right = add(node.right, e);
    	//更新height
    	node.height = 1+Math.max(getHeight(node.left),getHeight(node.right));
    	//计算平衡因子
    	int balanceFactor = getBalanceFactor(node);
    	if(balanceFactor > 1 && getBalanceFactor(node.left)>0) {
    		//右旋LL
    		return rightRotate(node);
    	}
    	if(balanceFactor < -1 && getBalanceFactor(node.right)<0) {
    		//左旋RR
    		return leftRotate(node);
    	}
    	//LR
    	if(balanceFactor > 1 && getBalanceFactor(node.left) < 0){
    		node.left = leftRotate(node.left);
    		return rightRotate(node);
    	}
    	//RL
    	if(balanceFactor < -1 && getBalanceFactor(node.right) > 0){
    		node.right = rightRotate(node.right);
    		return leftRotate(node);
    	}
    	return node;
    }

    public E remove(E e){
    	Node node = getNode(root, e);
    	if(node != null){
    		root = remove(root, e);
    		return node.e;
    	}
    	return null;
    }
    
    private Node remove(Node node, E e){
    
    	if( node == null )
    		return null;
    	Node retNode;
    	if( e.compareTo(node.e) < 0 ){
    		node.left = remove(node.left , e);
    		retNode = node;
    	}
    	else if(e.compareTo(node.e) > 0 ){
    		node.right = remove(node.right, e);
    		retNode = node;
    	}
    	else{   // e.compareTo(node.e) == 0
    		// 待删除节点左子树为空的情况
    		if(node.left == null){
    			Node rightNode = node.right;
    			node.right = null;
    			size --;
    			retNode = rightNode;
    		}
    		// 待删除节点右子树为空的情况
    		else if(node.right == null){
    			Node leftNode = node.left;
    			node.left = null;
    			size --;
    			retNode = leftNode;
    		}else {
    			// 待删除节点左右子树均不为空的情况
    			// 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点
    			// 用这个节点顶替待删除节点的位置
    			Node successor = minimum(node.right);
    			successor.right = remove(node.right, successor.e);
    			successor.left = node.left;
    
    			node.left = node.right = null;
    
    			retNode = successor;
    		}
    	}
    	if(retNode==null)
    		return null;
    	//维护平衡
    	//更新height
    	retNode.height = 1+Math.max(getHeight(retNode.left),getHeight(retNode.right));
    	//计算平衡因子
    	int balanceFactor = getBalanceFactor(retNode);
    	if(balanceFactor > 1 && getBalanceFactor(retNode.left)>=0) {
    		//右旋LL
    		return rightRotate(retNode);
    	}
    	if(balanceFactor < -1 && getBalanceFactor(retNode.right)<=0) {
    		//左旋RR
    		return leftRotate(retNode);
    	}
    	//LR
    	if(balanceFactor > 1 && getBalanceFactor(retNode.left) < 0){
    		node.left = leftRotate(retNode.left);
    		return rightRotate(retNode);
    	}
    	//RL
    	if(balanceFactor < -1 && getBalanceFactor(retNode.right) > 0){
    		node.right = rightRotate(retNode.right);
    		return leftRotate(retNode);
    	}
    	return retNode;
    }

}

```
### 哈希&哈希函数
```markdown
Hash是指把任意长度的输入通过一定的算法变成固定长度的输出的过程，这个输出称作Hash值，或者Hash码，这个算法叫做Hash算法，或者Hash函数，
    这个过程我们一般就称作Hash，或者计算Hash，Hash翻译为中文有哈希、散列、杂凑等。
既然是固定长度的输出，那就意味着输入是无限多的，输出是有限的，必然会出现不同的输入可能会得到相同的输出的情况，所以，Hash算法一般来说也是不可逆的。
哈希算法的用途
哈希算法，是一种广义的算法，或者说是一种思想，它没有一个固定的公式，只要满足上面定义的算法，都可以称作Hash算法。
    通常来说，它具有以下用途：
    1.加密密码，比如，使用MD5+盐的方式来加密密码；
    2.快速查询，比如，哈希表的使用，通过哈希表能够快速查询元素；
    3.数字签名，比如，系统间调用加上签名，可以防止篡改数据；
    4.文件检验，比如，下载腾讯游戏的时候通常都有有一个MD5值，安装包下载下来之后计算出来一个MD5值与官方的MD5值进行对比，就可知道下载过程中有没有文件损坏，有没有被篡改等；
String重写的hashCode()方法：
public int hashCode() {
    int h = hash;
    if (h == 0 && value.length > 0) {
        char val[] = value;
        for (int i = 0; i < value.length; i++) {
            h = 31 * h + val[i];
        }
        hash = h;
    }
    return h;
}
哈希冲突处理
    线性探测法:出现冲突的时候依次往后挪直到找到空位置为止。
    二次探测法:当出现冲突时，我不是往后一位一位这样来找空位置，而是使用原来的hash值加上i的二次方来寻找，i依次从1，2，3...这样，直到找到空位置为止。
    链表法:链表的效率低
    链表树法:当链表长的时候升级成红黑树
一致性Hash:
```
