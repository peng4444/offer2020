# Java容器集合总结及面试题

[TOC]

### 3.Java容器集合
#### 1.Java容器集合简介
[java集合详解](https://www.cnblogs.com/yanzezhong/p/12808089.html)
```markdown
数组 - > 链表 ->类集  ：类集就是Java数据结构的实现，类集就是动态对象数组   源码
    Collection
        List（有序，可重复集合）
            ArrayList:基于动态数组实现，支持随机访问。
            LinkedList:基于双向链表(JDK1.6以前为循环链表，JDK1.7取消了)实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。
            Vector:和ArrayList类似，但它是线程安全的(synchronized锁)，效率低。
        Set（无序，不可重复集合）
            HashSet:HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。基于哈希表实现，支持快速查找，但不支持有序性操作。
                    并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。
            LinkedHashSet:具有HashSet的查找效率，且内部使用双向链表维护元素的插入顺序。
            SortedSet接口
                TreeSet:基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如。
        Queue
            LinkedList:可以用它来实现双向队列。
            PriorityQueue:基于堆结构实现，可以用它来实现优先队列。
    Map(双列集合)
        HashTable：和HashMap类似，但是线程安全的(synchronized锁)，意味着同一时刻多个线程可以同时写入HashTable并且不会导致数据不一致。
        可以使用ConcurrentHashMap来支持线程安全，并且ConcurrentHashMap的效率会更高，因为ConcurrentHashMap引入了分段锁。 
            Poperties
        HashMap：（数组+链表+红黑树）当链表长度超过8时，将链表转换为红黑树，链表长度低于6，就把红黑树转回链表，以减少搜索时间。
        LinkedHashMap：继承HashMap实现Map接口，使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。
        SortedMap接口
            TreeMap：基于红黑树实现。          
集合输出 Iterator,ListIterator(双向集合输出),Enumeration,foreach,Enumeration只有在Vector接口中使用
Map遍历的两种方式
 keyset和entryset，前者是获得key的集合，后者是获得key-value的集合，返回的都是set视图，利用set有迭代器iterator，通过iterator.next来遍历。
 推荐使用entrySet()方法，效率较高。对于keySet其实是遍历了2次，一次是转为iterator，一次就是从HashMap中取出key所对于的value。
    而entryset只是遍历了第一次，它把key和value都放到了entry中，所以快了。    
```
#### Java容器集合源码
##### [ArrayList详解-源码分析](https://www.cnblogs.com/strive-for-life/p/12923608.html)
```markdown
* ArrayList是基于数组实现的集合列表
* 支持任意性的访问（可根据索引直接得到你想要的元素）
* 线程不安全
* 支持动态扩容
* 查询快，增删慢
默认默认容量大小为10，新数组的容量大小为旧数组容量的1.5倍，2^n。
详细讲解ArrayList的部分源码。
```
##### [LinkedList详解-源码分析](https://www.cnblogs.com/strive-for-life/p/12932845.html)
```markdown
* 基于双向链表实现
* 便于插入和删除，不便于遍历
* 非线程安全
* 有序（链表维护顺序）
transient关键字标识变量不会被序列化。节点都被transient修饰。
LinkedList是基于双向链表实现的，即每一个节点都保存了上一个节点和下一个节点的信息。
LinkedList根据索引获取元素效率低的原因是因为它需要一个节点一个节点的遍历，获取首节点和尾节点很快。
LinkedList实现了Deque接口，具有双向队列的性质，可以实现数据结构中的堆栈。
```
#### 2.Collection和Collections有什么区别？
```markdown
 Collection是容器接口，是List和Set的根接口; Collections是工具类，提供处理集合的各种方法
如何决定使用HashMap还是TreeMap？
     HashMap效率高，存取数据快，但是数据无序
     TreeMap效率低，但是存储数据是排序的，可以取到最大和最小值
ArrayList和LinkedList的区别是什么？
     ArrayList动态数组，索引方便，插入不方便
     LinkedList链表，索引不方便，插入方便
ArrayList和Vector的区别是什么？
     ArrayList 线程不安全，扩容*1.5
     Vector方法使用synchronized关键字。线程安全，扩容*2，效率比ArrayList低，适合存大数据并且要求线程安全
Iterator和ListIterator有什么区别？
     Iterator是List和Set的迭代器
     ListIterator是List的迭代器
     Iterator单向，ListIterator双向，ListIterator继承自Iterator，并且实现了更多功能，添加替换等。
在 Queue中poll()和remove()有什么区别？
     poll()和remove ()都将移除并且返回对头，但是在poll()在队列为空时返回null，而remove()会抛出NoSuchElementException异常。
     peek()和element ()都将在不移除的情况下返回队头，但是peek()方法在队列为空时返回null，调用element()方法会抛出NoSuchElementException 异常。
     add()和offer()都是向队列中添加一个元素。但是如果想在一个满的队列中加入一个新元素，调用add()方法就会抛出一个unchecked异常，而调用offer()方法会返回false。
```
#### 3.[Java集合排序策略接口Comparator](https://www.cnblogs.com/felordcn/p/12921857.html)
```markdown
List<People> peoples = new ArrayList<>();
  // 中间省略
  // 按照年龄从小到大排序
peoples.sort(Comparator.comparing(People::getAge));
Comparator是一个函数式接口。它经常用于没有天然排序的集合进行排序，如 Collections.sort 或 Arrays.sort。
或者对于某些有序数据结构的排序规则进行声明，如TreeSet 、TreeMap。也就是该接口主要用来进行集合排序。
```
#### 3.Java容器中的设计模式
[设计模式 - 迭代器模式详解及其在ArrayList中的应用](https://www.cnblogs.com/songjilong/p/12807345.html)
```markdown
迭代器模式：Collection继承了Iterable接口，iterator()方法能够产生一个Iterator对象，通过这个对象就可以迭代遍历Collection中的元素。
            从 JDK1.5之后可以使用foreach方法来遍历实现了Iterable接口的聚合对象。
适配器模式：java.util.Arrays#asList()可以把数组类型转换为List类型。
            应该注意的是asList()的参数为泛型的变长参数，不能使用基本类型数组作为参数，只能使用相应的包装类型数组。
```
#### [面试：在面试中关于List（ArrayList、LinkedList）集合会怎么问呢](https://www.cnblogs.com/Ccwwlx/p/13124514.html)
>> ArrayList(1.8):是由动态再分配的Object[]数组作为底层结构，可设置null值，是非线程安全的。
    默认容量为10,扩容操作为当前容量*1.5倍。
>> LinkedList是一个继承于AbstractSequentialList的双向链表。它也可以被当做堆栈、队列或双端队列进行使用，而且LinkedList也为非线程安全，
jdk1.6使用的是一个带有header节头结点的双向循环链表，头结点不存储实际数据，在1.6之后，就变更使用两个节点first、last指向首尾节点。   
```markdown
区别：
    ArrayList是实现了基于动态数组的数据结构，LinkedList是基于链表结构。
    对于随机访问的get和set方法查询元素，ArrayList要优于LinkedList，因为LinkedList循环链表寻找元素。
    对于新增和删除操作add和remove，LinkedList比较高效，因为ArrayList要移动数据。
优缺点：
    对ArrayList和LinkedList而言，在末尾增加一个元素所花的开销都是固定的。对ArrayList而言，主要是在内部数组中增加一项，指向所添加的元素，
        偶尔可能会导致对数组重新进行分配；而对LinkedList而言，这个开销是 统一的，分配一个内部Entry对象。
    在ArrayList集合中添加或者删除一个元素时，当前的列表移动元素后面所有的元素都会被移动。而LinkedList集合中添加或者删除一个元素的开销是固定的。
    LinkedList集合不支持 高效的随机随机访问（RandomAccess），因为可能产生二次项的行为。
    ArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间
应用场景:
ArrayList使用在查询比较多，但是插入和删除比较少的情况，而LinkedList用在查询比较少而插入删除比较多的情况
```
#### [数据结构:用实例分析ArrayList与LinkedList的读写性能](https://www.cnblogs.com/zhuhuix/p/13042761.html)
```markdown
List使用首选ArrayList。对于个别插入删除非常多的可以使用LinkedList。
LinkedList，遍历建议使用Iterator迭代器，尤其是数据量较大时LinkedList避免使用get遍历。
```
#### modCount属性的作用？
```markdown
modCount属性代表为结构性修改（改变list的size大小、以其他方式改变他导致正在进行迭代时出现错误的结果）的次数，
该属性被Iterator以及ListIterator的实现类所使用，且很多非线程安全使用modCount属性。初始化迭代器时会给这个modCount赋值，如果在遍历的过程中，
一旦发现这个对象的modCount和迭代器存储的modCount不一样，Iterator或者ListIterator 将抛出ConcurrentModificationException异常，
这是jdk在面对迭代遍历的时候为了避免不确定性而采取的fail-fast（快速失败）原则：
在线程不安全的集合中，如果使用迭代器的过程中，发现集合被修改，会抛出ConcurrentModificationExceptions错误，这就是fail-fast机制。
对集合进行结构性修改时，modCount都会增加，在初始化迭代器时，modCount的值会赋给expectedModCount，在迭代的过程中，
只要modCount改变了，int expectedModCount=modCount等式就不成立了，迭代器检测到这一点，就会抛出错误：urrentModificationExceptions。
```
#### 4.ConcurrentHashMap如何实现线程同步
```markdown
hashmap的线程安全版，引入segment，每一个segment都是线程安全的，相当于一个hashtable，因此ConcurrentHashMap也不允许出现 null。
这样就把整个类锁变成了局部锁，用哪一个segment就给哪一个segment加锁。减少竞争，提高效率。
对于 jdk1.8 的改进：
     取消的 segment，转而采用数组元素作为锁。把锁的粒度从多个 node 变成一个 node，进一步减少锁竞争
     链表大于 8 的时候转化为红黑树
实现线程同步：元素 Node，字段修饰为 final 和 volatile，采用乐观锁CAS，和分而治之的思想
     put 操作和初始化操作：
         volatile字段，标识位，表示当前是否有线程在初始化，volatile 字段保证了所有线程的可见。
         CAS机制，保证只有一个线程能够初始化
     size()/判断大小
         首先通过 CAS 机制，如果没有线程竞争，直接递增 count，
         失败就初始化桶，每一个桶并发的记录（同样是CAS机制，最大程度利用并发），如果桶计数频繁失败就扩容桶。
```
#### HashMap知识总结
[HashMap面试必问的数据结构相关知识总结](https://www.cnblogs.com/Young111/p/11519952.html)
[【两万字】面试官：听说你很懂集合源码，接我二十道问题！](https://www.cnblogs.com/viyoung/p/13208296.html)
```markdown
1：HashMap的数据结构？
哈希表结构（链表散列：数组+链表）实现，结合数组和链表的优点。当链表长度超过8时，链表转换为红黑树。transient Node<K,V>[] table;
2：HashMap的工作原理？
HashMap底层是hash数组和单向链表实现，数组中的每个元素都是链表，由Node内部类（实现 Map.Entry<K,V>接口）实现，HashMap通过put&get方法存储和获取。
存储对象时，将K/V键值传给put()方法：
　　①、调用 hash(K)方法计算K的hash值，然后结合数组长度，计算得数组下标；
　　②、调整数组大小（当容器中的元素个数大于capacity*loadfactor时，容器会进行扩容resize为 2n）；
　　③、i.如果K的hash值在HashMap中不存在，则执行插入，若存在，则发生碰撞；
　　　　ii.如果K的hash值在HashMap中存在，且它们两者equals返回true，则更新键值对；
　　　　iii. 如果K的hash值在HashMap中存在，且它们两者equals返回false，则插入链表的尾部（尾插法）或者红黑树中（树的添加方式）。
（JDK1.7之前使用头插法、JDK1.8使用尾插法）（注意：当碰撞导致链表大于TREEIFY_THRESHOLD=8时，就把链表转换成红黑树）
获取对象时，将K传给get()方法：①、调用hash(K)方法（计算K的hash值）从而获取该键值所在链表的数组下标；②、顺序遍历链表，equals()方法查找相同Node链表中K值对应的V值。
hashCode是定位的，存储位置；equals是定性的，比较两者是否相等。
3.当两个对象的hashCode相同会发生什么？
因为hashCode相同，不一定就是相等的（equals方法比较），所以两个对象所在数组的下标相同，"碰撞"就此发生。又因为HashMap使用链表存储对象，这个Node会存储到链表中。
4.你知道hash的实现吗？为什么要这样实现？
JDK1.8中，是通过hashCode()的高16位异或低16位实现的：(h=k.hashCode())^(h>>>16)，主要是从速度，功效和质量来考虑的，减少系统的开销，
也不会造成因为高位没有参与下标的计算，从而引起的碰撞。
5.为什么要用异或运算符？
　　保证了对象的hashCode的32位值只要有一位发生改变，整个hash()返回值就会改变。尽可能的减少碰撞。
6.HashMap的table的容量如何确定？loadFactor是什么？ 该容量如何变化？这种变化会带来什么问题？
　　①、table数组大小是由capacity这个参数确定的，默认是16，也可以构造时传入，最大限制是1<<30；
　　②、loadFactor是装载因子，主要目的是用来确认table数组是否需要动态扩展，默认值是0.75，比如table数组大小为16，装载因子为0.75时，threshold就是12，当table的实际大小超过12时，table就需要动态扩容；
　　③、扩容时，调用resize()方法，将table长度变为原来的两倍（注意是table长度，而不是threshold）
　　④、如果数据很大的情况下，扩展时将会带来性能的损失，在性能要求很高的地方，这种损失很可能很致命。
7.HashMap中put方法的过程？
    答：“调用哈希函数获取Key对应的hash值，再计算其数组下标；
    如果没有出现哈希冲突，则直接放入数组；如果出现哈希冲突，则以链表的方式放在链表后面；
    如果链表长度超过阀值( TREEIFY THRESHOLD==8)，就把链表转成红黑树，链表长度低于6，就把红黑树转回链表;
    如果结点的key已经存在，则替换其value即可；
    如果集合中的键值对大于12，调用resize方法进行数组扩容。”
8.数组扩容的过程？
创建一个新的数组，其容量为旧数组的两倍，并重新计算旧数组中结点的存储位置。结点在新数组中的位置只有两种，原下标位置或原下标+旧数组的大小。
9.拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？
之所以选择红黑树是为了解决二叉查找树的缺陷，二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成很深的问题），遍历查找会非常慢。
而红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，引入红黑树就是为了查找数据快，解决链表查询深度的问题，我们知道红黑树属于平衡二叉树，
但是为了保持“平衡”是需要付出代价的，但是该代价所损耗的资源要比遍历线性链表要少，所以当长度大于8的时候，会使用红黑树，如果链表长度很短的话，根本不需要引入红黑树，引入反而会慢。
10.说说你对红黑树的见解？
    1、每个节点非红即黑
    2、根节点总是黑色的
    3、如果节点是红色的，则它的子节点必须是黑色的（反之不一定）
    4、每个叶子节点都是黑色的空节点（NIL节点）
    5、从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）
11.jdk8中对HashMap做了哪些改变？
在java1.8中，如果链表的长度超过了8，那么链表将转换为红黑树。（桶的数量必须大于64，小于64的时候只会扩容）
发生hash碰撞时，java1.7会在链表的头部插入，而java1.8会在链表的尾部插入,在java1.8中，Entry被Node替代(换了一个马甲)。
12.HashMap，LinkedHashMap，TreeMap 有什么区别？
　　HashMap参考其他问题；
　　LinkedHashMap保存了记录的插入顺序，在用Iterator遍历时，先取到的记录肯定是先插入的；遍历比HashMap慢；
　　TreeMap实现SortMap接口，能够把它保存的记录根据键排序（默认按键值升序排序，也可以指定排序的比较器）
13.HashMap&TreeMap&LinkedHashMap使用场景？
　　一般情况下，使用最多的是HashMap。
　　HashMap：在Map中插入、删除和定位元素时；
　　TreeMap：在需要按自然顺序或自定义顺序遍历键的情况下；
　　LinkedHashMap：在需要输出的顺序和输入的顺序相同的情况下。
14.HashMap和HashTable有什么区别？
　　①、HashMap是线程不安全的，HashTable是线程安全的；
　　②、由于线程安全，所以HashTable的效率比不上HashMap；
　　③、HashMap最多只允许一条记录的键为null，允许多条记录的值为null，而 HashTable不允许；
　　④、HashMap默认初始化数组的大小为16，HashTable为11，前者扩容时，扩大两倍，后者扩大两倍+1；
　　⑤、HashMap需要重新计算hash值，而HashTable直接使用对象的hashCode
15.Java中的另一个线程安全的与HashMap极其类似的类是什么？同样是线程安全，它与HashTable在线程同步上有什么不同？
　　ConcurrentHashMap类（是Java并发包java.util.concurrent中提供的一个线程安全且高效的HashMap实现）。
　　HashTable是使用synchronize关键字加锁的原理（就是对对象加锁）；
　　而针对ConcurrentHashMap，在JDK 1.7中采用 分段锁的方式；JDK 1.8中直接采用了CAS（无锁算法）+ synchronized。
16.HashMap&ConcurrentHashMap的区别？
　　除了加锁，原理上无太大区别。另外，HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。
17.为什么ConcurrentHashMap比HashTable效率要高？
　　HashTable使用一把锁（锁住整个链表结构）处理并发问题，多个线程竞争一把锁，容易阻塞；
　　ConcurrentHashMap 
JDK1.7中使用分段锁（ReentrantLock+Segment+HashEntry），相当于把一个HashMap分成多个段，每段分配一把锁，这样支持多线程访问。锁粒度：基于Segment，包含多个HashEntry。
JDK1.8中使用CAS+synchronized+Node+红黑树。锁粒度：Node（首结点）（实现 Map.Entry<K,V>）。锁粒度降低了。
18.针对ConcurrentHashMap锁机制具体分析（JDK 1.7 VS JDK 1.8）？
　　JDK 1.7 中，采用分段锁的机制，实现并发的更新操作，底层采用数组+链表的存储结构，包括两个核心静态内部类Segment和HashEntry。
　　　　①、Segment 继承 ReentrantLock（重入锁） 用来充当锁的角色，每个 Segment 对象守护每个散列映射表的若干个桶；
　　　　②、HashEntry 用来封装映射表的键-值对；
　　　　③、每个桶是由若干个 HashEntry 对象链接起来的链表
　　JDK1.8中，采用Node+CAS+Synchronized来保证并发安全。取消类Segment，直接用table数组存储键值对；
    当HashEntry对象组成的链表长度超过TREEIFY_THRESHOLD时，链表转换为红黑树，提升性能。底层变更为数组+链表+红黑树。
19.ConcurrentHashMap 在 JDK 1.8 中，为什么要使用内置锁 synchronized 来代替重入锁 ReentrantLock？
　　①、粒度降低了；
　　②、JVM 开发团队没有放弃 synchronized，而且基于 JVM 的 synchronized 优化空间更大，更加自然。
　　③、在大量的数据操作下，对于 JVM 的内存压力，基于 API 的 ReentrantLock 会开销更多的内存。
20.ConcurrentHashMap 简单介绍？
①、重要的常量：
　　private transient volatile int sizeCtl;
　　当为负数时，-1 表示正在初始化，-N 表示 N - 1 个线程正在进行扩容；
　　当为 0 时，表示 table 还没有初始化；
　　当为其他正数时，表示初始化或者下一次进行扩容的大小。
②、数据结构：
　　Node 是存储结构的基本单元，继承 HashMap 中的 Entry，用于存储数据；
　　TreeNode 继承 Node，但是数据结构换成了二叉树结构，是红黑树的存储结构，用于红黑树中存储数据；
　　TreeBin 是封装 TreeNode 的容器，提供转换红黑树的一些条件和锁的控制。
③、存储对象时（put() 方法）：
　　1.如果没有初始化，就调用 initTable() 方法来进行初始化；
　　2.如果没有 hash 冲突就直接 CAS 无锁插入；
　　3.如果需要扩容，就先进行扩容；
　　4.如果存在 hash 冲突，就加锁来保证线程安全，两种情况：一种是链表形式就直接遍历到尾端插入，一种是红黑树就按照红黑树结构插入；
　　5.如果该链表的数量大于阀值 8，就要先转换成红黑树的结构，break 再一次进入循环
　　6.如果添加成功就调用 addCount() 方法统计 size，并且检查是否需要扩容。
④、扩容方法 transfer()：默认容量为 16，扩容时，容量变为原来的两倍。
　　helpTransfer()：调用多个工作线程一起帮助进行扩容，这样的效率就会更高。
⑤、获取对象时（get()方法）：
　　1.计算 hash 值，定位到该 table 索引位置，如果是首结点符合就返回；
　　2.如果遇到扩容时，会调用标记正在扩容结点 ForwardingNode.find()方法，查找该结点，匹配就返回；
　　3.以上都不符合的话，就往下遍历结点，匹配就返回，否则最后就返回 null。
21.ConcurrentHashMap 的并发度是什么？
　　程序运行时能够同时更新ConccurentHashMap且不产生锁竞争的最大线程数。默认为16，且可以在构造函数中设置。
   当用户设置并发度时，ConcurrentHashMap 会使用大于等于该值的最小2幂指数作为实际并发度（假如用户设置并发度为17，实际并发度则为32）
```
#### 未阅读
[随笔分类 - Java提高篇](https://www.cnblogs.com/mfrank/category/1118474.html)

[Java集合框架——大量数据处理操作练习题](https://blog.csdn.net/ZQ_313/article/details/84797467)

[当前标签：集合源码](https://www.cnblogs.com/tong-yuan/tag/%E9%9B%86%E5%90%88/default.html?page=2)

[[面试必问之ArrayList](https://www.cnblogs.com/fsmly/p/11283921.html)]

[LinkedList集合解析及手写集合](https://www.cnblogs.com/hang-on/p/11469263.html)

[JAVA面试题 手写ArrayList的实现，在笔试中过关斩将?](https://www.cnblogs.com/marsitman/p/11204338.html)

[List集合根据存储对象的属性字段排序实现](https://blog.csdn.net/u013821825/article/details/61202287)

[HashMap常见面试题整理](https://www.cnblogs.com/zengcongcong/p/11295349.html)

[深入理解HashMap](https://www.cnblogs.com/fsmly/p/11235484.html)

[红黑树这个数据结构，让你又爱又恨？看了这篇，妥妥的征服它](https://www.cnblogs.com/wskwbog/p/11236136.html)

[[Java集合HashSet的原理及常用方法](https://www.cnblogs.com/LiaHon/p/11257805.html)]

[[TreeMap 还能排序？分析下源码就明白了](https://www.cnblogs.com/wskwbog/p/11245010.html)]

[[这 3 个 Set集合的实现有点简单，那来做个总结吧](https://www.cnblogs.com/wskwbog/p/11260056.html)]

[[HashMap、HashTable、ConcurrentHashMap](https://www.cnblogs.com/wudidamowang666/p/11286279.html)]

[[Java集合系列(四)：HashMap、Hashtable、LinkedHashMap、TreeMap的使用方法及区别](https://www.cnblogs.com/zwwhnly/p/11304627.html)]

[刨死你系列——HashMap(jdk1.8)](https://www.cnblogs.com/Young111/p/11471049.html)

[[HashMap 实现及原理](https://www.cnblogs.com/jay-wu/p/10773976.html)]

[[jdk1.8 HashMap底层数据结构：深入解析为什么jdk1.8 HashMap的容量一定要是2的n次幂](https://www.cnblogs.com/laipimei/p/11316140.html)]

[[Array List和Linked List实现分析](https://www.cnblogs.com/fenjyang/p/11480944.html)]

[[Java 迭代接口：Iterator、ListIterator 和 Spliterator](https://www.cnblogs.com/liululee/p/11416038.html)]

[Comparable接口的实现和使用](https://www.cnblogs.com/wl-centrinc/p/11872758.html)
[Java集合的Stack、Queue、Map的遍历](https://blog.csdn.net/m0_37204491/article/details/70208831)
### 4.Java集合容器博客
#### [1.口气带你踩完五个 List 的大坑，真的是处处坑啊！](https://www.cnblogs.com/goodAndyxublog/p/12758755.html)
```markdown
1.数组转List:Arrays.toList(arrays)：
        不支持增删元素，会抛出UnsupportedOperationException
        共享原始数组，修改原始数组，影响新集合；修改新集合，影响原始数组。
        返回结果为Arrays一个内部类，修复List<String> list = new ArrayList<>(Arrays.asList(arrays));
2.List.subList()：
        生成新集合也会与原始 List 互相影响。SubList持有原始List引用，导致原有List无法被释放
        ArrayList的subList结果不可强转成ArrayList。subList返回的是ArrayList的内部类SubList，并不是ArrayList而是
        ArrayList的一个视图，对于SubList子列表的所有操作最终会反映到原列表上。
3.foreach删除元素：
        foreach这种迭代方式实际就是Iterator迭代器实现方式 所以ArrayList可能报异常
        CopyOnWriteList写操作发生在快照上，不会发生异常。
        修复使用Iterator#remove删除元素，JDK1.8List#removeIf
4.不可变集合：
        不可变集合只能被读取，不能做任何修改，包括增加，删除，修改，从而保护不可变集合的安全。
        不可变集合仅仅是原集合的视图，原集合任何改动都会影响不可变集合。
        使用 JDK9 List#of 方法。使用 Guava immutable list两种方式防止上。
5.使用工具类Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的add/remove/clear方法会抛出
        UnsupportedOperationException异常。asList的返回对象是一个Arrays内部类，并没有实现集合的修改方法。
```
####[2.Map集合怎么也有这么多坑？一不小心又踩了好几个！](https://www.cnblogs.com/goodAndyxublog/p/12840460.html)
```markdown
1.不是所有的Map都能包含null
    HashMap只允许一个key为null,value允许为null;
    ConcurrentHashMap不允许key和value为null;
![](https://img2020.cnblogs.com/other/1419561/202005/1419561-20200507074454124-572637654.jpg) 
2.自定义对象为HashMap的key
    对象的相同属性值重复插入，不会被替代，会插入新的一对键值。
    所以如果需要使用自定义对象做为Map集合的key，那么一定记得重写hashCode与equals方法。
    使用lombok的EqualsAndHashCode自动重写hashCode与equals方法：
        当Map中置入自定义对象后，接着修改了商品金额。然后当我们想根据同一个对象取出Map中存的值时，却发现取不出来了。
        上面的问题主要是因为get方法是根据对象的hashcode计算产生的hash值取定位内部存储位置。
        当我们修改了对象属性后，导致对象hashcode产生的了变化，从而导致get方法无法获取到值。
3.错用ConcurrentHashMap导致线程不安全
    深入分析这个问题原因，实际上是因为第一步与第二步是一个组合逻辑，不是一个原子操作。
    ConcurrentHashMap只能保证这两步单的操作是个原子操作，线程安全。但是并不能保证两个组合逻辑线程安全，
    很有可能A线程刚通过get方法取到值，还未来得及加1，线程发生了切换，B线程也进来取到同样的值。
4.List集合这些坑，Map中也有
    Map 接口除了支持增删改查功能以外，还有三个特有的方法，能返回所有 key，返回所有的 value，返回所有 kv 键值对。
    // 返回 key 的 set 视图
    Set<K> keySet()；
    // 返回所有 value   Collection 视图
    Collection<V> values();
    // 返回 key-value 的 set 视图
    Set<Map.Entry<K, V>> entrySet();
    这三个方法创建返回新集合，底层其实都依赖的原有Map中数据，所以一旦Map中元素变动，就会同步影响返回的集合。
    另外这三个方法返回新集合，是不支持的新增以及修改操作的，但是却支持clear、remove 等操作。
    所以如果需要对外返回Map这三个方法产生的集合，建议再来个套娃。new ArrayList<>(map.values());
    最后再简单提一下，使用foreach方式遍历新增/删除Map中元素，也将会和List集合一样，抛出ConcurrentModificationException。
```
#### [3.还在用迭代器处理集合吗？试试Stream，真香](https://www.cnblogs.com/keatsCoder/p/12846233.html)
```markdown

```
#### [4.瞬间教你学会使用java中list的retainAll方法](https://www.cnblogs.com/jichi/p/12892150.html)
```markdown
当我们有两个list集合的时候，我们可以使用retainAll方法求得两个list集合的子集。
```