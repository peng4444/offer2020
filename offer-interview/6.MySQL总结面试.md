#MySQL学习面试总结
>> [CyC2018大佬]()
>> [MySQL 三万字精华总结 + 面试100 问，吊打面试官绰绰有余（收藏系列）](https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&mid=2247487818&idx=2&sn=61e5c392c68bb6b1474d140e8ee6e3ba&chksm=ce405a9ef937d3888cfa608e3b3e7c329b1255f5d60d6e5bc3ddb2c754f22f24ad2c11e317ab&mpshare=1&scene=23&srcid=&sharer_sharetime=1590881519689&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
>> [三万字、91道MySQL面试题](https://www.cnblogs.com/wyl-0120/p/12556334.html)

[TOC]


## MySQL基础
### 0.主键、外键、超键、候选键
```markdown
超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。
    超键包含候选键和主键。
候选键：是最小超键，即没有冗余元素的超键。
主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。
外键：在一个表中存在的另一个表的主键称此表的外键。
[为什么大多数互联网公司不用外键约束](https://www.cnblogs.com/JethroYu/p/13570630.html)
```
### 1.数据库范式【5+】
```markdown
 第一范式：每个字段都不可以再拆分。实体中的某个属性不能有多个值或者不能有重复的属性。
 第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。消除部分子函数依赖,非主属性完全依赖于主关键字。
 第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。消除传递依赖,不包含已在其它表中已包含的非主关键字信息。
 BCNF范式：不存在任何字段对任一候选关键字段的传递函数依赖。
在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。
 第四范式:要求把同一表内的多对多关系删除。
 第五范式:从最终结构重新建立原始结构。
```
### 2.mysql有哪些数据类型
```markdown
1、整数类型，包括TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示1字节、2字节、3字节、4字节、8字节整数。
    任何整数类型都可以加上UNSIGNED属性，表示数据是无符号的，即非负整数。
    长度：整数类型可以被指定长度，例如：INT(11)表示长度为11的INT类型。
    长度在大多数场景是没有意义的，它不会限制值的合法范围，只会影响显示字符的个数，而且需要和UNSIGNED ZEROFILL属性配合使用才有意义。
    例子，假定类型设定为INT(5)，属性为UNSIGNED ZEROFILL，如果用户插入的数据为12的话，那么数据库实际存储数据为00012。
2、实数类型，包括FLOAT（单精度浮点数）、DOUBLE（双精度浮点数）、DECIMAL(m,d)（压缩严格的定点数）。
    DECIMAL可以用于存储比BIGINT还大的整型，能存储精确的小数。而FLOAT和DOUBLE是有取值范围的，并支持使用标准的浮点进行近似计算。
    计算时FLOAT和DOUBLE相比DECIMAL效率更高一些，DECIMAL你可以理解成是用字符串进行处理。
3、字符串类型，包括VARCHAR、CHAR、TEXT、BLOB用于存储可变长字符串，它比定长类型更节省空间。
    VARCHAR(M)用于存储可变长字符串，它比定长类型更节省空间。M为0~65535之间的整数
        VARCHAR使用额外1或2个字节存储字符串长度。列长度小于255字节时，使用1字节表示，否则使用2字节表示。
        VARCHAR存储的内容超出设置的长度时，内容会被截断。
    CHAR(M)是定长的，根据定义的字符串长度分配足够的空间。CHAR会根据需要使用空格进行填充方便比较。M为0~255之间的整数
        CHAR适合存储很短的字符串，或者所有值都接近同一个长度。CHAR存储的内容超出设置的长度时，内容同样会被截断。
        char的存储方式是：对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节。
        varchar的存储方式是：对每个英文字符占用2个字节，汉字也占用2个字节。
    使用策略：
        对于经常变更的数据来说，CHAR比VARCHAR更好，因为CHAR不容易产生碎片。对于非常短的列，CHAR比VARCHAR在存储空间上更有效率。
        使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。尽量避免使用TEXT/BLOB类型，查询时会使用临时表，导致严重的性能开销。   
        char的存取速度还是要比varchar要快得多，因为其长度固定，方便程序的存储与查找。
4、枚举类型（ENUM），把不重复的数据存储为一个预定义的集合。
    有时可以使用ENUM代替常用的字符串类型。ENUM存储非常紧凑，会把列表值压缩到一个或两个字节。
    ENUM在内部存储时，其实存的是整数。尽量避免使用数字作为ENUM枚举的常量，因为容易混乱。排序是按照内部存储的整数
5、日期和时间类型，尽量使用timestamp，空间效率高于datetime，year YYYY 1901~2155 time HH:MM:SS -838:59:59~838:59:59
    date YYYY-MM-DD 1000-01-01~9999-12-3 datetime YYYY-MM-DD HH:MM:SS timestamp YYYY-MM-DD HH:MM:SS
    用整数保存时间戳通常不方便处理。如果需要存储微妙，可以使用bigint存储。
```
### 3.mysql有关权限的表都有哪几个
```markdown
MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。
这些权限表分别user，db，table_priv，columns_priv和host。下面分别介绍一下这些表的结构和内容：
    1、user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。
    2、db权限表：记录各个帐号在各个数据库上的操作权限。
    3、table_priv权限表：记录数据表级的操作权限。
    4、columns_priv权限表：记录数据列级的操作权限。
    5、host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。
```
### 4.SQL执行顺序
```markdown
SELECT语句，语法顺序如下：
    1. SELECT 
    2. DISTINCT <select_list>
    3. FROM <left_table>
    4. <join_type> JOIN <right_table>
    5. ON <join_condition>
    6. WHERE <where_condition>
    7. GROUP BY <group_by_list>
    8. HAVING <having_condition>
    9. ORDER BY <order_by_condition>
    10.LIMIT <limit_number>
SELECT 语句，执行顺序如下：
    FROM
    <表名> # 选取表，将多个表数据通过笛卡尔积变成一个表。
    ON
    <筛选条件> # 对笛卡尔积的虚表进行筛选
    JOIN <join, left join, right join...> 
    <join表> # 指定join，用于添加数据到on之后的虚表中，例如left join会将左表的剩余数据添加到虚表中
    WHERE
    <where条件> # 对上述虚表进行筛选
    GROUP BY
    <分组条件> # 分组
    <SUM()等聚合函数> # 用于having子句进行判断，在书写上这类聚合函数是写在having判断里面的
    HAVING
    <分组筛选> # 对分组后的结果进行聚合筛选
    SELECT
    <返回数据列表> # 返回的单列必须在group by子句中，聚合函数除外
    DISTINCT
    # 数据除重
    ORDER BY
    <排序条件> # 排序
    LIMIT
    <行数限制>
```
### 4.MySQL事务
>> 事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。
>> 事务是逻辑上的一组操作，要么都执行，要么都不执行。
#### 1.事务的四大特性ACID【5+】
```markdown
事务的四大特性指的是满足ACID特性的一组操作，可以通Commit提交一个事务，也可以使用Rollback进行回滚。
**原子性**:事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。
    回滚可以用回滚日志来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。
**一致性**:数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。
**隔离性**:一个事务所做的修改在最终提交以前，对其它事务是不可见的。
**持久性**:一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。
```
#### 2.事务并发一致性问题【5+】
[跟面试官侃半小时MySQL事务隔离性，从基本概念深入到实现](https://www.cnblogs.com/awan-note/p/12584757.html)
```markdown
在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。丢失修改、读脏数据、不可重复读、幻影读
更新丢失：mysql所有事务隔离级别在数据库层面上均可避免。
脏读(Drity Read)：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据。READ-COMMITTED事务隔离级别以上可以避免。
 不可重复读(Non-repeatable read)：事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，
    结果因此本事务先后两次读到的数据因更新结果会不一致。不可重复读的重点是修改。同样的条件，你读取过的数据，再次读取出来发现值不一样。
    REPEATABLE_READ事务隔离级别以上避免。
 幻读(Phantom Read)：幻读发生在当两个完全相同的查询执行时，第二次查询所返回的结果集跟第一个查询不相同。
    幻读的重点在于新增或者删除。同样的条件， 第1次和第2次读出来的记录数不一样。SERIALIZABLE事务隔离级别可避免。
脏读与不可重复读的区别在于：前者读到的是其他事务未提交的数据，后者读到的是其他事务已提交的数据。
不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多条读取一条记录发现记录增多或者减少了。
```
#### 3.事务的隔离级别及各级别下的并发访问问题【10+】
[一文彻底读懂MySQL事务的四大隔离级别](https://www.cnblogs.com/jay-huaxiao/p/12639435.html)--
[5分钟带你读懂事务隔离性与隔离级别](https://www.cnblogs.com/coder-programming/p/10693473.html)
```markdown
 Read uncommitted：读未提交，就是一个事务可以读取另一个未提交事务的数据。会造成脏读。
 Read committed：读提交，就是一个事务要等另一个事务提交后才能读取数据。若有事务对数据进行更新（UPDATE）操作时，
    读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题。但会造成不可重复读。
 Repeatable read：可重复读，就是在开始读取数据（事务开启）时，不再允许修改操作在同一个事务里，SELECT的结果是事务开始时时间点的状态，
    因此，同样的SELECT操作读到的结果会是一致的。但是，会有幻读现象。
 Serializable：可序列化，Serializable是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。
    但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。
Mysql默认采用的REPEATABLE_READ隔离级别Oracle默认采用的READ_COMMITTED隔离级别
    隔离级别	并发问题
    读未提交	可能会导致脏读、幻读或不可重复读
    读已提交	可能会导致幻读或不可重复读
    可重复度	可能会导致幻读
    可串行化	不会产⽣⼲扰
>> select @@tx_isolation; # 查看数据库默认的隔离级别
>> set session transaction isolation level read uncommitted; #设置数据库的隔离级别为读未提交
>> start translation; # 开启事务

```
#### 4.InnoDB可重复读级别下如何避免幻读？【3+】
```markdown
当前读与快照读
next-key锁（行锁+gap锁）
```
#### 5.RC,RR级别下的InnoDB的非阻塞读如何实现？
```markdown
事务隔离级别RC(read commit)和RR（repeatable read）两种事务隔离级别基于多版本并发控制MVCC(multi-version concurrency control）来实现。
​由于RC隔离级别需要保持语句级别的一致性，事务中每一次读取都是访问当前时间点的已提交数据，因此事务中多条查询语句会创建多个不同的ReadView，开销较大，复杂度更高；
    而对于RR隔离级别，仅需要一个版本的ReadView，消耗更少，因此Mysql默认使用RR隔离级别。
​RC隔离级别获得的是语句级读一致性；RR隔离级别获得的是事务级读一致性
​对于RC隔离级别，访问的数据是每次语句执行时间点的数据，而对于RR隔离级别，访问的数据是事务中第一条语句执行时间点的数据。
```
#### 6.事务的隔离级别和加锁的关系？
```markdown
  读未提交  不加锁
     事务读不阻塞其他事务读和写，事务写阻塞其他事务写但不阻塞读。
     可以通过写操作加 “持续 - X 锁” 实现。
  读已提交  加行锁，只锁要修改的行
     事务读不会阻塞其他事务读和写，事务写会阻塞其他事务读和写。
     可以通过写操作加 “持续 - X” 锁，读操作加 “临时 - S 锁” 实现。
  可重复读  加行锁，锁定的是查询的行
     事务读会阻塞其他事务事务写但不阻塞读，事务写会阻塞其他事务读和写。
     可以通过写操作加 “持续 - X” 锁，读操作加 “持续 - S 锁” 实现。
  串行化  加表锁，在读取的每张表上加锁
     “行级锁” 做不到，需使用 “表级锁”。
```
#### 7.嵌套事务
```markdown
什么是嵌套事务？
嵌套是子事务套在父事务中执行，子事务是父事务的一部分，在进入子事务之前，父事务建立一个回滚点，叫save point，然后执行子事务，
    这个子事务的执行也算是父事务的一部分，然后子事务执行结束，父事务继续执行。重点就在于那个save point。看几个问题就明了了：
如果子事务回滚，会发生什么？
父事务会回滚到进入子事务前建立的save point，然后尝试其他的事务或者其他的业务逻辑，父事务之前的操作不会受到影响，更不会自动回滚。
如果父事务回滚，会发生什么？
父事务回滚，子事务也会跟着回滚！为什么呢，因为父事务结束之前，子事务是不会提交的，我们说子事务是父事务的一部分，正是这个道理。那么：
事务的提交，是什么情况？
是父事务先提交，然后子事务提交，还是子事务先提交，父事务再提交？答案是第二种情况，还是那句话，子事务是父事务的一部分，由父事务统一提交。
```
### 5.MySQL锁【5+】
>> 当数据库有并发事务的时候，可能会产生数据的不一致，这时候需要一些机制来保证访问的次序，锁机制就是这样的一个机制。
#### 1.MySQL中的锁【5+】
[2.说一说你对MySQL中锁的了解？](https://www.cnblogs.com/notfound9/p/13062524.html)
```markdown
 悲观锁: 先获取锁，再进行业务操作。即 “悲观” 的认为获取锁是非常有可能失败的，因此要先确保获取锁成功再进行业务操作。
    通常来讲在数据库上的悲观锁需要数据库本身提供支持，即通过常用的select … for update操作来实现悲观锁。
 乐观锁的特点先进行业务操作，不到万不得已不去拿锁。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。
    如果其他事务有更新的话，那么当前正在提交的事务会进行回滚。
 表级锁：Mysql中锁定粒度最大的一种锁，对当前操作的整张表加锁，实现简单 ，资源消耗也比较少，加锁快，不会出现死锁 。
    其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。
    开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。
 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。行锁又分为读锁和写锁：
    MySQL中InnoDB引擎的行锁是怎么实现的？
    InnoDB是基于索引来完成行锁。select * from tab_with_index where id = 1 for update;
        for update可以根据条件来完成行锁锁定，并且id是有索引键的列，如果id不是索引键那么InnoDB将完成表锁，并发将无从谈起
 共享锁：读锁或S锁。如果事务T对数据A加上共享锁后，则其他事务只能对 A再加共享锁，不能加排它锁。获准共享锁的事务只能读数据，不能修改数据。
 排它锁：独占锁、写锁或X锁。如果事务T对数据A加上排它锁后，则其他事务不能再对A加任何类型的锁。获得排它锁的事务即能读数据又能修改数据。
    InnoDB 实现了标准的行级锁，包括两种：共享锁（简称 s 锁）、排它锁（简称 x 锁）。
    共享锁（S锁）：允许持锁事务读取一行。
    排他锁（X锁）：允许持锁事务更新或者删除一行。
1.2 意向锁
    意向共享锁( IS 锁)：事务想要获得一张表中某几行的共享锁
    意向排他锁( IX 锁)： 事务想要获得一张表中某几行的排他锁
1.3 记录锁（Record Locks）
    记录锁是最简单的行锁，仅仅锁住一行。如：SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE
    记录锁永远都是加在索引上的，即使一个表没有索引，InnoDB也会隐式的创建一个索引，并使用这个索引实施记录锁。
    会阻塞其他事务对其插入、更新、删除
1.4 间隙锁（Gap Locks）
    间隙锁是一种加在两个索引之间的锁，或者加在第一个索引之前，或最后一个索引之后的间隙。
    使用间隙锁锁住的是一个区间，而不仅仅是这个区间中的每一条数据。
    间隙锁只阻止其他事务插入到间隙中，他们不阻止其他事务在同一个间隙上获得间隙锁，所以 gap x lock 和 gap s lock 有相同的作用。
1.5 Next-Key Locks
    Next-key锁是记录锁和间隙锁的组合，它指的是加在某条记录以及这条记录前面间隙上的锁。
    next-key lock实际上就是行锁的一种，只不过它不只是会锁住当前行记录的本身，还会锁定一个范围。
    InnoDB实现的隔离级别RR时可以避免幻读现象的，这是通过next-key lock机制实现的。
1.6插入意向锁（Insert Intention）
    插入意向锁是在插入一行记录操作之前设置的一种间隙锁，这个锁释放了一种插入方式的信号，
    亦即多个事务在相同的索引间隙插入时如果不是插入间隙中相同的位置就不需要互相等待。
1.7 三级封锁协议
    **一级封锁协议**:事务T要修改数据A时必须加X(写)锁，直到T结束才释放锁。可以解决丢失修改问题。
    **二级封锁协议**:在一级的基础上，要求读取数据A时必须加S(读)锁，读取完马上释放S(读)锁。可以解决读脏数据问题。
    **三级封锁协议**:在二级的基础上，要求读取数据A时必须加S(读)锁，直到事务结束了才能释放S(读)锁。可以解决不可重复读的问题
1.8 两段锁协议
    加锁和解锁分为两个阶段进行。
    可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。
    事务遵循两段锁协议是保证可串行化调度的充分条件。
    MySQL的InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。
```
[【原创】惊！史上最全的select加锁分析(Mysql)](https://www.cnblogs.com/rjzheng/p/9950951.html)
[超全面的MySQL语句加锁分析](https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&mid=2653198050&idx=2&sn=68a6594ac35976532ad6a0eec6dc06dd&chksm=8c99e438bbee6d2e8e9bdf80a3312723c92e20afb1918ca6d29cd8ded1d670637c413704ca61&mpshare=1&scene=23&srcid=#rd)
#### 2.隔离级别与锁的关系
```markdown
在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突
在Read Committed级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁；
在Repeatable Read级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。
SERIALIZABLE是限制性最强的隔离级别，因为该级别锁定整个范围的键，并一直持有锁，直到事务完成。
```
#### 3.死锁死循环四要素
```markdown
MyISAM⽀持表锁，InnoDB⽀持表锁和⾏锁，默认为⾏锁
    表级锁：开销⼩，加锁快，不会出现死锁。锁定粒度⼤，发⽣锁冲突的概率最⾼，并发量最低
    ⾏级锁：开销⼤，加锁慢，会出现死锁。锁⼒度⼩，发⽣锁冲突的概率⼩，并发度最⾼
死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。
- 互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。
    如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。
- 请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，
    此时请求进程阻塞，但又对自己已获得的其它资源保持不放。
- 不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。
- 环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；
    P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。
常见的解决死锁的方法
    1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。
    2、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；
    3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；
    如果业务处理不好可以用分布式事务锁或者使用乐观锁
```
#### 4.分析死锁
[1.手把手教你分析Mysql死锁问题](https://www.cnblogs.com/jay-huaxiao/p/12685287.html)
```markdown
环境准备：
    select @@tx_isolation;  # 查看数据库隔离级别
    set autocommit=0;  # 自动提交关闭
    //id是自增主键，name是非唯一索引，balance普通字段
    表结构:
        CREATE TABLE `account` (
              `id` int(11) NOT NULL AUTO_INCREMENT,
              `name` varchar(255) DEFAULT NULL,
              `balance` int(11) DEFAULT NULL,
              PRIMARY KEY (`id`),
              KEY `idx_name` (`name`) USING BTREE
            ) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;
    表中的数据：(1,Eason,100),(2,Wei,100)
    模拟并发：
        mysql> update  account  set balance =1000 where name ='Wei'; -- 1）事务A执行更新操作，更新成功
        mysql> update  account  set balance =1000 where name ='Eason'; -- 2）事务B执行更新操作，更新成功
        mysql> insert into account values(null,'Jay',100); -- 3）事务A执行插入操作，陷入阻塞~
    select * from information_schema.innodb_locks; # 查看锁情况
        mysql> insert into account values(null,'Yan',100); -- 4）事务B执行插入操作，插入成功，同时事务A的插入由阻塞变为死锁error。
    show engine innodb status; # 查看最近一次死锁日志
        1）找到关键词TRANSACTION，事务38048
        2）查看正在执行的SQL
        3）正在等待锁释放(WAITING FOR THIS LOCK TO BE GRANTED)，...
-- MySQL中提供了两种封锁粒度：行级锁以及表级锁。应该尽量只锁定需要修改的那部分数据，而不是所有的资源。
加锁机制：乐观锁、悲观锁。
兼容性：共享锁、排它锁。
锁粒度：表锁、页锁、行锁。
锁模式：记录锁、gap锁、next-key锁、意向锁、插入意向锁。
```
#### 5.死锁的解决办法?
```markdown
1.查出的线程杀死 kill
    SELECT trx_MySQL_thread_id FROM information_schema.INNODB_TRX;
2.设置锁的超时时间
    Innodb 行锁的等待时间，单位秒。可在会话级别设置，RDS 实例该参数的默认值为 50（秒）。
    生产环境不推荐使用过大的 innodb_lock_wait_timeout参数值
    该参数支持在会话级别修改，方便应用在会话级别单独设置某些特殊操作的行锁等待超时时间，如下：
    set innodb_lock_wait_timeout=1000; —设置当前会话 Innodb 行锁等待超时时间，单位秒。
3.指定获取锁的顺序
```
#### 6.数据库的乐观锁和悲观锁是什么？怎么实现的？
```markdown
数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。
乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。
    悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制
    乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。
    实现方式：一般会使用版本号机制或CAS算法实现。
两种锁的使用场景
    从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），
    即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。
    但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。
```
### 6.MySQL索引 【10+】
[mysql数据库的索引](https://www.cnblogs.com/wangsen/p/10864136.html)
>> 如何使用联合索引，最左匹配原则，字段顺序如何选择
#### 0.什么是索引？为什么要使用索引?
```markdown
索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。
索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。
更通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。索引是一个文件，它是要占据物理空间的。
为什么要使用索引：快速查询数据;绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能快，其余大部分场景使用BTree索引。
```
#### 1.索引分类【5+】
```markdown
 主键索引 （PRIMARY KEY）:数据列不允许重复，不允许为NULL，一个表只能有一个主键。
 唯一索引 （UNIQUE）:数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。
    1、可以通过 ALTER TABLE table_name ADD UNIQUE (column)；创建唯一索引
    2、可以通过 ALTER TABLE table_name ADD UNIQUE (column1,column2)；创建唯一组合索引
 普通索引 （INDEX）:基本的索引类型，没有唯一性的限制，允许为NULL值。
    1、可以通过ALTER TABLE table_name ADD INDEX index_name (column);创建普通索引
    2、可以通过ALTER TABLE table_name ADD INDEX index_name(column1, column2, column3)；创建组合索引
 全文索引 （FULLTEXT）:是目前搜索引擎使用的一种关键技术。用来查找文本中的关键字，而不是直接与索引中的值比较。
    1.可以通过ALTER TABLE table_name ADD FULLTEXT (column);创建全文索引
 组合索引 （INDEX）:MySQL可以使用多个字段同时建立一个索引，叫做联合索引。
    只有在查询条件中使用了创建索引的第一个字段，索引才能生效被使用，使用组合索引遵循最左前缀匹配集合。
    1、在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。
    具体原因为:
    MySQL使用索引时需要索引有序，假设现在建立了"name，age，school"的联合索引，那么索引的排序为: 先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。
    当进行查询时，此时索引仅仅按照name严格有序，因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。
    因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。
```
#### 2.B+Tree定义【2+】
```markdown
B-Tree指的是Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。
B-Tree的定义：
    - 根节点至少包括两个孩子;
    - 树中每个节点最多包含m个孩子(m>=2);
    - 除根节点和叶节点外，其他每个节点至少有ceil(m/2)个孩子;
    - 所有叶子节点都位于同一层。
    - 假设每个非终端节点中包含有n个关键字信息，其中：
        a).ki(i=1...n)为关键字，且关键字按升序排序k(i-1)<ki
        b).关键字的个数n必须满足：[ceil(m/2)-1]<=n<=m-1
        c).非叶子节点的指针：p[1],p[2],....p[m]指向关键字指向k[1]的子树，p[m]指向关键字大于k[m-1]的子树，其他p[i]指向关键字属于(k[i-1],k[i])的子树。 
B+Tree是基于B-Tree和叶子节点顺序访问指针进行实现，它具有B-Tree的平衡性，并且通过顺序访问指针来提高区间查询的性能。
在B+Tree中，一个节点中的key从左到右非递减排列，如果某个指针的左右相邻key分别是keyi和keyi+1，且不为null，则该指针指向节点的所有key大于等于keyi且小于等于keyi+1。
B+Tree的定义：在B数的基础之上，添加了
    - 非叶子节点的子树指针与关键字个数相同；
    - 非叶子节点的子树指针p[i],指向关键字[k[i],k[i+1]]的子树；
    - 非叶子节点仅用来索引，数据都保存在叶子节点中；
    - 所有的叶子节点有一个链指针指向下一个叶子节点。
B+Tree更加合适来做存储索引：
    - B+树的磁盘读写代价更低;B+树空间利用率更高，可减少I/O次数，磁盘读写代价更低。
    - B+树的查询效率更加稳定;B树只适合随机检索，而B+树同时支持随机检索和顺序检索；
    - B+树更有利于对数据库的扫描。B+树的查询效率更加稳定。
B+Tree:实际的用户记录其实都存放在B+树的叶子节点上，而非叶子节点存放的是目录项。
红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用B+Tree作为索引结构，主要有以下两个原因：
    （一）更少的查找次数：平衡树查找操作的时间复杂度和树高h相关，O(h)=O(logdN)，其中d为每个节点的出度。
    （二）利用磁盘预读特性：为了减少磁盘I/O操作，磁盘往往不是严格按需读取，而是每次都会预读。
```
#### 3.索引的数据结构-B+Tree索引【2+】
```markdown
B+Tree索引是大多数MySQL存储引擎的默认索引类型。
    因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。
    因为B+Tree的有序性，所以除了用于查找，还可以用于排序和分组。
    可以指定多个列作为索引列，多个索引列共同组成键。
    适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。
    如果不是按照索引列的顺序进行查找，则无法使用索引。
InnoDB的B+Tree索引分为主索引和辅助索引。
    主索引的叶子节点data域记录着完整的数据记录，这种索引方式被称为聚簇索引。
    因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。
    辅助索引的叶子节点的data域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。
B+树的磁盘读写代价低，更少的查询次数，查询效率更加稳定，有利于对数据库的扫描
​   相对B树，B+树是B树的升级版，只是把非叶子节点冗余一下，这么做的好处是为了提高范围查找的效率，解决数据库遍历效率低下问题；
   B+树只有叶节点存放数据，其余节点用来索引，而B树是每个索引节点都会有Data域。
​   在大规模数据存储的时候，红黑树往往出现由于树的深度过大而造成磁盘IO读写过于频繁，进而导致效率低下的情况。
   所以，只要我们通过某种较好的树结构减少树的结构尽量减少树的高度，B树与B+树可以有多个子女，从几十到上千，可以降低树的高度。
​   磁盘预读原理：将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：
   每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。
```
#### 4.索引的数据结构-哈希索引【1+】
```markdown
Hash索引：Hash索引底层是哈希表，哈希表是一种以key-value存储数据的结构，所以多个数据在存储关系上是完全没有任何顺序关系的，
    所以，对于区间查询是无法直接通过索引查询的，就需要全表扫描。所以，哈希索引只适用于等值查询的场景。
    而B+树是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描。
哈希索引能以O(1)时间进行查找，但是失去了有序性：无法用于排序与分组；只支持精确查找，无法用于部分查找和范围查找。
InnoDB存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在B+Tree索引之上再创建一个哈希索引，
    这样就让B+Tree索引具有哈希索引的一些优点，比如快速的哈希查找。
Hash索引：也可以用来作为索引。    
    - 仅仅能够满足"=","IN"，不能使用范围查询
    - 无法被用来避免数据操作
    - 不能利用部分索引键查询
    - 不能避免表扫描
    - 遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高
```
#### 5.全文索引
```markdown
MyISAM存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。
    查找条件使用MATCH AGAINST，而不是普通的WHERE。
    全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。
InnoDB存储引擎在MySQL5.6.4版本中也开始支持全文索引。
```
#### 6.空间数据索引
```markdown
MyISAM存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，
    可以有效地使用任意维度来进行组合查询。必须使用GIS相关的函数来维护数据。
```
#### 7.聚簇索引和非聚簇索引区别【8+】
```markdown
聚集索引表记录的排列顺序和索引的排列顺序一致，所以查询效率快，只要找到第一个索引值记录，其余就连续性的记录在物理也一样连续存放。
    聚集索引对应的缺点就是修改慢，因为为了保证表中记录的物理和索引顺序一致，在记录插入的时候，会对数据页重新排序。
非聚集索引指定了表中记录的逻辑顺序，但是记录的物理和索引不一定一致，两种索引都采用B+树结构，非聚集索引的叶子层并不和实际数据页相重叠，
    而采用叶子层包含一个指向表中的记录在数据页中的指针方式。非聚集索引层次多，不会造成数据重排。
​聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。
innoDB:使用主键索引使用的密集索引,数据行的物理顺序与列值（一般是主键的那一列）的逻辑顺序相同，一个表中只能拥有一个聚集索引。
    - 聚集索引的叶子节点存放有对应的数据节点，可以直接获取到对应的数据，
    - 如果不创建索引，系统会自动创建一个隐含列作为表的聚集索引。
    - 最好还是在创建表的时候添加聚集索引
    - 在经常用于查询或聚合条件的字段上建立聚集索引。这类查询条件包括between,>,<,group by,max,min,count等。
    缺点：
    - 插入和更新索引的速度会比较慢，因为将会导致被更新的行移动。
MyISAM:不管是主键索引，还是二级索引使用的都是稀疏索引,数据行的物理顺序与列值的逻辑顺序不相同，一个表中可以拥有多个非聚集索引。
    - 叶子节点存放的不是实际数据，而是指向实际数据的指针。
    - 聚集索引以外的索引都是非聚集索引,细分可以分为：普通索引，唯一索引，全文索引。
```
#### 8.两种存储引擎的BTree索引实现方式是不同的。
```markdown
●MyISAM:B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候,首先按照B+Tree搜索算法搜索索引,
    如果指定的Key存在,则取出其data域的值,然后以data域的值为地址读取相应的数据记录。这被称为"非聚簇索引"。
● InnoDB:其数据文件本身就是索引文件。相比MyISAM,索引文件和数据文件是分离的,其表数据文件本身就是按B+Tree组织的一个素引结构,
    树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键,因此InnoDB表数据文件本身就是主索引。
    这被称为"聚簇索引（或聚集索引）"。而其余的索引都作为辅助索引,辅助索引的data域存储相应记录主键的值而不是地址,这也是和MyISAM不同的地方。
    在根据主索引搜索时,直接找到key所在的节点即可取出数据;在根据辅助索引查找时,则需要先取出主键的值,再走一遍主索引。
    因此,在设计表的时候,不建议使用过长的字段作为主键,也不建议使用非单调的字段作为主键,这样会造成主索引频繁分裂。
```
#### 9.索引优化
[MySQL如何创建一个好索引？创建索引的5条建议](https://www.cnblogs.com/chenkeyu/p/12799207.html)
```markdown
1. 独立的列
在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。
2. 多列索引
在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把actor_id和film_id设置为多列索引。
3. 索引列的顺序
让选择性最强的索引列放在前面。索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。
选择性越高，每个记录的区分度越高，查询效率也越高。
4. 前缀索引
对于BLOB、TEXT和VARCHAR类型的列，必须使用前缀索引，只索引开始的部分字符。前缀长度的选取需要根据索引选择性来确定。
5. 覆盖索引
索引包含所有需要查询的字段的值。
如果要查询的字段都建立过索引，那么引擎会直接在索引表中查询而不会访问原始数据（否则只要有一个字段没有建立索引就会做全表扫描），这叫索引覆盖。
具有以下优点：
    索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。
    一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。
    对于InnoDB引擎，若辅助索引能够覆盖查询，则无需访问主索引。
```
#### 10.索引的优点【1+】
```markdown
索引的优点：
    1.大大减少了服务器需要扫描的数据行数。
    2.帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree索引是有序的，可以用于ORDER BY和GROUP BY操作。
        临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。
    3.将随机I/O变为顺序I/O（B+Tree索引是有序的，会将相邻的数据都存储在一起）。
索引的缺点
    1.时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率；
    2.空间方面：索引需要占物理空间。
```
#### 11.创建索引的原则【2+】
[mysql索引设计的注意事项(大量示例,收藏再看)](https://www.cnblogs.com/wangtcc/p/mysql-suo-yin-she-ji-de-zhu-yi-shi-xiang-da-liang-.html)
```markdown
索引虽好，但也不是无限制的使用，最好符合一下几个原则
1） 最左前缀匹配原则，组合索引非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，
    比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，
    如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
2）较频繁作为查询条件的字段才去创建索引
3）更新频繁字段不适合创建索引
4）若是不能有效区分数据的列不适合做索引列（如性别，男女未知，最多也就三种，区分度实在太低）
5）尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a，b)的索引，那么只需要修改原来的索引即可。
6）定义有外键的数据列一定要建立索引。
7）对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。
8）对于定义为text、image和bit的数据类型的列不要建立索引。
创建索引的三种方式
    第一种方式：在执行CREATE TABLE时创建索引
    第二种方式：使用ALTER TABLE命令去增加索引
    第三种方式：使用CREATE INDEX命令创建
删除索引
    根据索引名删除普通索引、唯一索引、全文索引：alter table 表名 drop KEY 索引名
    删除主键索引：alter table 表名 drop primary key（因为主键只有一个）。
    这里值得注意的是，如果主键自增长，那么不能直接执行此操作（自增长依赖于主键索引）
创建索引时需要注意什么？
    非空字段：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，
        因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；
    取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，
        返回值越大说明字段的唯一值越多字段的离散程度高；
    索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。
```
#### 12.索引哪些情况会失效【6+】
```markdown
索引哪些情况会失效
    1.查询条件包含or，可能导致索引失效，or语句前后没有同时使用索引。
    如果字段类型是字符串，where时一定用引号括起来，否则索引失效
    2.like通配符可能导致索引失效，like以%开头，索引无效。
    3.联合索引，查询时的条件列不是联合索引中的第一个列，索引失效。
    4.在索引列上使用mysql的内置函数，索引失效。
    5.对索引列运算（如，+、-、*、/），索引失效。
    6.索引字段上使用（！= 或者 < >，not in）时，可能会导致索引失效。
    7.索引字段上使用is null， is not null，可能导致索引失效。
    8.左连接查询或者右连接查询查询关联的字段编码格式不一样，可能导致索引失效。
    9.mysql执行引擎估计使用全表扫描要比使用索引快,则不使用索引。
5.这个是着重想问的。下面几个sql语句怎么走索引，怎么查到之后拿出数据
    题目：建立索引（name，age）主键为id，
    select （id，name, sex） from XX where name like “%AA%”
    select （id，name, sex） from XX where age>10
    select （id，name, sex） from XX where age>10 and name like "AA%"
    第一个不能走索引，因为模糊匹配以%开头
    第二个不能走索引，因为最左匹配原则
    第三个可以走部分索引，因为and两边的条件可以交换，并且name字段的条件没有以%开头
```
#### 13.回表查询和覆盖索引
```markdown
普通索引需要扫描两遍索引树
（1）先通过普通索引定位到主键值id=5；
（2）在通过聚集索引定位到行记录；
这就是所谓的回表查询，先定位主键值，再定位行记录，它的性能较扫一遍索引树更低。
覆盖索引：如果where条件的列和返回的数据在一个索引中，那么不需要回查表，那么就叫覆盖索引。
实现覆盖索引：常见的方法是，将被查询的字段，建立到联合索引里去。
```
#### 14.什么是最左前缀原则？什么是最左匹配原则
```markdown
前缀索引
    语法：index(field(10))，使用字段值的前10个字符建立索引，默认是使用字段的全部内容建立索引。
    前提：前缀的标识度高。比如密码就适合建立前缀索引，因为密码几乎各不相同。
    实操的难度：在于前缀截取的长度。
    我们可以利用select count(*)/count(distinct left(password,prefixLen));
    通过从调整prefixLen的值（从1自增）查看不同前缀长度的一个平均匹配度，接近1时就可以了（表示一个密码的前prefixLen个字符几乎能确定唯一一条记录）
什么是最左前缀原则？什么是最左匹配原则?
最左前缀原则顾名思义，就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。
最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，
    比如a=1 and b=2 and c>3 and d=4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
=和in可以乱序，比如a=1 and b=2 and c=3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式
```
### 7.MySQL数据库优化和查询性能优化【2+】
[SQL优化最干货总结 - MySQL（2020最新版）](https://blog.csdn.net/qq_39390545/article/details/107020686)
#### 1.使用Explain进行分析【5+】
[Explain 执行计划包含字段信息](https://www.cnblogs.com/chengxy-nds/p/12924373.html)

[MySQL SQL Explain输出学习](https://www.cnblogs.com/dbabd/p/10471068.html)

[SQL优化与诊断](https://www.cnblogs.com/kkzhilu/p/13352940.html)
```markdown
Explain用来分析SELECT查询语句，开发人员可以通过分析Explain结果来优化查询语句。判断有没有使用到索引
比较重要的字段有：select_type : 查询类型，有简单查询、联合查询、子查询等,key : 使用的索引,rows : 扫描的行数。
table：显示这一行的数据是关于哪张表的
type：这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、index和ALL
all：full table scan ;MySQL将遍历全表以找到匹配的行；
index: index scan; index 和 all的区别在于index类型只遍历索引；
range：索引范围扫描，对索引的扫描开始于某一点，返回匹配值的行，常见与between ，等查询；
ref：非唯一性索引扫描，返回匹配某个单独值的所有行，常见于使用非唯一索引即唯一索引的非唯一前缀进行查找；
eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常用于主键或者唯一索引扫描；
const，system：当MySQL对某查询某部分进行优化，并转为一个常量时，使用这些访问类型。如果将主键置于where列表中，MySQL就能将该查询转化为一个常量。
possible_keys：显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从WHERE语句中选择一个合适的语句
key：实际使用的索引。如果为NULL，则没有使用索引。很少的情况下，MySQL会选择优化不足的索引。这种情况下，可以在SELECT语句中使用USE INDEX（indexname）来强制使用一个索引或者用IGNORE INDEX（indexname）来强制MySQL忽略索引
key_len：使用的索引的长度。在不损失精确性的情况下，长度越短越好
ref：显示索引的哪一列被使用了，如果可能的话，是一个常数
rows：MySQL认为必须检查的用来返回请求数据的行数
Extra：关于MySQL如何解析查询的额外信息。
```
#### 2.优化数据访问
```markdown
1. 减少请求的数据量
    只返回必要的列：最好不要使用 SELECT * 语句。
    只返回必要的行：使用LIMIT语句来限制返回的数据。
    缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存
    带来的查询性能提升将会是非常明显的。
2. 减少服务器端扫描的行数
    最有效的方式是使用索引来覆盖查询。
```
#### 3.重构查询方式
```markdown
1. 切分大查询 
    一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。
2. 分解大连接查询    
    将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：
    让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。
    分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。减少锁竞争；
    在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。
    查询本身效率也可能会有所提升。例如下面的例子中，使用IN()代替连接查询，可以让MySQL按照ID顺序进行查询，这可能比随机的连接要更高效。
```
#### 1.MySQL数据库优化
```markdown
优化成本：硬件>系统配置>数据库表结构>SQL 及索引。
优化效果：硬件<系统配置<数据库表结构<SQL 及索引。
对于MySQL层优化我一般遵从五个原则：
    1.减少数据访问：设置合理的字段类型，启用压缩，通过索引访问等减少磁盘 IO。
    2.返回更少的数据：只返回需要的字段和数据分页处理，减少磁盘 IO 及网络 IO。
    3.减少交互次数：批量 DML 操作，函数存储等减少数据连接次数。
    4.减少服务器 CPU 开销：尽量减少数据库排序操作以及全表查询，减少 CPU 内存占用。
    5.利用更多资源：使用表分区，可以增加并行操作，更大限度利用 CPU 资源。
总结到SQL优化中，就如下三点：
    1.最大化利用索引。
    2.尽可能避免全表扫描。
    3.减少无效数据的查询。
```
#### 2.SQL优化策略适用于数据量较大的场景下
```markdown
1.避免不走索引的场景
    ①尽量避免在字段开头模糊查询，会导致数据库引擎放弃索引进行全表扫描 
        SELECT * FROM t WHERE username LIKE '%陈%'
        优化方式：尽量在字段后面使用模糊查询。SELECT * FROM t WHERE username LIKE '陈%'
        如果需求是要在前面使用模糊查询：
        1.使用MySQL内置函数INSTR（str，substr）来匹配，作用类似于Java中的indexOf()，查询字符串出现的角标位置。
        2.使用FullText全文索引，用match against检索。
        3.数据量较大的情况，建议引用ElasticSearch、Solr，亿级数据量检索速度秒级。
        4.当表数据量较少（几千条儿那种），别整花里胡哨的，直接用like '%xx%'。
    ②尽量避免使用 in 和 not in，会导致引擎走全表扫描
        SELECT * FROM t WHERE id IN (2,3)
        优化方式：如果是连续数值，可以用 between 代替。SELECT * FROM t WHERE id BETWEEN 2 AND 3
        如果是子查询，可以用 exists 代替。
            -- 不走索引
            select * from A where A.id in (select id from B);
            -- 走索引
            select * from A where exists (select * from B where B.id = A.id);
    ③尽量避免使用 or，会导致数据库引擎放弃索引进行全表扫描
        SELECT * FROM t WHERE id = 1 OR id = 3
        优化方式：可以用 union 代替 or。
        SELECT * FROM t WHERE id = 1 UNION SELECT * FROM t WHERE id = 3
    ④尽量避免进行 null 值的判断，会导致数据库引擎放弃索引进行全表扫描
        SELECT * FROM t WHERE score IS NULL
        优化方式：可以给字段添加默认值 0，对 0 值进行判断。
        SELECT * FROM t WHERE score = 0
    ⑤尽量避免在 where 条件中等号的左侧进行表达式、函数操作，会导致数据库引擎放弃索引进行全表扫描
        可以将表达式、函数操作移动到等号右侧，如下：
           -- 全表扫描
           SELECT * FROM T WHERE score/10 = 9
           -- 走索引
           SELECT * FROM T WHERE score = 10*9 
    ⑥当数据量大时，避免使用 where 1=1 的条件
        通常为了方便拼装查询条件，我们会默认使用该条件，数据库引擎会放弃索引进行全表扫描。
        SELECT username, age, sex FROM T WHERE 1=1
        优化方式：用代码拼装 SQL 时进行判断，没 where 条件就去掉 where，有 where 条件就加 and。
    ⑦查询条件不能用 <> 或者 !=
        使用索引列作为条件进行查询时，需要避免使用<>或者!=等判断条件。
        如确实业务需要，使用到不等于符号，需要在重新评估索引建立，避免在此字段上建立索引，改由查询条件中其他索引字段代替。
    ⑧where 条件仅包含复合索引非前置列
        如下：复合（联合）索引包含 key_part1，key_part2，key_part3三列，但SQL语句没有包含索引前置列"key_part1"，
            按照MySQL联合索引的最左匹配原则，不会走联合索引。
        select col1 from table where key_part2=1 and key_part3=2
    ⑨隐式类型转换造成不使用索引
        如下SQL语句由于索引对列类型为varchar，但给定的值为数值，涉及隐式类型转换，造成不能正确走索引。
        select col1 from table where col_varchar=123; 
    ⑩order by 条件要与 where 中条件一致，否则 order by 不会利用索引进行排序
        -- 不走age索引
        SELECT * FROM t order by age;
        -- 走age索引
        SELECT * FROM t where age > 0 order by age;
```
#### 3.SELECT 语句其他优化
```markdown
①避免出现 select *
②避免出现不确定结果的函数
③多表关联查询时，小表在前，大表在后
④使用表的别名
⑤用 where 字句替换 HAVING 字句
⑥调整 Where 字句中的连接顺序
```
#### 4.增删改DML语句优化
```markdown
①大批量插入数据
②适当使用 commit
③避免重复查询更新的数据
④查询优先还是更新（insert、update、delete）优先
```
#### 5.查询条件优化
```markdown
①对于复杂的查询，可以使用中间临时表暂存数据
②优化 group by 语句
③优化 join 语句
④优化 union 查询
⑤拆分复杂 SQL 为多个小 SQL，避免大事务
⑥使用 truncate 代替 delete
⑦使用合理的分页方式以提高分页效率
```
#### 6.建表优化
```markdown
①在表中建立索引，优先考虑 where、order by 使用到的字段。
②尽量使用数字型字段（如性别，男：1 女：2），若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。
这是因为引擎在处理查询和连接时会 逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。
③查询数据量大的表 会造成查询缓慢。主要的原因是扫描行数过多。这个时候可以通过程序，分段分页进行查询，循环遍历，将结果合并处理进行展示。
要查询 100000 到 100050 的数据，如下：
SELECT * FROM (SELECT ROW_NUMBER() OVER(ORDER BY ID ASC) AS rowid,* 
   FROM infoTab)t WHERE t.rowid > 100000 AND t.rowid <= 100050
④用 varchar/nvarchar 代替 char/nchar。
尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。
不要以为NULL不需要空间，比如：char(100) 型，在字段建立时，空间就固定了， 不管是否插入值（NULL 也包含在内），都是占用100个字符的空间的，如果是varchar这样的变长字段，null不占用空间。
```
### 8.存储引擎【10+】
#### 1.InnoDB
```markdown
- 存储引擎说⽩了就是如何存储数据、如何为存储的数据建⽴索引和如何更新、查询数据等技术的实现⽅法
**InnoDB**是MySQL默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。
实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。
    在可重复读隔离级别下，通过多版本并发控制MVCC+间隙锁Next-KeyLocking防止幻影读。
    主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。
    内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。
    支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。
InnoDB存储引擎的锁的算法有三种：
    - Record lock: 单个行记录上的锁。
    - Gap lock : 间隙锁，锁定yoga范围，不包括记录本身。（目的是阻止多个事务将记录插入到同一个范围内，会导致幻读）
    - Next-key lock: record + gap锁定一个范围，包含记录本身。
InnoDB采用Next-Key Lock解决幻读问题。在insert into test(xid) values (1), (3), (5), (8), (11);后，
    由于xid上是有索引的，该算法总是会去锁住索引记录。现在，该索引可能被锁住的范围如下：(-∞,1],(1,3],(3,5],(5,8],(8,11],(11,+∞)。
    Session A（select * from test where id = 8 for update）执行后会锁住的范围：(5,8], (8,11]。除了锁住8所在的范围，还会锁住下一个范围，所谓Next-Key。
InnoDB的关键特性
    1.插入缓冲：对于非聚集索引的插入或更新操作，不是每一次直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，若在，则直接插入；
        若不在，则先放入到一个Insert Buffer对象中。然后再以一定的频率和情况进行Insert Buffer和辅助索引页子节点的merge（合并）操作，
        这时通常能将多个插入合并到一个操作中（因为在一个索引页中），这就大大提高了对于非聚集索引插入的性能。
    2.两次写：两次写带给InnoDB存储引擎的是数据页的可靠性，有经验的DBA也许会想，如果发生写失效，可以通过重做日志进行恢复。
        这是一个办法。但是必须清楚地认识到，如果这个页本身已经发生了损坏（物理到page页的物理日志成功页内逻辑日志失败），再对其进行重做是没有意义的。
        这就是说，在应用（apply）重做日志前，用户需要一个页的副本，当写入失效发生时，先通过页的副本来还原该页，再进行重做。
        在对缓冲池的脏页进行刷新时，并不直接写磁盘，而是会通过memcpy函数将脏页先复制到内存中的doublewrite buffer，
        之后通过doublewrite buffer再分两次，每次1MB顺序地写入共享表空间的物理磁盘上，这就是doublewrite。
    3.自适应哈希索引：InnoDB存储引擎会监控对表上各索引页的查询。如果观察到建立哈希索引可以带来速度提升，则建立哈希索引，称之为自适应哈希索引。
    4.异步IO：为了提高磁盘操作性能，当前的数据库系统都采用异步IO（AIO）的方式来处理磁盘操作。AIO的另一个优势是可以进行IO Merge操作，也就是将多个IO合并为1个IO，这样可以提高IOPS的性能。
    5.刷新邻接页：当刷新一个脏页时，InnoDB存储引擎会检测该页所在区（extent）的所有页，如果是脏页，那么一起进行刷新。
        这样做的好处显而易见，通过AIO可以将多个IO写入操作合并为一个IO操作，故该工作机制在传统机械磁盘下有着显著的优势。
```
#### 2.MyISAM
```markdown
**MyISAM**:设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。
    提供了大量的特性，包括压缩表、空间数据索引等。
    不支持事务。不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。
    但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。
    可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。
    如果指定了DELAY_KEY_WRITE选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，
    只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，
    但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。
**3.为什么myisam读比较快**
```
#### 3.InnoDB和MyISAM比较区别
```markdown
**InnoDB和MyISAM比较**
    事务：InnoDB是事务型的，可以使用Commit和Rollback语句。MyISAM不支持事务。
    并发：MyISAM只支持表级锁，而InnoDB默认行级锁还支持表级锁。锁定力度小并发能力高。
    外键：InnoDB支持外键。MyISAM不支持
    索引：B+树索引，myisam是堆表，支持全文索引，不支持哈希索引。B+树索引，Innodb是索引组织表，支持哈希索引，不支持全文索引。
    备份：InnoDB支持在线热备份。
    崩溃恢复：MyISAM崩溃后发生损坏的概率比InnoDB高很多，而且恢复的速度也更慢。
    记录存储顺序:MyISAM按记录插入顺序保存,InnoDB:按主键大小有序插入
    存储结构：MyISAM每张表被存放在三个文件：frm-表格定义、MYD(MYData)-数据文件、MYI(MYIndex)-索引文件	
            InnoDB所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB
    存储空间：MyISAM可被压缩，存储空间较小。InnoDB的表需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引
    可移植性、备份及恢复：由于MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作	
        InnoDB免费的方案可以是拷贝数据文件、备份binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了
    文件格式:MyISAM数据和索引是分别存储的，数据.MYD，索引.MYI	InnoDB数据和索引是集中存储的，.ibd
    SELECT	MyISAM更优	INSERT、UPDATE、DELETE		InnoDB更优
    select count(*)	myisam更快，因为myisam内部维护了一个计数器，可以直接调取。
MyISAM适合的场景：频繁执行全表count语句；对数据进行增删改的频率不高，查询非常频繁；没有事务；
InnoDB适合的场景：数据增删查改都非常否频繁；可靠性要求比较高，要求支持事务。
memory(heap)：这种类型的数据表只存在于内存中。它使⽤散列索引，所以数据的存取速度⾮常快。因为是存在于内存中，所以这种类型常应⽤于临时表中。
archive：这种类型只⽀持select 和 insert语句，⽽且不⽀持索引。
    Desc[ribe] tablename：查看数据表的结构。
    show engines：命令可以显示当前数据库⽀持的存储引擎情况
在一张自增表里面总共有7条数据，删除最后两条之后，重启数据库又插入了一条数据，id为几？
    表的存储引擎为InnoDB,那么id就是6.如果表的存储引擎是MyISAM,那么id就是8.
    InnoDB存储引擎会把自增的最大id记录在内存中，重启之后会导致最大id丢失。
    如果不重启数据库InnoDB存储引擎插入的id也为8。
```
#### 4.InnoDB和MyISAM中的索引类型
[参考文献：聊一聊InnoDB引擎中的索引类型](https://www.cnblogs.com/jamaler/p/12222176.html)
[B-Tree和B+Tree结构及应用，InnoDB引擎， MyISAM引擎](https://www.cnblogs.com/ITnoteforlsy/p/12228149.html)  
```markdown
在InnoDB引擎中有三,在InnoDB引擎中使用B+树来实现B-Tree索引种索引：
    B-Tree 索引 
    哈希索引
    全文索引
B-Tree索引是InnoDB引擎的默认索引,在InnoDB引擎中使用 B+树来实现 B-Tree 索引.
    B-Tree 索引中又有主键索引和普通索引
        主键索引也叫聚集索引，是按照主键构建得一棵B+树，只要建立了主键就会自动加上索引，
        主键索引得特点是：叶子节点上存放着整张表的行记录数据，所以叶子节点也叫数据页。
        普通索引也叫二级索引，跟主键索引的主要区别在于叶子结点没有存放行记录的全部数据，
        只包含了需要的键值，还有一个标签，用来告诉存储引擎在哪里可以找到这行数据。
        普通索引因为行记录里没有数据的全部信息，在使用普通索引查询时，需要现在普通索引树上搜索一遍，再回到主键索引树上查询到需要的信息，这个过程也叫回表。
    每一张表其实就是多个B+树，树结点的key值就是某一行的主键，value是该行的其他数据。新建索引就是新增一个B+树，查询不走索引就是遍历主B+树。
InnoDB索引是聚簇索引，MyISAM索引是非聚簇索引。
InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。
MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。
InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。
```
#### 5.InnoDB引擎中的这些索引策略
[参考文献：聊一聊 InnoDB 引擎中的这些索引策略](https://www.cnblogs.com/jamaler/p/12239558.html)
```markdown
覆盖索引:是指在普通索引树中可以得到查询的结果，不需要在回到主键索引树中再次搜索。
    减少树的搜索次数，显著提升查询性能。
    索引是按照值的顺序存储，所以对于I/O密集型的范围查询比随机从磁盘中读取每一行的I/O要少很多。
    索引的条目远小于数据的条目，在索引树上读取会极大的减小数据库的访问量。
最左前缀原则:是建立在联合索引之上的，如果我们建立了联合索引，我们不需要使用索引的全部定义，
只要用到了索引中的最左边的那个字段就可以使用这个索引，这就是B-tree索引支持最左前缀原则。
索引下推优化:是MySQL5.6引入的，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。
```
#### 6.其他的存储引擎
```markdown
1.InnoDB存储引擎：InnoDB存储引擎支持事务，其设计目标主要面向在线事务处理（OLTP）的应用。
    其特点是行锁设计，支持外键，并支持非锁定锁，即默认读取操作不会产生锁。从Mysql5.5.8版本开始，InnoDB存储引擎是默认的存储引擎。
2.MyISAM存储引擎：MyISAM存储引擎不支持事务、表锁设计，支持全文索引，主要面向一些OLAP数据库应用。
    InnoDB的数据文件本身就是主索引文件，而MyISAM的主索引和数据是分开的。
3.NDB存储引擎：NDB存储引擎是一个集群存储引擎，其结构是share nothing的集群架构，能提供更高的可用性。
    NDB的特点是数据全部放在内存中（从MySQL 5.1版本开始，可以将非索引数据放在磁盘上），因此主键查找的速度极快，
    并且通过添加NDB数据存储节点可以线性地提高数据库性能，是高可用、高性能的集群系统。
    NDB存储引擎的连接操作是在MySQL数据库层完成的，而不是在存储引擎层完成的。
    这意味着，复杂的连接操作需要巨大的网络开销，因此查询速度很慢。如果解决了这个问题，NDB存储引擎的市场应该是非常巨大的。
4.Memory存储引擎：Memory存储引擎（之前称HEAP存储引擎）将表中的数据存放在内存中，如果数据库重启或发生崩溃，表中的数据都将消失。
    它非常适合用于存储临时数据的临时表，以及数据仓库中的纬度表。
    Memory存储引擎默认使用哈希索引，而不是我们熟悉的B+树索引。
    虽然Memory存储引擎速度非常快，但在使用上还是有一定的限制。
    比如，只支持表锁，并发性能较差，并且不支持TEXT和BLOB列类型。
    最重要的是，存储变长字段时是按照定常字段的方式进行的，因此会浪费内存。
5.Archive存储引擎：Archive存储引擎只支持INSERT和SELECT操作，从MySQL 5.1开始支持索引。
    Archive存储引擎使用zlib算法将数据行（row）进行压缩后存储，压缩比一般可达1∶10。
    正如其名字所示，Archive存储引擎非常适合存储归档数据，如日志信息。
    Archive存储引擎使用行锁来实现高并发的插入操作，但是其本身并不是事务安全的存储引擎，其设计目标主要是提供高速的插入和压缩功能。
6.Maria存储引擎：Maria存储引擎是新开发的引擎，设计目标主要是用来取代原有的MyISAM存储引擎，从而成为MySQL的默认存储引擎。它可以看做是MyISAM的后续版本。
    Maria存储引擎的特点是：支持缓存数据和索引文件，应用了行锁设计，提供了MVCC功能，支持事务和非事务安全的选项，以及更好的BLOB字符类型的处理性能。
```
### 9.存储过程——游标
[面试官突然问我MySQL存储过程，我竟然连基础都不会！（详细）](https://www.cnblogs.com/ziph/p/13090117.html)
```markdown
存储过程（Stored Procedure）是在大型数据库系统中，一组为了完成特定功能的SQL语句集，
    它存储在数据库中，一次编译后永久有效，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。
存储过程是数据库中的一个重要对象。在数据量特别庞大的情况下利用存储过程能达到倍速的效率提升。
    i.存储过程的创建语句：create procedure procedure_name([存储过程的参数列表])
                    Begin
                        Sql语句
                    End
    ii.调用存储过程：call procedure_name([parameter])
    iii.查看存储过程：show statue
当我们了了解存储过程是什么之后，就需要了解数据库中存在的这三种类型的数据库存储类型程序，如下：
    存储过程：存储过程是最常见的存储程序，存储过程是能够接受输入和输出参数并且能够在请求时被执行的程序单元。
    存储函数：存储函数和存储过程很相像，但是它的执行结果会返回一个值。最重要的是存储函数可以被用来充当标准的SQL语句，允许程序员有效的扩展SQL语言的能力。
    触发器：触发器是用来响应激活或者触发数据库行为事件的存储程序。通常，触发器用来作为数据库操作语言的响应而被调用，触发器可以被用来作为数据校验和自动反向格式化。
注意：其他的数据库提供了别的数据存储程序，包括包和类。目前MySQL不提供这种结构。
优点
    1）存储过程是预编译过的，执行效率高。
    2）存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。
    3）安全性高，执行存储过程需要有一定权限的用户。
    4）存储过程可以重复使用，减少数据库开发人员的工作量。
缺点
    1）调试麻烦，但是用PL/SQL Developer调试很方便！弥补这个缺点。
    2）移植问题，数据库端代码当然是与数据库相关的。但是如果是做工程型项目，基本不存在移植问题。
    3）重新编译问题，因为后端代码是运行前编译的，如果带有引用关系的对象发生改变时，受影响的存储过程、包将需要重新编译（不过也可以设置成运行时刻自动编译）。
    4）如果在一个程序系统中大量的使用存储过程，到程序交付使用的时候随着用户需求的增加会导致数据结构的变化，接着就是系统的相关问题了，
        最后如果用户想维护该系统可以说是很难很难、而且代价是空前的，维护起来更麻烦。
```
[存储过程——游标](https://www.cnblogs.com/shanzhiming/p/12975175.html)
```markdown
SQL游标(cursor)是一个数据库对象，用于从结果集中检索某一行的数据。
游标是系统为用户开设的一个数据缓冲区，存放SQL语句的执行结果。每个游标区都有一个名字,用户可以用SQL语句逐一从游标中获取记录，
    并赋给主变量，交由主语言进一步处理。在编程中，我们使用诸如for或while之类的循环一次遍历一项，游标遵循相同的方法。
    当在SQL中，应用程序逻辑需要一次只处理一行，而不是一次处理整个结果集。可以使用游标完成此操作。
```
### 10.MySQL触发器
```markdown
触发器（trigger）是MySQL提供给程序员和数据分析员来保证数据完整性的一种方法，它是与表事件相关的特殊的存储过程，
    它的执行不是由程序调用，也不是手工启动，而是由事件来触发，比如当对一个表进行操作（insert，delete， update）时就会激活它执行。
    简单理解为：你执行一条sql语句，这条sql语句的执行会自动去触发执行其他的sql语句。
触发器的作用：
    可在写入数据表前，强制检验或转换数据。
    触发器发生错误时，异动的结果会被撤销。
    部分数据库管理系统可以针对数据定义语言（DDL）使用触发器，称为DDL触发器。
    可依照特定的情况，替换异动的指令 (INSTEAD OF)。
触发器也是存储过程程序的一种，而触发器内部的执行SQL语句是可以多行操作的，所以在MySQL的存储过程程序中，要定义结束符。
MySQL表中允许有多少个TRIGGERS？
    在MySQL表中允许有六个触发器，如下：
    BEFORE INSERT
    AFTER INSERT
    BEFORE UPDATE
    AFTER UPDATE
    BEFORE DELETE and
    AFTER DELETE
```
### 11.主从复制【2+】
[聊聊MySQL主从复制的几种复制方式](https://www.cnblogs.com/itbsl/p/13507401.html)
[mycat数据库集群系列之mysql主从同步设置](https://www.cnblogs.com/xiaoXuZhi/p/xyh_mysqlMasterSlaveSet.html)
```markdown
通过主从复制的方式来同步数据：从原来的数据库复制一个完全一样的数据库，原来的数据库称作主数据库，复制的数据库称为从数据库。
主从复制的原理:通过binlog日志实现的。
    主库将变更写binlog日志，然后从库连接到主库后，从库有一个IO线程，将主库的binlog日志拷贝到自己本地，写入一个中继日志中，
    接着从库中有一个sql线程会从中继日志读取binlog，然后执行binlog日志中的内容，也就是在自己本地再执行一遍sql，这样就可以保证自己跟主库的数据一致。
    半同步复制：semi-sync复制，指的就是主库写入binlog日志后，就会将强制此时立即将数据同步到从库，从库将日志写入自己本地的relay log之后，
        接着会返回一个ack给主库，主库接收到至少一个从库ack之后才会认为写完成。
    并发复制：指的是从库开启多个线程，并行读取relay log中不同库的日志，然后并行重放不同库的日志，这样库级别的并行。（将主库分库也可缓解延迟问题）
主从复制的过程：
     在每个事务更新数据完成之前，master在二进制日志记录这些改变。写入二进制日志完成后，master通知存储引擎提交事务。
     Slave将master的binary log复制到其中继日志。首先slave开始一个工作线程（I/O），I/O线程在master上打开一个普通的连接，
    然后开始binlog dump process。从master的二进制日志中读取事件，如果已经跟上master，它会睡眠并等待master产生新的事件，I/O线程将这些事件写入中继日志。
     Sql slave thread（sql从线程）处理该过程的最后一步，sql线程从中继日志读取事件，并重放其中的事件而更新slave数据，
    使其与master中的数据一致，只要该线程与I/O线程保持一致，中继日志通常会位于os缓存中，所以中继日志的开销很小。
主要涉及三个线程：binlog线程、I/O线程和SQL线程。
    binlog 线程：负责将主服务器上的数据更改写入二进制日志（Bin log）中。
    I/O线程 ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。
    SQL执行线程 ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。
MySQL主从复制的几种实现方式
    异步复制：MySQL的复制默认是异步的，
    多线程复制：在MySQL5.7中，带来了全新的多线程复制技术，解决了当master同一个schema下的数据发生了变更，从库不能并发应用的问题，
        同时也真正将binlog组提交的优势充分发挥出来，保障了从库并发应用Relay Log的能力。
    增强半同步复制：为了保证主库上的每一个BINLOG事务都能够被可靠地复制到从库上，主库在每次事务成功提交时，并不及时反馈给前端应用用户，
        而是等待至少一个从库(详见参数rpl_semi_sync_master_wait_for_slave_count)也接收到BINLOG事务并成功写入中继日志后，主库才返回Commit操作成功给客户端
        半同步复制保证了事务成功提交后，至少有两份日志记录，一份在主库的BINLOG日志上，另一份在至少一个从库的中继日志Relay Log上，从而更进一步保证了数据的完整性。
```
### 12.读写分离【2+】
[提高性能，MySQL 读写分离环境搭建](https://www.cnblogs.com/lenve/p/10855172.html)-- [基于Mycat实现读写分离](https://www.cnblogs.com/atcloud/p/10789850.html)
-- [Mycat → 实现数据库的读写分离与高可用](https://www.cnblogs.com/youzhibing/p/9553766.html)
```markdown
读写分离是依赖于主从复制，而主从复制又是为读写分离服务的。因为主从复制要求slave不能写只能读（如果对slave执行写操作，
那么show slave status将会呈现Slave_SQL_Running=NO，此时你需要按照前面提到的手动同步一下slave）。
主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。读写分离能提高性能的原因在于：
    - 主从服务器负责各自的读和写，极大程度缓解了锁的争用；
    - 从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；
    - 增加冗余，提高可用性。
读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。
    方案一：使用mysql-proxy代理
        优点：直接实现读写分离和负载均衡，不用修改代码，master和slave用一样的帐号，mysql官方不建议实际生产中使用
        缺点：降低性能， 不支持事务
    方案二：使用AbstractRoutingDataSource+aop+annotation在dao层决定数据源。
        - 如果采用了mybatis，可以将读写分离放在ORM层，比如mybatis可以通过mybatis plugin拦截sql语句，
        所有的insert/update/delete都访问master库，所有的select 都访问salve库，这样对于dao层都是透明。
        plugin实现时可以通过注解或者分析语句是读写方法来选定主从库。不过这样依然有一个问题，也就是不支持事务，
        所以我们还需要重写一下DataSourceTransactionManager，将read-only的事务扔进读库，其余的有读有写的扔进写库。
    方案三：使用AbstractRoutingDataSource+aop+annotation在service层决定数据源，
        可以支持事务.
        缺点：类内部方法通过this.xx()方式相互调用时，aop不会进行拦截，需进行特殊处理。
```
### 13.MySQL日志【2+】
[超干货！为了让你彻底弄懂MySQL事务日志，我通宵肝出了这份图解！](https://www.cnblogs.com/AmazingJiang/p/13034409.html)
```markdown
MySQL日志系统是数据库的重要组件，用于记录数据库的更新和修改。若数据库发生故障，可通过不同日志记录恢复数据库的原来数据。
    因此实际上日志系统直接决定着MySQL运行的鲁棒性和稳健性。
MySQL的日志有很多种，如二进制日志（binlog）、错误日志、查询日志、慢查询日志等，
    此外InnoDB存储引擎还提供了两种日志：redolog（重做日志）和undolog（回滚日志）。
    这里将重点针对InnoDB引擎，对重做日志、回滚日志和二进制日志这三种进行分析。
undoLog回滚日志文件 主要用于事务中执行失败，进行回滚，以及MVCC中对于数据历史版本的查看。
    由引擎层的InnoDB引擎实现,是逻辑日志,记录数据修改被修改前的值,比如"把id='B'修改为id ='B2'，那么undo日志就会用来存放id ='B'的记录”。
    当一条数据需要更新前,会先把修改前的记录存储在undolog中,如果这个修改出现异常,,则会使用undo日志来实现回滚操作,保证事务的一致性。
    当事务提交之后，undo log并不能立马被删除,而是会被放到待清理链表中,待判断没有事物用到该版本的信息时才可以清理相应undolog。
    它保存了事务发生之前的数据的一个版本，用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读。
redoLog是重做日志文件是记录数据修改之后的值，用于持久化到磁盘中。
    redo log包括两部分：一是内存中的日志缓冲(redo log buffer)，该部分日志是易失性的；二是磁盘上的重做日志文件(redo log file)，该部分日志是持久的。
    由引擎层的InnoDB引擎实现,是物理日志,记录的是物理数据页修改的信息,比如“某个数据页上内容发生了哪些改动”。
    当一条数据需要更新时,InnoDB会先将数据更新，然后记录redoLog 在内存中，然后找个时间将redoLog的操作执行到磁盘上的文件上。
    不管是否提交成功我都记录，你要是回滚了，那我连回滚的修改也记录。它确保了事务的持久性。
    每个InnoDB存储引擎至少有1个重做日志文件组（group），每个文件组下至少有2个重做日志文件，如默认的ib_logfile0和ib_logfile1。
    为了得到更高的可靠性，用户可以设置多个的镜像日志组（mirrored log groups），将不同的文件组放在不同的磁盘上，以此提高重做日志的高可用性。
    在日志组中每个重做日志文件的大小一致，并以循环写入的方式运行。
    InnoDB存储引擎先写重做日志文件1，当达到文件的最后时，会切换至重做日志文件2，再当重做日志文件2也被写满时，会再切换到重做日志文件1中。
binlog是记录所有数据库表结构变更（例如CREATE、ALTER TABLE…）以及表数据修改（INSERT、UPDATE、DELETE…）的二进制日志。
    binlog不会记录SELECT和SHOW这类操作，因为这类操作对数据本身并没有修改，但你可以通过查询通用日志来查看MySQL执行过的所有语句。
    二进制日志包括两类文件：
        - 索引文件（文件名后缀为.index）用于记录哪些日志文件正在被使用
        - 日志文件（文件名后缀为.00000*）记录数据库所有的DDL和DML(除了数据查询语句)语句事件。
    在my.cnf中有这么三条配置
        - log_bin：on 打开binlog日志
        - log_bin_basename：bin文件路径及名前缀（/var/log/mysql/mysql-bin）
        - log_bin_index：bin文件index（/var/log/mysql/mysql-bin.index）
    用途：恢复、复制、审计。
    MySQL的binlog有有几种录入格式？分别有什么区别？有三种格式，statement，row和mixed。
    1、statement模式下，每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。
    由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。
    2、row级别下，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，
    会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大。
    3、mixed，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。
    此外，新版的MySQL中对row级别也做了一些优化，当表结构发生变化的时候，会记录语句而不是逐行记录。
```
### 14.MySQL分库分表【2+】
[MySql分库分表与分区的区别和思考](https://www.cnblogs.com/GrimMjx/p/11772033.html)
[MyCat实现MySQL分库分表来了](https://www.cnblogs.com/fkaka/p/13516475.html)
```markdown
当一张表随着时间和业务的发展，库里表的数据量会越来越大。数据操作也随之会越来越大。一台物理机的资源有限，
最终能承载的数据量、数据的处理能力都会受到限制。这时候就会使用分库分表来承接超大规模的表，单机放不下的那种。
区别于分区的是，分区一般都是放在单机里的，用的比较多的是时间范围分区，方便归档。
只不过分库分表需要代码实现，分区则是mysql内部实现。分库分表和分区并不冲突，可以结合使用。
既然分库分表了，那么肯定涉及到分布式事务，如何保证插入到不同库的多条记录能够要么同时成功，要么同时失败。
```
### 15.MySQL备份与主备配置
[MySQL备份与主备配置](https://www.cnblogs.com/jxtxzzw/p/10844462.html)
```markdown
数据备份类型
    全量备份：备份整个数据库(全量备份的方法有 2 种，一种是利用数据库管理工具提供的备份恢复和导入导出功能)
    增量备份：备份自上一次备份以来（增量或完全）以来变化的数据。(binlog用于记录用户对数据库更新的SQL语句信息)
    差异备份：备份自上一次完全备份以来变化的数据
必须要在未登录状态下
* 导出整个数据库 mysqldump -u ⽤户名 -p 数据库名 > 导出的⽂件名
* 导出⼀个表 mysqldump -u ⽤户名 -p 数据库名 表名> 导出的⽂件名
* 导出⼀个数据库结构 mysqldump -u dbuser -p -d --add-drop-table dbname >d:/dbname_db.sql
    -d 没有数据 --add-drop-table 在每个create语句之前增加⼀个drop table
```
### 16.MySQL运维
[聊聊数据库~5.SQL运维上篇](https://www.cnblogs.com/dotnetcrazy/p/10810798.html)
[聊聊数据库~6.SQL运维中篇](https://www.cnblogs.com/dotnetcrazy/p/11029323.html)
### 17.Having作用
```markdown
来过滤由GROUP BY语句返回的记录集(对分组后结果过滤，可以使用聚合函数如(max、min))
SELECT id, COUNT(course) as numcourse, AVG(score) as avgscore
FROM student
GROUP BY id
HAVING AVG(score)>=80;
```
### 18.通⽤SQL函数
```markdown
数学函数
    Abs（num）求绝对值
    floor（num）向下取整
    ceil（num）向上取整
字符串函数
    insert (s1,index,length,s2) 替换函数
        S1表示被替换的字符串
        s2表示将要替换的字符串
        Index表示被替换的位置,从1开始
        Lebgth表示被替换的⻓度
    upper（str），ucase（str）将字⺟改为⼤写
    lower（str），lcase（str）将字⺟改为⼩写
    left（str，length）返回str字符串的前length个字符
    right（str，length）返回str字符串的后length个字符
    substring（str，index，length）返回str字符串从index位开始⻓度为length个字符（index从1开始）
    reverse（str）将str字符串倒序输出
⽇期函数
    curdate（）、current_date( )获取当前⽇期
    curtime（）、current_time( )获取当前⽇期
    now（）获取当前⽇期和时间
    datediff（d1、d2）d1和d2之间的天数差
    adddate（date，num）返回date⽇期开始，之后num天的⽇期
    subdate（date，num）返回date⽇期开始，之前num天的⽇期
聚合函数
    Count（字段）根据某个字段统计总记录数（当前数据库保存到多少条数据）
    sum（字段）计算某个字段的数值总和
    avg（字段）计算某个字段的数值的平均值
    Max（字段）、min（字段）求某个字段最⼤或最⼩值
```
### 19.left join和inner join的区别，嵌套子查询如何优化。数据库表的连接【5+】
```markdown
inner join把匹配的关联数据显示出来；left join把左边的表全部显示出来，右边的表显示出符合条件的数据，right join正好相反。
SELECT a.,b. FROM luntan LEFT JOIN usertable as b ON a.username=b.username
交叉连接（CROSS JOIN） 生成笛卡尔积
内连接（INNER JOIN）
外连接（LEFT JOIN/RIGHT JOIN）
联合查询（UNION与UNION ALL）
全连接（FULL JOIN）
交叉连接（CROSS JOIN）
内连接分为三类
    等值连接：ON A.id=B.id
    不等值连接：ON A.id > B.id
    自连接：SELECT * FROM A T1 INNER JOIN A T2 ON T1.id=T2.pid
外连接（LEFT JOIN/RIGHT JOIN）
    左外连接：LEFT OUTER JOIN, 以左表为主，先查询出左表，按照ON后的关联条件匹配右表，没有匹配到的用NULL填充，可以简写成LEFT JOIN
    右外连接：RIGHT OUTER JOIN, 以右表为主，先查询出右表，按照ON后的关联条件匹配左表，没有匹配到的用NULL填充，可以简写成RIGHT JOIN
联合查询（UNION与UNION ALL）
    SELECT * FROM A UNION SELECT * FROM B UNION ...
    就是把多个结果集集中在一起，UNION前的结果为基准，需要注意的是联合查询的列数要相等，相同的记录行会合并
    如果使用UNION ALL，不会合并重复的记录行
    效率 UNION 高于 UNION ALL
全连接（FULL JOIN）
    MySQL不支持全连接
    可以使用LEFT JOIN 和UNION和RIGHT JOIN联合使用
    SELECT * FROM A LEFT JOIN B ON A.id=B.id UNIONSELECT * FROM A RIGHT JOIN B ON A.id=B.id
```
### 20.视图
```markdown
1. 为什么要使用视图？什么是视图？
为了提高复杂SQL语句的复用性和表操作的安全性，MySQL数据库管理系统提供了视图特性。所谓视图，本质上是一种虚拟表，在物理上是不存在的，其内容与真实的表相似，包含一系列带有名称的列和行数据。
但是，视图并不在数据库中以储存的数据值形式存在。行和列数据来自定义视图的查询所引用基本表，并且在具体引用视图时动态生成。
视图使开发者只关心感兴趣的某些特定数据和所负责的特定任务，只能看到视图中所定义的数据，而不是视图所引用表中的数据，从而提高了数据库中数据的安全性。
2. 视图有哪些特点？
视图的特点如下:
    视图的列可以来自不同的表，是表的抽象和在逻辑意义上建立的新关系。
    视图是由基本表(实表)产生的表(虚表)。
    视图的建立和删除不影响基本表。
    对视图内容的更新(添加，删除和修改)直接影响基本表。
    当视图来自多个基本表时，不允许添加和删除数据。
    视图的操作包括创建视图，查看视图，删除视图和修改视图。
3. 视图的使用场景有哪些？
视图根本用途：简化sql查询，提高开发效率。如果说还有另外一个用途那就是兼容老的表结构。
下面是视图的常见使用场景：
    重用SQL语句；
    简化复杂的SQL操作。在编写查询后，可以方便的重用它而不必知道它的基本查询细节；
    使用表的组成部分而不是整个表；
    保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限；
    更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。
4. 视图的优点
    查询简单化。视图能简化用户的操作
    数据安全性。视图使用户能以多种角度看待同一数据，能够对机密数据提供安全保护
    逻辑数据独立性。视图对重构数据库提供了一定程度的逻辑独立性
5. 视图的缺点
    性能。数据库必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，数据库也把它变成一个复杂的结合体，需要花费一定的时间。
    修改限制。当用户试图修改视图的某些行时，数据库必须把它转化为对基本表的某些行的修改。事实上，当从视图中插入或者删除时，情况也是这样。
    对于简单视图来说，这是很方便的，但是，对于比较复杂的视图，可能是不可修改的 这些视图有如下特征：
        1.有UNIQUE等集合操作符的视图。2.有GROUP BY子句的视图。3.有诸如AVG\SUM\MAX等聚合函数的视图。
        4.使用DISTINCT关键字的视图。5.连接表的视图（其中有些例外）
6. 什么是游标？
    游标是系统为用户开设的一个数据缓冲区，存放SQL语句的执行结果，每个游标区都有一个名字。用户可以通过游标逐一获取记录并赋给主变量，交由主语言进一步处理。
```
## 优秀的博客文章
### 1.数据库设计
[14 个实用的数据库设计技巧](https://mp.weixin.qq.com/s?__biz=MzUxOTc4NjEyMw==&mid=2247484832&idx=1&sn=2671b8dded66352415eb0aaab9065de0&chksm=f9f51e44ce829752344c6e92a54340f23ebe2ccfe19f8d2bfa46ae2ff261a9873137beee18a0&mpshare=1&scene=23&srcid=&sharer_sharetime=1568260711776&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
```markdown

```
[浅析实际项目中对数据库设计的一些思考](https://www.cnblogs.com/Kevin-ZhangCG/p/10270996.html)
[数据库状态标识位flag设计](https://www.cnblogs.com/gouyg/p/mysql-flag-php.html)
### 1.埋在MySQL数据库应用中的17个关键问题！
[埋在MySQL数据库应用中的17个关键问题！](https://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247487762&idx=1&sn=dc71279f36959b62b63b48108cf8dca3&chksm=e9c5e8a3deb261b5e755d3ace7f2e4c6d69ac20e2510a2f7bd7a32adaf1413b053e3ab411aa7&mpshare=1&scene=23&srcid=1204BeiYSpXyUpL3fQ6wUW0P#rd)
```markdown
MySQL的一些问题：性能优化、高可用性、强一致性、安全、备份、集群、横向扩展、纵向扩展、负载均衡、读写分离等
一：单Master：
    数据备份：冷备，热备，温备
    数据还原
    备份监控
    数据文件远程存储
二：一主一从：初衷是系统性能和系统高可用性问题
    数据备份，性能优化、读写分离、负载均衡
三：一主n从：可用性、一致性、性能中一种或者多种的要求比较高
四：横向集群
    横向集群主要是从业务特性的角度对系统进行切分，最彻底就是切分成了各个子系统，子系统之间通过一些数据同步的方案来把一些核心数据进行共享，以避免跨库调用跨库join。
五、纵向集群
```
[数据库并发处理 - 上的一把好"锁"](https://www.cnblogs.com/michael9/p/12167434.html)

[索引很难么？带你从头到尾捋一遍MySQL索引结构，不信你学不会！](https://www.cnblogs.com/javazhiyin/p/12016500.html)

[后端程序员必备：书写高质量SQL的30条建议](https://www.cnblogs.com/jay-huaxiao/p/12546973.html)

[教你如何迅速秒杀掉：99%的海量数据处理面试题](https://blog.csdn.net/v_july_v/article/details/7382693)

[很用心的为你写了 9 道 MySQL 面试题](https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247488127&idx=4&sn=040019b9991f9d62dcb0ded7d6cb7d1a&chksm=fa0e7dfecd79f4e8e2ab5b0e84ce7efa25589ebbb9eecf1b51d5413bc7edfc501a903c859201&mpshare=1&scene=23&srcid=&sharer_sharetime=1587272608819&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)

[mysql insert锁机制](https://blog.csdn.net/zhanghongzheng3213/article/details/53436240)




[被敖丙用烂的「数据库调优」连招？真香，淦！](https://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&mid=2453143331&idx=1&sn=e387e1b1beb4cd516ee2d67ce934115e&chksm=8cf2dda0bb8554b67c7441db899edc25f740828ed545980a64b75f13ef9946ff402cc2a36937&mpshare=1&scene=23&srcid=&sharer_sharetime=1591853606997&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
### 2.按照这些优化技巧来写SQL，连公司DBA也鼓掌称赞！
[按照这些优化技巧来写SQL，连公司DBA也鼓掌称赞！](https://www.cnblogs.com/Howinfun/p/12857976.html)
```markdown
一、索引优化
    1、建立普通索引
    2、建立复合索引
    3、最左前缀匹配原则 [面试中常被提到的最左前缀匹配原则](https://www.cnblogs.com/ljl150/p/12934071.html)
    4、索引下推
    5、覆盖索引
    6、普通索引
    7、前缀索引
    8、干净的索引列
二、SQL 优化
    1、Order By优化
    2、Join优化
    3、Group By优化
    4、OR 优化
    5、IN 优化
    6、Like 优化
三、数据表设计优化
    1、数据类型：应该选择更简单或者占用空间更小的类型。
    2、避免空值：
    3、超长字符串：
```
### 3.MySQL优化
[4.数据库优化 - SQL优化](https://www.cnblogs.com/lyn20141231/p/11742042.html)
[基于MySQL的SQL优化总结](https://www.cnblogs.com/itzhouq/p/mysql1.html)
[数据库语句优化](https://www.cnblogs.com/shiguangliushi/p/10832554.html)
[用 Explain 命令分析 MySQL 的 SQL 执行](https://www.cnblogs.com/remcarpediem/p/13138063.html)
[Explain执行计划和SQL优化](https://www.cnblogs.com/keme/p/9882663.html)
[SQL优化指南](https://www.cnblogs.com/fengyumeng/p/9888148.html)
### 4.MySQL慢查询优化和排查【2+】
[MySQL慢查询日志总结](https://www.cnblogs.com/kerrycode/p/5593204.html)
[MySQL慢查询日志释疑总结](https://www.cnblogs.com/kerrycode/p/9963764.html)
[MySQL 性能优化之慢查询](https://www.cnblogs.com/chenyanbin/p/13128593.html)
>> 慢查询：就是在日志中记录运行比较慢的SQL语句，需要开启才能使用，或者修改配置文件。
#### 1.如何定位并优化慢查询sql
```markdown
具体场景具体分析，只提出大致思路：
    - 根据慢日志定位慢查询SQL
    - 使用explain等等工具分析SQL
    - 使用show profile[s] 查看由问题的SQL的性能使用情况
    - 修改SQL或者尽量让SQL走索引
>> show variables like "%quer%"  -- 获取慢查询的信息(慢查询日志的开启情况，慢查询日志存储地址，慢查询插入时间设置)
>> show status like '%slow_queries%' -- 查看慢查询的数量
>> set global show_query_log = on; -- 打开慢查询日志
>> set global long_query_time = 1; -- 设置慢查询超过1秒开始的记录
```
#### 2.常见的慢查询的优化
```markdown
索引没起作用的情况：
    - 使用like关键字的查询语句
        如果使用like关键字进行查询的查询语句中，如果匹配字符串的第一个字符串为%,索引不会起作用。
        只有%不在第一个位置索引才会起作用。
    - 使用多列索引的查询语句
        mysql可以为多个字段创建索引，一个索引最多可以包括16个字段。
        对于多列索引，只有查询条件使用了这些字段中的第一个字段时,索引才会使用。
```
### 2.[一个SQL执行的很慢，我们要分两种情况讨论](https://www.cnblogs.com/kubidemanong/p/10734045.html)【2+】
```markdown
    1、大多数情况下很正常，偶尔很慢，则有如下原因
        (1)、数据库在刷新脏页，例如 redo log 写满了需要同步到磁盘。
        (2)、执行的时候，遇到锁，如表锁、行锁。
    2、这条 SQL 语句一直执行的很慢，则有如下原因。
        (1)、没有用上索引：例如该字段没有索引；由于对字段进行运算、函数操作导致无法用索引。
        (2)、数据库选错了索引。
```
### 4.MySQL大数据量查询优化
[3.Mysql面试题及千万级数据查询优化](https://www.cnblogs.com/lyn20141231/p/11742042.html)
[MySQL上亿大表优化实践](https://www.cnblogs.com/YangJiaXin/p/10828244.html#%E5%88%86%E6%9E%90)
### [写一手好SQL很有必要](https://www.cnblogs.com/xiaoyangjia/p/11267191.html)

## MySQL实战
### [01.当执行一条select语句时，MySQL到底做了啥？](https://www.cnblogs.com/hoxis/p/10006871.html)【1+】
![MySQL一条语句的执行流程](https://imgkr.cn-bj.ufileos.com/c7ab6d9b-751b-4725-affc-fc0d6506ccd2.png)
```markdown
1.通过MySQL的基础架构看MySQL的命令执行流程。
MySQL主要分为server层和存储引擎层。
    - server 层中包含连接器，查询缓存，分析器，优化器，执行器，大多数核心功能以及内置函数，存储过程，触发器，视图等。
    - 存储引擎层主要负责最终数据的存储和提取，例如常用的存储引擎 InnoDB、MyISAM 等。
客户端先查询缓存，看这条语句是否执行过，存在缓存中，存在及立即调用缓存到执行器执行。
    若不存在缓存，则到解析器然后预处理器->查询优化器->执行计划->执行器->存储引擎。
```
### [02.一条update SQL语句是如何执行的]()
```markdown
一条更新语句的执行过程和查询语句类似，更新的流程涉及两个日志：redo log（重做日志）和binlog（归档日志）。
```

### [MySQL服务器 IO 100%的案例分析](https://www.cnblogs.com/wangdong/p/9814988.html)
### [MySQL全文索引简单实现搜索引擎](https://www.cnblogs.com/YangJiaXin/p/11153579.html) 

## MySQL工作使用
### [项目上线后，谈一下感触比较深的一点：查询优化](https://www.cnblogs.com/youzhibing/p/11105897.html)
[SQL运行内幕：从执行原理看调优的本质](https://www.cnblogs.com/arthinking/p/13205303.html)
### [MySQL数据库“十宗罪”【十大经典错误案例】](https://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247487474&idx=1&sn=d5cc8f77a4a992142d34c76e3df14e1e&chksm=e9c5f643deb27f55f15df6f96a86da660a782a4a11f2f4bd2331ad562d8d3742b14a09be264b&mpshare=1&scene=23&srcid=1106aA1lme4DMfsqEdsg48PO#rd)
```markdown
Top 1：Too many connections（连接数过多，导致连接不上数据库，业务无法正常进行）
Top 2：（主从复制报错类型）
Top 3：MySQL安装过程中的报错
Top 4：数据库密码忘记的问题
Top 5：truncate 删除数据，导致自动清空自增ID，前端返回报错 not found。
Top 6：阿里云 MySQL 的配置文件中，需要注意一个参数设置就是：
Top 7：数据库总会出现中文乱码的情况
Top 8：使用 binlog_format=statement 这种格式，跨库操作，导致从库丢失数据，用户访问导致出现错误数据信息。
Top 9：MySQL 数据库连接超时的报错 
Top 10 ：can't open file (errno:24)
```
### [Java操作MySQL数据库 limit 实现分批分页，解决内存溢出问题](https://blog.csdn.net/Agly_Clarlie/article/details/53185750)
### [千万级数据表选错索引导致的线上慢查询事故](https://mp.weixin.qq.com/s?__biz=MzU4Mjk0MjkxNA==&mid=2247486994&idx=2&sn=43f4979b0ee60eb5c0d99d21126514c1&chksm=fdb1e7bfcac66ea99f2f1b21cf96e87b975069915d20b02ea3667d22a9f0f29218f9e7dbcb4d&mpshare=1&scene=23&srcid=0819MYlNG1ZvEQlzWakNGllM&sharer_sharetime=1597799142625&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
## 数据库面试题
### MySQL常见6个考题在实际工作中的运用
[MySQL常见6个考题在实际工作中的运用](https://www.cnblogs.com/xiexj/p/12952378.html)
#### 1.MyISAM和InnoDB的区别，什么时候选择MyISAM?
```markdown
InnoDB是目前MySQL主流版本(5.6、5.7、8.0)默认的存储引擎，支持事务、外键、行级锁，对于并发条件下要求数据的一致性，适用于对数据准确性要求高的场景。
MyISAM只支持表级锁、数据排列是按照插入顺序，没有做规则排序。适合应用以查询和插入为主，只有很少量的更新和删除操作，对事务的完整性和并发性要求不是很高的场景。
通常都会有几张MyISAM的数据表，通常用来存储历史记录，与使用InnoDB存储实时记录信息的配合使用。
```
#### 2.简述MySQL的MVCC多版本并发控制【3+】
```markdown
MVCC：Multi-Version Concurrency Control，即多版本的并发控制协议。
    MVCC多版本并发控制是MySQL中基于乐观锁理论实现隔离级别的方式，用于读已提交和可重复读取隔离级别的实现。
    MVCC的特点就是在同一时刻，不同事务可以读取到不同版本的数据，从而可以解决脏读和不可重复读的问题。
        MVCC实际上是通过数据的隐藏列和回滚日志(undolog),实现多个版本数据的共存。
        这样的好处是，使用MVCC进行读数据的时候，不用加锁，从而避免了同时读写的冲突。
MVCC是通过保存数据在某个时间点的快照来实现的. 不同存储引擎的MVCC实现是不同的,典型的有乐观并发控制和悲观并发控制.
​   InnoDB的MVCC,是通过在每行记录后面保存两个隐藏的列来实现的,这两个列，分别保存了这个行的创建时间，一个保存的是行的删除时间。
   这里存储的并不是实际的时间值,而是系统版本号(可以理解为事务的ID)，每开始一个新的事务，系统版本号就会自动递增，事务开始时刻的系统版本号会作为事务的ID.
​   InnoDB只会查找版本早于当前事务版本的数据行(也就是,行的系统版本号小于或等于事务的系统版本号)，这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的.
​   1.MVCC手段只适用于Msyql隔离级别中的读已提交（Read committed）和可重复读（Repeatable Read）.
​   2.Read uncimmitted由于存在脏读，即能读到未提交事务的数据行，所以不适用MVCC.
​   原因是MVCC的创建版本和删除版本只要在事务提交后才会产生。客观上，我们认为他就是乐观锁的一整实现方式，就是每行都有版本号，保存时根据版本号决定是否成功。
```
#### 3.分布式锁的实现方式
```markdown
主流有三种
    1>基于数据库
        1.1>基于数据库主键：插入一条数据，指定主键。如果有两条插入会主键冲突，并发执行失败
        1.2>基于数据库排他锁：提交一个update事务，如果这个事务不提交，其他也对锁定范围内执行update就会阻塞，解决并发问题
    2>基于缓存比如redis的setNX
    3>基于zookeeper
```
#### 4.为什么采用B+树作为索引结构?
```markdown
采用Hash表，范围查找需要全表扫描；采用二叉查找树，由于无法保证平衡，可能退化为链表；采用平衡二叉树，通过旋转解决了平衡的问题，但是旋转操作效率太低；
采用红黑树，树太高，IO次数多；采用普通B树，节点要存数索引和数据，一个内存页可存储的数据还是少，另外范围查找也需要多次IO；
而B+Tree有三个特性：
    1>非叶子节点不存储data，只存储索引(冗余)，可以放更多的索引
    2>叶子节点包含所有索引字段
    3>叶子节点用指针链接，提高范围查询的性能
```
### [100道MySQL数据库经典面试题解析（收藏版）](https://www.cnblogs.com/jay-huaxiao/p/12950484.html)
#### 1. MySQL索引使用有哪些注意事项呢？
>> 可以从三个维度回答这个问题：索引哪些情况会失效，索引不适合哪些场景，索引规则
```markdown
索引哪些情况会失效
    查询条件包含or，可能导致索引失效
    如何字段类型是字符串，where时一定用引号括起来，否则索引失效
    like通配符可能导致索引失效。
    联合索引，查询时的条件列不是联合索引中的第一个列，索引失效。
    在索引列上使用mysql的内置函数，索引失效。
    对索引列运算（如，+、-、*、/），索引失效。
    索引字段上使用（！= 或者 < >，not in）时，可能会导致索引失效。
    索引字段上使用is null， is not null，可能导致索引失效。
    左连接查询或者右连接查询查询关联的字段编码格式不一样，可能导致索引失效。
    mysql估计使用全表扫描要比使用索引快,则不使用索引。
索引不适合哪些场景
    数据量少的不适合加索引
    更新比较频繁的也不适合加索引
    区分度低的字段不适合加索引（如性别）
索引的一些潜规则
    覆盖索引
    回表
    索引数据结构（B+树）
    最左前缀原则
    索引下推
```
#### 2. MySQL遇到过死锁问题吗，你是如何解决的？
```markdown
我排查死锁的一般步骤是酱紫的：
    查看死锁日志show engine innodb status;
    找出死锁Sql
    分析sql加锁情况
    模拟死锁案发
    分析死锁日志
    分析死锁结果
```
#### 3. 日常工作中你是怎么优化SQL的？
```markdown
可以从这几个维度回答这个问题：
    加索引
    避免返回不必要的数据
    适当分批量进行
    优化sql结构
    分库分表
    读写分离
```
#### 4.为什么用自增列作为主键
```markdown
如果我们定义了主键(PRIMARY KEY)，那么InnoDB会选择主键作为**聚集索引**、
    如果没有显式定义主键，则InnoDB会选择第一个不包含有NULL值的唯一索引作为**主键索引**、
    如果也没有这样的唯一索引，则InnoDB会选择内置6字节长的ROWID作为隐含的**聚集索引**(ROWID随着行记录的写入而主键递增，这个ROWID不像ORACLE的ROWID那样可引用，是隐含的)。
    数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，
    因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）
如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页
如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新记录都要被插到现有索引页的中间某个位置，
    此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，
    同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。
```
#### 5.存储过程和函数的区别？
```markdown
 存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。
    函数每次执行都需要编译一次。
 存储过程中可以使用try-catch块和事务，而函数中不可以
 函数有且只有一个输入参数和一个返回值，而存储过程没有这个限制
 函数可以被存储过程调用而存储过程不可以被函数调用
```
#### 6.视图的操作会对基本表产生影响吗？
```markdown
 视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，视图通常是有一个表或者多个表的行或列的子集。
对视图的修改会影响基本表。它使得我们获取数据更容易，相比多表查询。
 当用户试图修改视图的某些信息时，数据库必须把它转化为对基本表的某些信息的修改，对于简单的视图来说，这是很方便的，
但是，对于比较复杂的视图，可能是不可修改的。
```
#### 7.什么是临时表，临时表什么时候删除?
```markdown
临时表可以手动删除：
DROP TEMPORARY TABLE IF EXISTS temp_tb;
临时表只在当前连接可见，当关闭连接时，MySQL会自动删除表并释放所有空间。因此在不同的连接中可以创建同名的临时表，并且操作属于本连接的临时表。
创建临时表的语法与创建表语法类似，不同之处是增加关键字TEMPORARY，
如：
    CREATE TEMPORARY TABLE tmp_table (
    NAME VARCHAR (10) NOT NULL,
    time date NOT NULL
    );
    select * from tmp_table;
```
#### 8.Mysql如何保证一致性和持久性
```markdown
MySQL为了保证ACID中的一致性和持久性，使用了WAL(Write-Ahead Logging,先写日志再写磁盘)。
    Redo log就是一种WAL的应用。当数据库忽然掉电，再重新启动时，MySQL可以通过Redo log还原数据。
    也就是说，每次事务提交时，不用同步刷新磁盘数据文件，只需要同步刷新Redo log就足够了。
```
#### 9.非关系型数据库和关系型数据库区别，优势比较?
```markdown
非关系型数据库的优势：
    性能：NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。
    可扩展性：同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。
关系型数据库的优势：
    复杂查询：可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。
    事务支持：使得对于安全性能很高的数据访问要求得以实现。
其他：
    1.对于这两类数据库，对方的优势就是自己的弱势，反之亦然。
    2.NOSQL数据库慢慢开始具备SQL数据库的一些复杂查询功能，比如MongoDB。
    3.对于事务的支持也可以用一些系统级的原子操作来实现例如乐观锁之类的方法来曲线救国，比如Redis set nx。
```
### [5.不就是SELECT COUNT语句吗，竟然能被面试官虐的体无完肤](https://www.cnblogs.com/hollischuang/p/11711778.html)

## MySQL的一些命令
[1000行MySQL学习笔记](https://mp.weixin.qq.com/s?__biz=MzIxNTQ0MDQxNg==&mid=2247486626&idx=1&sn=360e0ff2e280e800a5e6defb2cc5aabf&chksm=979901eda0ee88fbaf17f81b6cbf1d870aa59bd78ea2fcf25a91e9ca157f2c77f9d6f6bb7f95&mpshare=1&scene=23&srcid=&sharer_sharetime=1575470170943&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
```mysql
show engines;  # 查看MySQL所有的的存储引擎
show variables like '%storage_engine%'; # 查看默认的存储引擎
show table status like 'table_name'; #查看表的存储引擎
```
[MySQL基础知识和常用命令总结](https://www.cnblogs.com/justisme/p/12797955.html)
## LeetCode MySQL题目
```mysql
-- 175,181,183,184,176,177,178,180,626,
```
### 182. 查找重复的电子邮箱
```markdown
-- 编写一个 SQL 查询，查找 Person 表中所有重复的电子邮箱。
-- 解法1
select email from person group by email having count(email)>1

--解法2
select email from (select count(1) as t,email from person group by email)r  where r.t>1;

-- 解法3
select distinct(p1.Email) from Person p1  
    join Person  p2 on p1.Email = p2.Email AND p1.Id!=p2.Id
```
### 184.184. 部门工资最高的员工
```markdown
-- Employee 表包含所有员工信息，每个员工有其对应的 Id, salary 和 department Id。
select DeportmentId,MAX(Salary) from Employee Group BY DeportmentId;

SELECT
    Department.name AS 'Department',
    Employee.name AS 'Employee',
    Salary
FROM
    Employee
        JOIN
    Department ON Employee.DepartmentId = Department.Id
WHERE
    (Employee.DepartmentId , Salary) IN
    (   SELECT
            DepartmentId, MAX(Salary)
        FROM
            Employee
        GROUP BY DepartmentId
	)
```
### 196. 删除重复的电子邮箱
```markdown
DELETE p1.* from Person p1, Person p2 where p1.Email = p2.Email AND p1.Id>p2.Id;
delete p1 from (Person as p1 left join Person as p2 on p1.Email = p2.Email) where p1.Id = p2.Id;
delete from Person where Id not in (
    select Id from(
        select MIN(Id) as Id
        from Person
        GROUP BY Email
    ) as temp
);
```
### 595. 大的国家
```markdown
-- 如果一个国家的面积超过300万平方公里，或者人口超过2500万，那么这个国家就是大国家。
select name,population,area from World where area >3000000 or population >25000000;
select name,population,area from World where area > 3000000 
    UNION 
select name,population,area from World where population > 25000000;
```
### 601. 体育馆的人流量
```markdown
-- X 市建了一个新的体育馆，每日人流量信息被记录在这三列信息中：序号 (id)、日期 (visit_date)、 人流量 (people)。
-- 请编写一个查询语句，找出人流量的高峰期。高峰期时，至少连续三行记录中的人流量不少于100。
select distinct a.* from stadium a,stadium b,stadium c 
    where a.people>=100 and b.people>=100 and c.people>=100
and (
    (a.id = b.id+1 and b.id = c.id + 1 and a.id = c.id + 2) or 
    (a.id = b.id-1 and a.id = c.id + 1 and b.id = c.id + 2) or 
    (a.id = b.id-1 and b.id = c.id - 1 and c.id = a.id + 2)
) order by a.id;

```
### 627.交换工资
```markdown
-- 给定一个salary表，如下所示，有m=男性和f=女性的值。交换所有的f和m值（例如，将所有f值更改为m，反之亦然）。
-- 要求只使用一个更新（Update）语句，并且没有中间的临时表。
update salary set sex = if(sex = 'm','f','m');
update salary
    set sex = (case sex
                when 'm' then 'f'
                else 'm'
            end
            );
update salary set sex = char ( ASCII(sex) ^ ASCII('m') ^ ASCII('f'));
```
### 620. 有趣的电影
```markdown
select * from cinema where id%2=1 and description!= 'boring' order by rating DESC;
select * from cinema where id%2=1 and description <> 'boring' order by rating DESC;
```
### 596. 超过5名学生的课
```markdown
#共三种写法
#最朴实的写法，共三层查询，先利用 DISTINCT 去掉重复记录得到表 A，再利用 GROUP BY 为 CLASS 分组，然
#后用 COUNT() 统计每组个数得到表 B，最后在最外层限定数量 >=5 查到结果
SELECT B.CLASS								#最外层
	FROM (SELECT A.CLASS,COUNT(A.CLASS) C          #第二层查询，得到具有 CLASS、COUNT(CLASS) 的表 B
		FROM (SELECT DISTINCT *				#第三层查询，去重得到表 A
			FROM COURSES) A
	GROUP BY A.CLASS) B						#分组
	WHERE B.C >= 5;							#条件

#稍微优化，两层查询，主要是因为用了 HAVING 省了一层查询
SELECT A.CLASS					#最外层
	FROM (SELECT DISTINCT *		#第二层查询，去重得到表 a
		FROM COURSES) A
	GROUP BY A.CLASS			        #分组
	HAVING COUNT(A.CLASS) >= 5;	#利用 COUNT() 计算每组个数并筛选

#极致优化，一层查询，利用 GROUP BY 为 CLASS 分组后，直接用 COUNT() 统计每组学生个数，在统计前先用
# DISTINCT 去掉重复学生
SELECT CLASS
	FROM COURSES
	GROUP BY CLASS							#分组
	HAVING COUNT(DISTINCT STUDENT) >= 5;          #利用 COUNT() 统计每门课 STUDENT 的个数，同时利
```
