#MySQL学习面试总结
>> [CyC2018大佬]()
>> [MySQL 三万字精华总结 + 面试100 问，吊打面试官绰绰有余（收藏系列）](https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&mid=2247487818&idx=2&sn=61e5c392c68bb6b1474d140e8ee6e3ba&chksm=ce405a9ef937d3888cfa608e3b3e7c329b1255f5d60d6e5bc3ddb2c754f22f24ad2c11e317ab&mpshare=1&scene=23&srcid=&sharer_sharetime=1590881519689&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)

[TOC]


## MySQL基础
### 1.数据库范式【2+】
```markdown
 第一范式：无重复的列,实体中的某个属性不能有多个值或者不能有重复的属性。
 第二范式：属性完全依赖于主键,消除部分子函数依赖,非主属性完全依赖于主关键字。
 第三范式：属性不依赖于其它非主属性,消除传递依赖,不包含已在其它表中已包含的非主关键字信息。
 BCNF范式：不存在任何字段对任一候选关键字段的传递函数依赖。
```
### 2.mysql有哪些数据类型
```markdown
1、整数类型，包括TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示1字节、2字节、3字节、4字节、8字节整数。
    任何整数类型都可以加上UNSIGNED属性，表示数据是无符号的，即非负整数。
    长度：整数类型可以被指定长度，例如：INT(11)表示长度为11的INT类型。
    长度在大多数场景是没有意义的，它不会限制值的合法范围，只会影响显示字符的个数，而且需要和UNSIGNED ZEROFILL属性配合使用才有意义。
    例子，假定类型设定为INT(5)，属性为UNSIGNED ZEROFILL，如果用户插入的数据为12的话，那么数据库实际存储数据为00012。
2、实数类型，包括FLOAT、DOUBLE、DECIMAL。
    DECIMAL可以用于存储比BIGINT还大的整型，能存储精确的小数。而FLOAT和DOUBLE是有取值范围的，并支持使用标准的浮点进行近似计算。
    计算时FLOAT和DOUBLE相比DECIMAL效率更高一些，DECIMAL你可以理解成是用字符串进行处理。
3、字符串类型，包括VARCHAR、CHAR、TEXT、BLOB
    VARCHAR用于存储可变长字符串，它比定长类型更节省空间。
    VARCHAR使用额外1或2个字节存储字符串长度。列长度小于255字节时，使用1字节表示，否则使用2字节表示。
    VARCHAR存储的内容超出设置的长度时，内容会被截断。
    CHAR是定长的，根据定义的字符串长度分配足够的空间。CHAR会根据需要使用空格进行填充方便比较。
    CHAR适合存储很短的字符串，或者所有值都接近同一个长度。CHAR存储的内容超出设置的长度时，内容同样会被截断。
    使用策略：
    对于经常变更的数据来说，CHAR比VARCHAR更好，因为CHAR不容易产生碎片。对于非常短的列，CHAR比VARCHAR在存储空间上更有效率。
    使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。尽量避免使用TEXT/BLOB类型，查询时会使用临时表，导致严重的性能开销。
4、枚举类型（ENUM），把不重复的数据存储为一个预定义的集合。
    有时可以使用ENUM代替常用的字符串类型。ENUM存储非常紧凑，会把列表值压缩到一个或两个字节。
    ENUM在内部存储时，其实存的是整数。尽量避免使用数字作为ENUM枚举的常量，因为容易混乱。排序是按照内部存储的整数
5、日期和时间类型，尽量使用timestamp，空间效率高于datetime，
    用整数保存时间戳通常不方便处理。如果需要存储微妙，可以使用bigint存储。
```
### 3.mysql有关权限的表都有哪几个
```markdown
MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。
这些权限表分别user，db，table_priv，columns_priv和host。下面分别介绍一下这些表的结构和内容：
    1、user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。
    2、db权限表：记录各个帐号在各个数据库上的操作权限。
    3、table_priv权限表：记录数据表级的操作权限。
    4、columns_priv权限表：记录数据列级的操作权限。
    5、host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。
```
#### 
### 4.MySQL事务
#### 1.事务的四大特性
```markdown
事务的四大特性指的是满足ACID特性的一组操作，可以通 Commit提交一个事务，也可以使用Rollback进行回滚。
**原子性**:事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。
    回滚可以用回滚日志来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。
**一致性**:数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。
**隔离性**:一个事务所做的修改在最终提交以前，对其它事务是不可见的。
**持久性**:一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。
```
#### 2.事务的隔离级别及各级别下的并发访问问题【5+】
[一文彻底读懂MySQL事务的四大隔离级别](https://www.cnblogs.com/jay-huaxiao/p/12639435.html)--
[5分钟带你读懂事务隔离性与隔离级别](https://www.cnblogs.com/coder-programming/p/10693473.html)
```markdown
 Read uncommitted：读未提交，就是一个事务可以读取另一个未提交事务的数据。会造成脏读。
 Read committed：读提交，就是一个事务要等另一个事务提交后才能读取数据。若有事务对数据进行更新（UPDATE）操作时，
    读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题。但会造成不可重复读。
 Repeatable read：重复读，就是在开始读取数据（事务开启）时，不再允许修改操作在同一个事务里，SELECT的结果是事务开始时时间点的状态，
    因此，同样的SELECT操作读到的结果会是一致的。但是，会有幻读现象。
 Serializable：序列化，Serializable是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。
    但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。
>> select @@tx_isolation; # 查看数据库默认的隔离级别
>> set session transaction isolation level read uncommitted; #设置数据库的隔离级别为读未提交
>> start translation; # 开启事务
```
#### 3.事务并发一致性问题【2+】
[跟面试官侃半小时MySQL事务隔离性，从基本概念深入到实现](https://www.cnblogs.com/awan-note/p/12584757.html)
```markdown
在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。丢失修改、读脏数据、不可重复读、幻影读
更新丢失：mysql所有事务隔离级别在数据库层面上均可避免。
脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据。READ-COMMITTED事务隔离级别以上可以避免。
 不可重复读：事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，
    结果因此本事务先后两次读到的数据因更新结果会不一致。不可重复读的重点是修改。同样的条件，你读取过的数据，再次读取出来发现值不一样。
    REPEATABLE_READ事务隔离级别以上避免。
 幻读：幻读发生在当两个完全相同的查询执行时，第二次查询所返回的结果集跟第一个查询不相同。
    幻读的重点在于新增或者删除。同样的条件， 第1次和第2次读出来的记录数不一样。SERIALIZABLE事务隔离级别可避免。
脏读与不可重复读的区别在于：前者读到的是其他事务未提交的数据，后者读到的是其他事务已提交的数据。
不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多条读取一条记录发现记录增多或者减少了。
```
#### 4.InnoDB可重复读级别下如何避免幻读？
```markdown
当前读与快照读
next-key锁（行锁+gap锁）
```
#### 5.RC,RR级别下的InnoDB的非阻塞读如何实现？
```markdown

```
#### 6.事务的隔离级别和加锁的关系？
```markdown
  读未提交
     事务读不阻塞其他事务读和写，事务写阻塞其他事务写但不阻塞读。
     可以通过写操作加 “持续 - X 锁” 实现。
  读已提交
     事务读不会阻塞其他事务读和写，事务写会阻塞其他事务读和写。
     可以通过写操作加 “持续 - X” 锁，读操作加 “临时 - S 锁” 实现。
  可重复读
     事务读会阻塞其他事务事务写但不阻塞读，事务写会阻塞其他事务读和写。
     可以通过写操作加 “持续 - X” 锁，读操作加 “持续 - S 锁” 实现。
  串行化
     “行级锁” 做不到，需使用 “表级锁”。
```
### 5.MySQL锁
>> 数据库的乐观锁悲观锁咋实现？
#### MySQL中的锁【5+】
[2.说一说你对MySQL中锁的了解？](https://www.cnblogs.com/notfound9/p/13062524.html)
```markdown
 悲观锁: 先获取锁，再进行业务操作。即 “悲观” 的认为获取锁是非常有可能失败的，因此要先确保获取锁成功再进行业务操作。
    通常来讲在数据库上的悲观锁需要数据库本身提供支持，即通过常用的select … for update操作来实现悲观锁。
 乐观锁的特点先进行业务操作，不到万不得已不去拿锁。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。
    如果其他事务有更新的话，那么当前正在提交的事务会进行回滚。
 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。
 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。
行锁又分为读锁和写锁：
 共享锁：读锁或S锁。如果事务T对数据A加上共享锁后，则其他事务只能对 A再加共享锁，不能加排它锁。获准共享锁的事务只能读数据，不能修改数据。
 排它锁：独占锁、写锁或X锁。如果事务T对数据A加上排它锁后，则其他事务不能再对A加任何类型的锁。获得排它锁的事务即能读数据又能修改数据。
```
##### 1.1共享锁与排他锁
```markdown
InnoDB 实现了标准的行级锁，包括两种：共享锁（简称 s 锁）、排它锁（简称 x 锁）。
共享锁（S锁）：允许持锁事务读取一行。
排他锁（X锁）：允许持锁事务更新或者删除一行。
```
##### 1.2 意向锁
```markdown
意向共享锁( IS 锁)：事务想要获得一张表中某几行的共享锁
意向排他锁( IX 锁)： 事务想要获得一张表中某几行的排他锁
```
##### 1.3 记录锁（Record Locks）
```markdown
记录锁是最简单的行锁，仅仅锁住一行。如：SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE
记录锁永远都是加在索引上的，即使一个表没有索引，InnoDB也会隐式的创建一个索引，并使用这个索引实施记录锁。
会阻塞其他事务对其插入、更新、删除
```
##### 1.4 间隙锁（Gap Locks）
```markdown
间隙锁是一种加在两个索引之间的锁，或者加在第一个索引之前，或最后一个索引之后的间隙。
使用间隙锁锁住的是一个区间，而不仅仅是这个区间中的每一条数据。
间隙锁只阻止其他事务插入到间隙中，他们不阻止其他事务在同一个间隙上获得间隙锁，所以 gap x lock 和 gap s lock 有相同的作用。
```
##### 1.5 Next-Key Locks
```markdown
Next-key锁是记录锁和间隙锁的组合，它指的是加在某条记录以及这条记录前面间隙上的锁。
next-key lock实际上就是行锁的一种，只不过它不只是会锁住当前行记录的本身，还会锁定一个范围。
InnoDB实现的隔离级别RR时可以避免幻读现象的，这是通过next-key lock机制实现的。
```
##### 1.6插入意向锁（Insert Intention）
```markdown
插入意向锁是在插入一行记录操作之前设置的一种间隙锁，这个锁释放了一种插入方式的信号，
亦即多个事务在相同的索引间隙插入时如果不是插入间隙中相同的位置就不需要互相等待。
```
##### 1.7 三级封锁协议
```markdown
**一级封锁协议**:事务T要修改数据A时必须加X(写)锁，直到T结束才释放锁。可以解决丢失修改问题。
**二级封锁协议**:在一级的基础上，要求读取数据A时必须加S(读)锁，读取完马上释放S(读)锁。可以解决读脏数据问题。
**三级封锁协议**:在二级的基础上，要求读取数据A时必须加S(读)锁，直到事务结束了才能释放S(读)锁。可以解决不可重复读的问题
```
##### 1.8 两段锁协议
```markdown
加锁和解锁分为两个阶段进行。
可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。
事务遵循两段锁协议是保证可串行化调度的充分条件。
MySQL的InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。
```

[【原创】惊！史上最全的select加锁分析(Mysql)](https://www.cnblogs.com/rjzheng/p/9950951.html)

[超全面的MySQL语句加锁分析](https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&mid=2653198050&idx=2&sn=68a6594ac35976532ad6a0eec6dc06dd&chksm=8c99e438bbee6d2e8e9bdf80a3312723c92e20afb1918ca6d29cd8ded1d670637c413704ca61&mpshare=1&scene=23&srcid=#rd)
#### 死锁死循环四要素
```markdown
MyISAM⽀持表锁，InnoDB⽀持表锁和⾏锁，默认为⾏锁
    表级锁：开销⼩，加锁快，不会出现死锁。锁定粒度⼤，发⽣锁冲突的概率最⾼，并发量最低
    ⾏级锁：开销⼤，加锁慢，会出现死锁。锁⼒度⼩，发⽣锁冲突的概率⼩，并发度最⾼
- 互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。
    如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。
- 请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，
    此时请求进程阻塞，但又对自己已获得的其它资源保持不放。
- 不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。
- 环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；
    P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。
```
#### 分析死锁
[1.手把手教你分析Mysql死锁问题](https://www.cnblogs.com/jay-huaxiao/p/12685287.html)
```markdown
环境准备：
    select @@tx_isolation;  # 查看数据库隔离级别
    set autocommit=0;  # 自动提交关闭
    //id是自增主键，name是非唯一索引，balance普通字段
    表结构:
        CREATE TABLE `account` (
              `id` int(11) NOT NULL AUTO_INCREMENT,
              `name` varchar(255) DEFAULT NULL,
              `balance` int(11) DEFAULT NULL,
              PRIMARY KEY (`id`),
              KEY `idx_name` (`name`) USING BTREE
            ) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;
    表中的数据：(1,Eason,100),(2,Wei,100)
    模拟并发：
        mysql> update  account  set balance =1000 where name ='Wei'; -- 1）事务A执行更新操作，更新成功
        mysql> update  account  set balance =1000 where name ='Eason'; -- 2）事务B执行更新操作，更新成功
        mysql> insert into account values(null,'Jay',100); -- 3）事务A执行插入操作，陷入阻塞~
    select * from information_schema.innodb_locks; # 查看锁情况
        mysql> insert into account values(null,'Yan',100); -- 4）事务B执行插入操作，插入成功，同时事务A的插入由阻塞变为死锁error。
    show engine innodb status; # 查看最近一次死锁日志
        1）找到关键词TRANSACTION，事务38048
        2）查看正在执行的SQL
        3）正在等待锁释放(WAITING FOR THIS LOCK TO BE GRANTED)，...
-- MySQL中提供了两种封锁粒度：行级锁以及表级锁。应该尽量只锁定需要修改的那部分数据，而不是所有的资源。
加锁机制：乐观锁、悲观锁。
兼容性：共享锁、排它锁。
锁粒度：表锁、页锁、行锁。
锁模式：记录锁、gap锁、next-key锁、意向锁、插入意向锁。
```
### 6.MySQL索引 
[mysql数据库的索引](https://www.cnblogs.com/wangsen/p/10864136.html)
>> 为什么要使用索引：快速查询数据;绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能快，其余大部分场景使用BTree索引。
>> 什么样的信息能够成为索引：
>> 索引的数据结构：
>> 如何使用联合索引，最左匹配原则，字段顺序如何选择
#### 1.索引分类【3+】
```markdown
 主键索引 （PRIMARY KEY）:数据列不允许重复，不允许为NULL，一个表只能有一个主键。
 唯一索引 （UNIQUE）:数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。
    1、可以通过 ALTER TABLE table_name ADD UNIQUE (column)；创建唯一索引
    2、可以通过 ALTER TABLE table_name ADD UNIQUE (column1,column2)；创建唯一组合索引
 普通索引 （INDEX）:基本的索引类型，没有唯一性的限制，允许为NULL值。
    1、可以通过ALTER TABLE table_name ADD INDEX index_name (column);创建普通索引
    2、可以通过ALTER TABLE table_name ADD INDEX index_name(column1, column2, column3)；创建组合索引
 组合索引 （INDEX）:MySQL可以使用多个字段同时建立一个索引，叫做联合索引。
    只有在查询条件中使用了创建索引的第一个字段，索引才能生效被使用，使用组合索引遵循最左前缀匹配集合。
    1、在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。
 全文索引 （FULLTEXT）:是目前搜索引擎使用的一种关键技术。用来查找文本中的关键字，而不是直接与索引中的值比较。
    1.可以通过ALTER TABLE table_name ADD FULLTEXT (column);创建全文索引
```
#### 2.B+Tree原理【2+】
```markdown
B-Tree指的是Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。
B-Tree的定义：
    - 根节点至少包括两个孩子;
    - 树中每个节点最多包含m个孩子(m>=2);
    - 除根节点和叶节点外，其他每个节点至少有ceil(m/2)个孩子;
    - 所有叶子节点都位于同一层。
    - 假设每个非终端节点中包含有n个关键字信息，其中：
        a).ki(i=1...n)为关键字，且关键字按升序排序k(i-1)<ki
        b).关键字的个数n必须满足：[ceil(m/2)-1]<=n<=m-1
        c).非叶子节点的指针：p[1],p[2],....p[m]指向关键字指向k[1]的子树，p[m]指向关键字大于k[m-1]的子树，其他p[i]指向关键字属于(k[i-1],k[i])的子树。 
B+Tree是基于B-Tree和叶子节点顺序访问指针进行实现，它具有B-Tree的平衡性，并且通过顺序访问指针来提高区间查询的性能。
在B+Tree中，一个节点中的key从左到右非递减排列，如果某个指针的左右相邻key分别是keyi和keyi+1，且不为null，则该指针指向节点的所有key大于等于keyi且小于等于keyi+1。
B+Tree的定义：在B数的基础之上，添加了
    - 非叶子节点的子树指针与关键字个数相同；
    - 非叶子节点的子树指针p[i],指向关键字[k[i],k[i+1]]的子树；
    - 非叶子节点仅用来索引，数据都保存在叶子节点中；
    - 所有的叶子节点有一个链指针指向下一个叶子节点。
B+Tree更加合适来做存储索引：
    - B+树的磁盘读写代价更低;B+树空间利用率更高，可减少I/O次数，磁盘读写代价更低。
    - B+树的查询效率更加稳定;B树只适合随机检索，而B+树同时支持随机检索和顺序检索；
    - B+树更有利于对数据库的扫描。B+树的查询效率更加稳定。
红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用B+Tree作为索引结构，主要有以下两个原因：
（一）更少的查找次数：平衡树查找操作的时间复杂度和树高 h 相关，O(h)=O(logdN)，其中 d 为每个节点的出度。
（二）利用磁盘预读特性：为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。
Hash索引：也可以用来作为索引。    
    - 仅仅能够满足"=","IN"，不能使用范围查询
    - 无法被用来避免数据操作
    - 不能利用部分索引键查询
    - 不能避免表扫描
    - 遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高
BitMap索引也是一个神器。
```
#### 3.B+Tree索引【2+】
```markdown
B+Tree索引是大多数MySQL存储引擎的默认索引类型。因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。
因为B+Tree的有序性，所以除了用于查找，还可以用于排序和分组。可以指定多个列作为索引列，多个索引列共同组成键。
适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。
InnoDB的B+Tree索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。
因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。
辅助索引的叶子节点的data域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。
```
#### 4.哈希索引【1+】
```markdown
哈希索引能以O(1)时间进行查找，但是失去了有序性：无法用于排序与分组；只支持精确查找，无法用于部分查找和范围查找。
InnoDB存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在B+Tree索引之上再创建一个哈希索引，
这样就让B+Tree索引具有哈希索引的一些优点，比如快速的哈希查找。
```
#### 5.全文索引
```markdown
MyISAM存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。
查找条件使用 MATCH AGAINST，而不是普通的WHERE。全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。
InnoDB存储引擎在MySQL5.6.4版本中也开始支持全文索引。
```
#### 6.空间数据索引
```markdown
MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，
可以有效地使用任意维度来进行组合查询。必须使用 GIS 相关的函数来维护数据。
```
#### 7.密集索引和稀疏索引的区别【5+】
```markdown
innoDB:使用主键索引使用的密集索引,数据行的物理顺序与列值（一般是主键的那一列）的逻辑顺序相同，一个表中只能拥有一个聚集索引。
    - 聚集索引的叶子节点存放有对应的数据节点，可以直接获取到对应的数据，
    - 如果不创建索引，系统会自动创建一个隐含列作为表的聚集索引。
    - 最好还是在创建表的时候添加聚集索引
    - 在经常用于查询或聚合条件的字段上建立聚集索引。这类查询条件包括 between, >, <,group by, max,min, count等。
    缺点：
    - 插入和更新索引的速度会比较慢，因为将会导致被更新的行移动。
MyISAM: 不管是主键索引，还是二级索引使用的都是稀疏索引,数据行的物理顺序与列值的逻辑顺序不相同，一个表中可以拥有多个非聚集索引。
    - 叶子节点存放的不是实际数据，而是指向实际数据的指针。
    - 聚集索引以外的索引都是非聚集索引,细分可以分为：普通索引，唯一索引，全文索引
```
#### 8.两种存储引擎的BTree索引实现方式是不同的。
```markdown
●MyISAM:B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候,首先按照B+Tree搜索算法搜索索引,如果指定的Key存在,则取出其 data域的
值,然后以data域的值为地址读取相应的数据记录。这被称为"非聚簇索引"。
● InnoDB:其数据文件本身就是索引文件。相比MyISAM,索引文件和数据文件是分离的,其表数据文件本身就是按B+Tree组织的一个素引结构,树的叶节点data域
保存了完整的数据记录。这个索引的key是数据表的主键,因此InnoDB表数据文件本身就是主索引。这被称为"聚簇索引（或聚集索引）"。而其余的索引都作为辅助
索引,辅助索引的data域存储相应记录主键的值而不是地址,这也是和MyISAM不同的地方。在根据主索引搜索时,直接找到key所在的节点即可取出数据;在根
据辅助索引查找时,则需要先取出主键的值,再走一遍主索引。因此,在设计表的时候,不建议使用过长的字段作为主键,也不建议使用非单调的字段作为
主键,这样会造成主索引频繁分裂。
```
#### 9.索引优化
[MySQL如何创建一个好索引？创建索引的5条建议](https://www.cnblogs.com/chenkeyu/p/12799207.html)
##### 1.独立的列
```markdown
在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。
```
##### 2. 多列索引
```markdown
在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把actor_id和film_id设置为多列索引。
```
##### 3. 索引列的顺序
```markdown
让选择性最强的索引列放在前面。索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。
选择性越高，每个记录的区分度越高，查询效率也越高。
```
##### 4. 前缀索引
```markdown
对于BLOB、TEXT和VARCHAR类型的列，必须使用前缀索引，只索引开始的部分字符。前缀长度的选取需要根据索引选择性来确定。
```
##### 5. 覆盖索引
```markdown
索引包含所有需要查询的字段的值。
如果要查询的字段都建立过索引，那么引擎会直接在索引表中查询而不会访问原始数据（否则只要有一个字段没有建立索引就会做全表扫描），这叫索引覆盖。
具有以下优点：
    索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。
    一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。
    对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。
```
#### 10.索引的优点【1+】
```markdown
1.大大减少了服务器需要扫描的数据行数。
2.帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和GROUP BY 操作。
    临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。
3.将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。
```
#### 11.创建索引的原则
[mysql索引设计的注意事项(大量示例,收藏再看)](https://www.cnblogs.com/wangtcc/p/mysql-suo-yin-she-ji-de-zhu-yi-shi-xiang-da-liang-.html)
```markdown
索引虽好，但也不是无限制的使用，最好符合一下几个原则
1） 最左前缀匹配原则，组合索引非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，
    比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，
    如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
2）较频繁作为查询条件的字段才去创建索引
3）更新频繁字段不适合创建索引
4）若是不能有效区分数据的列不适合做索引列（如性别，男女未知，最多也就三种，区分度实在太低）
5）尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a，b)的索引，那么只需要修改原来的索引即可。
6）定义有外键的数据列一定要建立索引。
7）对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。
8）对于定义为text、image和bit的数据类型的列不要建立索引。
创建索引的三种方式
    第一种方式：在执行CREATE TABLE时创建索引
    第二种方式：使用ALTER TABLE命令去增加索引
    第三种方式：使用CREATE INDEX命令创建
删除索引
    根据索引名删除普通索引、唯一索引、全文索引：alter table 表名 drop KEY 索引名
    删除主键索引：alter table 表名 drop primary key（因为主键只有一个）。
    这里值得注意的是，如果主键自增长，那么不能直接执行此操作（自增长依赖于主键索引）
创建索引时需要注意什么？
    非空字段：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，
        因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；
    取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，
        返回值越大说明字段的唯一值越多字段的离散程度高；
    索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。
```
#### 12.索引哪些情况会失效【6+】
```markdown
索引哪些情况会失效
    1.查询条件包含or，可能导致索引失效，or语句前后没有同时使用索引。
    如果字段类型是字符串，where时一定用引号括起来，否则索引失效
    2.like通配符可能导致索引失效，like以%开头，索引无效。
    3.联合索引，查询时的条件列不是联合索引中的第一个列，索引失效。
    4.在索引列上使用mysql的内置函数，索引失效。
    5.对索引列运算（如，+、-、*、/），索引失效。
    6.索引字段上使用（！= 或者 < >，not in）时，可能会导致索引失效。
    7.索引字段上使用is null， is not null，可能导致索引失效。
    8.左连接查询或者右连接查询查询关联的字段编码格式不一样，可能导致索引失效。
    9.mysql执行引擎估计使用全表扫描要比使用索引快,则不使用索引。
5.这个是着重想问的。下面几个sql语句怎么走索引，怎么查到之后拿出数据
    题目：建立索引（name，age）主键为id，
    select （id，name, sex） from XX where name like “%AA%”
    select （id，name, sex） from XX where age>10
    select （id，name, sex） from XX where age>10 and name like "AA%"
    第一个不能走索引，因为模糊匹配以%开头
    第二个不能走索引，因为最左匹配原则
    第三个可以走部分索引，因为and两边的条件可以交换，并且name字段的条件没有以%开头
```
### 7.查询性能优化【2+】
#### 1.使用Explain进行分析【1+】
[Explain 执行计划包含字段信息](https://www.cnblogs.com/chengxy-nds/p/12924373.html)

[MySQL SQL Explain输出学习](https://www.cnblogs.com/dbabd/p/10471068.html)

[SQL优化与诊断](https://www.cnblogs.com/kkzhilu/p/13352940.html)
```markdown
Explain用来分析SELECT查询语句，开发人员可以通过分析Explain结果来优化查询语句。判断有没有使用到索引
比较重要的字段有：select_type : 查询类型，有简单查询、联合查询、子查询等,key : 使用的索引,rows : 扫描的行数。
```
#### 2.优化数据访问
```markdown
1. 减少请求的数据量
    只返回必要的列：最好不要使用 SELECT * 语句。
    只返回必要的行：使用LIMIT语句来限制返回的数据。
    缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存
    带来的查询性能提升将会是非常明显的。
2. 减少服务器端扫描的行数
    最有效的方式是使用索引来覆盖查询。
```
#### 3.重构查询方式
```markdown
1. 切分大查询 
    一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。
2. 分解大连接查询    
    将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：
    让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。
    分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。减少锁竞争；
    在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。
    查询本身效率也可能会有所提升。例如下面的例子中，使用IN()代替连接查询，可以让MySQL按照ID顺序进行查询，这可能比随机的连接要更高效。
```
### 8.存储引擎【6+】
#### 1.InnoDB
```markdown
- 存储引擎说⽩了就是如何存储数据、如何为存储的数据建⽴索引和如何更新、查询数据等技术的实现⽅法
**InnoDB**是MySQL默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。
实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。
    在可重复读隔离级别下，通过多版本并发控制MVCC+间隙锁Next-KeyLocking防止幻影读。
    主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。
    内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。
    支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。
InnoDB存储引擎的锁的算法有三种：
    - Record lock: 单个行记录上的锁。
    - Gap lock : 间隙锁，锁定yoga范围，不包括记录本身。（目的是阻止多个事务将记录插入到同一个范围内，会导致幻读）
    - Next-key lock: record + gap锁定一个范围，包含记录本身。
```
#### 2.MyISAM
```markdown
**MyISAM**:设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。
    提供了大量的特性，包括压缩表、空间数据索引等。
    不支持事务。不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。
    但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。
    可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。
    如果指定了DELAY_KEY_WRITE选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，
    只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，
    但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。
**3.为什么myisam读比较快**
```
#### 3.InnoDB和MyISAM比较
```markdown
**InnoDB和MyISAM比较**
    事务：InnoDB是事务型的，可以使用Commit和Rollback语句。
    并发：MyISAM只支持表级锁，而InnoDB默认行级锁还支持表级锁。MyISAM不支持事务。
    外键：InnoDB支持外键。
    备份：InnoDB支持在线热备份。
    崩溃恢复：MyISAM崩溃后发生损坏的概率比InnoDB高很多，而且恢复的速度也更慢。
    其它特性：MyISAM支持压缩表和空间数据索引。
MyISAM适合的场景：频繁执行全表count语句；对数据进行增删改的频率不高，查询非常频繁；没有事务；
InnoDB适合的场景：数据增删查改都非常否频繁；可靠性要求比较高，要求支持事务。
memory(heap)：这种类型的数据表只存在于内存中。它使⽤散列索引，所以数据的存取
速度⾮常快。因为是存在于内存中，所以这种类型常应⽤于临时表中。
archive：这种类型只⽀持select 和 insert语句，⽽且不⽀持索引。
Desc[ribe] tablename：查看数据表的结构。
show engines：命令可以显示当前数据库⽀持的存储引擎情况
```
#### 4.InnoDB引擎中的索引类型
[参考文献：聊一聊InnoDB引擎中的索引类型](https://www.cnblogs.com/jamaler/p/12222176.html)

[B-Tree和B+Tree结构及应用，InnoDB引擎， MyISAM引擎](https://www.cnblogs.com/ITnoteforlsy/p/12228149.html)  
```markdown
在InnoDB引擎中有三,在InnoDB引擎中使用B+树来实现B-Tree索引种索引：
    B-Tree 索引 
    哈希索引
    全文索引
B-Tree 索引是 InnoDB 引擎的默认索引,在 InnoDB 引擎中使用 B+树来实现 B-Tree 索引.
    B-Tree 索引中又有主键索引和普通索引
        主键索引也叫聚集索引，是按照主键构建得一棵B+树，只要建立了主键就会自动加上索引，
        主键索引得特点是：叶子节点上存放着整张表的行记录数据，所以叶子节点也叫数据页。
        普通索引也叫二级索引，跟主键索引的主要区别在于叶子结点没有存放行记录的全部数据，
        只包含了需要的键值，还有一个标签，用来告诉存储引擎在哪里可以找到这行数据。
        普通索引因为行记录里没有数据的全部信息，在使用普通索引查询时，需要现在普通索引树上搜索一遍，再回到主键索引树上查询到需要的信息，这个过程也叫回表。
    每一张表其实就是多个B+树，树结点的key值就是某一行的主键，value是该行的其他数据。新建索引就是新增一个B+树，查询不走索引就是遍历主B+树。
```
#### 5.InnoDB引擎中的这些索引策略
[参考文献：聊一聊 InnoDB 引擎中的这些索引策略](https://www.cnblogs.com/jamaler/p/12239558.html)
```markdown
覆盖索引:是指在普通索引树中可以得到查询的结果，不需要在回到主键索引树中再次搜索。
    减少树的搜索次数，显著提升查询性能。
    索引是按照值的顺序存储，所以对于I/O密集型的范围查询比随机从磁盘中读取每一行的I/O要少很多。
    索引的条目远小于数据的条目，在索引树上读取会极大的减小数据库的访问量。
最左前缀原则:是建立在联合索引之上的，如果我们建立了联合索引，我们不需要使用索引的全部定义，
只要用到了索引中的最左边的那个字段就可以使用这个索引，这就是B-tree索引支持最左前缀原则。
索引下推优化:是MySQL5.6引入的，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。
```
### 9.存储过程——游标
[面试官突然问我MySQL存储过程，我竟然连基础都不会！（详细）](https://www.cnblogs.com/ziph/p/13090117.html)
```markdown
存储过程（Stored Procedure）是在大型数据库系统中，一组为了完成特定功能的SQL语句集，
    它存储在数据库中，一次编译后永久有效，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。
存储过程是数据库中的一个重要对象。在数据量特别庞大的情况下利用存储过程能达到倍速的效率提升。
    i.存储过程的创建语句：create procedure procedure_name([存储过程的参数列表])
                    Begin
                        Sql语句
                    End
    ii.调用存储过程：call procedure_name([parameter])
    iii.查看存储过程：show statue
当我们了了解存储过程是什么之后，就需要了解数据库中存在的这三种类型的数据库存储类型程序，如下：
    存储过程：存储过程是最常见的存储程序，存储过程是能够接受输入和输出参数并且能够在请求时被执行的程序单元。
    存储函数：存储函数和存储过程很相像，但是它的执行结果会返回一个值。最重要的是存储函数可以被用来充当标准的SQL语句，允许程序员有效的扩展SQL语言的能力。
    触发器：触发器是用来响应激活或者触发数据库行为事件的存储程序。通常，触发器用来作为数据库操作语言的响应而被调用，触发器可以被用来作为数据校验和自动反向格式化。
注意：其他的数据库提供了别的数据存储程序，包括包和类。目前MySQL不提供这种结构。
```
[存储过程——游标](https://www.cnblogs.com/shanzhiming/p/12975175.html)
```markdown
SQL游标(cursor)是一个数据库对象，用于从结果集中检索某一行的数据。
游标是系统为用户开设的一个数据缓冲区，存放SQL语句的执行结果。每个游标区都有一个名字,用户可以用SQL语句逐一从游标中获取记录，
并赋给主变量，交由主语言进一步处理。在编程中，我们使用诸如for或while之类的循环一次遍历一项，游标遵循相同的方法。
当在SQL中，应用程序逻辑需要一次只处理一行，而不是一次处理整个结果集。可以使用游标完成此操作。
```
### MySQL触发器
```markdown
触发器（trigger）是MySQL提供给程序员和数据分析员来保证数据完整性的一种方法，它是与表事件相关的特殊的存储过程，
    它的执行不是由程序调用，也不是手工启动，而是由事件来触发，比如当对一个表进行操作（insert，delete， update）时就会激活它执行。
    简单理解为：你执行一条sql语句，这条sql语句的执行会自动去触发执行其他的sql语句。
触发器的作用：
    可在写入数据表前，强制检验或转换数据。
    触发器发生错误时，异动的结果会被撤销。
    部分数据库管理系统可以针对数据定义语言（DDL）使用触发器，称为DDL触发器。
    可依照特定的情况，替换异动的指令 (INSTEAD OF)。
触发器也是存储过程程序的一种，而触发器内部的执行SQL语句是可以多行操作的，所以在MySQL的存储过程程序中，要定义结束符。
MySQL表中允许有多少个TRIGGERS？
    在MySQL表中允许有六个触发器，如下：
    BEFORE INSERT
    AFTER INSERT
    BEFORE UPDATE
    AFTER UPDATE
    BEFORE DELETE and
    AFTER DELETE
```
### 主从复制【1+】
```markdown
通过主从复制的方式来同步数据：从原来的数据库复制一个完全一样的数据库，原来的数据库称作主数据库，复制的数据库称为从数据库。
主从复制的原理实际上就是通过binlog日志实现的。binlog日志中保存了数据库中所有SQL语句，通过对binlog日志中SQL的复制，然后再进行语句的执行即可实现从数据库与主数据库的同步。
主从复制的过程：
 在每个事务更新数据完成之前，master在二进制日志记录这些改变。写入二进制日志完成后，master通知存储引擎提交事务。
 Slave将master的binary log复制到其中继日志。首先slave开始一个工作线程（I/O），I/O线程在master上打开一个普通的连接，
然后开始binlog dump process。从master的二进制日志中读取事件，如果已经跟上master，它会睡眠并等待master产生新的事件，I/O线程将这些事件写入中继日志。
 Sql slave thread（sql从线程）处理该过程的最后一步，sql线程从中继日志读取事件，并重放其中的事件而更新slave数据，
    使其与master中的数据一致，只要该线程与I/O线程保持一致，中继日志通常会位于os缓存中，所以中继日志的开销很小。
主要涉及三个线程：binlog线程、I/O线程和SQL线程。
    binlog 线程：负责将主服务器上的数据更改写入二进制日志（Bin log）中。
    I/O线程 ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。
    SQL执行线程 ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。
```
### 读写分离
[提高性能，MySQL 读写分离环境搭建](https://www.cnblogs.com/lenve/p/10855172.html)-- [基于Mycat实现读写分离](https://www.cnblogs.com/atcloud/p/10789850.html)
-- [Mycat → 实现数据库的读写分离与高可用](https://www.cnblogs.com/youzhibing/p/9553766.html)
```markdown
读写分离是依赖于主从复制，而主从复制又是为读写分离服务的。因为主从复制要求slave不能写只能读（如果对slave执行写操作，
那么show slave status将会呈现Slave_SQL_Running=NO，此时你需要按照前面提到的手动同步一下slave）。
主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。读写分离能提高性能的原因在于：
    - 主从服务器负责各自的读和写，极大程度缓解了锁的争用；
    - 从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；
    - 增加冗余，提高可用性。
读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。
    方案一：使用mysql-proxy代理
        优点：直接实现读写分离和负载均衡，不用修改代码，master和slave用一样的帐号，mysql官方不建议实际生产中使用
        缺点：降低性能， 不支持事务
    方案二：使用AbstractRoutingDataSource+aop+annotation在dao层决定数据源。
        - 如果采用了mybatis，可以将读写分离放在ORM层，比如mybatis可以通过mybatis plugin拦截sql语句，
        所有的insert/update/delete都访问master库，所有的select 都访问salve库，这样对于dao层都是透明。
        plugin实现时可以通过注解或者分析语句是读写方法来选定主从库。不过这样依然有一个问题，也就是不支持事务，
        所以我们还需要重写一下DataSourceTransactionManager，将read-only的事务扔进读库，其余的有读有写的扔进写库。
    方案三：使用AbstractRoutingDataSource+aop+annotation在service层决定数据源，
        可以支持事务.
        缺点：类内部方法通过this.xx()方式相互调用时，aop不会进行拦截，需进行特殊处理。
```
### MySQL日志
[超干货！为了让你彻底弄懂MySQL事务日志，我通宵肝出了这份图解！](https://www.cnblogs.com/AmazingJiang/p/13034409.html)
```markdown
MySQL日志系统是数据库的重要组件，用于记录数据库的更新和修改。若数据库发生故障，可通过不同日志记录恢复数据库的原来数据。
因此实际上日志系统直接决定着MySQL运行的鲁棒性和稳健性。
MySQL的日志有很多种，如二进制日志（binlog）、错误日志、查询日志、慢查询日志等，
    此外InnoDB存储引擎还提供了两种日志：redolog（重做日志）和undolog（回滚日志）。
    这里将重点针对InnoDB引擎，对重做日志、回滚日志和二进制日志这三种进行分析。
```
#### redo log重做日志
```markdown
重做日志（redo log）是InnoDB引擎层的日志，用来记录事务操作引起数据的变化，记录的是数据页的物理修改。
重做日记的作用其实很好理解，我打个比方。数据库中数据的修改就好比你写的论文，万一哪天论文丢了怎么呢？以防这种不幸的发生，
我们可以在写论文的时候，每一次修改都拿个小本本记录一下，记录什么时间对某一页进行了怎么样的修改。这就是重做日志。
InnoDB引擎对数据的更新，是先将更新记录写入redolog日志，然后在系统空闲的时候或者是按照设定的更新策略再将日志中的内容更新到磁盘之中。
这就是所谓的**预写式技术**（Write Ahead logging）。这种技术可以大大减少IO操作的频率，提升数据刷新的效率。
脏数据刷盘:redo log日志的大小是固定的，为了能够持续不断的对更新记录进行写入，在redolog日志中设置了两个标志位置，checkpoint和write_pos，分别表示记录擦除的位置和记录写入的位置。
脏日志刷盘:redo log日志在记录时，为了保证日志文件的持久化，也需要经历将日志记录从内存写入到磁盘的过程。
redo log日志可分为两个部分，一是存在易失性内存中的缓存日志redolog buff，二是保存在磁盘上的redolog日志文件redolog file。
为了确保每次记录都能够写入到磁盘中的日志中，每次将redolog buffer中的日志写入redolog file的过程中都会调用一次操作系统的fsync操作。
```
#### bin log二进制日志/归档日志
[什么是 binlog？](https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&mid=2653196018&idx=1&sn=27f2466a6b2bbdda8b73b0a04675771a&chksm=8c99fc28bbee753e68a50408221be7907f385d2b72f013ed45a450e04cda1c3b0432f535f338&mpshare=1&scene=23&srcid=111533wqfwtBrc16Gnr7vxYi#rd)
```markdown
binlog是记录所有数据库表结构变更（例如CREATE、ALTER TABLE…）以及表数据修改（INSERT、UPDATE、DELETE…）的二进制日志。
binlog不会记录SELECT和SHOW这类操作，因为这类操作对数据本身并没有修改，但你可以通过查询通用日志来查看MySQL执行过的所有语句。
二进制日志包括两类文件：
    - 索引文件（文件名后缀为.index）用于记录哪些日志文件正在被使用
    - 日志文件（文件名后缀为.00000*）记录数据库所有的DDL和DML(除了数据查询语句)语句事件。
在my.cnf中有这么三条配置
    - log_bin：on 打开binlog日志
    - log_bin_basename：bin文件路径及名前缀（/var/log/mysql/mysql-bin）
    - log_bin_index：bin文件index（/var/log/mysql/mysql-bin.index）
用途：恢复、复制、审计。
MySQL的binlog有有几种录入格式？分别有什么区别？有三种格式，statement，row和mixed。
1、statement模式下，每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。
    由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。
2、row级别下，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，
    会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大。
3、mixed，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。
    此外，新版的MySQL中对row级别也做了一些优化，当表结构发生变化的时候，会记录语句而不是逐行记录。
```
#### 回滚日志（undo log）
```markdown
回滚日志同样也是InnoDB引擎提供的日志，顾名思义，回滚日志的作用就是对数据进行回滚。
当事务对数据库进行修改，InnoDB引擎不仅会记录redo log，还会生成对应的undo log日志；
如果事务执行失败或调用了rollback，导致事务需要回滚，就可以利用undo log中的信息将数据回滚到修改之前的样子。
但是undo log不redo log不一样，它属于逻辑日志。它对SQL语句执行相关的信息进行记录。
```
### MySQL分库分表及分区
[MySql分库分表与分区的区别和思考](https://www.cnblogs.com/GrimMjx/p/11772033.html)
```markdown
当一张表随着时间和业务的发展，库里表的数据量会越来越大。数据操作也随之会越来越大。一台物理机的资源有限，
最终能承载的数据量、数据的处理能力都会受到限制。这时候就会使用分库分表来承接超大规模的表，单机放不下的那种。
区别于分区的是，分区一般都是放在单机里的，用的比较多的是时间范围分区，方便归档。
只不过分库分表需要代码实现，分区则是mysql内部实现。分库分表和分区并不冲突，可以结合使用。
既然分库分表了，那么肯定涉及到分布式事务，如何保证插入到不同库的多条记录能够要么同时成功，要么同时失败。
```
### MySQL备份与主备配置
[MySQL备份与主备配置](https://www.cnblogs.com/jxtxzzw/p/10844462.html)
```markdown
数据备份类型
    全量备份：备份整个数据库(全量备份的方法有 2 种，一种是利用数据库管理工具提供的备份恢复和导入导出功能)
    增量备份：备份自上一次备份以来（增量或完全）以来变化的数据。(binlog用于记录用户对数据库更新的SQL语句信息)
    差异备份：备份自上一次完全备份以来变化的数据
必须要在未登录状态下
* 导出整个数据库 mysqldump -u ⽤户名 -p 数据库名 > 导出的⽂件名
* 导出⼀个表 mysqldump -u ⽤户名 -p 数据库名 表名> 导出的⽂件名
* 导出⼀个数据库结构 mysqldump -u dbuser -p -d --add-drop-table dbname >d:/dbname_db.sql
    -d 没有数据 --add-drop-table 在每个create语句之前增加⼀个drop table
```
### MySQL运维
[聊聊数据库~5.SQL运维上篇](https://www.cnblogs.com/dotnetcrazy/p/10810798.html)
[聊聊数据库~6.SQL运维中篇](https://www.cnblogs.com/dotnetcrazy/p/11029323.html)
### Having作用
```markdown
来过滤由GROUP BY语句返回的记录集(对分组后结果过滤，可以使用聚合函数如(max、min))
SELECT id, COUNT(course) as numcourse, AVG(score) as avgscore
FROM student
GROUP BY id
HAVING AVG(score)>=80;
```
### 通⽤SQL函数
```markdown
数学函数
    Abs（num）求绝对值
    floor（num）向下取整
    ceil（num）向上取整
字符串函数
    insert (s1,index,length,s2) 替换函数
        S1表示被替换的字符串
        s2表示将要替换的字符串
        Index表示被替换的位置,从1开始
        Lebgth表示被替换的⻓度
    upper（str），ucase（str）将字⺟改为⼤写
    lower（str），lcase（str）将字⺟改为⼩写
    left（str，length）返回str字符串的前length个字符
    right（str，length）返回str字符串的后length个字符
    substring（str，index，length）返回str字符串从index位开始⻓度为length个字符（index从1开始）
    reverse（str）将str字符串倒序输出
⽇期函数
    curdate（）、current_date( )获取当前⽇期
    curtime（）、current_time( )获取当前⽇期
    now（）获取当前⽇期和时间
    datediff（d1、d2）d1和d2之间的天数差
    adddate（date，num）返回date⽇期开始，之后num天的⽇期
    subdate（date，num）返回date⽇期开始，之前num天的⽇期
聚合函数
    Count（字段）根据某个字段统计总记录数（当前数据库保存到多少条数据）
    sum（字段）计算某个字段的数值总和
    avg（字段）计算某个字段的数值的平均值
    Max（字段）、min（字段）求某个字段最⼤或最⼩值
```
## 优秀的博客文章
### 1.数据库设计
[14 个实用的数据库设计技巧](https://mp.weixin.qq.com/s?__biz=MzUxOTc4NjEyMw==&mid=2247484832&idx=1&sn=2671b8dded66352415eb0aaab9065de0&chksm=f9f51e44ce829752344c6e92a54340f23ebe2ccfe19f8d2bfa46ae2ff261a9873137beee18a0&mpshare=1&scene=23&srcid=&sharer_sharetime=1568260711776&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
```markdown

```
[浅析实际项目中对数据库设计的一些思考](https://www.cnblogs.com/Kevin-ZhangCG/p/10270996.html)
[数据库状态标识位flag设计](https://www.cnblogs.com/gouyg/p/mysql-flag-php.html)
### 1.埋在MySQL数据库应用中的17个关键问题！
[埋在MySQL数据库应用中的17个关键问题！](https://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247487762&idx=1&sn=dc71279f36959b62b63b48108cf8dca3&chksm=e9c5e8a3deb261b5e755d3ace7f2e4c6d69ac20e2510a2f7bd7a32adaf1413b053e3ab411aa7&mpshare=1&scene=23&srcid=1204BeiYSpXyUpL3fQ6wUW0P#rd)
```markdown
MySQL的一些问题：性能优化、高可用性、强一致性、安全、备份、集群、横向扩展、纵向扩展、负载均衡、读写分离等
一：单Master：
    数据备份：冷备，热备，温备
    数据还原
    备份监控
    数据文件远程存储
二：一主一从：初衷是系统性能和系统高可用性问题
    数据备份，性能优化、读写分离、负载均衡
三：一主n从：可用性、一致性、性能中一种或者多种的要求比较高
四：横向集群
    横向集群主要是从业务特性的角度对系统进行切分，最彻底就是切分成了各个子系统，子系统之间通过一些数据同步的方案来把一些核心数据进行共享，以避免跨库调用跨库join。
五、纵向集群
```
[数据库并发处理 - 上的一把好"锁"](https://www.cnblogs.com/michael9/p/12167434.html)

[索引很难么？带你从头到尾捋一遍MySQL索引结构，不信你学不会！](https://www.cnblogs.com/javazhiyin/p/12016500.html)

[后端程序员必备：书写高质量SQL的30条建议](https://www.cnblogs.com/jay-huaxiao/p/12546973.html)

[教你如何迅速秒杀掉：99%的海量数据处理面试题](https://blog.csdn.net/v_july_v/article/details/7382693)

[很用心的为你写了 9 道 MySQL 面试题](https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247488127&idx=4&sn=040019b9991f9d62dcb0ded7d6cb7d1a&chksm=fa0e7dfecd79f4e8e2ab5b0e84ce7efa25589ebbb9eecf1b51d5413bc7edfc501a903c859201&mpshare=1&scene=23&srcid=&sharer_sharetime=1587272608819&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)

[mysql insert锁机制](https://blog.csdn.net/zhanghongzheng3213/article/details/53436240)




[被敖丙用烂的「数据库调优」连招？真香，淦！](https://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&mid=2453143331&idx=1&sn=e387e1b1beb4cd516ee2d67ce934115e&chksm=8cf2dda0bb8554b67c7441db899edc25f740828ed545980a64b75f13ef9946ff402cc2a36937&mpshare=1&scene=23&srcid=&sharer_sharetime=1591853606997&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
### 2.按照这些优化技巧来写SQL，连公司DBA也鼓掌称赞！
[按照这些优化技巧来写SQL，连公司DBA也鼓掌称赞！](https://www.cnblogs.com/Howinfun/p/12857976.html)
```markdown
一、索引优化
    1、建立普通索引
    2、建立复合索引
    3、最左前缀匹配原则 [面试中常被提到的最左前缀匹配原则](https://www.cnblogs.com/ljl150/p/12934071.html)
    4、索引下推
    5、覆盖索引
    6、普通索引
    7、前缀索引
    8、干净的索引列
二、SQL 优化
    1、Order By优化
    2、Join优化
    3、Group By优化
    4、OR 优化
    5、IN 优化
    6、Like 优化
三、数据表设计优化
    1、数据类型：应该选择更简单或者占用空间更小的类型。
    2、避免空值：
    3、超长字符串：
```
### 3.MySQL优化
[4.数据库优化 - SQL优化](https://www.cnblogs.com/lyn20141231/p/11742042.html)
[基于MySQL的SQL优化总结](https://www.cnblogs.com/itzhouq/p/mysql1.html)
[数据库语句优化](https://www.cnblogs.com/shiguangliushi/p/10832554.html)
[用 Explain 命令分析 MySQL 的 SQL 执行](https://www.cnblogs.com/remcarpediem/p/13138063.html)
[Explain执行计划和SQL优化](https://www.cnblogs.com/keme/p/9882663.html)
[SQL优化指南](https://www.cnblogs.com/fengyumeng/p/9888148.html)
### 4.MySQL慢查询优化和排查【2+】
[MySQL慢查询日志总结](https://www.cnblogs.com/kerrycode/p/5593204.html)
[MySQL慢查询日志释疑总结](https://www.cnblogs.com/kerrycode/p/9963764.html)
[MySQL 性能优化之慢查询](https://www.cnblogs.com/chenyanbin/p/13128593.html)
>> 慢查询：就是在日志中记录运行比较慢的SQL语句，需要开启才能使用，或者修改配置文件。
#### 1.如何定位并优化慢查询sql
```markdown
具体场景具体分析，只提出大致思路：
    - 根据慢日志定位慢查询SQL
    - 使用explain等等工具分析SQL
    - 使用show profile[s] 查看由问题的SQL的性能使用情况
    - 修改SQL或者尽量让SQL走索引
>> show variables like "%quer%"  -- 获取慢查询的信息(慢查询日志的开启情况，慢查询日志存储地址，慢查询插入时间设置)
>> show status like '%slow_queries%' -- 查看慢查询的数量
>> set global show_query_log = on; -- 打开慢查询日志
>> set global long_query_time = 1; -- 设置慢查询开始的时间
```
#### 2.常见的慢查询的优化
```markdown
索引没起作用的情况：
    - 使用like关键字的查询语句
        如果使用like关键字进行查询的查询语句中，如果匹配字符串的第一个字符串为%,索引不会起作用。
        只有%不在第一个位置索引才会起作用。
    - 使用多列索引的查询语句
        mysql可以为多个字段创建索引，一个索引最多可以包括16个字段。
        对于多列索引，只有查询条件使用了这些字段中的第一个字段时,索引才会使用。
```
### 2.[一个SQL执行的很慢，我们要分两种情况讨论](https://www.cnblogs.com/kubidemanong/p/10734045.html)【1+】
```markdown
    1、大多数情况下很正常，偶尔很慢，则有如下原因
        (1)、数据库在刷新脏页，例如 redo log 写满了需要同步到磁盘。
        (2)、执行的时候，遇到锁，如表锁、行锁。
    2、这条 SQL 语句一直执行的很慢，则有如下原因。
        (1)、没有用上索引：例如该字段没有索引；由于对字段进行运算、函数操作导致无法用索引。
        (2)、数据库选错了索引。
```
### 4.MySQL大数据量查询优化
[3.Mysql面试题及千万级数据查询优化](https://www.cnblogs.com/lyn20141231/p/11742042.html)
[MySQL上亿大表优化实践](https://www.cnblogs.com/YangJiaXin/p/10828244.html#%E5%88%86%E6%9E%90)
### [写一手好SQL很有必要](https://www.cnblogs.com/xiaoyangjia/p/11267191.html)

## MySQL实战
### [01.当执行一条select语句时，MySQL到底做了啥？](https://www.cnblogs.com/hoxis/p/10006871.html)
![MySQL一条语句的执行流程](https://imgkr.cn-bj.ufileos.com/c7ab6d9b-751b-4725-affc-fc0d6506ccd2.png)
```markdown
1.通过MySQL的基础架构看MySQL的命令执行流程。
MySQL主要分为server层和存储引擎层。
    - server 层中包含连接器，查询缓存，分析器，优化器，执行器，大多数核心功能以及内置函数，存储过程，触发器，视图等。
    - 存储引擎层主要负责最终数据的存储和提取，例如常用的存储引擎 InnoDB、MyISAM 等。
客户端先查询缓存，看这条语句是否执行过，存在缓存中，存在及立即调用缓存到执行器执行。
    若不存在缓存，则到解析器然后预处理器->查询优化器->执行计划->执行器->存储引擎。
```
### [02.一条update SQL语句是如何执行的]()
```markdown
一条更新语句的执行过程和查询语句类似，更新的流程涉及两个日志：redo log（重做日志）和binlog（归档日志）。
```

### [MySQL服务器 IO 100%的案例分析](https://www.cnblogs.com/wangdong/p/9814988.html)
### [MySQL全文索引简单实现搜索引擎](https://www.cnblogs.com/YangJiaXin/p/11153579.html) 

## MySQL工作使用
### [项目上线后，谈一下感触比较深的一点：查询优化](https://www.cnblogs.com/youzhibing/p/11105897.html)
```markdown

```
[SQL运行内幕：从执行原理看调优的本质](https://www.cnblogs.com/arthinking/p/13205303.html)
### [MySQL数据库“十宗罪”【十大经典错误案例】](https://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247487474&idx=1&sn=d5cc8f77a4a992142d34c76e3df14e1e&chksm=e9c5f643deb27f55f15df6f96a86da660a782a4a11f2f4bd2331ad562d8d3742b14a09be264b&mpshare=1&scene=23&srcid=1106aA1lme4DMfsqEdsg48PO#rd)
```markdown
Top 1：Too many connections（连接数过多，导致连接不上数据库，业务无法正常进行）
Top 2：（主从复制报错类型）
Top 3：MySQL安装过程中的报错
Top 4：数据库密码忘记的问题
Top 5：truncate 删除数据，导致自动清空自增ID，前端返回报错 not found。
Top 6：阿里云 MySQL 的配置文件中，需要注意一个参数设置就是：
Top 7：数据库总会出现中文乱码的情况
Top 8：使用 binlog_format=statement 这种格式，跨库操作，导致从库丢失数据，用户访问导致出现错误数据信息。
Top 9：MySQL 数据库连接超时的报错 
Top 10 ：can't open file (errno:24)
```
### [Java操作MySQL数据库 limit 实现分批分页，解决内存溢出问题](https://blog.csdn.net/Agly_Clarlie/article/details/53185750)

## 数据库面试题
### MySQL常见6个考题在实际工作中的运用
[MySQL常见6个考题在实际工作中的运用](https://www.cnblogs.com/xiexj/p/12952378.html)
#### 1.MyISAM和InnoDB的区别，什么时候选择MyISAM?
```markdown
InnoDB是目前MySQL主流版本(5.6、5.7、8.0)默认的存储引擎，支持事务、外键、行级锁，对于并发条件下要求数据的一致性，适用于对数据准确性要求高的场景。
MyISAM只支持表级锁、数据排列是按照插入顺序，没有做规则排序。适合应用以查询和插入为主，只有很少量的更新和删除操作，对事务的完整性和并发性要求不是很高的场景。
通常都会有几张MyISAM的数据表，通常用来存储历史记录，与使用InnoDB存储实时记录信息的配合使用。
```
#### 2.简述MySQL的MVCC多版本并发控制【2+】
```markdown
MVCC：Multi-Version Concurrency Control，即多版本的并发控制协议。MVCC就是用来实现上面的第三个隔离级别，可重复读RR。
MVCC的特点就是在同一时刻，不同事务可以读取到不同版本的数据，从而可以解决脏读和不可重复读的问题。
    MVCC实际上是通过数据的隐藏列和回滚日志(undolog),实现多个版本数据的共存。
    这样的好处是，使用MVCC进行读数据的时候，不用加锁，从而避免了同时读写的冲突。
```
#### 3.分布式锁的实现方式
```markdown
主流有三种
    1>基于数据库
        1.1>基于数据库主键：插入一条数据，指定主键。如果有两条插入会主键冲突，并发执行失败
        1.2>基于数据库排他锁：提交一个update事务，如果这个事务不提交，其他也对锁定范围内执行update就会阻塞，解决并发问题
    2>基于缓存比如redis的setNX
    3>基于zookeeper
```
#### 4.为什么采用B+树作为索引结构?
```markdown
采用Hash表，范围查找需要全表扫描；采用二叉查找树，由于无法保证平衡，可能退化为链表；采用平衡二叉树，通过旋转解决了平衡的问题，但是旋转操作效率太低；
采用红黑树，树太高，IO次数多；采用普通B树，节点要存数索引和数据，一个内存页可存储的数据还是少，另外范围查找也需要多次IO；
而B+Tree有三个特性：
    1>非叶子节点不存储data，只存储索引(冗余)，可以放更多的索引
    2>叶子节点包含所有索引字段
    3>叶子节点用指针链接，提高范围查询的性能
```
### [100道MySQL数据库经典面试题解析（收藏版）](https://www.cnblogs.com/jay-huaxiao/p/12950484.html)
#### 1. MySQL索引使用有哪些注意事项呢？
>> 可以从三个维度回答这个问题：索引哪些情况会失效，索引不适合哪些场景，索引规则
```markdown
索引哪些情况会失效
    查询条件包含or，可能导致索引失效
    如何字段类型是字符串，where时一定用引号括起来，否则索引失效
    like通配符可能导致索引失效。
    联合索引，查询时的条件列不是联合索引中的第一个列，索引失效。
    在索引列上使用mysql的内置函数，索引失效。
    对索引列运算（如，+、-、*、/），索引失效。
    索引字段上使用（！= 或者 < >，not in）时，可能会导致索引失效。
    索引字段上使用is null， is not null，可能导致索引失效。
    左连接查询或者右连接查询查询关联的字段编码格式不一样，可能导致索引失效。
    mysql估计使用全表扫描要比使用索引快,则不使用索引。
索引不适合哪些场景
    数据量少的不适合加索引
    更新比较频繁的也不适合加索引
    区分度低的字段不适合加索引（如性别）
索引的一些潜规则
    覆盖索引
    回表
    索引数据结构（B+树）
    最左前缀原则
    索引下推
```
#### 2. MySQL 遇到过死锁问题吗，你是如何解决的？
```markdown
我排查死锁的一般步骤是酱紫的：
    查看死锁日志show engine innodb status;
    找出死锁Sql
    分析sql加锁情况
    模拟死锁案发
    分析死锁日志
    分析死锁结果
```
#### 3. 日常工作中你是怎么优化SQL的？
```markdown
可以从这几个维度回答这个问题：
    加索引
    避免返回不必要的数据
    适当分批量进行
    优化sql结构
    分库分表
    读写分离
```
#### 存储过程和函数的区别？
```markdown
 存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。
    函数每次执行都需要编译一次。
 存储过程中可以使用try-catch块和事务，而函数中不可以
 函数有且只有一个输入参数和一个返回值，而存储过程没有这个限制
 函数可以被存储过程调用而存储过程不可以被函数调用
```
#### 视图的操作会对基本表产生影响吗？
```markdown
 视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，视图通常是有一个表或者多个表的行或列的子集。
对视图的修改会影响基本表。它使得我们获取数据更容易，相比多表查询。
 当用户试图修改视图的某些信息时，数据库必须把它转化为对基本表的某些信息的修改，对于简单的视图来说，这是很方便的，
但是，对于比较复杂的试图，可能是不可修改的。
```
### [5.不就是SELECT COUNT语句吗，竟然能被面试官虐的体无完肤](https://www.cnblogs.com/hollischuang/p/11711778.html)

## MySQL的一些命令
[1000行MySQL学习笔记](https://mp.weixin.qq.com/s?__biz=MzIxNTQ0MDQxNg==&mid=2247486626&idx=1&sn=360e0ff2e280e800a5e6defb2cc5aabf&chksm=979901eda0ee88fbaf17f81b6cbf1d870aa59bd78ea2fcf25a91e9ca157f2c77f9d6f6bb7f95&mpshare=1&scene=23&srcid=&sharer_sharetime=1575470170943&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
```mysql
show engines;  # 查看MySQL所有的的存储引擎
show variables like '%storage_engine%'; # 查看默认的存储引擎
show table status like 'table_name'; #查看表的存储引擎
```
[MySQL基础知识和常用命令总结](https://www.cnblogs.com/justisme/p/12797955.html)

## LeetCode MySQL题目
```mysql
-- 175,181,183,184,176,177,178,180,626,
```
### 182. 查找重复的电子邮箱
```mysql
-- 编写一个 SQL 查询，查找 Person 表中所有重复的电子邮箱。
-- 解法1
select email from person group by email having count(email)>1

--解法2
select email from (select count(1) as t,email from person group by email)r  where r.t>1;

-- 解法3
select distinct(p1.Email) from Person p1  
    join Person  p2 on p1.Email = p2.Email AND p1.Id!=p2.Id
```
### 184.184. 部门工资最高的员工
```mysql
-- Employee 表包含所有员工信息，每个员工有其对应的 Id, salary 和 department Id。
select DeportmentId,MAX(Salary) from Employee Group BY DeportmentId;

SELECT
    Department.name AS 'Department',
    Employee.name AS 'Employee',
    Salary
FROM
    Employee
        JOIN
    Department ON Employee.DepartmentId = Department.Id
WHERE
    (Employee.DepartmentId , Salary) IN
    (   SELECT
            DepartmentId, MAX(Salary)
        FROM
            Employee
        GROUP BY DepartmentId
	)
```
### 196. 删除重复的电子邮箱
```mysql
DELETE p1.* from Person p1, Person p2 where p1.Email = p2.Email AND p1.Id>p2.Id;
delete p1 from (Person as p1 left join Person as p2 on p1.Email = p2.Email) where p1.Id = p2.Id;
delete from Person where Id not in (
    select Id from(
        select MIN(Id) as Id
        from Person
        GROUP BY Email
    ) as temp
);
```
### 595. 大的国家
```mysql
-- 如果一个国家的面积超过300万平方公里，或者人口超过2500万，那么这个国家就是大国家。
select name,population,area from World where area >3000000 or population >25000000;
select name,population,area from World where area > 3000000 
    UNION 
select name,population,area from World where population > 25000000;
```
### 601. 体育馆的人流量
```mysql
-- X 市建了一个新的体育馆，每日人流量信息被记录在这三列信息中：序号 (id)、日期 (visit_date)、 人流量 (people)。
-- 请编写一个查询语句，找出人流量的高峰期。高峰期时，至少连续三行记录中的人流量不少于100。
select distinct a.* from stadium a,stadium b,stadium c 
    where a.people>=100 and b.people>=100 and c.people>=100
and (
    (a.id = b.id+1 and b.id = c.id + 1 and a.id = c.id + 2) or 
    (a.id = b.id-1 and a.id = c.id + 1 and b.id = c.id + 2) or 
    (a.id = b.id-1 and b.id = c.id - 1 and c.id = a.id + 2)
) order by a.id;

```
### 627.交换工资
```mysql
-- 给定一个salary表，如下所示，有m=男性和f=女性的值。交换所有的f和m值（例如，将所有f值更改为m，反之亦然）。
-- 要求只使用一个更新（Update）语句，并且没有中间的临时表。
update salary set sex = if(sex = 'm','f','m');
update salary
    set sex = (case sex
                when 'm' then 'f'
                else 'm'
            end
            );
update salary set sex = char ( ASCII(sex) ^ ASCII('m') ^ ASCII('f'));
```
### 620. 有趣的电影
```mysql
select * from cinema where id%2=1 and description!= 'boring' order by rating DESC;
select * from cinema where id%2=1 and description <> 'boring' order by rating DESC;
```
### 596. 超过5名学生的课
```mysql
#共三种写法
#最朴实的写法，共三层查询，先利用 DISTINCT 去掉重复记录得到表 A，再利用 GROUP BY 为 CLASS 分组，然
#后用 COUNT() 统计每组个数得到表 B，最后在最外层限定数量 >=5 查到结果
SELECT B.CLASS								#最外层
	FROM (SELECT A.CLASS,COUNT(A.CLASS) C          #第二层查询，得到具有 CLASS、COUNT(CLASS) 的表 B
		FROM (SELECT DISTINCT *				#第三层查询，去重得到表 A
			FROM COURSES) A
	GROUP BY A.CLASS) B						#分组
	WHERE B.C >= 5;							#条件

#稍微优化，两层查询，主要是因为用了 HAVING 省了一层查询
SELECT A.CLASS					#最外层
	FROM (SELECT DISTINCT *		#第二层查询，去重得到表 a
		FROM COURSES) A
	GROUP BY A.CLASS			        #分组
	HAVING COUNT(A.CLASS) >= 5;	#利用 COUNT() 计算每组个数并筛选

#极致优化，一层查询，利用 GROUP BY 为 CLASS 分组后，直接用 COUNT() 统计每组学生个数，在统计前先用
# DISTINCT 去掉重复学生
SELECT CLASS
	FROM COURSES
	GROUP BY CLASS							#分组
	HAVING COUNT(DISTINCT STUDENT) >= 5;          #利用 COUNT() 统计每门课 STUDENT 的个数，同时利
```
