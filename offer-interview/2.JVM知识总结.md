# JVM知识总结
>> **深入了解Java虚拟机第二版，第三版**

>> [1.参考博客：随笔分类 - Java虚拟机](https://www.cnblogs.com/ysocean/category/1151281.html)
[2.随笔分类 - JVM](https://www.cnblogs.com/pony1223/category/1181798.html)
[3.随笔分类 - 05.JVM基础系列](https://www.cnblogs.com/chanshuyi/category/1335567.html)
>> [4.JVM 底层原理知识总结](https://doocs.github.io/jvm)

[TOC]


## 基础知识整理
>> 参考：cyc2018大佬

>> 参考：[Java程序员必备基础结构图](https://www.cnblogs.com/jay-huaxiao/p/12819379.html)
>> 参考：[JVM-垃圾回收篇-知识梳理](https://www.cnblogs.com/linzworld/p/13685715.html)
>> 参考：[一文带你学会java的jvm精华知识点](https://www.cnblogs.com/jichi/p/12827921.html)
### 0.JVM简介(JDK,JRE,JVM)【5+】
[JVM中的五大内存区域划分详解及快速扫盲](https://www.cnblogs.com/chaogu94/p/12529692.html)
```markdown
Java文件必须先通过javac的编译器，将代码编译成class文件，然后通过JVM把class文件解释成各个平台可以识别的机器码，最终实现跨平台运行代码。
    Java文件->Java编译器->Class文件->JVM->机器码
JDK：全称为JavaDevelopmentKit，java开发工具包，提供了Java的开发环境和运行环境。
        即所有有关java的东西都包含在里面，比如运行环境JRE、java的核心代码、JVM等等。
JRE：全称为JavaRuntimeEnvironment，java运行环境，为Java的运行提供了所需的环境。
        即想要运行java文件必须先有java的环境才行，jre就是提供了这么一个环境。
JVM(Java Virtual Machine)Java虚拟机，包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收，堆和一个存储方法域。
    JVM是运行在操作系统之上的，它与硬件没有直接的交互。是java最核心的部分。JDK>JRE>JVM
具体来说JDK其实包含了JRE，同时还包含了编译Java源码的编译器Javac，还包含了很多Java程序调试和分析的工具。
简单来说，如果需要运行Java程序，只需要安装JRE就可以了，如果需要编写Java程序，需要安装JDK。
```
>> 参考：[JVM-内存模型](https://www.cnblogs.com/ljl150/p/12535658.html)
### 0.JVM的主要组成部分及其作用
```markdown
Class Loader类加载器：类加载器的作用是把Java代码转换为字节码，比如编写一个HelloWord.java程序，然后通过javac编译成class文件。
    Class Loader承担加载到内存中被执行的责任，当然，不可能随便建立一个.class文件就能被加载的，Class Loader加载的class文件是有格式要求。
 Runtime data area运行数据区：运行数据区是整个JVM的重点。运行时数据区再把字节码加载到内存中。
 Execution Engine执行引擎：Class Loader只管加载，只要符合文件结构就加载，至于说能不能运行，则不是它负责的，
    那是由Execution Engine负责的。执行引擎也叫做解释器 (Interpreter)，负责解释命令，提交操作系统执行。
 Native Interface本地接口：本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序，Java诞生的时候是C/C++横行的时候，
    要想立足，必须有一个聪明的、睿智的调用C/C++程序，于是就在内存中专门开辟了一块区域处理标记为native的代码。
```
### 1.Java运行时内存区域【10+】
![运行时数据区域](https://user-gold-cdn.xitu.io/2020/4/29/171c6a4017b17e4a?w=906&h=699&f=png&s=69259)
![](https://img-blog.csdnimg.cn/2020031921400547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_30,text_5YWs5LyX5Y-377ya57yW56iL5byA5Y-R5YiG5Lqr6ICF,size_16,color_FFFFFF,t_70)
```markdown
1.程序计数器(线程私有):记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。唯一没有OOM的区域。
        由于线程的切换，CPU在执行的过程中，一个线程执行完了，接下来CPU切换到另一个线程去执行，
        另外一个线程执行完再切回到之前的线程，这时需要记住原线程的下一条指令的位置，所以每一个线程都需要有自己的PC。
2.虚拟机栈(线程私有):每个Java方法在执行的同时会创建一个栈帧用于存储**局部变量表、操作数栈、常量池引用、动态链接、返回地址**等信息。
        每一个方法调用直至执行完成的过程，对应着一个栈帧在Java虚拟机栈中入栈和出栈的过程。
        在Java虚拟机规范中，对此区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将会抛出StackOverflowError异常；
            **如果虚拟机栈动态扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。**
        局部变量表：局部变量表是一组变量值存储空间，用来存放方法参数、方法内部定义的局部变量。局部变量表的容量是以变量槽（variable slot）为最小的单位。
            Java虚拟机没有明确规定一个slot所占的空间大小。只是导向性的说了每一个slot能存放8中基本数据类型中的一种(long 和double这种64位的需要两个slot)；
        操作数栈：是用来记录一个方法在执行的过程中，字节码指令向操作数栈中进行入栈和出栈的过程。
            大小在编译的时候已经确定了，当一个方法刚开始执行的时候，操作数栈中是空发的，在方法执行的过程中会有各种字节码指令往操作数栈中入栈和出栈。
        动态链接：因为字节码文件中有很多符号的引用，这些符号引用一部分会在类加载的解析阶段或第一次使用的时候转化成直接引用，这种称为静态解析；
            另一部分会在运行期间转化为直接引用，称为动态链接。
        返回地址（returnAddress）：类型（指向了一条字节码指令的地址）
3.本地方法栈(线程私有):本地方法栈与Java虚拟机栈类似，区别只不过是本地方法栈为Native本地方法服务，虚拟机栈为虚拟机执行Java方法服务。
        在HotSpot虚拟机实现中是把本地方法栈和虚拟机栈合二为一的，同理它也会抛出StackOverflowError和OOM异常。
4.堆内存(线程共享):主要用于存放新创建的对象(所有对象都在这里分配内存)，是垃圾收集的主要区域（"GC堆"），对象实例的分配区域。
        1.Java堆内存 = 老年代 + 新生代，新生代与老年代默认比例的值为 1:2 ，可以通过参数 –XX:NewRatio 配置。
        2.新生代 = Eden区 + From Survivor区（简称S0）+ To Survivor区（简称S1区）
        3.默认的，Eden : from : to = 8 : 1 : 1 ，可以通过参数–XX:SurvivorRatio来设定。
    Java对象在堆内存中包括对象头、实例数据和补齐填充3个部分：
        1.对象头包括Mark Word(存储哈希码，GC分代年龄等)和类型指针(对象指向它的类型元数据的指针),如果是数组对象，还有一个保存数组长度的空间。
        2.实例数据是对象真正存储的有效信息，包括了对象的所有成员变量，其大小由各个成员变量的大小共同决定。
        3.对齐填充不是必然存在的，仅仅起占位符的作用。
5.方法区/永久代(线程共享):用于存放已被**JVM加载的类信息、常量、静态变量、即时编译器编译后的代码**等数据。
        运行时常量池（Runtime Constant Pool）:运行时常量池是方法区的一部分。
        Class文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池。
        用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。 
在Java8中，永久代已经被移除，被一个称为**元空间**的区域所取代。元空间的本质和永久代类似，
    元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。
```
![堆内存结构的默认分配图：](https://user-gold-cdn.xitu.io/2020/4/30/171c6b5bddadd635?w=955&h=353&f=png&s=30398)
![用一张图总结](https://img-blog.csdnimg.cn/2020031921400547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_30,text_5YWs5LyX5Y-377ya57yW56iL5byA5Y-R5YiG5Lqr6ICF,size_16,color_FFFFFF,t_70)
#### 1.1程序计数器、虚拟机栈、本地方法栈为什么是私有的？
```markdown
程序计数器的作用：
    1.字节码接收器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
    2.在多线程中，程序计数器用于记录当前程序执行的位置，从而当线程被切换回来的时候知道线程上次运行到哪里了。
    3.需要注意的是，如果执行的是native方法，程序计数器记录的是undefined地址，只有线程的是java代码时记录的是下一条指令的地址。
    所以程序计数器私有主要是为了线程切换之后能够恢复到正确的执行位置。
虚拟机栈：每个Java方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等等信息。从方法调用直至执行完成的过程，
            就对应着一个栈帧在Java虚拟机中入栈的过程。
本地方法栈：虚拟机栈为虚拟机在线Java方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的Native方法服务。
    为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。
```
#### 1.2.JDK8使用元空间(mateSpace)替代永久代(PermGen)，及两者区别。
```markdown
- 元空间使用本地内存，而永久代使用的是JVM的内存
- 字符串常量池存在永久代中，容易出现性能问题和内存溢出
- 类和方法的信息大小难易确定，给永久代的大小指定带来困难
- 永久代会为GC带来不必要的复杂性
- 方便HotSpot与其他JVM如Jrockit的集成。
```
### 2.Java中成员变量、局部变量、静态变量、常量分别存储在那些内存区域中？【2+】
```markdown
 成员变量：堆内存
 局部变量：
     局部变量是基本类型（8 种基本类型）：栈内存
     局部变量是对象：对象实例存储在堆内存中，对象引用存储在栈内存中
 静态变量（static 修饰）：方法区（元数据区）
 常量（final 修饰）：方法区（元数据区）
String aa = new String();new创建的对象存储在堆内存中；aa这个局部变量存储在栈内存中；
new一个对象，引用放在堆内存，基本数据类型的数据会放在栈内存。
```
### 2.Java创建一个对象步骤和类实例化原理
[深入理解Java对象的创建过程：类的初始化与实例化](https://blog.csdn.net/justloveyou_/article/details/72466416)
[面试题：JVM在Java堆中对对象的创建、内存结构、访问方式](https://www.cnblogs.com/okho-ice/p/13697472.html)
>> Java对象的创建过程包括类初始化（JVM类加载机制）和类实例化两个阶段。
>> 类的实例化是指创建一个类的实例(对象)的过程；
>> 类的初始化是指为类中各个类成员(被static修饰的成员变量)赋初始值的过程，是类生命周期中的一个阶段。
>> 在Java中，一个对象在可以被使用之前必须要被正确地初始化，这一点是Java规范规定的。
>> 在实例化一个对象时，JVM首先会检查相关类型是否已经加载并初始化，如果没有，则JVM立即进行加载并调用类构造器完成类的初始化。
>> 在类初始化过程中或初始化完毕后，根据具体情况才会去对类进行实例化。
#### 2.1.Java对象创建时机
```markdown
（1）使用new关键字创建对象 　Student student = new Student();
（2）反射创建对象
　　使用Class类的newInstance方法
　　　　Student student2 = (Student)Class.forName("Student类全限定名").newInstance()；
　　使用Constructor类的newInstance方法
　　　　Constructor<Student> constructor = Student.class.getConstructor(Integer.class);
　　　　Student stu3 = constructor.newInstance(123);
（3）使用Clone方法创建对象（实现Cloneable接口）
　　无论何时调用一个对象的clone方法，JVM都会创建一个新的、一样的对象，需说明的是，用clone方法创建对象的过程中并不会调用任何构造函数。
（4）使用(反)序列化机制创建对象（实现Serializable接口）
　　当我们反序列化一个对象时，JVM会给我们创建一个单独的对象，在此过程中，JVM并不会调用任何构造函数。
```
#### 2.2. Java对象的创建过程
```markdown
当一个对象被创建时，虚拟机就会为其分配内存来存放对象自己的实例变量及其从父类继承过来的实例变量（即使这些从超类继承过来的
实例变量有可能被隐藏也会被分配空间）。在为这些实例变量分配内存的同时，这些实例变量也会被赋予默认值(零值)。
主要涉及三种执行对象初始化的结构，分别是实例变量初始化、实例代码块初始化、构造函数初始化。
    编译器构造类的构造函数<init>()（按顺序执行）：
　　  父类构造器
　　  实例变量初始化和实例代码块初始化相关代码
　　  本身构造函数
    1、实例变量初始化和实例代码块初始化按照编程顺序来执行，不允许顺序靠前的实例代码块访问其后面定义的实例变量，但是可以赋值。
    2、每一个Java中的对象都至少会有一个构造函数，如果我们没有显式定义构造函数，那么它将会有一个默认无参的构造函数。
    3、实例化一个类的对象的过程是一个典型的递归过程。首先实例化Object类，再依次对以下各类进行实例化，直到完成对目标类的实例化。
创建一个对象的步骤：**类加载检查、分配内存、初始化零值、设置对象头、执行init方法**
    1.类加载检查：在执行到new命令时，查看new后面的参数是否正确定位到常量池中的符号引用，并且该符号引用是否被正确的加载、连接和初始化。
    2.内存分配：为对象分配内存，有指针碰撞和空闲列表两种方式。
         指针碰撞：适用于内存完整，无碎片。内存使用和未使用中间由指针隔开，分配的时候指针移动相应的位置。
         空闲列表：适用于内存不完整，有碎片。维护一个列表，列表记录可用的内存，使用时分配给对象一个足够的内存空间并更新列表
    3.初始化零值：将对象分配到的空间初始化零值（不包括对象头）
    4.设置对象头：对象头信息包括哈希码、GC分代信息、元数据信息、对象是哪个类的示例等
    5.执行init方法：给对象设置程序值，执行构造方法。
```
#### 2.3.Java类实例化时，JVM执行顺序
```markdown
1.父类静态代码块,2.父类静态变量,3.子类静态代码块,3.子类静态变量,4.父类成员变量赋值,
5.父类构造方式开始执行,6.子类成员变量赋值,7.子类构造方式开始执行
    需要注意的地方是静态变量和静态代码块谁在前面谁先执行。
```
#### 2.4.对象有哪几部分构成？虚拟机如何访问对象
```markdown
对象在内存中的组成部分（对象在内存的划分、对象的内存布局）:
     对象头：
         第一：对象标记：存储对象自身的运行时数据，如哈希码、GC分代年龄、锁标志、偏向线程ID等，这部分占8B，称为Mark Word。
         第二：类型指针：是对象指向它的类型元数据的指针，占4B。JVM通过该指针来确定对象是哪个类的实例。
     实例数据：对象真正存储的有效信息，定义的各种字段的值。
     对齐填充：没有实际意义，JVM内存地址需要8字节的整数倍
虚拟机如何访问对象
    Java 程序会通过栈上的 reference 引用操作堆对象，访问方式由虚拟机决定，主流访问方式主要有句柄和直接指针。
     句柄：堆中专门划分一个区域作为句柄池，虚拟机栈存储是堆中句柄的地址，句柄存储的是对象的实例数据和类型数据的地址
     直接指针：栈中的引用直接指向的就是对象的实例数据和类型数据的地址。
     对比：直接指针避免二次寻址；使用句柄，在对象移动时，只修改句柄地址而不用改变引用的地址。
```
### 3.JVM虚拟机何时结束生命周期
```markdown
1.程序正常执行结束；
2.程序在执行过程中遇到了异常或错误而异常终止；
3.由于操作系统出现错误而导致Java虚拟机进程；
4.某线程调用Runtime类或System类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作。
5.除此之外，JNI(Java Native Interface) 规范描述了用JNI Invocation API来加载或卸载Java虛拟机时，Java虛拟机的退出情况。
```
### 4.JVM怎么判断对象是否可以回收【5+】
```markdown
垃圾收集主要是针对堆和方法区(线程共享区域)进行。
程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要进行垃圾回收。
JVM判断对象是否存活算法?
**引用计数算法**: 为对象添加一个引用计数器，当对象增加一个引用时计数器加1，引用失效时计数器减1。引用计数为0的对象可被回收。
    在两个对象出现**循环引用**的情况下，此时引用计数器永远不为0，导致无法对它们进行回收。正是因为循环引用的存在，因此Java虚拟机不使用引用计数算法。
**可达性分析算法**:
    以GC Roots为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。
    Java虚拟机使用该算法来判断对象是否可被回收，Java中可以作为GC Roots的对象：
        - 虚拟机栈中局部变量表中引用的对象
        - 本地方法栈中JNI(Native方法)中引用的对象
        - 方法区中类静态属性引用的对象
        - 方法区中的常量引用的对象
        - 活跃线程的引用对象
    方法区的回收:因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。
       主要是对常量池的回收和对类的卸载，主要回收两部分内容：废弃常量和无用的类。
       为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。
       类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载：
            该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。
            加载该类的ClassLoader已经被回收。
            该类对应的Class对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。
    finalize():当一个对象可被回收时，如果需要执行该对象的finalize()方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。
        自救只能进行一次，如果回收的对象之前调用了finalize()方法自救，后面回收时不会再调用该方法。
**回收不可达的对象不是一定就要被回收掉？？**
    当⼀个对象不可达GC Root时，这个对象并不会⽴⻢被回收，⽽是出于⼀个死缓的阶段，若要被真正的回收需要经历两次标记。
    如果对象在可达性分析中没有与GC Root的引⽤链，那么此时就会被第⼀次标记并且进⾏⼀次筛选，筛选的条件是是否有必要执⾏finalize()⽅法。
        当对象没有覆盖finalize()⽅法或者已被虚拟机调⽤过，那么就认为是没必要的。
        如果该对象有必要执⾏finalize()⽅法，那么这个对象将会放在⼀个称为F-Queue的对队列中，虚拟机会触发⼀个Finalize()线程去执⾏，
        此线程是低优先级的，并且虚拟机不会承诺⼀直等待它运⾏完，这是因为如果finalize()执⾏缓慢或者发⽣了死锁，那么就会造成F-Queue队列⼀直等待，造成了内存回收系统的崩溃。
        GC对处于F-Queue中的对象进⾏第⼆次被标记，这时，该对象将被移除”即将回收”集合，等待回收。
```
### 5.JVM垃圾回收算法【10+】
[Java垃圾收集算法](https://www.cnblogs.com/rainple/p/10793500.html)
[JVM垃圾回收算法详解](https://www.cnblogs.com/xwgblog/p/11703104.html)
```markdown
在JVM内存模型中会将堆内存划分新生代、老年代两个区域，两块区域的主要区别在于新生代存放存活时间较短的对象，
老年代存放存活时间较久的对象，除了存活时间不同外，还有垃圾回收策略的不同，在JVM中中有以下回收算法：
    复制算法：将JVM推分成二等分，给对象分配内存的时候总是使用其中的一块来分配，分配满了以后，GC就会进行标记，然后将存活的对象
        移动到另外一块空白的区域，然后清除掉所有没有存活的对象，这样重复的处理，始终就会有一块空白的区域没有被合理的利用到。
        优点：按顺序分配内存即可，实现简单、运行高效，不用考虑内存碎片。
        缺点：可用的内存大小缩小为原来的一半，对象存活率高时会频繁进行复制。
    标记-清除算法：标记阶段是从根集合(GC Root)开始扫描，每到达一个对象就会标记该对象为存活状态，清除阶段在扫描完成之后将没有标记的对象给清除掉。
        优点：实现简单，不需要对象进行移动。
        不足：标记和清除过程效率都不高；会产生大量不连续的内存碎片，导致无法给大对象分配内存。
    标记-整理算法：从根集合(GCRoot)开始扫描进行标记然后清除无用的对象，清除完成后它会整理内存。没有内存碎片的问题。
        优点:不会产生内存碎片。不足:需要移动大量对象，处理效率比较低。
    分代收集算法：将heap区域划分为新生代和老年代，新生代的空间比老年代的空间要小。新生代又分为了Eden和两个survivor空间，它们的比例为8:1:1。
        对象被创建时，内存的分配是在新生代的Eden区发生的，大对象直接在老年代分配内存。（大部分JVM采用的方法）
        该算法主要是为了解决标记-清除，产⽣⼤量内存碎⽚的问题；当对象存活率较⾼时，也解决了复制算法的效率问题。
    新生代使用：因为新生代中每次垃圾回收都要回收大部分对象，即要复制的操作比较少，所以选择复制算法。
    老年代使用：老年代的对象存活几率比较高的，使用标记 - 清除 或者 标记 - 整理 算法。
```
### 6.垃圾回收器【10+】详细CMS和G1
[一文了解JVM全部垃圾回收器，从Serial到ZGC](https://www.cnblogs.com/zackku/p/10056865.html)
```markdown
Serial收集器:(新生代收集器、复制算法，串行垃圾回收器) JVM参数：-XX:+UseSerialGC
    是单线程执行垃圾回收的。当需要执行垃圾回收时，程序会暂停一切手上的工作，然后单线程执行垃圾回收。
ParNew收集器:(新生代收集器、复制算法，并行垃圾回收器) JVM参数: -XX:UserParNewGC
    ParNew同样用于新生代，是Serial的多线程版本，并且在参数、算法（同样是复制算法）上也完全和Serial相同。
Parallel Scavenge收集器:(新生代收集器、复制算法、并行垃圾回收器，老年代采用标记-整理算法)  
    新生代的收集器，同样用的是复制算法，也是并行多线程收集。与ParNew最大的不同，它关注的是垃圾回收的吞吐量(高效率的利益CPU)。
    -XX:+UseParallelGC:使用Parallel收集器+老年代串行；-XX:+UseParallelOldGC:使用Parallel收集器+老年代并行
Serial Old收集器:(老年代收集器、标记-整理算法、串行垃圾回收器) -XX:+UseSerialOldGC
    是Serial收集器的老年代版本，与Serial一样是单线程，不同的是算法用的是标记-整理（Mark-Compact）。
Parallel Old收集器:(老年代收集器、标记-整理算法、并行垃圾回收器) -XX:+UseParallelOldGC
    是Parallel Scavenge收集器的老年代版本,多线程，吞吐量优先。其中的算法替换成Mark-Compact。
**CMS收集器**:(老年代收集器、标记-清除算法，并发垃圾回收器) JVM参数: -XX:+UseConcMarkSweepGC
    同样是老年代的收集器。它关注的是垃圾回收最短的停顿时间（低停顿），在老年代并不频繁GC的场景下，是比较适用的。
    分为以下四个流程：
        初始标记：仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，需要停顿。
        并发标记：进行GC Roots Tracing的过程，它在整个回收过程中耗时最长，不需要停顿。
            并发预清除：查找执行并发标记阶段从年轻代晋升到老年代的对象
        重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。
        并发清除：清除垃圾对象，不需要停顿。
    初始标记和重新标记需要 STW（Stop The World，系统停顿）。
    优点:并发收集低停顿
    缺点: 1.吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致CPU利用率不够高。
         2.无法处理浮动垃圾，可能出现Concurrent Mode Failure。
            浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次GC时才能进行回收。
            由于浮动垃圾的存在，因此需要预留出一部分内存，意味着CMS收集不能像其它收集器那样等待老年代快满的时候再回收。
            如果预留的内存不够存放浮动垃圾，就会出现Concurrent Mode Failure，这时虚拟机将临时启用Serial Old来替代CMS。
         3.标记-清除算法导致的空间碎片往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次Full GC。
         4.GC过程中会出现STW(Stop-The-World)，若Old区对象太多，STW耗费大量时间。
以前收集器的特点：
    年轻代和老年代是各自独立且连续的内存块；
    年轻代收集使用eden+s0+s1进行复制算法；
    老年代收集必须扫描整个老年代区域；
    都是以尽可能少而快速地执行GC为设计原则；
**G1收集器**:(混合收集器 复制+标记-整理算法) JVM参数: -XX:+UseG1GC
    G1可以说是CMS的终极改进版，解决了CMS内存碎片、更多的内存空间登问题。虽然流程与CMS比较相似，但底层的原理已是完全不同。
    G1（Garbage-First）是一款面向服务端应用的垃圾收集器，在多CPU和大内存的场景下有很好的性能。HotSpot开发团队赋予使命是未来可以替换掉CMS收集器。
    堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而G1可以直接对新生代和老年代一起回收。
    G1 收集器的运作大致可划分为以下几个步骤：
        1.初始标记：首先初始标记(Initial-Mark),这个阶段是停顿的(Stop the World Event)，并且会触发一次普通Mintor GC。对应GC log:GC pause (young) (inital-mark)
        2.Root Region Scanning，程序运行过程中会回收survivor区(存活到老年代)，这一过程必须在young GC之前完成。
        3.并发标记Concurrent Marking，在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被young GC中断。
            在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那个这个区域会被立即回收(图中打X)。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。
        4.最终标记Remark：会有短暂停顿(STW)。为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的
            Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中。这阶段需要停顿线程，但是可并行执行。
        5.筛选回收：多线程清除失活对象，会有STW。首先对各个Region中的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。
            此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。
    G1特点：在满足短时间停顿的同时，达到一个高的吞吐量，适用于多核处理器，大内存的系统。
        1.短停顿时间且可控：
            G1对内存进行分区，基于部分内存回收的新生代收集和混合收集。
            更精确的预测GC停顿时间，可以根据-XX:MaxGCPauseMillis参数指定停顿时间；
        2.高吞吐量：
            优化GC工作，使其尽可能与Mutator并发工作；
            设计了新的并发标记线程，用于并发标记内存；
            设计了Refine线程并发处理分区之间的引用关系；
            收缩空闲空间不会造成由长GC引起的应用停顿时间；
            G1没有CMS的碎片化问题（或者说不那么严重），G1整体上采用标记-整理算法，局部是通过复制算法。
    G1底层原理
        G1算法将堆划分为若干个区域 Eden,Survivor,Old,Humongous:大对象;
ZGC(Z Garbage Collector): 
    在JDK11中新加入的具有实验性质的低延迟垃圾收集器，
    ZGC几乎在所有地方并发执行的，除了初始标记的是STW的。所以停顿时间几乎就耗费在初始标记上，这部分的实际是非常少的。
    ZGC主要新增了两项技术，一个是着色指针Colored Pointer，另一个是读屏障Load Barrier。
    * 着色指针Colored Pointer
        ZGC利用指针的64位中的几位表示Finalizable、Remapped、Marked1、Marked0（ZGC仅支持64位平台），以标记该指向内存的存储状态。
        相当于在对象的指针上标注了对象的信息。注意，这里的指针相当于Java术语当中的引用。
        在这个被指向的内存发生变化的时候（内存在Compact被移动时），颜色就会发生变化。
        在G1的时候就说到过，Compact阶段是需要STW，否则会影响用户线程执行。那么怎么解决这个问题呢？
    * 读屏障Load Barrier
        由于着色指针的存在，在程序运行时访问对象的时候，可以轻易知道对象在内存的存储状态（通过指针访问对象），若请求读的内存在被着色了。
        那么则会触发读屏障。读屏障会更新指针再返回结果，此过程有一定的耗费，从而达到与用户线程并发的效果。
        把这两项技术联合下理解，引用R大（RednaxelaFX）的话与标记对象的传统算法相比，ZGC在指针上做标记，在访问指针时加入Load Barrier（读屏障），比如当对象正被GC移动，指针上的颜色就会不对，
        这个屏障就会先把指针更新为有效地址再返回，也就是，永远只有单个对象读取时有概率被减速，而不存在为了保持应用与GC一致而粗暴整体的Stop The World。
    ZGC虽然目前还在JDK 11还在实验阶段，但由于算法与思想是一个非常大的提升，相信在未来不久会成为主流的GC收集器使用。
jdk1.7 默认垃圾收集器Parallel Scavenge（新生代）+Parallel Old（老年代）
**jdk1.8 默认垃圾收集器**：Parallel Scavenge（新生代）+Parallel Old（老年代）
jdk1.9 默认垃圾收集器G1
 -XX:+PrintCommandLineFlags jvm参数可查看默认设置收集器类型
 -XX:+PrintGCDetails 亦可通过打印的GC日志的新生代、老年代名称判断
 java -XX:+PrintCommandLineFlags -version   --查看默认的垃圾回收器
java的GC回收的类型主要有几种：
   UseSerialGC,UseParallelGC,UseConcMarkSweepGC,UseParNewGC,UseParallelOldGC,UseG1GC
```
### 7.JAVA内存分配与回收策略
[垃圾回收与内存分配策略](https://www.cnblogs.com/CodeMLB/p/12113279.html)
[JAVA GC（垃圾回收机制）面试讲解](https://www.cnblogs.com/dmzna/p/12913458.html)
#### 1.Minor GC(YGC)和Full GC【5+】
```markdown
针对HotSpot VM的实现，它里面的GC其实准确分类只有两大种：
部分收集 (Partial GC)：
    新生代收集（Minor GC/Young GC）：只对新生代进行垃圾收集；
    老年代收集（Major GC/Old GC）：只对老年代进行垃圾收集。需要注意的是Major GC在有的语境中也用于指代整堆收集；
    混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。
整堆收集 (Full GC)：收集整个Java堆和方法区。
Minor GC：回收新生代，因为新生代对象存活时间很短，因此Minor GC会频繁执行，执行的速度一般也会比较快。
    当Eden区没有⾜够的空间进⾏分配时，虚拟机会执⾏⼀次Minor GC.Minor Gc通常发⽣在新⽣代的Eden区，在这个区的对象⽣存期短，往往发⽣Gc的频率较⾼，回收速度⽐较快;
Full GC：回收老年代和新生代，老年代对象其存活时间长，因此Full GC很少执行，执行速度会比Minor GC慢很多。
    Full Gc/Major GC发⽣在⽼年代，⼀般情况下，触发⽼年代GC的时候不会触发MinorGC,但是通过配置，可以在Full GC之前进⾏⼀次Minor GC这样可以加快⽼年代的回收速度。
    垃圾回收不会发⽣在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)
    Java8中已经移除了永久代，新加了⼀个叫做元数据区的native内存区
```
#### 2.内存分配策略和内存分配方式
![对象内存分配流程图](https://user-gold-cdn.xitu.io/2020/5/1/171d05dec9c7bbfd?w=972&h=943&f=png&s=115538)
```markdown
1. 对象优先在堆的Eden区分配:大多数情况下，对象在新生代Eden上分配，当Eden空间不够时，发起Minor GC(YGC)。
    YGC处理的区域只有新生代。大部分对象在短时间内都是可收回掉的，YGC后只有极少数的对象能存活下来，而被移动到S0区（采用的是复制算法）。
    当触发下一次YGC时，会将Eden区和S0区的存活对象移动到S1区，同时清空Eden区和S0区。
    当再次触发YGC时，这时候处理的区域就变成了Eden区和S1区（即S0和S1进行角色交换）。每经过一次YGC，存活对象的年龄就会加1。
2. 大对象直接进入老年代:
    大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。
    经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。
    -XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在Eden和Survivor之间的大量内存复制。
3. 长期存活的对象进入老年代
    为对象定义年龄计数器，对象在Eden出生并经过Minor GC依然存活，将移动到Survivor中，年龄就增加1岁，增加到一定年龄则移动到老年代中。
    -XX:MaxTenuringThreshold用来定义年龄的阈值。
4. 动态对象年龄判定
    虚拟机并不是永远要求对象的年龄必须达到MaxTenuringThreshold才能晋升老年代，如果在Survivor中相同年龄
    所有对象大小的总和大于Survivor空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到MaxTenuringThreshold中要求的年龄。
5. 空间分配担保
    在发生Minor GC之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么Minor GC可以确认是安全的。
    如果不成立的话虚拟机会查看HandlePromotionFailure的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否
    大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC；如果小于，或者HandlePromotionFailure的值不允许冒险，那么就要进行一次Full GC。
对象分配内存的方式有哪些？
    对象所需内存大小在类加载完成后便可完全确定，分配空间的任务实际上等于把一块确定大小的内存块从Java堆中划分出来。
    指针碰撞：假设Java堆内存规整，被使用过的内存放在一边，空闲的放在另一边，中间放着一个指针作为分界指示器，分配内存就是把指针向空闲方向挪动一段与对象大小相等的距离。
    空闲列表：如果Java堆内存不规整，虚拟机必须维护一个列表记录哪些内存可用，在分配时从列表中找到一块足够大的空间划分给对象并更新列表记录。
    选择哪种分配方式由堆是否规整决定，堆是否规整由垃圾收集器是否有空间压缩能力决定。使用Serial、ParNew等收集器时，系统采用指针碰撞；使用CMS这种基于清除算法的垃圾收集器时，采用空间列表。
```
#### 3.JVM Minor GC和Full GC的触发条件【5+】
>> 新生代和老年代什么时候会触发GC。
[线上服务的FGC问题排查，看这篇就够了！](https://www.cnblogs.com/luojunwu/p/13128045.html)
```markdown
对于Minor GC，其触发条件非常简单，当Eden空间满时，就将触发一次Minor GC。
而Full GC则相对复杂，有以下条件：
    1.System.gc()或者Runtime.gc()被显式调用时:建议虚拟机执行Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。
    2.老年代空间不足:老年代空间不足的常见场景为的大对象直接进入老年代、长期存活的对象进入老年代等。
    3.空间分配担保失败:使用复制算法的Minor GC需要老年代的内存空间作担保，如果担保失败会执行一次Full GC。
    4.JDK1.7 及以前的永久代空间不足:
        在JDK1.7及以前，HotSpot虚拟机中的方法区是用永久代实现的，永久代中存放的为一些Class的信息、常量、静态变量等数据。
    5.Concurrent Mode Failure:执行CMS GC的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是GC过程中浮动垃圾过多导致暂时
        性的空间不足），便会报Concurrent Mode Failure错误，并触发Full GC。
    6.Metaspace（元空间）在空间不足时会进行扩容，当扩容到了-XX:MetaspaceSize 参数的指定值时，也会触发FGC。
System.gc()方法的调用:建议JVM进行Full GC,只是建议而非一定,但很多情况下它会触发Full GC,从而增加Full GC的频率,也即增加了间歇性停顿的次数。
    强烈影响系建议能不使用此方法就别使用，让虚拟机自己去管理它的内存，可通过通过-XX:+ DisableExplicitGC来禁止RMI调用System.gc。
老年代空间不足:老年代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出如下错误：
    java.lang.OutOfMemoryError: Java heap space为避免以上两种状况引起的Full GC，
    调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。
永生区空间不足:JVM规范中运行时数据区域中的方法区，在HotSpot虚拟机中又被习惯称为永生代或者永生区，Permanet Generation中
    存放的为一些class的信息、常量、静态变量等数据，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation可能会被占满，
    在未配置为采用CMS GC的情况下也会执行Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出如下错误信息：
    java.lang.OutOfMemoryError: PermGen space为避免Perm Gen占满造成Full GC现象，可采用的方法为增大Perm Gen空间或转为使用CMS GC。
CMS GC时出现promotion failed和concurrent mode failure
Minor GC晋升到老年代的平均大小大于老年代的剩余空间
使用RMI来进行RPC或者管理jdk应用，每小时执行1次Full GC
```
#### 4.给对象分配内存如何保证线程安全？
```markdown
对象创建十分频繁，即使修改一个指针的位置在并发下也不是线程安全的，可能正给对象A分配内存，指针还没来得及修改，对象B又使用了指针来分配内存。
解决方法：① CAS加失败重试保证更新原子性。
        ② 把内存分配按线程划分在不同空间，即每个线程在Java堆中预先分配一小块内存，叫做本地线程分配缓冲TLAB，哪个线程要分配内存就在对应的TLAB分配，TLAB用完了再进行同步。
CAS+失败重试：CAS是乐观锁，每次都假设成功，在执行，失败就重试，找到成功。保证更新的原子性
TLAB：为每一个线程，预先在Eden区域分配一块内存，对象先分配到这里，当该区域内存不足或用完之后，使用CAS+失败重试机制
```
#### 5.内存泄露和内存溢出分别是什么？什么原因造成？如何避免？【5+】
```markdown
 内存泄露Memory Leak：指一个**本应被回收的对象因为其他对象的引用而不能被回收**，从而在堆中寄存，造成内存泄露，长周期对象持有短周期对象的引用会造成。
 内存溢出OutOfMemory：**无法为对象分配足够的内存，对象申请过多**。无限创建实例对象，这样堆内存迟早会满。
java中有垃圾回收机制，它可以保证⼀对象不再被引⽤的时候，即对象变成了孤⼉的时候，对象将⾃动被垃圾回收器从内存中清除掉。
避免：
     不要在循环中创建对象
     不要一次调用过多数据
     大量字符串使用 StringBuffer 或者 StringBuilder
     方法区很少进行垃圾回收，尽量避免申请常量和静态变量
```
### 8.类的生命周期、初始化时机和加载机制【10+】
>>[JVM之类加载器、加载过程及双亲委派机制](https://www.cnblogs.com/songjilong/p/12834729.html)
>>[探秘类加载器和类加载机制](https://www.cnblogs.com/jasongan/p/10151681.html)
>>[一文带你深扒ClassLoader内核，揭开它的神秘面纱！](https://www.cnblogs.com/wmyskxz/p/13575224.html)
#### 0.类加载是做什么的
```markdown
Java为了实现「一次编译，到处运行」的目标，采用了一种特别的方案：先编译为与任何具体及其环境及操作系统环境无关的中间代码（也就是.class字节码文件），
    然后交由各个平台特定的Java解释器（也就是JVM）来负责解释运行。
Java程序运行流程：Java源文件(.java) -> Java编译器 -> 字节码文件(.class) -> Java加载器-> JVM虚拟机运行
ClassLoader(类加载器)就是那个把字节码交给JVM的搬运工（加载进内存）。它负责将字节码形式的Class转换成JVM中内存形式的Class对象。
    字节码可以是来自于磁盘上的.class文件，也可以是jar包里的*.class，甚至是来自远程服务器提供的字节流。
    字节码的本质其实就是一个有特定复杂格式的字节数组byte[]。
类加载器不光可以把Class加载到JVM之中并解析成JVM统一要求的对象格式，还有一个重要的作用就是审查每个类应该由谁加载。
Java类不会一次全部加载到内存，而是在应用程序需要时加载，这也是需要类加载器的地方。
```
#### 1.类的生命周期（类加载过程）【5+】
[JVM类生命周期概述：加载时机与加载过程](https://blog.csdn.net/justloveyou_/article/details/72466105)
![类的生命周期图](https://user-gold-cdn.xitu.io/2020/4/30/171c843fe9b784cb?w=1364&h=707&f=png&s=67514)
```markdown
类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类。因为如果一次性加载，那么会占用很多的内存。
加载（Loading）验证（Verification）准备（Preparation）解析（Resolution）初始化（Initialization）使用（Using）卸载（Unloading）
类加载过程：包含了加载、验证、准备、解析和初始化这5个阶段。
    1. 加载（加载过程完成以下三件事：）
        1.通过类的完全限定名称获取定义该类的二进制字节流。
        2.将该字节流表示的静态存储结构转换为方法区的运行时存储结构。
        3.在内存中生成一个代表该类的Class对象，作为方法区中该类各种数据的访问入口。
    2. 验证（确保被加载的类的正确性）
        验证的目的是确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
        验证阶段有：文件格式校验、元数据校验、字节码校验、符号引用校验。
        验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响。
    3. 准备（为类的静态变量分配内存，并将其初始化为默认值）
        准备阶段是正式为类中定义的变量（静态变量）分配内存并设置类变量初始值的阶段。这些变量所使用的内存都将在方法区中进行分配。
        类变量是被static修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。
        实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。
        应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。
    4.解析（把类中的符号引用转换为直接引用（重要））
        解析阶段是虚拟机将常量池的符号引用替换为直接引用的过程。
        解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。
        其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持Java的动态绑定。
    5. 初始化
        初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。
        在Java中对类变量进行初始值设定有两种方式： 
            1️⃣ 声明类变量是指定初始值；
            2️⃣ 使用静态代码块为类变量指定初始值；
        JVM 初始化步骤：
            1️⃣ 假如这个类还没有被加载和连接，则程序先加载并连接该类
            2️⃣ 假如该类的直接父类还没有被初始化，则先初始化其直接父类
            3️⃣ 假如类中有初始化语句，则系统依次执行这些初始化语句
    6.使用
    7.卸载
[类的双亲委派机制](https://www.cnblogs.com/mazhimazhi/p/13338549.html)
![类的加载流程](https://img2020.cnblogs.com/blog/1542615/202007/1542615-20200713205920681-1954888968.png)
JVM调用java.lang.ClassLoader类的loadClass()方法开始类加载流程，
    AppClassLoader类加载器过调用findLoadedClass()方法查找此类是否已经被加载过了，如果没有，则需要优先调用父类加载器去加载。
    除了用C++实现的引导类加载器需要通过调用findBootstrapClassOrNull()方法外，其它用Java实现的类加载器都有parent字段，
    因为这些类都继承了ClassLoader这个基类（这个类中有对parent字段的定义），
    如实现了扩展类加载器的ExtClassLoader类和实现了应用类加载器/系统类加载器的AppClassLoader类的继承关系。
    当父类无法实现加载请求时，也就是class为null时，当前类加载器调用findClass()方法尝试自己完成加载请求。
loadClass和forName的区别
    Class.forName得到的class是已经初始化完成的
    Classloader.loadClass得到的class是还没有链接的
```
#### 2.类初始化时机
```markdown
1. 主动引用
    1) 遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类没有进行过初始化，则需要先对其进行初始化。
    2) 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
    3) 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
    4) 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。
    5) 当使用jdk1.7动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getstatic,REF_putstatic,
        REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。
2. 被动引用
    1.通过子类引用父类的静态字段，不会导致子类初始化。
        System.out.println(SubClass.value); // value字段在 SuperClass 中定义
    2.通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动
      生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。SuperClass[] sca = new SuperClass[10];
    3.常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。
        System.out.println(ConstClass.HELLOWORLD)。
```
#### 3.类加载器分类【5+】
![双亲委派模型](https://user-gold-cdn.xitu.io/2020/4/30/171c84d6f56e220d?w=880&h=857&f=png&s=70024)
```markdown
JVM支持两种类型的类加载器：引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）。
从Java虚拟机的角度来讲，只存在以下两种不同的类加载器：
    启动类加载器（Bootstrap ClassLoader），使用C++实现，是虚拟机自身的一部分；
        所有其它类的加载器，使用Java实现，独立于虚拟机，继承自抽象类java.lang.ClassLoader。
        加载jre/lib包下面的jar文件，比如说常见的rt.jar（包含了Java标准库下的所有类文件，比如说java.lang包下的类，
        java.net包下的类，java.util包下的类，java.io包下的类，java.sql包下的类）。
从Java开发人员的角度看，类加载器可以划分得更细致一些：
    启动类加载器（Bootstrap ClassLoader）
        这个类加载器使用C/C++编写，嵌套在JVM内部
        它用来加载Java核心类库(JAVA_HOME/jre/lib/rt.jar、resources.jar、sun.boot.class.path路径下的内容)，用于提供Java自身需要的类
        并不继承ClassLoader，没有父加载器
        加载扩展类和应用程序类加载器，并指定为它们的父加载器
        出于安全考虑，bootstrap启动类加载器只加载包名为java、javax、sun开头的类
    扩展类加载器（Extension ClassLoader）
        Java语言编写，由sun.misc.Launcher$ExtClassLoader实现
        派生于ClassLoader类
        父类加载器为启动类加载器
        从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录(扩展目录)下加载类库。
        如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。
    应用程序类加载器（Application ClassLoader）
        Java语言编写，由sun.misc.Launcher$AppClassLoader实现
        派生于ClassLoader类
        父类加载器为扩展类加载器
        它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库
        该类加载器是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载
        通过ClassLoader.getSystemClassLoader()方法可以获取到该类加载器
    用户自定义类加载器（User-Defined ClassLoader）
        在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。
        为什么要自定义类加载器？
            * 隔离加载类
            * 修改类加载的方式
            * 扩展加载源
            * 防止源码泄漏
        用户自定义类加载器实现步骤：
            1.开发人员可以通过继承抽象类java.lang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求
            2.在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写loadClass()方法，从而实现自定义的类加载类，
                但是在JDK1.2之后已不再建议用户去覆盖loadclass()方法，而是建议把自定义的类加载逻辑写在findclass()方法中。
            3.在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URIClassLoader类，
                这样就可以避免自己去编写findclass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。
```
```java
public class ClassLoaderTest {
    public static void main(String[] args) {
        // 获取系统类加载器
        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();
        System.out.println(systemClassLoader);

        // 获取其上层的：扩展类加载器
        ClassLoader extClassLoader = systemClassLoader.getParent();
        System.out.println(extClassLoader);

        // 试图获取 根加载器
        ClassLoader bootstrapClassLoader = extClassLoader.getParent();
        System.out.println(bootstrapClassLoader);

        // 获取自定义加载器
        ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();
        System.out.println(classLoader);
        
        // 获取String类型的加载器
        ClassLoader classLoader1 = String.class.getClassLoader();
        System.out.println(classLoader1);
    }
}
```
#### 4.双亲委派模型【5+】
![](https://img2020.cnblogs.com/blog/1542615/202007/1542615-20200713210038282-7502795.png)
```markdown
双亲委派模型构成:
    当一个类加载器接收到一个类加载的任务时，不会立即展开加载，而是将加载任务委托给它的父类加载器去执行，
    每一层的类都采用相同的方式，直至委托给最顶层的启动类加载器为止。
    如果父类加载器无法加载委托给它的类（它的搜索范围中没有找到所需要加载的类），便将类的加载任务退回给下一级类加载器去执行加载。
    具体的委派逻辑实现在java.lang.ClassLoader类的loadClass()方法中。
双亲委派模型工作过程是:
    1.先判断该类是否被加载过，如果未被加载就调用父类的loadClass()方法，如果父类为null，则使用启动类加载器作为加载器。
    2.如果父类加载失败，抛出ClassNotFoundException异常，则调用自己的findClass进行加载。
    简单概括：自底向上检查类是否被加载，自顶向下尝试加载类。
为什么需要双亲委派模型？:
    如果没有双亲委派，那么用户是不是可以自己定义一个java.lang.Object的同名类，java.lang.String的同名类，并把它放到ClassPath中,
    那么类之间的比较结果及类的唯一性将无法保证，因此，双亲委派模型可以防止内存中出现多份同样的字节码。
    1、避免类字节码的重复加载,确实保证了Java库类的安全性。
    2、保护程序安全，防止核心API被随意篡改
破坏双亲委派机制：可以⾃⼰定义⼀个类加载器，重写loadClass方法；
```
#### 5.自定义类加载器实现【2+】
[自定义ClassLoader](https://www.cnblogs.com/heartlake/p/12980009.html)
```markdown
自定义类加载器必须继承classloader。需要实现里面的findClass方法。
我们可以传入路径，通过二进制输出流，将路径内容读取为二进制数组。通过调用defineClass方法定义class。
在学习了类加载器的实现机制之后，我们知道了双亲委派模型并非强制模型，用户可以自定义类加载器，在什么情况下需要自定义类加载器呢？
1️⃣ 隔离加载类。在某些框架内进行中间件与应用的模块隔离，把类加载器到不同的环境。比如，阿里内某容器框架通过自定义类加载器确保应用中依赖的jar包不会影响到中间件运行时使用的jar包。
2️⃣ 修改类加载方式。类的加载模型并非强制，除了Bootstrap外，其他的加载并非一定要引入，或者根据实际情况在某个时间点进行按需的动态加载。
3️⃣ 扩展加载源。比如从数据库、网络，甚至是电视机顶盒进行加载。（下面👇我们会编写一个从网络加载类的例子）
4️⃣ 防止源码泄露。Java代码容易被编译和篡改，可以进行编译加密。那么类加载器也需要自定义，还原加密的字节码。
```
#### 6.获取ClassLoader的途径
```markdown
方式	                                 代码
1.获取当前类的ClassLoader	             clazz.getClassLoader()
2.获取当前线程上下文的 ClassLoader	   Thread.currentThread().getContextClassLoader()
3.获取系统的 ClassLoader	            ClassLoader.getSystemClassLoader()
4.获取调用者的 ClassLoader	          DriverManager.getCallerClassLoader()
//查看根加载器所能加载的目录
public class ClassLoaderTest1 {
    public static void main(String[] args) {
        System.out.println("*********启动类加载器************");
        // 获取BootstrapClassLoader 能够加载的API的路径
        URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
        for (URL url : urls) {
            System.out.println(url.toExternalForm());
        }
        // 从上面路径中，随意选择一个类，来看看他的类加载器是什么：得到的是null，说明是  根加载器
        ClassLoader classLoader = Provider.class.getClassLoader();
    }
}
```
#### 7.类加载器源码
[面试官：谈谈类加载器吧，你有没有看过类加载器的源码](https://www.cnblogs.com/zhuifeng523/p/13391064.html)
```markdown
ClassLoader的主要方法
    defineClass()用于将byte字节流解析成JVM能够识别的Class对象。有了这个方法意味着我们不仅可以通过.class文件实例化对象，
        还可以通过其他方式实例化对象，例如通过网络接收到一个类的字节码。
    findClass()通常和defineClass()一起使用，我们需要直接覆盖ClassLoader父类的findClass()方法来实现类的加载规则，从而取得要加载类的字节码
    loadClass()用于接受一个全类名，然后返回一个Class类型的对象。（该方法源码蕴含了著名的双亲委派模型）
    resolveClass()用于对Class进行链接，也就是把单一的Class加入到有继承关系的类树中。如果你想在类被加载到JVM中时就被链接（Link），
    那么可以在调用defineClass()之后紧接着调用一个resolveClass()方法，当然你也可以选择让JVM来解决什么时候才链接这个类（通常是真正被实实例化的时候）。
```
#### 8.了解下tomcat的类加载机制
```markdown
步骤：
    1.先在本地cache查找该类是否已经加载过，看看Tomcat有没有加载过这个类。
    2.如果Tomcat 没有加载过这个类，则从系统类加载器的cache中查找是否加载过。
    3.如果没有加载过这个类，尝试用ExtClassLoader类加载器类加载，重点来了，这里并没有首先使用AppClassLoader来加载类。
        这个Tomcat的WebAPPClassLoader违背了双亲委派机制，直接使用了ExtClassLoader来加载类。
        这里注意ExtClassLoader双亲委派依然有效，ExtClassLoader就会使用Bootstrap ClassLoader来对类进行加载，保证了Jre里面的核心类不会被重复加载。
        比如在Web中加载一个Object类。WebAppClassLoader→ExtClassLoader→Bootstrap ClassLoader，这个加载链，就保证了Object不会被重复加载。
    4.如果BoostrapClassLoader，没有加载成功，就会调用自己的findClass方法由自己来对类进行加载，findClass加载类的地址是自己本web应用下的class。
    5.加载依然失败，才使用AppClassLoader继续加载。
    6.都没有加载成功的话，抛出异常。
总结一下以上步骤，WebAppClassLoader加载类的时候，故意打破了JVM双亲委派机制，绕开了AppClassLoader，直接先使用ExtClassLoader来加载类。
```
### 9.栈帧概念及结构图
![栈帧概念结构图](https://user-gold-cdn.xitu.io/2020/5/1/171d0288ac431ad3?w=709&h=814&f=png&s=64282)
```markdown
栈帧（Frame）是用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接(Dynamic Linking)、方法返回值和异常分派(Dispatch Exception)。
栈帧随着方法调用而创建，随着方法结束而销毁——无论方法是正常完成还是异常完成（抛出了在方法内未被捕获的异常）都算作方法结束
栈帧是用于支持虚拟机进行方法调用和方法执行背后的数据结构。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址信息。
    局部变量表
        是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。局部变量表的容量以变量槽(Variable Slot)为最小单位。
    操作数栈
        操作数栈，也称操作栈，是一个后入先出栈。
        当一个方法刚刚开始执行的时候, 该方法的操作数栈也是空的。在方法的执行过程中会有各种字节码指令往操作数栈中写入和提取内容, 也就是出栈与入栈操作。
    动态连接
        每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用, 持有引用是为了支持方法调用过程中的动态连接(Dynamic Linking)。
    方法返回地址
        当一个方法开始执行时, 只有两种方式退出这个方法 。一种是执行引擎遇到任意一个方法返回的字节码指令。另外一种退出方式是在方法执行过程中遇到了异常。
```
### 10.JMM模型【4+】
[Java内存模型详解](https://www.cnblogs.com/wildwolf0/p/11455512.html)
![Java内存模型图](https://user-gold-cdn.xitu.io/2020/5/1/171cef6637426e1e?w=823&h=759&f=png&s=251488)
```markdown
Java线程的通信由JMM控制，JMM的主要目的是定义程序中各种变量的访问规则。变量包括实例字段、静态字段，但不包括局部变量与方法参数，因为它们是线程私有的，不存在多线程竞争。
    JMM遵循一个基本原则：只要不改变程序执行结果，编译器和处理器怎么优化都行。例如编译器分析某个锁只会单线程访问就消除锁，某个volatile变量只会单线程访问就把它当作普通变量。
Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存
    线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。
    不同线程间无法直接访问对方工作内存中的变量，线程通信必须经过主内存。
关于主内存与工作内存的交互，即变量如何从主内存拷贝到工作内存、从工作内存同步回主内存，JMM定义了8种原子操作：
    操作	 作用变量范围	作用
    lock	主内存	把变量标识为线程独占状态
    unlock	主内存	释放处于锁定状态的变量
    read	主内存	把变量值从主内存传到工作内存
    load	工作内存	把 read 得到的值放入工作内存的变量副本
    user	工作内存	把工作内存中的变量值传给执行引擎
    assign	工作内存	把从执行引擎接收的值赋给工作内存变量
    store	工作内存	把工作内存的变量值传到主内存
    write	主内存	把 store 取到的变量值放入主内存变量中
```
### 11.JVM参数及JVM启动参数【5+】
[JVM常用启动参数](https://www.cnblogs.com/flashsun/p/7246232.html)
![](https://user-gold-cdn.xitu.io/2020/5/1/171cfb2cb8a29672?w=1479&h=945&f=png&s=154318)
```markdown
public class TestDemo{
    public static void main(String[] args){
        System.out.println("Test Demo");
    }
}
1.首先我们通过 javac TestDemo.java 将其转成字节码
2.其次我们往往会输入java TestDemo这样的命令来启动JVM进程来执行此程序,其实我们在启动JVM进程的时候，可以指定相应的JVM的参数:
如下部分: java -server -Xms3g -Xmx3g -Xmn512m -Xss256k -XX:SurvivorRatio=8 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC TestDemo
JVM三大性能调优参数的含义：
一、堆大小设置（堆 = 年轻代 + 年老代+ 持久代）
    -Xmx3550m：设置JVM堆最大可用内存为3550M。
    -Xms3550m：设置JVM堆初始内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。超过服务器内存会报错。
    -Xss128k：设置每个线程的堆栈大小。（JDK5.0以后每个线程堆栈大小为1M）
    -Xmn1024m：设置年轻代大小为1024m。等效于同时配置下面两个。
        -XX:NewSize=1024m：设置年轻代初始值为1024M。
        -XX:MaxNewSize=1024m：设置年轻代最大值为1024M。
二、垃圾回收器设置（串行收集器、并行收集器、并发收集器 ）
    串行收集器
    -XX:+UseSerialGC：设置串行收集器。
    　　并行收集器（吞吐量优先）
    -XX:+UseParallelGC：设置年轻代为并行收集器。（此时年老代仍然为串行）
    -XX:+UseParallelOldGC：配置年老代为并行收集。
    -XX:ParallelGCThreads=20：配置并行收集器的线程数。
    -XX:MaxGCPauseMillis=100：设置每次年轻代垃圾回收的最长时间（单位毫秒）。如果无法满足此时间，JVM会自动调整年轻代大小，以满足此时间。
    -XX:+UseAdaptiveSizePolicy：设置此选项后，并行收集器会自动调整年轻代Eden区大小和Survivor区大小的比例，以达成目标系统规定的最低响应时间或者收集频率等指标。此参数建议在使用并行收集器时，一直打开。
    　　并发收集器（响应时间优先）
    -XX:+UseConcMarkSweepGC：即CMS收集，设置年老代为并发收集。
    -XX:+UseParNewGC：设置年轻代为并发收集。JDK5.0以上JVM会自行设置，无需再设。
    -XX:CMSFullGCsBeforeCompaction=0：每次Full GC后立刻开始压缩和整理内存。
    -XX:+UseCMSCompactAtFullCollection：打开内存空间的压缩和整理，在Full GC后执行。
    -XX:+CMSIncrementalMode：设置为增量收集模式。一般适用于单CPU情况。
    -XX:CMSInitiatingOccupancyFraction=70：表示年老代内存空间使用到70%时就开始执行CMS收集，以确保年老代有足够的空间接纳来自年轻代的对象，避免Full GC的发生。
    　　其它垃圾回收参数
    -XX:+ScavengeBeforeFullGC：年轻代GC优于Full GC执行。
    -XX:-DisableExplicitGC：不响应System.gc()代码，禁止调用System.gc()；但jvm的gc仍然有效。
    -XX:+UseThreadPriorities：启用本地线程优先级API。即使 java.lang.Thread.setPriority() 生效，不启用则无效。
    -XX:SoftRefLRUPolicyMSPerMB=0：软引用对象在最后一次被访问后能存活0毫秒（JVM默认为1000毫秒）。
    -XX:TargetSurvivorRatio=90：允许90%的Survivor区被占用（JVM默认为50%）。提高对于Survivor区的使用率。
三、辅助信息参数设置
    -XX:-CITime：打印消耗在JIT编译的时间。
    -XX:ErrorFile=./hs_err_pid.log：保存错误日志或数据到指定文件中。
    -XX:HeapDumpPath=./java_pid.hprof：指定Dump堆内存时的路径。
    -XX:-HeapDumpOnOutOfMemoryError：当首次遭遇内存溢出时Dump出此时的堆内存。
    -XX:OnError=";"：出现致命ERROR后运行自定义命令。
    -XX:OnOutOfMemoryError=";"：当首次遭遇内存溢出时执行自定义命令。
    -XX:-PrintClassHistogram：按下 Ctrl+Break 后打印堆内存中类实例的柱状信息，同JDK的 jmap -histo 命令。
    -XX:-PrintConcurrentLocks：按下 Ctrl+Break 后打印线程栈中并发锁的相关信息，同JDK的 jstack -l 命令。
    -XX:-PrintCompilation：当一个方法被编译时打印相关信息。
    -XX:-PrintGC：每次GC时打印相关信息。
    -XX:-PrintGCDetails：每次GC时打印详细信息。
    -XX:-PrintGCTimeStamps：打印每次GC的时间戳。
    -XX:-TraceClassLoading：跟踪类的加载信息。
    -XX:-TraceClassLoadingPreorder：跟踪被引用到的所有类的加载信息。
    -XX:-TraceClassResolution：跟踪常量池。
    -XX:-TraceClassUnloading：跟踪类的卸载信息。
```
### 13.对象的访问定位有那两种方式？
```markdown
建立对象就是为了使用对象，Java程序通过栈上的reference数据来操作堆上的具体对象。
目前主流的访问方式有1.使用句柄和2.直接指针。
    句柄：Java对堆会划分出一块内存来作为句柄池，reference中存储的就是的句柄地址，而句柄中包含了对象实例数据与数据类型各自的具体地址信息。
    直接指针：Java堆对象的布局中就必须如何放置访问类型数据相关的信息，reference中存储的直接就是对象的地址。
虚拟机如何访问对象
     句柄：堆中专门划分一个区域作为句柄池，虚拟机栈存储是堆中句柄的地址，句柄存储的是对象的实例数据和类型数据的地址
     直接指针：栈中的引用直接指向的就是对象的实例数据和类型数据的地址。
     对比：直接指针避免二次寻址；使用句柄，在对象移动时，只修改句柄地址而不用改变引用的地址。
```
### 14.常量池都包括哪些内容？常量池的位置？
```markdown
Java 中有三个常量池：字符串常量池、运行时常量池、class常量池
     字符常量池：全局字符串池里的内容是在类加载完成，经过验证，准备阶段之后在堆中生成字符串对象实例，也就是编译期间字符常量池已经创建完成。
     class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池(constant pool table)——注意这里的class常量池是存放在class文件中，而不是
在jvm中，用于存放编译器生成的各种字面量(Literal)和符号引用(SymbolicReferences)。字面量就是我们所说的常量概念，符号引用就是在类加载阶段的解析阶段，把符号引用替换成直接引用。
     jvm在执行某个类的时候，必须经过加载、连接、初始化，而连接又包括验证、准备、
解析三个阶段。而当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中，运行时常量池也是每个类都有一个。
 关于class常量池和运行时常量池可以这么理解：在java文件编译时，类的字面量和符
号引用，会存放在class类常量池，但是当类文件加载到jvm之后，class常量池的内容就被会加载到运行时常量池。
常量池的位置
 在JDK1.7之前运行时常量池逻辑包含字符串常量池存放在方法区，此时hotspot虚拟机对方法区的实现为永久代。
 在JDK1.7字符串常量池被从方法区拿到了堆中，这里没有提到运行时常量池，也就是
说字符串常量池被单独拿到堆，运行时常量池剩下的东西还在方法区 , 也就是hotspot中的永久代。
 在JDK1.8hotspot移除了永久代用元空间(Metaspace)取而代之，这时候 字符串常量
池还在堆,运行时常量池还在方法区,只不过方法区的实现从永久代变成了元空间(Metaspace)。
```
### 15.JVM性能调优，常用命令，以及工具
```markdown
对应进程的JVM状态以定位问题和解决问题并作出相应的优化
常用命令：jps、jinfo、jstat、jstack、jmap
jps：查看java进程及相关信息
    1.jps -l 输出jar包路径，类全名
    2.jps -m 输出main参数
    3.jps -v 输出JVM参数
jinfo：查看JVM参数
    1.jinfo 11666
    2.jinfo -flags 11666
jstat：查看JVM运行时的状态信息，包括内存状态、垃圾回收
    1.命令格式：
    2.jstat [option] LVMID [interval] [count]
    3.其中LVMID是进程id，interval是打印间隔时间（毫秒），count是打印次数（默认一直打印）
    4.
    5.option参数解释：
    6.-class class loader的行为统计
    7.-compiler HotSpt JIT编译器行为统计
    8.-gc 垃圾回收堆的行为统计
    9.-gccapacity 各个垃圾回收代容量(young,old,perm)和他们相应的空间统计
    10.-gcutil 垃圾回收统计概述
    11.-gccause 垃圾收集统计概述（同-gcutil），附加最近两次垃圾回收事件的原因
    12.-gcnew 新生代行为统计
    13.-gcnewcapacity 新生代与其相应的内存空间的统计
    14.-gcold 年老代和永生代行为统计
    15.-gcoldcapacity 年老代行为统计
    16.-gcpermcapacity 永生代行为统计
    17.-printcompilation HotSpot编译方法统计
jstack：查看JVM线程快照，jstack命令可以定位线程出现长时间卡顿的原因，例如死锁，死循环
    1.命令格式：
    2.jstack [-l] <pid> (连接运行中的进程)
    3.jstack -F [-m] [-l] <pid> (连接挂起的进程)
    4.jstack [-m] [-l] <executable> <core> (连接core文件)
    5.jstack [-m] [-l] [server_id@]<remote server IP or hostname> (连接远程debug服务器)
    6.option参数解释：
    7.-F 当使用jstack <pid>无响应时，强制输出线程堆栈。
    8.-m 同时输出java和本地堆栈(混合模式)
    9.-l 额外显示锁信息
jmap：可以用来查看内存信息
    1.命令格式：
    2.jmap [option] <pid> (连接正在执行的进程)
    3.jmap [option] <executable <core> (连接一个core文件)
    4.jmap [option] [server_id@]<remote server IP or hostname> (链接远程服务器)
    5.option参数解释：
    6.<none> to print same info as Solaris pmap
    7.-heap 打印java heap摘要
    8.-histo[:live] 打印堆中的 java对象统计信息
    9.-clstats 打印类加载器统计信息
    10.-finalizerinfo 打印在f-queue中等待执行finalizer方法的对象
    11.-dump:<dump-options> 生成java堆的dump文件
    12.dump-options:
    13.live 只转储存活的对象，如果没有指定则转储所有对象
    14.format=b 二进制格式
    15.file=<file> 转储文件到 <file>
    16.-F 强制选项
```
## 相关博客文章
### [1.从多线程的三个特性理解多线程开发](https://www.cnblogs.com/dafanjoy/p/10020225.html)
>> 原子性，可见性，有序性。
```markdown
1.共享变量
从JVM内存模型的角度上讲，存储在堆内存上数据都是线程共享的，如实例化的对象、全局变量、数组等。
存储在线程栈上的数据是线程独享的，如局部变量、操作栈、动态链接、方法出口等信息。
2.原子性操作
i++:不是原子性操作，虽然读取i和i=i+1都是原子性操作，两个合并就不是原子性操作，可能出现线程不安全。
```
### 2.关于强引用、软引用、弱引用、虚引用【5+】
[2.关于强引用、软引用、弱引用、虚引用，你该如何回答？](https://www.cnblogs.com/cxuanBlog/p/12774370.html)|
>> Object——>Reference——>SoftReference、——>WeakReference、——>PhantomReference
>>       ——>ReferenceQueue                  
```markdown
1. 强引用:**把一个对象赋给一个引用变量，被强引用关联的对象不会被回收**。使用new一个新对象的方式来创建强引用。(95%使用)
    Object obj = new Object();
    平时使用的new就是强引用，把一个对象赋给一个引用变量。它处于可达状态的时候，是不会被垃圾回收的。强引用是造成内存泄漏的主要原因。
2. 软引用:**被软引用关联的对象只有在内存不够的情况下才会被回收**。使用SoftReference类来创建软引用。
    Object obj = new Object();
    SoftReference<Object> sf = new SoftReference<Object>(obj);
    obj = null; // 使对象只被软引用关联
    软引用配合SoftReference使用，当系统中有足够的内存的时候，不会被回收，当系统中内存空间不足的时候会被回收，软引用存在于对内存敏感的程序中。
3. 弱引用:**被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前**。使用WeakReference类来创建弱引用。
    Object obj = new Object();
    WeakReference<Object> wf = new WeakReference<Object>(obj);
    obj = null;
    弱引用配合weakreference类来实现。比软引用的生存期更短，对于弱引用对象来说，只要垃圾回收机制一回收，不管内存空间是否充足就直接回收掉。
4. 虚引用:又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间（生命周期）造成影响，也无法通过虚引用得到一个对象。
    为一个对象设置虚引用的唯一**目的是能在这个对象被回收时收到一个系统通知**。使用PhantomReference来创建虚引用。
    Object obj = new Object();
    PhantomReference<Object> pf = new PhantomReference<Object>(obj, null);
    obj = null;
    虚引用需要phantomreference来实现，不能单独使用，必须配合引用队列。虚引用主要作用是跟踪对象的被垃圾回收的状态。
5.引用队列-使用软引用，弱引用和虚引用的时候都可以关联这个引用队列。
    - 无实际存储结构，存储逻辑依赖于内部节点之间的关系来表达
    - 存储关联的且被GC的软引用，弱引用以及虚引用
程序通过判断引用队列里面是不是有这个对象来判断，对象是否已经被回收了。
软引用，弱引用和虚引用用来解决OOM问题，用来保存图片的路径。主要用于缓存。
```
### 3.[JAVA各种OOM代码样例及解决方法](https://www.cnblogs.com/huangqingshi/p/13336648.html)【5+】
[面试官：哪些场景会产生OOM？怎么解决？](https://www.cnblogs.com/ilovejaney/p/13685788.html)
[教你写Bug，常见的OOM异常分析](https://mp.weixin.qq.com/s?__biz=MzU4Mjk0MjkxNA==&mid=2247486426&idx=2&sn=5151e216d6d1729bb23bf60475f97a9f&chksm=fdb1e277cac66b6197a0ab0dcb9ebead5eb5c1301708b7f71c9340d9361c3947ec196ab51323&mpshare=1&scene=23&srcid=07205vxhJya4d279DVUe2ME7&sharer_sharetime=1595210131720&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
```markdown
1.Java.lang.StackOverflowError 栈内存溢出(StackOFE.java)
原因分析:
    死循环递归调用:运行之后出现的错误如下，程序每次递归的时候，程序会把数据结果压入栈，包括里边的指针等，这个时候就需要帧栈大一些才能承受住更多的递归调用。
    执行了大量方法，导致线程栈空间耗尽
    方法内声明了海量的局部变量
    native 代码有栈上分配的逻辑，并且要求的内存还不小，比如java.net.SocketInputStream.read0会在栈上要求分配一个 64KB的缓存（64位Linux）
解决方案:
    修复引发无限递归调用的异常代码，通过程序抛出的异常堆栈，找出不断重复的代码行，按图索骥，修复无限递归Bug
    排查是否存在类之间的循环依赖（当两个对象相互引用，在调用toString方法时也会产生这个异常）
    通过JVM启动参数-Xss增加线程栈内存空间，某些正常使用场景需要执行大量方法或包含大量局部变量，这时可以适当地提高线程栈空间限制
2.Java.lang.OutOfMemoryError.Java heap space 堆内存溢出
    Java堆用于存储对象实例，我们只要不断的创建对象，并且保证GC Roots到对象之间有可达路径来避免GC清除这些对象，
    那随着对象数量的增加，总容量触及堆的最大容量限制后就会产生内存溢出异常。
原因分析:
     请求创建一个超大对象，通常是一个大数组
     超出预期的访问量/数据量，通常是上游系统请求流量飙升，常见于各类促销/秒杀活动，可以结合业务流量指标排查是否有尖状峰值
     过度使用终结器（Finalizer），该对象没有立即被GC
     内存泄漏（Memory Leak），大量对象引用没有释放，JVM无法对其自动回收，常见于使用了File等资源没有回收  
解决方案:
     针对大部分情况，通常只需要通过-Xmx参数调高JVM堆内存空间即可。如果仍然没有解决，可以参考以下情况做进一步处理：
        如果是超大对象，可以检查其合理性，比如是否一次性查询了数据库全部结果，而没有做结果数限制
        如果是业务峰值压力，可以考虑添加机器资源，或者做限流降级。
        如果是内存泄漏，需要找到持有的对象，修改代码设计，比如关闭没有释放的连接
3.Java.lang.OutOfMemoryError.GC overhead limit exceeded GC超出警戒，回收时间过长
    JDK1.6之后新增了一个错误类型，如果堆内存太小的时候会报这个错误。
    如果98%的GC的时候回收不到2%的时候会报这个错误，也就是最小最大内存出现了问题的时候会报这个错误。
4.Java.lang.OutOfMemoryError.Direct buffer memory 直接内存溢出
    直接内存，即堆外内存。NIO为了提高性能，避免在Java Heap和native Heap中切换，所以使用直接内存，默认情况下，直接内存的大小和对内存大小一致。
    堆外内存不受JVM的限制，但是受制于机器整体内存的大小限制。
5.Java.lang.OutOfMemoryError.unable to create new native thread 不能再创建更多的本地线程
    无限的创建线程，直到没法再创建线程。
6.Java.lang.OutOfMemoryError:Metaspace 元空间内存溢出
    元数据区域也成为方法区，存储着类的相关信息，常量池，方法描述符，字段描述符，运行时产生大量的类就会造成这个区域的溢出。
7.java.lang.OutOfMemoryError: Requested array size exceeds VM limit
    JVM限制了数组的最大长度，该错误表示程序请求创建的数组超过最大长度限制。
    JVM在为数组分配内存前，会检查要分配的数据结构在系统中是否可寻址，通常为Integer.MAX_VALUE-2。
    此类问题比较罕见，通常需要检查代码，确认业务是否需要创建如此大的数组，是否可以拆分为多个块，分批执行。
8.java.lang.OutOfMemoryError: Out of swap space
    启动Java应用程序会分配有限的内存。此限制是通过-Xmx和其他类似的启动参数指定的。
    在JVM请求的总内存大于可用物理内存的情况下，操作系统开始将内容从内存换出到硬盘驱动器。
    该错误表示所有可用的虚拟内存已被耗尽。虚拟内存（Virtual Memory）由物理内存（Physical Memory）和交换空间（Swap Space）两部分组成。
9.java.lang.OutOfMemoryError：Kill process or sacrifice child
    操作系统是建立在流程概念之上的。这些进程由几个内核作业负责，其中一个名为“ Out of memory Killer”，它会在可用内存极低的情况下“杀死”（kill）某些进程。
    OOM Killer 会对所有进程进行打分，然后将评分较低的进程“杀死”，具体的评分规则可以参考 Surviving the Linux OOM Killer。
    不同于其他的OOM错误， Kill processorsacrifice child错误不是由JVM层面触发的，而是由操作系统层面触发的。
```
### 4.又抓了一个导致频繁GC的鬼--数组动态扩容
[又抓了一个导致频繁GC的鬼--数组动态扩容](https://www.cnblogs.com/perfma/p/12981030.html)
```markdown
系统一直在做cms gc，但是老生代一直不降下去，但是执行一次jmap -histo:live之后，也就是主动触发一次full gc之后，
通过jstat -gcutil来看老生代一下就降下去了，初看下理论上不太可能，因为full gc也会对old做回收，
于是我要同事针对他们的场景写了一个简单的demo出来，然后果然还真能重现，不过他的demo设置的Heap有32G，
于是我通过慢慢调整，最终在很小的内存下也能重现出来
```
```java
// -Xmx500M -Xms500M -Xmn200M -XX:+UseConcMarkSweepGC
// -XX:+UseCMSInitiatingDccupancyOnly -XX:CMSInitiatingOccupancyFraction=90
public class Test{
    public static void main(String[] args){
      allocateMemory();
      try{
          Thread.sleep(10000);
      }catch (Exception e){
          
      }
    }
    public static void allocateMemory(){
        List<byte[]> list = new ArrayList<>();
        int size = 1024 * 1024 * 480;
        int lne = size / (20*1024);
        for(int i = 0;i<len;i++){
            try{
                byte[] bytes = new byte[20*1024];
                list.add(bytes);
            }catch (java.lang.OutOfMemoryError error){
                
            }
        }
    }
}
```
```markdown
正如我上面注释里写的JVM参数，控制新生代200M，老生代300M，老生代使用率达到90%的时候触发CMS GC，
大家可以跑跑看，这种情况下会发现不断做CMS GC，但是老生代就是不降下去，但是只要你主动触发一次Full GC，老生代立马就会回收。
当allocateMemory方法执行完之后，期待的结果是gc之后List及里面的byte数组都应该被回收掉，可是事实并不是这样的。
存在跨代引用的问题：因为传给System.arrayCopy的新数组是在java层面构建传进来的，在新生代分配的可能性最大，这样再加上拷贝仅仅是浅拷贝，
那么老生代里的byte数组因为存在新生代里新数组的引用，那仅仅做CMS GC就不可能回收这些老生代的对象了，因为CMS GC的一个gc root就是新生代里的对象
只要保证在cms gc回收old之前做一次ygc就能保证新生代里的那个新数组被回收而没有指向老生代那些byte数组，
那么这些数组就能正常被cms gc回收了，所以加上-XX:+CMSScavengeBeforeRemark即可解此问题。
```
### 5.JVM性能调优监控工具jps、jstack、jmap、jhat、jstat、hprof使用详解
[JVM性能调优监控工具jps、jstack、jmap、jhat、jstat、hprof 使用详解](https://mp.weixin.qq.com/s?__biz=MzU2NDg0OTgyMA==&mid=2247487317&idx=1&sn=fc0a61244b401301a1eacad7730476c6&chksm=fc45f2a6cb327bb07d5270ac4ad3c12493fdc0750d9ce816203d33631725fe0dceb69bcfdec2&mpshare=1&scene=23&srcid=&sharer_sharetime=1590881871386&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
```markdown
jps虚拟机进程状况工具，主要用来输出JVM中运行的进程状态信息。语法格式如下：jps [options] [hostid]
    命令行参数选项说明如下：
    -q 不输出类名、Jar名和传入main方法的参数
    -m 输出传入main方法的参数
    -l 输出main类或Jar的全限名
    -v 输出传入JVM的参数
    # jps -m -l
jinfo：Java配置信息工具，查看JVM参数
    jinfo -flag 具体参数 java进程编号
    jinfo 11666
    jinfo -flags 11666
jstackJava堆栈跟踪工具，主要用来查看某个Java进程内的线程堆栈信息。查看JVM线程快照，jstack命令可以定位线程出现长时间卡顿的原因，例如死锁，死循环
    语法格式如下：jstack [option] pid ;jstack [option] executable core;jstack [option] [server-id@]remote-hostname-or-ip
    命令行参数选项说明如下：-l long listings，会打印出额外的锁信息，在发生死锁时可以用jstack -l pid来观察锁持有情况-m mixed mode，
    不仅会输出Java堆栈信息，还会输出C/C++堆栈信息（比如Native方法）
    jstack可以定位到线程堆栈，根据堆栈信息我们可以定位到具体代码，所以它在JVM性能调优中使用得非常多。
jmap（Memory Map）Java内存映像工具和 jhat（Java Heap Analysis Tool）虚拟机堆转储快照分析工具：jmap导出堆内存，然后使用jhat来进行分析，jmap语法格式如下：
jstat虚拟机统计信息监视工具，（JVM统计监测工具）: 看看各个区内存和GC的情况,查看JVM运行时的状态信息，包括内存状态、垃圾回收.
hprof能够展现CPU使用率，统计堆内存使用情况。
```
### [【JVM系列】一步步解析java执行内幕](https://www.cnblogs.com/wangjiming/p/10455993.html)
```markdown
通过一个小demo给大家演示一下CMS和G1两种垃圾回收器对物理内存归还的区别。[MemoryRecycleTest](cn.offer2020.pbj.book_reading.JVM.jvmdemo.MemoryRecycleTest)
首先使用CMS垃圾回收器：将jvm运行参数设置为：-Xms128M -Xmx2048M -XX:+UseConcMarkSweepGC
使用G1垃圾回收器：将jvm运行参数设置为：-Xms128M -Xmx2048M -XX:+UseG1GC
CMS垃圾回收器，在内存开辟后，会随着System.gc()执行次数逐渐增多和回收频率逐渐拉长，从继续开辟内存到慢慢归还物理内存给操作系统，
直到出现一次全部归还，就会在每次调用System.gc()都归还所有剩余的物理内存给操作系统；G1恰恰相反，G1是在JVM每次回收垃圾后，主动归还物理内存给操作系统，不做任何保留，大大降低了内存占用。
另外，查看java堆栈实时情况，推荐使用JProfiler和VisualVM。如果是本地推荐JProfiler，因为功能强大，不过远程配置麻烦；
如果是连远程java进程，推荐VisualVM，功能够用，连接远程只需配置一些jvm参数。
```
### [可能是最全面的G1学习笔记](https://www.cnblogs.com/javaadu/p/10713956.html)
#### 1.G1出现的初衷是什么？
```markdown
在G1提出之前，经典的垃圾收集器主要有三种类型：串行收集器、并行收集器和并发标记清除收集器，这三种收集器分别可以是满足
Java应用三种不同的需求：内存占用及并发开销最小化、应用吞吐量最大化和应用GC暂停时间最小化，
但是，上述三种垃圾收集器都有几个共同的问题：
    （1）所有针对老年代的操作必须扫描整个老年代空间；
    （2）新生代和老年代是独立的连续的内存块，必须先决定年轻代和老年代在虚拟地址空间的位置。
设计目标
G1是一种服务端应用使用的垃圾收集器，目标是用在多核、大内存的机器上，它在大多数情况下可以实现指定的GC暂停时间，同时还能保持较高的吞吐量。
```
#### 2.G1适合在什么场景下使用？
```markdown
G1适用于以下几种应用：
    - 可以像CMS收集器一样，允许垃圾收集线程和应用线程并行执行，即需要额外的CPU资源；
    - 压缩空闲空间不会延长GC的暂停时间；
    - 需要更易预测的GC暂停时间；
    - 不需要实现很高的吞吐量
```
#### 3.G1的trade-off是什么？
```markdown
1. 分区（Region）
G1采取了不同的策略来解决并行、串行和CMS收集器的碎片、暂停时间不可控制等问题——G1将整个堆分成相同大小的分区（Region）
2. 收集集合（CSet）
一组可被回收的分区的集合。在CSet中存活的数据会在GC过程中被移动到另一个可用分区，CSet中的分区可以来自Eden空间、survivor空间、或者老年代。CSet会占用不到整个堆空间的1%大小。
3. 已记忆集合（RSet）
RSet记录了其他Region中的对象引用本Region中对象的关系，属于points-into结构（谁引用了我的对象）。RSet的价值在于使得垃圾收集器不需要扫描整个堆找到谁引用了当前分区中的对象，只需要扫描RSet即可。
4. Snapshot-At-The-Beginning(SATB)
SATB是维持并发GC的正确性的一个手段，G1GC的并发理论基础就是SATB，SATB是由Taiichi Yuasa为增量式标记清除垃圾收集器设计的一个标记算法。
```
#### 4.G1的详细过程？
```markdown
G1收集器的收集活动主要有四种操作：
    - 新生代垃圾收集
    - 后台收集、并发周期
    - 混合式垃圾收集
    - 必要时候的Full GC
G1收集器的模式主要有两种：
    - Young GC（新生代垃圾收集）
    - Mixed GC（混合垃圾收集）
```
```markdown
如何理解G1的gc日志?
G1的调优思路？
G1和CMS的对比和选择？
```
### [JVM的逃逸分析](https://www.cnblogs.com/fuguoliang/p/9753061.html)
[【性能优化】面试官：Java中的对象都是在堆上分配的吗？](https://www.cnblogs.com/binghe001/p/13709476.html)
```markdown
逃逸分析出现原因：Java中的对象默认都是分配到堆上，在调用栈中，只保存了对象的指针。当对象不再使用后，需要依靠GC来遍历引用树并回收内存。
    如果堆中对象数量太多，回收对象还有整理内存，都会会带来时间上的消耗，GC表示压力很大，然后影响性能。
    所以，在我们日常开发中，内存，时间都是相当的宝贵，该如何优化堆栈开销，是一个比较重要的问题。
在计算机语言编译器优化原理中，逃逸分析是指分析指针动态范围的方法，它同编译器优化原理的指针分析和外形分析相关联。
    当变量（或者对象）在方法中分配后，其指针有可能被返回或者被全局引用，这样就会被其他方法或者线程所引用，这种现象称作指针（或者引用）的逃逸(Escape)。
    通俗点讲，如果一个对象的指针被多个方法或者线程引用时，那么我们就称这个对象的指针（或对象）的逃逸（Escape）。
    public StringBuilder escapeDemo1(String a, String b) {
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append(a);
        stringBuilder.append(b);
        return stringBuilder;//return stringBuilder.toString();
    //　如此，就没有返回StringBuilder，而是toString()，那么StringBuilder没有从方法中直接脱离，就没有发生逃逸。
    }
什么是逃逸分析:逃逸分析，是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。
    通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。
逃逸分析的原理
　　Java本身的限制（对象只能分配到堆中），为了减少临时对象在堆内分配的数量，我会在一个方法体内定义一个局部变量，
   并且该变量在方法执行过程中未发生逃逸，按照JVM调优机制，首先会在堆内存创建类的实例，然后将此对象的引用压入调用栈，继续执行，这是JVM优化前的方式。
   然后，我采用逃逸分析对JVM进行优化。即针对栈的重新分配方式，首先找出未逃逸的变量，将该变量直接存到栈里，无需进入堆，分配完成后，继续调用栈内执行，最后线程执行结束，栈空间被回收，局部变量也被回收了。
    如此操作，是优化前在堆中，优化后在栈中，从而减少了堆中对象的分配和销毁，从而优化性能。
逃逸的方式
　　方法逃逸：在一个方法体内，定义一个局部变量，而它可能被外部方法引用，比如作为调用参数传递给方法，或作为对象直接返回。或者，可以理解成对象跳出了方法。
　　线程逃逸：这个对象被其他线程访问到，比如赋值给了实例变量，并被其他线程访问到了。对象逃出了当前线程。
逃逸分析的好处
　　如果一个对象不会在方法体内，或线程内发生逃逸（或者说是通过逃逸分析后，使其未能发生逃逸）
　　1. 栈上分配
　　　　一般情况下，不会逃逸的对象所占空间比较大，如果能使用栈上的空间，那么大量的对象将随方法的结束而销毁，减轻了GC压力
　　2. 同步消除
　　　　如果你定义的类的方法上有同步锁，但在运行时，却只有一个线程在访问，此时逃逸分析后的机器码，会去掉同步锁运行。
　　3. 标量替换
　　　　Java虚拟机中的原始数据类型（int，long等数值类型以及reference类型等）都不能再进一步分解，它们可以称为标量。相对的，如果一个数据可以继续分解，那它称为聚合量，Java中最典型的聚合量是对象。
       如果逃逸分析证明一个对象不会被外部访问，并且这个对象是可分解的，那程序真正执行的时候将可能不创建这个对象，而改为直接创建它的若干个被这个方法使用到的成员变量来代替。
       拆散后的变量便可以被单独分析与优化，可以各自分别在栈帧或寄存器上分配空间，原本的对象就无需整体分配空间了。
总结：栈上的空间一般而言是非常小的，只能存放若干变化和小的数据结构，无法存储大容量数据。目前的实现都是采用不那么准确但是时间压力相对较小的算法来完成逃逸分析，这就可能导致效果不稳定。
    所以，逃逸分析的效果只能在特定场景下，满足高频和高数量的小容量的变量分配结构，才是合适的。
```
### System.gc()和Runtime.gc()会做什么事情？
```markdown
这两个⽅法⽤来提示JVM要进⾏垃圾回收。但是，⽴即开始还是延迟进⾏垃圾回收是取决于JVM的。
```
### finalize()⽅法什么时候被调⽤？析构函数(finalization)的⽬的是什么？
```markdown
垃圾回收器(garbage colector)决定回收某对象时，就会运⾏该对象的finalize()⽅法,但是在Java中很不幸，如果内存总是充⾜的，
    那么垃圾回收可能永远不会进⾏，也就是说filalize()可能永远不被执⾏，显然指望它做收尾⼯作是靠不住的。
那么finalize()究竟是做什么的呢？ 它最主要的⽤途是回收特殊渠道申请的内存。
    Java程序有垃圾回收器，所以⼀般情况下内存问题不⽤程序员操⼼。
    但有⼀种JNI(Java Native Interface)调⽤non-Java程序（C或C++），finalize()的⼯作就是回收这部分的内存。
```
### 
[Java线上问题排查思路及Linux常用问题分析命令学习](https://www.cnblogs.com/wang-meng/p/71c2a5cba49794f5af38f243db4f70ab.html)
[JVM监控和调优常用命令工具总结](https://www.cnblogs.com/wxisme/p/9878494.html)
[JAVA线上故障排查全套路](https://fredal.xin/java-error-check)
## JVM相关面试总结
### [大厂面试经：高频率JVM面试问题整理！](https://www.cnblogs.com/xwgblog/p/11842394.html)
### [JVM面试考点总结](https://mp.weixin.qq.com/s?__biz=MzI3ODg2OTY1OQ==&mid=2247485506&idx=1&sn=cfa4f73ab24edb757649cc849621777e&chksm=eb512bb6dc26a2a0b1f9103aa70eb4504c60523661dfd151aace4ac25d2ab2a333e181249b10&mpshare=1&scene=23&srcid=#rd)
### 

