# 笔试真题训练

## 20200819
### [2020搜狗笔试1](https://www.nowcoder.com/test/question/done?tid=36176943&qid=1009393#summary)
#### 1.
```markdown
import java.util.*;
/**
 * LRU 算法 LinkHashMap 或者 hashMap + Queue
 */
public class Main {
     public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        sc.nextLine();
        //记录数据
        LinkedHashMap<String , Long> LRUhashMap = new LinkedHashMap<>();
        while (sc.hasNext()){
            //输入k - v
            String[] insert = sc.nextLine().split(" ");
            String key = insert[0];
            String value = insert[1];
            if(LRUhashMap.containsKey(key)){
                if(LRUhashMap.get(key)-Long.valueOf(value) < 0){
                    LRUhashMap.remove(key);
                    LRUhashMap.put(key,Long.valueOf(value));
                }
            }else{
                if(LRUhashMap.size() < N){ //空间剩余
                    LRUhashMap.put(key,Long.valueOf(value));
                }else if(LRUhashMap.size() == N){ //空间不足
                    for(String s : LRUhashMap.keySet()){
                        System.out.println(s + " " + LRUhashMap.get(s));
                        LRUhashMap.remove(s);
                        LRUhashMap.put(key,Long.valueOf(value));
                        break;
                    }
                }
            }
        }
    }
}
```
#### 3
```markdown
import java.util.*;
 
/**
 *    1. 使用hashmap构建树形结构
 *    2. 递归分治法：假设已知 各个子节点的分发时间：
 *        则： 2.1 对子节点的分发时间进行降序排列
 *            2.2 当前节点优先对 子节点分发时间 较长的节点进行分发, 
 *                如:子节点分发时间 4 2 1 1 1 0, k=2, 则: 先后分发顺序(42)(11)(10),也就是
 *                     (42)+1 (11)+2 (10)+3 => 5 3 3 3 4 3 => 分三轮分发, 最终所需时间为 5 h。
 *             2.3 当节点为叶子结点, 分发时间为0
 *             2.4 最后使用分治法进行递归分发,相当于从叶子节点向上推。
 */
class Node{
    int id = 0;
    List<Node> sons = new ArrayList<>();
    Node parent = null;
}
 
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        HashMap<Integer , Node> hashMap = new HashMap<>();
        int K = sc.nextInt();
        int N = sc.nextInt();
        if(K == 0 || N == 0){
            System.out.println(0);
        }
        sc.nextLine();
        //树形构建
        for(int i = 0;i < N;i++){
            int node_n = sc.nextInt();
            //指定父节点
            int parent_id = sc.nextInt();
            Node my = null;
            if(hashMap.containsKey(parent_id)){
                //父节点存在
                my = hashMap.get(parent_id);
            }else{
                //父节点不存在
                my = new Node();
                my.id = parent_id;
                hashMap.put(parent_id,my);
            }
            //儿子节点
            for(int j = 0;j < node_n - 1;j++){
                int son_id = sc.nextInt();
                if(hashMap.containsKey(son_id)){
                    //儿子节点存在
                    hashMap.get(parent_id).sons.add(hashMap.get(son_id));
                }else{
                    //儿子节点不存在
                    Node son = new Node();
                    son.id = son_id;
                    son.parent = my;
                    hashMap.put(son.id,son);
                    hashMap.get(parent_id).sons.add(son);
                }
            }
            sc.nextLine();
        }
        //根节点存在
        Node root = hashMap.get(0);
        //分治法
        System.out.println(FZ(root , K));
    }
    public static int FZ(Node node , int k){
        int max = 0;
        if(node.sons.size() == 0){
            return 0;
        }else{
            Integer[] sons_time = new Integer[node.sons.size()];
            int i = 0;
            //统计分支时间
            for(Node son:node.sons){
                sons_time[i++] = FZ(son , k);
            }
            //合并分支与当前时间
            //降序排序
            Arrays.sort(sons_time, new Comparator<Integer>() {
                @Override
                public int compare(Integer o1, Integer o2) {
                    return o2 - o1;
                }
            });
            //计算当前节点为root所需要的时间
            int add = 1;
            for(int j = 0; j < sons_time.length ; j++){
                if(j!=0 && (j%k) == 0){
                    add++;
                }
                sons_time[j] += add;
                if(sons_time[j] > max){
                    max = sons_time[j];
                }
            }
        }
        return max;
    }
}
```

### [2020搜狗笔试2](https://www.nowcoder.com/test/question/done?tid=36179124&qid=1009391#summary)
#### 1
```markdown
import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int sum = 0;
        int password;
        int N = scanner.nextInt();
        int M = scanner.nextInt();
        int[] arr = new int[N];
        for (int i=0;i<M;i++){
            int L = scanner.nextInt();
            int R = scanner.nextInt();
            for(int j=L;j<R;j++){
                arr[j] = i+1;
            }
            arr[R] = i+1;
        }
        for (int i=0;i<arr.length;i++){
            sum+= i*arr[i];
        }
        password = sum % 100000009;
        System.out.println(password);
    }
}
```
#### 2.
```markdown
/**
 * 前缀 后缀 的匹配问题 easy
 */
 
import java.util.Scanner;
  
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int M = sc.nextInt();
        sc.nextLine();
        //读取规则
        String[] patterns = new String[N];
        for(int i =0 ;i < N;i++){
            patterns[i] = sc.nextLine();
        }
        //读取IP
        String[] IPs = new String[M];
        for(int i = 0;i < M; i++){
            IPs[i] = sc.nextLine();
        }
        //暴力匹配
        for(int i = 0; i < IPs.length;i++){
            boolean lock = false;
            for(int j = 0; j < patterns.length;j++){
                String t = "";
                if(patterns[j].charAt(0) == '*'){
                    t = patterns[j].replace("*","");
                    if(IPs[i].endsWith(t)){
                        System.out.print(1 + " ");
                        lock = true;
                        break;
                    }
                }else if(patterns[j].charAt(patterns[j].length()-1) == '*'){
                    t = patterns[j].replace("*","");
                    if(IPs[i].startsWith(t)){
                        System.out.print(1 + " ");
                        lock = true;
                        break;
                    }
                }else{
                    if(patterns[j].equals(IPs[i])){
                        System.out.print(1 + " ");
                        lock = true;
                        break;
                    }
                }
            }
            if(lock == false){
                System.out.print(0 + " ");
            }
        }
    }
}
```

## 20200820
### [2020 4399](https://www.nowcoder.com/profile/8791875/test/36202246/844365#summary)
#### 1.
```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        double ans1 = 100,ans2 = 100;
        for(int i = 0;i<n-1;i++){
            ans2*=0.5;
            ans1+=ans2*2;
        }
        ans2*=0.5;
        System.out.println(ans1+" "+ans2);
    }
}
```
#### 2.
```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int pNum = n;
        int index = 0;
        int countNum = 0;
        int[] arr = new int[n];
        while(pNum>1){
            if(arr[index]==0){
                countNum++;
                if(countNum==3){
                    countNum=0;
                    arr[index] = 1;
                    pNum--;
                }
            }
            index++;
            if(index==n) index = 0;
        }
        for(int i = 0;i<n;i++){
            if(arr[i]==0) System.out.println(i+1);
        }
    }
}
```
### [2020 4399](https://www.nowcoder.com/profile/8791875/test/36198670/110543#summary)
#### 1.
```java
//将20个球放进12个不同的袋子，每个袋子可以放0-20个球，有多少种放法？分析如何计算，然后编程解答。
//进阶问题：每个袋子只能放0个、2个或3个球，该如何计算？
public int ballBag(int bag, int ball) {
        int[][] dp = new int[bag + 1][ball + 1];
        int i, j, k, sum;
        for (i = 1; i <= bag; i++) {
            dp[i][0] = 1;
        }//无论几个包，放入0个球的方法只有一种
        for (j = 0; j <= ball; j++) {
            dp[1][j] = 1;
        }//无论几个球，放入1个包的方法也只有一种
        for (i = 2; i <= bag; i++) {
            for (j = 1; j <= ball; j++) {
                sum = 0;
                for (k = 0; k <= j; k++) {
                    sum += dp[i - 1][k];
                }
                dp[i][j] = sum;
            }
        }
        return dp[bag][ball];
    }
```
#### 2.
```java
import java.util.Scanner;
public class solution {
        public String findit(String str){
        Scanner scanner = new Scanner(System.in);
        String str1 = scanner.next();
        String str2 = scanner.next();
        char[] char1 = str1.toCharArray();
        char[] char2 = str2.toCharArray();
        int p1 = 0;
        int p2 = 0;
        while(p1<str1.length() && p2<str2.length()){
            while(p1<str1.length() && p2<str2.length() && char1[p1]!=char2[p2]){
                p1++;
            }
            p1++;
            p2++;
        }
        if(p2 >= char2.length){
            return new String("不可描述");
        }else{
            return str1;
        }        
    }
}
```