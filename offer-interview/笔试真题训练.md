# 笔试真题训练

## 20200819
### [2020搜狗笔试1](https://www.nowcoder.com/test/question/done?tid=36176943&qid=1009393#summary)
#### 1.
```markdown
import java.util.*;
/**
 * LRU 算法 LinkHashMap 或者 hashMap + Queue
 */
public class Main {
     public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        sc.nextLine();
        //记录数据
        LinkedHashMap<String , Long> LRUhashMap = new LinkedHashMap<>();
        while (sc.hasNext()){
            //输入k - v
            String[] insert = sc.nextLine().split(" ");
            String key = insert[0];
            String value = insert[1];
            if(LRUhashMap.containsKey(key)){
                if(LRUhashMap.get(key)-Long.valueOf(value) < 0){
                    LRUhashMap.remove(key);
                    LRUhashMap.put(key,Long.valueOf(value));
                }
            }else{
                if(LRUhashMap.size() < N){ //空间剩余
                    LRUhashMap.put(key,Long.valueOf(value));
                }else if(LRUhashMap.size() == N){ //空间不足
                    for(String s : LRUhashMap.keySet()){
                        System.out.println(s + " " + LRUhashMap.get(s));
                        LRUhashMap.remove(s);
                        LRUhashMap.put(key,Long.valueOf(value));
                        break;
                    }
                }
            }
        }
    }
}
```
#### 3
```markdown
import java.util.*;
 
/**
 *    1. 使用hashmap构建树形结构
 *    2. 递归分治法：假设已知 各个子节点的分发时间：
 *        则： 2.1 对子节点的分发时间进行降序排列
 *            2.2 当前节点优先对 子节点分发时间 较长的节点进行分发, 
 *                如:子节点分发时间 4 2 1 1 1 0, k=2, 则: 先后分发顺序(42)(11)(10),也就是
 *                     (42)+1 (11)+2 (10)+3 => 5 3 3 3 4 3 => 分三轮分发, 最终所需时间为 5 h。
 *             2.3 当节点为叶子结点, 分发时间为0
 *             2.4 最后使用分治法进行递归分发,相当于从叶子节点向上推。
 */
class Node{
    int id = 0;
    List<Node> sons = new ArrayList<>();
    Node parent = null;
}
 
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        HashMap<Integer , Node> hashMap = new HashMap<>();
        int K = sc.nextInt();
        int N = sc.nextInt();
        if(K == 0 || N == 0){
            System.out.println(0);
        }
        sc.nextLine();
        //树形构建
        for(int i = 0;i < N;i++){
            int node_n = sc.nextInt();
            //指定父节点
            int parent_id = sc.nextInt();
            Node my = null;
            if(hashMap.containsKey(parent_id)){
                //父节点存在
                my = hashMap.get(parent_id);
            }else{
                //父节点不存在
                my = new Node();
                my.id = parent_id;
                hashMap.put(parent_id,my);
            }
            //儿子节点
            for(int j = 0;j < node_n - 1;j++){
                int son_id = sc.nextInt();
                if(hashMap.containsKey(son_id)){
                    //儿子节点存在
                    hashMap.get(parent_id).sons.add(hashMap.get(son_id));
                }else{
                    //儿子节点不存在
                    Node son = new Node();
                    son.id = son_id;
                    son.parent = my;
                    hashMap.put(son.id,son);
                    hashMap.get(parent_id).sons.add(son);
                }
            }
            sc.nextLine();
        }
        //根节点存在
        Node root = hashMap.get(0);
        //分治法
        System.out.println(FZ(root , K));
    }
    public static int FZ(Node node , int k){
        int max = 0;
        if(node.sons.size() == 0){
            return 0;
        }else{
            Integer[] sons_time = new Integer[node.sons.size()];
            int i = 0;
            //统计分支时间
            for(Node son:node.sons){
                sons_time[i++] = FZ(son , k);
            }
            //合并分支与当前时间
            //降序排序
            Arrays.sort(sons_time, new Comparator<Integer>() {
                @Override
                public int compare(Integer o1, Integer o2) {
                    return o2 - o1;
                }
            });
            //计算当前节点为root所需要的时间
            int add = 1;
            for(int j = 0; j < sons_time.length ; j++){
                if(j!=0 && (j%k) == 0){
                    add++;
                }
                sons_time[j] += add;
                if(sons_time[j] > max){
                    max = sons_time[j];
                }
            }
        }
        return max;
    }
}
```

### [2020搜狗笔试2](https://www.nowcoder.com/test/question/done?tid=36179124&qid=1009391#summary)
#### 1
```markdown
import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int sum = 0;
        int password;
        int N = scanner.nextInt();
        int M = scanner.nextInt();
        int[] arr = new int[N];
        for (int i=0;i<M;i++){
            int L = scanner.nextInt();
            int R = scanner.nextInt();
            for(int j=L;j<R;j++){
                arr[j] = i+1;
            }
            arr[R] = i+1;
        }
        for (int i=0;i<arr.length;i++){
            sum+= i*arr[i];
        }
        password = sum % 100000009;
        System.out.println(password);
    }
}
```
#### 2.
```markdown
/**
 * 前缀 后缀 的匹配问题 easy
 */
 
import java.util.Scanner;
  
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int M = sc.nextInt();
        sc.nextLine();
        //读取规则
        String[] patterns = new String[N];
        for(int i =0 ;i < N;i++){
            patterns[i] = sc.nextLine();
        }
        //读取IP
        String[] IPs = new String[M];
        for(int i = 0;i < M; i++){
            IPs[i] = sc.nextLine();
        }
        //暴力匹配
        for(int i = 0; i < IPs.length;i++){
            boolean lock = false;
            for(int j = 0; j < patterns.length;j++){
                String t = "";
                if(patterns[j].charAt(0) == '*'){
                    t = patterns[j].replace("*","");
                    if(IPs[i].endsWith(t)){
                        System.out.print(1 + " ");
                        lock = true;
                        break;
                    }
                }else if(patterns[j].charAt(patterns[j].length()-1) == '*'){
                    t = patterns[j].replace("*","");
                    if(IPs[i].startsWith(t)){
                        System.out.print(1 + " ");
                        lock = true;
                        break;
                    }
                }else{
                    if(patterns[j].equals(IPs[i])){
                        System.out.print(1 + " ");
                        lock = true;
                        break;
                    }
                }
            }
            if(lock == false){
                System.out.print(0 + " ");
            }
        }
    }
}
```

## 20200820
### [2020 4399](https://www.nowcoder.com/profile/8791875/test/36202246/844365#summary)
#### 1.
```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        double ans1 = 100,ans2 = 100;
        for(int i = 0;i<n-1;i++){
            ans2*=0.5;
            ans1+=ans2*2;
        }
        ans2*=0.5;
        System.out.println(ans1+" "+ans2);
    }
}
```
#### 2.
```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int pNum = n;
        int index = 0;
        int countNum = 0;
        int[] arr = new int[n];
        while(pNum>1){
            if(arr[index]==0){
                countNum++;
                if(countNum==3){
                    countNum=0;
                    arr[index] = 1;
                    pNum--;
                }
            }
            index++;
            if(index==n) index = 0;
        }
        for(int i = 0;i<n;i++){
            if(arr[i]==0) System.out.println(i+1);
        }
    }
}
```
### [2020 4399](https://www.nowcoder.com/profile/8791875/test/36198670/110543#summary)
#### 1.
```java
//将20个球放进12个不同的袋子，每个袋子可以放0-20个球，有多少种放法？分析如何计算，然后编程解答。
//进阶问题：每个袋子只能放0个、2个或3个球，该如何计算？
public int ballBag(int bag, int ball) {
        int[][] dp = new int[bag + 1][ball + 1];
        int i, j, k, sum;
        for (i = 1; i <= bag; i++) {
            dp[i][0] = 1;
        }//无论几个包，放入0个球的方法只有一种
        for (j = 0; j <= ball; j++) {
            dp[1][j] = 1;
        }//无论几个球，放入1个包的方法也只有一种
        for (i = 2; i <= bag; i++) {
            for (j = 1; j <= ball; j++) {
                sum = 0;
                for (k = 0; k <= j; k++) {
                    sum += dp[i - 1][k];
                }
                dp[i][j] = sum;
            }
        }
        return dp[bag][ball];
    }
```
#### 2.
```java
import java.util.Scanner;
public class solution {
        public String findit(String str){
        Scanner scanner = new Scanner(System.in);
        String str1 = scanner.next();
        String str2 = scanner.next();
        char[] char1 = str1.toCharArray();
        char[] char2 = str2.toCharArray();
        int p1 = 0;
        int p2 = 0;
        while(p1<str1.length() && p2<str2.length()){
            while(p1<str1.length() && p2<str2.length() && char1[p1]!=char2[p2]){
                p1++;
            }
            p1++;
            p2++;
        }
        if(p2 >= char2.length){
            return new String("不可描述");
        }else{
            return str1;
        }        
    }
}
```

## 20200821
### [商汤科技2020-8-20开发笔试A卷](https://www.nowcoder.com/discuss/483879)
```markdown
//一：给定一个字符串，找“Good”，字符顺序不可变，每个字符只能用一次
class Solution {
    public int method(char[] chars) {
        if (chars.length < 4)
            return 0;
        int res = 0;
        int numOfG = 0, numOfO = 0;
        for (int i = 0; i < chars.length; i++) {
            if (chars[i] == 'G')
                numOfG++;
            if (chars[i] == 'o') {
                if (numOfG > 0)
                    numOfO++;
            }
            if (chars[i] == 'd') {
                if (numOfG > 0 && numOfO >= 2) {
                    res++;
                    numOfG--;
                    numOfO = numOfO - 2;
                }
            }
        }
        return res;
    }
}
//二、最常上升子序列，leetcode原题
class SolutionMainTwo {
    public int[][] cur = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    public int r, c;
    public int method(int[][] array, int n, int m) {
        if (n == 0 || m == 0 || array == null)
            return 0;
        r = n;
        c = m;
        int[][] curArray = new int[r][c];
        int ans = 0;
        for (int i = 0; i < r; ++i) {
            for (int j = 0; j < c; ++j) {
                ans = Math.max(ans, methodDFS(array, i, j, curArray));
            }
        }
        return ans;
    }
    private int methodDFS(int[][] matrix, int row, int column, int[][] curArray) {
        if (curArray[row][column] != 0)
            return curArray[row][column];
        ++curArray[row][column];
        for (int[] ints : cur) {
            int newRow = row + ints[0];
            int newColumn = column + ints[1];
            if (newRow >= 0 && newRow < r && newColumn >= 0 && newColumn < c && matrix[newRow][newColumn] > matrix[row][column]) {
                curArray[row][column] = Math.max(curArray[row][column], methodDFS(matrix, newRow, newColumn, curArray) + 1);
            }
        }
        return curArray[row][column];
    }
}
//三、大意是求删除区间的个数，可以使得删除后剩下的区间彼此不重叠（好像是这个意思）
class SolutionMainThree {
    /**
     *
     * @param intervals int整型二维数组
     * @return int整型
     */
    public int eraseOverlapIntervals (int[][] intervals) {
        // write code here
        if (intervals.length == 0)
            return 0;
        Arrays.sort(intervals, new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {
                return o1[0]-o2[0];
            }
        });
        int result = 0;
        int cur = 0;
        int len = intervals.length;
        for (int i = 1; i < len; i++) {
            if (intervals[cur][1]>intervals[i][0]){
                if (intervals[cur][1]>intervals[i][1])
                    cur = i;
                result++;
            }else{
                cur = i;
            }
        }
        return result;
    }
}
```
### [顺丰笔试，全A代码](https://www.nowcoder.com/discuss/483891)
[顺丰8月20笔试，java代码](https://www.nowcoder.com/discuss/483985)
```markdown
//第一题：出租服务器，求最大收益，对客户付出的金钱进行贪心
输入：第一行n,m。n服务器个数，m客户个数
     第二行 n个数，表示每台服务器的带宽大小
     剩下的m行 每行 需求的带宽大小，可以付出的金钱
3 3
1 2 3
5 100
3 2
1 2
输出 4
public static void main(String[] args) {
        Scanner in=new Scanner(System.in);
        int n=in.nextInt(),m=in.nextInt();//n服务器个数，m客户个数
        Integer[] a=new Integer[n];
        for (int i = 0; i < n; i++) {
            a[i]=in.nextInt();
        }
        int[][] b=new int[m][2];//第一个表示需要的带宽大小，第二个表示可以付出的金钱
        for (int i = 0; i < m; i++) {
                b[i][0]=in.nextInt();
                b[i][1]=in.nextInt();
        }
        Arrays.sort(b, new Comparator<int[]>() { @Override public int compare(int[] o1, int[] o2) {
                if(o1[1]!=o2[1]) return o2[1]-o1[1];//金钱降序排序
                return o1[0]-o1[0];//带宽大小升序排序
            }
        });
        Arrays.sort(a, new Comparator<Integer>() { @Override public int compare(Integer o1, Integer o2) {
                return o1-o2;//升序排序
            }
        });
        int ans=0,n_temp=n;
        for (int i = 0; i < m; i++) {//对客户进行遍历，贪心最大的金钱
            if(n_temp==0) break;//记录已经出租的服务器数
            int select=-1;
            for (int j = 0; j < n; j++) {//给客户安排带宽刚刚够的服务器，将更大的服务器留给后面的用户
                if(a[j]>=b[i][0]) {
                    select=j;
                    a[j]=-1;//用过的服务器标记为-1
                    break;
                }
            }
            if(select!=-1){
                n_temp--;
                ans+=b[i][1];
            }
        }
        System.out.println(ans);
    }
//第二题：赏金猎人，求最大收益，先按结束时间进行升序排序，然后DP
  给定n,以下n行，每行3个数 s e mon ，分别表示开始时间 结束时间 赏金，求赏金猎人能得到的最大赏金。
输入 ： 
4
1 2 3
2 3 5
2 8 10
3 9 11
输出:
3 8 13 19
19
class k{
    public int s;//开始时间
    public int e;//结束时间
    public int mon;//赏金
    public k(int s, int e, int mon) {
        this.s = s;
        this.e = e;
        this.mon = mon;
    }
} 

 public static void main(String[] args) {
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        k[] a=new k[n];
        for (int i = 0; i < n; i++) {
            int s=in.nextInt();
            int e=in.nextInt();
            int mon=in.nextInt();
            a[i]=new k(s,e,mon);
        }
        Arrays.sort(a, new Comparator<k>() { @Override public int compare(k o1, k o2) {
                return o1.e-o2.e;//按照结束时间升序排序
            }
        });
        int[] dp=new int[n];
        dp[0]=a[0].mon;
        for(int i=1;i<n;i++){
            k temp=a[i];
            int itemp=-1;
            for (int j = i-1; j >=0 ; j--) {
                //找出选择了第i个任务后，前边还能够接受的任务（只要接受的任务的结束时间《第i个任务的开始时间就可以，因为前边已经将区间按照结束时间来升序排序了）
                if(temp.s>=a[j].e){
                    itemp=j;
                    break;
                }
            }
            //dp[i-1]表示不选第i个任务，后边表示选第i个任务
            if(itemp==-1){
                dp[i]=Math.max(dp[i-1],temp.mon);
            }
            else dp[i]=Math.max(dp[i-1],temp.mon+dp[itemp]);
        }
        for (int i = 0; i < n; i++) {
            System.out.print(dp[i]+" ");
        }
        System.out.println();
        System.out.println(dp[n-1]);
    }
```

## 20200822
### [爱奇艺2018](https://www.nowcoder.com/test/question/done?tid=36373974&qid=137989#summary)
```markdown
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] num = new int[n];
        int ans = Integer.MIN_VALUE;
        for(int i = 0;i <n;i++){
            num[i] = sc.nextInt();
            num[i] = help(num[i]);
            ans = Math.max(ans,num[i]);
        }
        System.out.println(ans);
    }
    private static int help(int num){
        char[] cs = String.valueOf(num).toCharArray();
        Arrays.sort(cs);
        String s= new String(cs);
        return Integer.valueOf(s);
    }
}
//缺失的括号
public static void main(String args[]){
	    	 Scanner in = new Scanner(System.in);
	         String str = in.nextLine();
                 //count计数多出来的"("，n计数字符串最前面的")"
	         int count = 0, n=0;
	         for(int i = 0; i < str.length(); i++){
	             if(str.charAt(i) == '('){
	            	 count++;
	             }
	             if(str.charAt(i) == ')') {
	            	 if(count == 0){
	            		 n++;
	            	 }else{
	            		 count--;
	            	 }
	             }
	         }
	         System.out.println(count+n);
	     }
//DNA序列
//链接：https://www.nowcoder.com/questionTerminal/ab900f183e054c6d8769f2df977223b5
  来源：牛客网
  
  不需要讨论实际的序列，只要比较序列的个数就好了。从长度为1到长度为n分别进行讨论，将长度
  为i的子串加入到set容器中去，set容器会自动除去重复的元素，这样set容器的大小size（）就
  表示长度为i的种类数量了。长度为i的序列总共有4的i次方个（排列组合：每个位置都有四种
  选择），然后将set容器的size()与4的i次方进行比较，如果小于4的i次方，那肯定存在不包含的
  序列。
import java.util.*;
public class Main{
    public static void main(String args[]){
        Scanner scan = new Scanner(System.in);
        String input = scan.nextLine();
        int i,j,n = input.length();
        for(i=1;i<=n;i++){
            HashSet<String> set= new HashSet<String>();
            for(j=0;j<n-i;j++) set.add(input.substring(j,j+i));
            if(set.size()<Math.pow(4,i)){
                System.out.println(i);
                break;
            }
        }  
    }
}
    private static int solve(String s) {
        LinkedList<String> linkedList = new LinkedList<>();
        for (int i = 0; i < dns.length; i++) {
            String string = String.valueOf(dns[i]);
            if (s.contains(string)) {
                linkedList.add(String.valueOf(dns[i]));
            } else {
                return 1;
            }
        }
        return solve(s, linkedList);
    }
    private static int solve(String s, LinkedList<String> linkedList) {
        boolean find = false;
        int count = 0;
        while (!find) {
            String string = linkedList.poll();
            for (int i = 0; i < dns.length; i++) {
                String string2 = string + dns[i];
                if (!s.contains(string2)) {
                    find = true;
                    count = string2.length();
                    break;
                }
                linkedList.offer(string2);
            }
        }
        return count;
    }

```

## 20200823
### [爱奇艺2021-GUN]()
```markdown
//1.n的阶乘的末尾0-计算乘法因子里面有多少个5 - leetcode-172. 阶乘后的零
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int ans = 0;
        while(n>=5){
            ans +=n/5;
            n = n/5;
        }
        return ans;
    }
}
//2.路径是否相交 -leetcode 1496. 判断路径是否相交
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        Stirng paths = sc.nextLine();
        Set<String> set = new HashSet<>();
        int x = 0;
        int y = 0;
        set.add(x+","+y);
        for(int i = 0;i<paths.length();i++){
            char ch = paths.charAt(i);
            if('N'==ch){ y++;}
            if('S'==ch){ y--;}
            if('E'==ch){ x++;}
            if('W'==ch){ x--;}
            if(set.contains(x+","+y)) return true;
            else set.add(x+","+y);
        }
        return false;
    }
}
// leetcode -20. 有效的括号
//建立一个新的栈，然后遍历字符串的字符，进行比较
    public boolean isValid3(String s) {
        Stack<Character> stack = new Stack<>();
        for (char c : s.toCharArray()) {
            if(c=='(') stack.push(')');
            else if(c=='[') stack.push(']');
            else if(c=='{') stack.push('}');
            else if(stack.isEmpty()||c!=stack.pop()) return false;
        }
        return stack.isEmpty();
    }
```
### [8.23 老虎证券Java开发笔试](https://www.nowcoder.com/discuss/486494)
```markdown
//第一题 LeetCode 328. 奇偶链表
//一个链表，让位于奇数位的节点移到前面，且相对顺序不变。空间复杂度O(1),时间复杂度O(n)
//输入：2->3->1->5->4->NULL
//输出：2->1->4->3->5->NULL
    public static ListNode lineUp(ListNode head) {
        if (head == null) {
            return head;
        }
        ListNode single = head;
        ListNode doublePre = head.next;
        ListNode doubleAfter = head.next;
        while (single != null && doubleAfter != null) {
            single.next = doubleAfter.next;
            single = single.next;
            doubleAfter.next = single.next;
            doubleAfter = doubleAfter.next;
        }
        single.next = doublePre;
        return head;
    }
//LeetCode 39. 组合总和
//给定N支股票的价格和经理拥有的金钱m，经理可以选择买和不买。输出该经理最终花光m的所有组合
//输入：[3,8,6], 14
//输出：[[6,8]]
    public ArrayList<ArrayList<Integer>> combinationSum (int[] prices, int m) {
        ArrayList<ArrayList<Integer>> result = new ArrayList<>();
        if(prices == null || prices.length == 0 || m <= 0){
            return result;
        }
        Arrays.sort(prices);
        ArrayList<Integer> list = new ArrayList<>();
        combination(result, list, prices, m, 0);
        return result;
    }
    public void combination(ArrayList<ArrayList<Integer>> result, ArrayList<Integer> list, int[] prices, int target, int index){
        if(target <= 0){
            if(target == 0){
                result.add(new ArrayList<>(list));
            }
            return;
        }
        for(int i = index; i < prices.length; i++){
            list.add(prices[i]);
            combination(result, list, prices, target - prices[i], i + 1);
            list.remove(list.size() - 1);
        }
    }
```

## 20200824
### [腾讯笔试](https://www.nowcoder.com/discuss/486642)
[腾讯823校招笔试翻车经（请大家给点建议）](https://www.nowcoder.com/discuss/486707)
```java
//1.给一个长度为n的链表，挖掉第k个元素，问挖掉元素后的序列。
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        int[] arr = new int[n];
        for(int i = 1;i<=n;i++){
            arr[i] = sc.nextInt();
            if(i!=m){
                System.out.print(arr[i]+" ");
            }
        }
    }
//LeetCode-19. 删除链表的倒数第N个节点
    public ListNode removeNthFromEnd(ListNode head, int n) {
            ListNode dummy = new ListNode(0);
            dummy.next = head;
            ListNode first = dummy;
            ListNode second = dummy;
            for(int i = 1;i<n;i++){
                first = first.next;
                second = second.next;
            }
            while(first!=null){
                first = first.next;
                second = second.next;
            }
            second.next = second.next.next;
            return dummy.next;
        }
}
//2.给一个长度为n（n在5000内）的字符串，问字典序第k（k在5以内）大的子串是什么。
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        String str = sc.nextLine();
        int k = sc.nextInt();
        Set<String> set = new HashSet<>();
        int len = str.length();
        //// 大顶堆
        PriorityQueue<String> queue = new PriorityQueue<>((o1,o2)->o2.compareTo(o1));
        for(int i = 0;i<len;i++){
            for(int j = i+1;j<=len;j++){
                String temp = str.substring(i,j);
                if(queue.size()<k){
                    queue.add(temp);
                }else  if(temp.compareTo(queue.peek())>=0){//队列满，新的子串字典序>=队列里的子串字典序
                    continue;
                }else if(!queue.contains(temp)){//队列满，新的子串字典序<队列里的子串字典序,队列中不包含该子串
                    queue.poll();
                    queue.add(temp);
                }
            }
        }
        System.out.println(queue.peek());
    }
//3.给一个数n，把它拆成a+b=n，要求a和b的数位和最大，求这个数位和。
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        if(n<=18) return n;
        int res = 0;
        while(n>=10){
            long i = n%10+10;
            if(i<=18){
                res+=i;
                n = n - 10;
                n = n / 10;
            }else {
                res+=n%10;
                n/=10
            }
        }
        System.out.print(res+n);
    }
//4.有n（n在5000内）块木板，宽度是1，长度不固定，这些小木板拼接起来一块大木板。
//给一个宽度为1的刷子，每刷一次可以选择横着刷和竖着刷，过程中都不能离开木板。问最少要刷几次能把木板完全刷一遍。
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] nums = new int[n];
        for(int i =0;i<n;i++){
            nums[i] = sc.nextInt();
        }
        int[][] dp  = new int[n][n];
        dp[0][0] = 0;
        for(int i = 0;i<n;i++){
            for(int j = 0;j<=n;j++){
                int high;
                //竖着刷
                high = Math.min(j,nums[i+1]);
                dp[i+1][high] = Math.min(dp[i+1][high],dp[i][j]+1);
                //横着刷
                if(a[i+1]<n){
                    if(j>=a[i+1]) dp[i+1][a[i+1]] = Math.min(dp[i+1][a[i+1]],dp[i][j]);
                    else dp[i+1][a[i+1]] = Math.min(dp[i+1][a[i+1]],dp[i][j]+a[i+1]-j);
                }
            }
        }
        int ans = n;
        for(int i = 0;i<=n;i++) ans = Math.min(dp[n][i],ans);
        System.out.print(ans);//横着刷
    }
// 给定字符串str，给定范围[l, r]，求子串能拆成最少的回文串的个数。
import java.util.*;

public class Main {

    static HashMap<String, Integer> mem = new HashMap();
    private static int splitPa(String key) {
        if (mem.containsKey(key))
            return mem.get(key);
        int n = key.length();
        int best = n;
        for (int i = 0; i < n; i++) {
            String right = key.substring(i);
            if (isPa(right)) {
                String left = key.substring(0, i);
                best = Math.min(best, 1 + splitPa(left));
            }
        }
        mem.put(key, best);
        return best;
    }

    private static boolean isPa(String str) {
        int l = 0;
        int r = str.length() - 1;
        while (l < r) {
            if (str.charAt(l) != str.charAt(r))
                return false;
            l++;
            r--;
        }
        return true;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String str = sc.nextLine();
        int Q = sc.nextInt();
        mem.put("", 0);
        for (int q = 0; q < Q; q++) {
            int l = sc.nextInt();
            int r = sc.nextInt();
            System.out.println(splitPa(str.substring(l-1, r)));
        }
    }
}
```
### [306笔试8.24](https://www.nowcoder.com/discuss/487244)
[360Java笔试8月24日下午场](https://www.nowcoder.com/discuss/487177)
```java
//第一题:镜面反转，ABA 为NO，AHA为YES，ABC为NO，只需找到反转后和原来相同的字母（'A','H','I','M','O','T','U','V','W','X','Y'），并判断是不是回文
import java.util.*;
public class Main {

    public static void main(String[] args) {
        Set<Character> set=new HashSet<>();
        Character[] chars={'A','H','I','M','O','T','U','V','W','X','Y'};
        Arrays.stream(chars).forEach(set::add);
        Scanner input=new Scanner(System.in);
        while (input.hasNextLine()){
            System.out.println(IsExcept(set,input.nextLine()));
        }

    }
    private static String IsExcept(Set set,String string) {
        int left=0;
        int right=string.length()-1;
        while (left<=right){
            if (!set.contains(string.charAt(left))||!set.contains(string.charAt(right)))return "NO";
            if (string.charAt(left++)!=string.charAt(right--)){
                return "NO";
            }
        }
        return "YES";
    }
}
/**
 * 魔塔闯关  
 * 魔塔是一款时尚经典小游戏，我们将魔塔简化后的规则描述如下：
 * 魔塔有n关，而你可以自由选择前往攻略哪一关，每一关只能获得一次分数。
 * 第i关攻略完成后，你将会获得ai的分数。
 * 某些关有一个特殊的宝物，你只能在攻略完这一关的时候使用这个宝物（
 * 也可以不使用，额外的宝物并不能留到其他关卡使用），
 * 这个宝物将使得这一关不得分，但是将你现有的总得分乘以2作为新的得分。
 * 你现在知道了所有关卡的通关方法，也知道了每一关的得分和是否有宝物，你现在想知道，怎么选择攻略的顺序和使用宝物的方法才能让自己的得分最大化？
 * 输入描述
 * 输入第一行包含一个整数n
 * 接下来n行，每行两个整数ai,bi。ai表示第i关的分数，若bi为1，则第i关有宝物。
 * 输出描述
 * 输出包含一个数，即能获得的最大分数
闯关->只需将无道具的先冲关再将有道具的按照分数从大到小排序即可
 */
public class Main {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        long n = input.nextLong();
        PriorityQueue<Long> queue = new PriorityQueue<Long>((a, b) -> b.compareTo(a));
        long current=0;
        while (n > 0) {
            long[] item=new long[]{input.nextLong(), input.nextLong()};
            if (item[1]==0){
                current+=item[0];
            }else {
                queue.add(item[0]);
            }
            n--;
        }
        long max = getResult(queue, current);
        System.out.println(max);
    }

    private static long getResult(PriorityQueue<Long> queue, long current) {
        if (queue.isEmpty()) {
            return current;
        } else {
            while (!queue.isEmpty()) {
                current+=Math.max(current,queue.poll());
            }
            return current;
        }
    }
}
```
### [中兴0824]()
```java
//第一题子数组求平均最大值的
public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();

        int[] array = new int [n];
        for(int i = 0; i < n; i++){
            array[i] = sc.nextInt();
        }
        int max = array[0];
        int l = 0;
        int r = 0;
        int temp = array[0];
        for(int i = 1; i < array.length; i++){
            r++;
            temp = (array[i] + temp) / (r - l + 1);
            if(max < temp){
                max = temp;
            }
            if(max <= array[i]){
                max = array[i];
                temp = array[i];
                l = i;
                r = i;
            }
        }
        System.out.println(max);
    }
 //题目描述：
//输入:一个数字T，作为总共要输入的行数；接下来输入T行：每行
//  包括一个字符串s，进制数l和r，其中s只包括0-9和A-Z之间的字符，l<r
//输出：每行一个数字，是字符串转换为10进制后的数的和:sl+sl+1+...+sr-1+sr为奇数，输出1；为偶数输出0；
/**
 * 2
 * 101 2 3
 * 101 4 5
 */
public class test2 {
    public static void main(String args[]) {

        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        sc.nextLine();
        String[] arr = new String[n];
        for (int i = 0; i < n; i++) {
            arr[i] = sc.nextLine();
        }
        int[] a = isOddorEven(arr);
        for (int i = 0; i < n; i++) {
            System.out.println(a[i]);
        }
    }

    public static int[] isOddorEven(String[] arr) {
        int[] a = new int[arr.length];
        for (int i = 0; i < arr.length; i++) {
            String[] items = arr[i].split(" ");
            String s = items[0].toUpperCase();
            int ls = Integer.parseInt(items[1]);
            int rs = Integer.parseInt(items[2]);
            char[] char_arr = s.toCharArray();
            int res = 0;
            int tmp = 0;
            for (int k = ls; k <= rs; k++) {
                for (int j = char_arr.length - 1; j >= 0; j--) {
                    if (char_arr[j] >= 'A' && char_arr[j] <= 'Z') {
                        tmp = char_arr[j] - 'A' + 10;
                    } else if (char_arr[j] >= '0' && char_arr[j] <= '9') {
                        tmp = char_arr[j] - '0';
                    }else return null;
                    res += tmp * Math.pow(k, char_arr.length - j - 1);
                }
            }

            if (res % 2 == 0) {
                a[i] = 0;
            } else {
                a[i] = 1;
            }
        }
        return a;
    }
}
```
### [阿里0824]()
```markdown
import java.util.*;
public class Main{
    public static void main(String args[]) {
        Scanner input = new Scanner(System.in);
        while(input.hasNextInt()){
            long A = input.nextLong();
            long B = input.nextLong();
            long a = input.nextLong();
            long b = input.nextLong();
            long start = Math.min(A, (B*a)/b);
            for (long i = start; i >= 1 ; i--) {
                if((b*i)%a == 0 && (b*i)/a <= B){
                    long y = (b*i)/a;
                    System.out.println(i + " " + y);
                    break;
                }
            }
        }
    }
}
```

## 20200826
### [2020.08.26阿里巴巴笔试](https://www.nowcoder.com/discuss/488901)
```java
//1.第一题：给出两个长度均为n的字符串A, B（只包含小写字母），求字典序介于这两个字符串之间的且长度为n的字符串有多少个, 即满足 A < X < B；
//直接把字符串看出是一个26进制的数据，然后相减的结果 - 1 就是答案了！
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        for(int i = 0;i<T;i++){
            int n = sc.nextInt();
            String a = sc.next();
            String b = sc.next();
            System.out.print(help(a,b,n));
        }
    }

    public static long help(String a,Sting b,int n){
        if(a.compareTo(b)>=0) return 0;
        long res = 0;
        long base = 1;
        for(int i = n-1;i>=0;i--){
            int num1 = a.charAt(i)-'a';
            int num2 = b.charAt(i)-'a';
            res+=(num2-num1)*base;
            base*=26;
        }
        return res-1;
    }
}
//2. 有T个案例。每个案例有一个n代表怪兽数量，m代表宝剑耐久度。有n行，每一行是怪兽的hp和杀死后获得的奖励。
// 耐久度高于hp可以杀怪兽。奖励是可以不使用耐久度就可以杀死a个怪兽。对于每一个案例输出最多杀几个，花费的最少的耐久度。
static int[] solution(int[] w, int[] v, int V) {
        int len = w.length;
        int[] dp = new int[V + 1];
        int left;
        int n;
        for(int i = 0; i < len; ++i) {
            for(int j = V; j >= w[i]; --j) {
                left = v[i];
                n = 0;
                for(int k = 0; k < len; ++k) {
                    if(k != i && left > 0) {
                        ++n;
                        left--;
                        left += v[k];
                    }
                }
                dp[j] = Math.max(dp[j], n + 1);
            }
        }
        int[] ans = new int[2];
        ans[1] = dp[V];
        for(int i = 0; i <= V; ++i) {
            if(dp[i] == ans[1]) {
                ans[0] = i;
                break;
            }
        }
        return ans;
    }
```
### [20200826华为]()
```markdown
第一题：
输入一行32位的无符号整数数组，不定长，用空格分隔，要求对它们做“加密”：
步骤A：交换：对于每个整数，按二进制每两位交换，第一位和第二位换，第三和第四换，以此类推。如0010，交换成0001。
步骤B：循环右移：对于每个整数，按二进制右移两位，右移出来的最低2位放到下一个数的最高2位，以此类推。最后一个数的最低2位安到第一个数的最高2位。如果只有一个数，则右移后的最低两位放到自己的最高位。
输出“加密”后的数。
示例：输入1 2，输出1073747824  2147483648
public static void main(String[] args){
    Scanner sc = new Scanner(System.in);
    while(sc.hasNextLine()){
        String[] arr = sc.nextLine().split(" ");
        long[] arr1 = new long(arr.length);
        for(int i = 0;i<arr.length();i++){
            arr1[i] = Long.parseLong(arr[i]);
         }
        long[] res = help(arr1,arr1.length());
        int j = 0;
        while(j<arr1.length-1){
            System.out.print(res[j]+" ");
            j++;
        }
        System.out.print(res[j]);
    }
}
public static long []help(long []arr,int n){
        int[][]temp = new int[n][32];
        for(int i=0;i<n;i++){
            for(int j=0;j<32;j++){
                temp[i][j]=(int)arr[i]%2;
                arr[i]/=2;
            }
            for(int k=0;k<16;k++){
                int t = temp[i][2*k];
                temp[i][2*k]=temp[i][2*k+1];
                temp[i][2*k+1]=t;
            }
            arr[i]=0;
            for(int l=31;l>=0;l--){
                arr[i]*=2;
                arr[i]+=temp[i][l];
            }
        }
        if(n ==1){
            arr[0]=(long)(arr[0]/4+arr[0]%4*Math.pow(2,30));
            return arr;
        }
        long tt=0;
        long tt2=0;
        for(int i=0;i<n;i++){
            tt=arr[i]%4;
            arr[i]/=4;
            arr[i]+=tt2*Math.pow(2,30);
            tt2 = tt;
        }
        arr[0]+=tt2*Math.pow(2,30);
        return arr;
    }
第二题：输入一组矩形，分别给出宽和高，求这些矩形组成的连续最大面积（最大柱状图面积的变形）。
这题算法上leetcode有变形，算法倒是不难。比较费事的是输入格式，输入的是 “[1,2,3],[1,2,3]" 这样的一行字符串，第一个数组是宽，第二个数组是高，用c++费了好大劲一个个字符串处理的，这时候特别想念Python的split.
这题还考了边界处理，包括非法字符，两个数组长度不对等，宽<=0或高<=0的情况。不处理边界只能拿70%，别问我怎么知道的。 😣
LeetCode 84
public int largestRectangleArea(int[] heights) {
        int area = 0, n = heights.length;
        // 遍历每个柱子，以当前柱子的高度作为矩形的高 h，
        // 从当前柱子向左右遍历，找到矩形的宽度 w。
        for (int i = 0; i < n; i++) {
            int w = 1, h = heights[i], j = i;
            while (--j >= 0 && heights[j] >= h) {
                w++;
            }
            j = i;
            while (++j < n && heights[j] >= h) {
                w++;
            }
            area = Math.max(area, w * h);
        }

        return area;
    }
第三题：猜数字
给定一系列字符串，并告诉你每个字符串中有多少个字符是存在的并在最终位置上，有多少个字符存在，但是位置不对。请根据它们猜出正确的字符串。
示例：字符串，存在并位置对的个数，存在但是位置不对的个数
cloxy 3 0
cxmnu 1 1
kcotd  2 1
apqud  2 0
bldwz  1 1
答案：cloud
```
### [2020/8/26广联达java开发算法题]()
```markdown
1、跳舞机，用WSAD表示上下左右，踩对+20分，踩错-10分，当分数 为零时不会继续扣分（无负数分）
输入：两行字符串，完全由WSAD组成，长度一致，第一行时满分的步骤，第二行为小明踩的步骤
输出：一行一个数，表示得分。
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        String str = sc.nextLine();
        String youStr = sc.nextLine();
        int len = str.length();
        int[] dp = new int[len];
        if(str.charAt(0)==youStr.charAt(0)) dp[0] = 20;
        else dp[0] = 0;
        for(int i = 1;i<len;i++){
            if(str.charAt(i)!=youStr.charAt(i)){
                if(dp[i-1]-10<0) dp[i] = 0;
                else dp[i] = dp[i-1]-10;
            }else{
                dp[i] = dp[i-1] + 20;
            }
        }
        System.out.println(dp[len-1]);
    }
}
2、元素平衡
《XX魔法书》中记载，只有魔法师体内地火水风四种元素平衡的时候才是绝对安全的。
某魔法师在给自己做了一个体检，发现自己体内的四种元素数量分别是A，B，C，D，魔法师慌了，这时他看到魔法书中记载了一种转换魔法，可以把任意两个单位的元素转换成任意一种元素。
请问魔法师是否可以通过这种魔法，在保证自己体内的元素总量尽可能多的情况下， 使得自己体内的四种元素数量完全相同？如果可以，请输出平衡后体内元素总量，如果不能请输出-1。 
输入描述 输入仅包含一行，仅包含4个正整数A，B，C，D，分别表示四种元素的数量。(1<=A,B,C,D<=10^17) 
输出描述 输出仅包含一个整数,如题所示。 样例输入 1 2 2 4 样例输出 8
public int demo(int A,int B,int C,int D){
    int sum = A+B+C+D-1;
    int ave = sum/4;
    int remove = 2;
    int add = 1;
    help(A,ave,remove,add);
    help(B,ave,remove,add);
    help(C,ave,remove,add);
    help(D,ave,remove,add);
    if(remove==0&&add==0) return sum;
    else return -1;
}
public void help(int A,int ave,int remove,int add){
    if(A==ave) return;
    else if(A<ave){
        help(A+1,ave,remove,add-1);
    }else{
        help(A-1,ave,remove-1,add);
    }
}
3、排序
有一种排序算法定义如下，该排序算法每次只能把一个元素提到序列的开头，例如2，1，3，4，只需要一次操作把1提到序列起始位置就可以使得原序列从小到大有序。
现在给你个乱序的1-n的排列，请你计算最少需要多少次操作才可以使得原序列从小到大有序。
输入描述
输入有n个正整数，表示序列中的n个元素，中间用空格隔开。(1<=a_i<=n)
输出描述
输出仅包含一个整数，表示最少的操作次数。
public int demo(int[] num,int n){
    for()
}
```

## 20200827
### [8.27中兴笔试]()
```markdown
public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            int m = sc.nextInt();
            int n = sc.nextInt();
            Long[][] nums = new Long[m][n];
            for(int i = 0; i < m; i++){
                for(int j = 0; j < n; j++){
                    nums[i][j] = sc.nextLong();
                }
            }
            Long max = -Long.MAX_VALUE;
            for(int i = 1;i<m-1;i++){
                for(int j = 1;j<n-1;j++){
                    Long sum = getSum(nums, i, j);
                    max = Math.max(max,sum);
                }
            }
            System.out.println(max);
    }
            public static Long getSum(int[][] nums,int i,int j){
                Long sum = nums[i][j] + nums[i-1][j] + nums[i+1][j] + nums[i][j-1] + nums[i][j+1];
                return sum;
            }
```
### [8.z7京东笔试](https://www.nowcoder.com/discuss/490790)
[8-27京东笔试Java开发题解](https://www.nowcoder.com/discuss/490872)
```java
//1.求第n个数，规律是只含2,3,5，比如2,3,5,22,23,25,32,33,35，求第n个 leetCode264
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] dp = new int[n+1];
        int p2 = 0,p3 = 0,p5 = 0;
        for(int i = 1;i<=n;i++){
            int min = Math.min(dp[p2]*10+2,Math.min(dp[p3]*10+3,dp[p5]*10+5));
            if(min==dp[p2]*10+3) p2++;
            if(min==dp[p3]*10+3) p3++;
            if(min==dp[p5]*10+3) p5++;
            dp[i] = min;
        }
        System.out.println(dp[n]);
    }
}
//2.小球只能从左下，下，右下往下走，每个位置都有一个值，求从上到下的最大值
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[][] dp = new int[n][2*n+10];
        for(inti = 0;i<n;i++){
            for(int j = 0;j<2*i+1;j++){
                dp[i][j]  = sc.nextInt();
            }
        }
        for(int i = n-2;i>=0;i--){
            for(int j = 0;j<2*i+1;j++){
                dp[i][j] = Math.max(dp[i+1][j],Math.max(dp[i+1][j+1],dp[i+1][j+2]));
            }
        }
        System.out.println(dp[0][0]);
    }
}
```

## 20200828
### [8-28用友网络笔试](https://www.nowcoder.com/discuss/491814)
```markdown
//1.给定一个String数组。返回其升序排列后的结果;
public String[] main(String[] arr){
    //Arrays.sort(arr);
    return arr;
}
//2.给定两个数组，返回两个数组和合并后并升序排列的结果；
Arrays.sort(num);
//3.给定二维数组，每个格子有一个权值。输出从左上到右下的最小和。每次只能往右边走或者下面走；
    当处于左上角的时候continue;
    位于第一行的时候 只能由右侧转移得到 dp[i][j] += dp[i][j - 1];
    位于第一列的时候 只能由上方转移得到 dp[i][j] += dp[i - 1][j ];
    其他情况 dp[i][j] += Math.min(dp[i - 1][j], dp[i][j - 1]);
public int minStep(int[][] grid){
    if(grid.length==0||gird[0].length==0) return 0;
    int[][] dp = new int[grid.length][grid[0].length];
    dp[0][0] = grid[0][0];
    for(int i = 1;i<grid.length;i++){
        dp[i][0] = dp[i-1][0] +grid[i][0]; 
    }
    for(int i = 1;i<grid[0].length;i++){
        dp[0][i] = dp[0][i-1] + grid[0][i];
    }
    for(int i = 1;i<grid.length;i++){
        for(int j =1;j<grid.length;j++){
            dp[i][j] = gird[i][j] + Math.min(dp[i-1][j],dp[i][j-1]);
        }
    }
    return dp[grid.length-1][grid[0].length-1];
}
```
### [依图科技 8.28 笔试]()
```markdown  
//  1.给个机器人，一张方格图，四种操作，两个转向，一个前进给定步数，一个输出当前坐标。AC
//  2.给个1-9的字符串，问最多修改一个的情况下，最长的单字符子串为多少。AC
public int main(String str){
    int[] dp = new int[str.length];
    char[] chars = str.toCharArray();
    List<Character> list = new ArrayList<>();
    Set<Character> set = new HashSet<>();
    int index = 0;
    int maxLen = 0;
    while(set.size()<=2&&index<chars.length){
        list.add(chars[i]);
        set.add(chars[i]);
        maxLen = Math.max(maxLen,list.size());
    }
    return maxLen;
}
//  3.翻译无间隔的摩尔斯密码。AC
//  4.给定数组，问满足x^2 < z^2 < y^2的(x, y, z)有多少组，想不出来了... 60%
```
### [海康8.28笔试Java岗](https://www.nowcoder.com/discuss/491964)
```markdown
18道单选 4道多选 大题3道
大题分别是 SQL1题、字符串旋转（题目说是旋转，但从样例来看实际是拼接）、写一个简单工厂模式
2.输出1000-2000中素数的个数和具体值
```
### [alibaba8.28](https://www.nowcoder.com/discuss/491954)
```markdown
//1.对于01串，每次只能交换任意两个元素，把0变成1，或者把1变成0，或者反转整个串
从A串到B串需要多少步
public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        scanner.nextLine();
        String s1 = scanner.nextLine();
        String s2 = scanner.nextLine();
        StringBuilder sb = new StringBuilder(s1);
        String s3 = sb.reverse().toString();
        int res = Math.min(helper(s1,s2),1+helper(s3,s2)); //后面的注意加1表示翻转
        System.out.println(res);
    }    
public static int helper(String s1,String s2){
           int diff1=0;
           int diff2=0;
           for(int i=0;i<s1.length();i++){
               if(s1.charAt(i)!=s2.charAt(i)) {
                   if(s1.charAt(i)=='1')
                       diff1++;
                   else
                       diff2++;
               }
           }
          // System.out.println(diff1+"---"+diff2);
           int max = Math.max(diff1,diff2);
           return max;
    }
//2.输入n,m，可以对n里面的数位重新排列，问重新排列后的数满足不含前导0并且能够整除m的数有多少个。
    private static long[][] dp;
        private static char[] s;
        private static int m;
        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            s = ("" + sc.nextLong()).toCharArray();
            m = sc.nextInt();
            sc.close();
            dp = new long[(int) Math.pow(2, s.length)][m];
            for (long[] a : dp)
                for (int i = 0; i < a.length; i++)
                    a[i] = -1;
            System.out.println(getDP(0, 0));
        }
        private static long getDP(int mask, int mod) {
            if (dp[mask][mod] >= 0)
                return dp[mask][mod];
            if (mask == dp.length - 1) {
                dp[mask][mod] = mod == 0 ? 1 : 0;
                return dp[mask][mod];
            }
            dp[mask][mod] = 0;
            boolean[] used = new boolean[10];
            for (int i = 0; i < s.length; i++)
                if (!used[s[i] - '0'] && (mask | 1 << i) != mask && (mask > 0 || s[i] != '0')) {
                    dp[mask][mod] += getDP(mask | 1 << i, (10 * mod + (s[i] - '0')) % m);
                    used[s[i] - '0'] = true;
                }
            return dp[mask][mod];
        }
}
```

## 20200829
### [顺丰0829笔试](https://www.nowcoder.com/discuss/492702)
```markdown
第一题：长为n的序列，值-1表示不确定的元素，你的任务是将不确定的元素赋予一个正确的值，
使得将整个序列分割成最少的段，每段都是等差数列。输出最少的段数。
eg:[-1, -1, -1]，最少的段数是1，填上数之后为（1，1，1）
eg:[-1，-1，-1，4，5，1，2]最少段数是2，填上数之后为（1，2，3，4，5，1，2）
public int main(int n,int[] num){
    HashMap<Integer,Integeer> map = new HashMap<>();
    for(int i = 0;i<n;i++){
        if(num[i]!=-1){
            map.put(i,num[i]);
        }
    }
    //Set<Map.Entry<Integer,Integer>> set = map.entrySet<>();
    //for(Iterator<Map.Entry<Integer,Integer>> it = set.iterator();it.hasNext();){
    //    it.getKey();it.getValue();
    //}
    //
    int[] index = new int[n];
    int[] value = new int[n];
    int idx = 0;
    for(int i = 0;i<n;i++){
        if(num[i]!=-1){
            index[idx] = i;
            value[idx] = num[i];
            idx++;
        }
    }
    if(idx<3) return 1;
    int res = 1;
    int ix = 2;
    while(ix<idx){
        if((value[i]-value[i-1])/(index[i]-index[i-1]) != (value[i-1]-value[i-2])/(index[i-1]-index[i-2]))
            res++;
            ix = ix+2;
    }
    return res;
}
第二题：给定m个货物的价值[0, 0，1，1，0，0]，k个卡车，每个卡车只能装入连续的货物，要保证卡车装的货物数量最少，
卡车运输费用为所装货物价值和的平方，问最大运输费用是多少，此时卡车所装最少的货物数量是多少？
eg:货物价值数组 [ 0, 0，1，1，0，0], k=3,那么最大运输费用是2，最少货物数量是2，
方案是卡车1装货物（1，2），卡车2装货物（3，4），卡车3装货物（5，6）
```
### [2020.08.29美团点评秋招笔试](https://www.nowcoder.com/discuss/492804)
```markdown
1.
  添加一个头部字符串和一个尾部字符串。头部字符串满足至少包含一个“MT”子序列，
  且以T结尾。尾部字符串需要满足至少包含一个“MT”子序列，且以M开头。求 S是满
  足头尾字符串合法的情况下的最长的字符串。
   Scanner sc = new Scanner(System.in);
   int n = sc.nextInt();
    for(int i = 0;i<n;i++){
        String str = sc.nextLine();
        int len = str.length();
        int l = 0;
        int mcnt = 0;
        for(int i = 0;i<len;i++){
            if(str.charAt(i)=='M'){
                mcnt++;
            }else if(str.charAt(i)=='T'&&mcnt>0){
                l = i;
                break;
            }
        }
        int r = len - 1;
        int tcnt = 0;
        for(int i = len-1;i>=0;i--){
            if(s.charAt(i)=='T') tcnt++;
            else if(s.charAt(i)=='M'&&tcnt>0){
                r = i;
                break;
            }
        }
        System.out.println(str.substring(l+1,r-l-1));
    }
2.
  本着能者优先的原则，公司将这n个人按照业务能力从高到底编号为1~n。 编号靠前的人
  具有优先选择的权力，每一个人都会填写一个意向，这个意向是一个1~n的排列， 表示
  一个人希望的去的业务区域顺序，如果有两个人同时 希望去某一个业务区域则优先满足编号小的人
    Scanner sc = new Scanner(System.in);
    int[][] a = new int[305][305];
    int n = sc.nextInt();
    for(int i = 0;i<n;i++){
        for(int i = 1;i<=n;i++){
            for(int j = 1;j<=n;j++){
                a[i][j] = sc.nextInt();
            }
        }
        int[] ans = new int[n+1];
        boolean[] visited = new boolean[n+1];
        for(int i = 1;i<=n;i++){
            for(int j = 1;j<=n;j++){
                if(visited[a[i][]j]) continue;
                ans[i] = a[i][j];
                visited[a[i][j]] = true;
                break;
            }
        }
        for(int i = 1;i<=n;i++){
            if(i<n) System.out.print(ans[i]+" ");
            else System.out.print(ans[i]);
        }
    }
3.
    小美要去找小团“讲道理”。小团望风而逃，他们住的地方可以抽象成一棵有n个结点的树， 小美位于x位置，
小团位于y位置。小团和小美每个单位时间内都可以选择不动或者向相邻的位置转移， 假设小美足够聪明，
很显然最终小团会无路可逃，只能延缓一下被“讲道理”的时间，请问最多经过多少个单位时间后， 小团会被追上。
思路：AC 分别以 x y 为起点搜索到所有其他点的路径长度，然后取dx > dy得最大的dx就是答案

4.
  小团和小美各自选择一个[1,m]之间的整数，设小美选择的是l，小团选择的是r，
  我们认为两个人是默契的需要满足以下条件:
  1. l 小于等于r。
  2. 对于序列中的元素x，如果0<x<l,或r<x<m+1,则x按其顺序保留下来，要求保留下来的子序列单调不下降。
  小团为了表现出与小美最大的默契，因此事先做了功课，他想知道能够使得两人默契的二元组<l,r>一共有
  多少种。 我们称一个序列A为单调不下降的，当且仅当对于任意的i>j,满足A_i>=A_j。 输入第一行包含
  两个正整数m和n，表示序列元素的最大值和序列的长度。(1<=n,m<=100000)
  思路：AC 18%(我用的求逆序的算法，然后总数-逆序数), 题目真的没有读懂，好吧，不是不懂，
  是完全没有一点思路（卡了30min 无果）希望路过的大佬们可以提供点思路。非常感谢！
```
### [科大讯飞（8.29）](https://www.nowcoder.com/discuss/492955)
```markdown
1.给定m*n的矩阵，
  小明从【1,1】开始走，只能向右或者向下走，最终到达右下角，问经过的点的和最大是多少
  输入：3 3
     1 2 3
     4 5 6
     7 8 9
     输出：
     29
     解释：1 4 7 8 9
public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String s = sc.nextLine();
        String[] str = s.split(",");
        int m = Integer.parseInt(str[0]);
        int n = Integer.parseInt(str[1]);
        int[][] arr = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                arr[i][j] = sc.nextInt();
            }
        }
        int res = max(arr);
        System.out.println(res);
    }
    public static int max(int[][] arr) {
        for (int i = 1; i < arr.length; i++) {
            arr[i][0] = arr[i][0] + arr[i - 1][0];
        }
        for (int j = 1; j < arr[0].length; j++) {
            arr[0][j] = arr[0][j] + arr[0][j - 1];
        }
        for (int i = 1; i < arr.length; i++) {
            for (int j = 1; j < arr[0].length; j++) {
                arr[i][j] = arr[i][j] + Math.max(arr[i - 1][j], arr[i][j - 1]);
            }
        }
        return arr[arr.length - 1][arr[0].length - 1];
    }
2.系统使用自带的一个排序算法对序列（25，84，21，47，15，27，68，35，20）进行排序
  过程中进行采样，采样数据如下
  （15，84，21，47，25，27，68，35，20）
  （15，20，21，25，27，35，68，47，84）
  （15，20，21，25，27，35，47，68，84）
  请你实现这个算法
  输入：
  9
  25，84，21，47，15，27，68，35，20
  输出：
  15，20，21，25，27，35，47，68，84
public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        if (n <= 0) {
            return;
        }
        sc.nextLine();
        int[] arr = new int[n];
        String s = sc.nextLine();
        String[] str = s.split(",");
        for (int i = 0; i < str.length; i++) {
            arr[i] = Integer.parseInt(str[i]);
        }
        selectSort(arr);
        for (int j = 0; j < arr.length; j++) {
            if (j == arr.length - 1) {
                System.out.print(arr[j]);
            }else {
                System.out.print(arr[j] + ",");
            }
        }
    }
    public static void selectSort(int[] arr) {
        for (int i = 0; i < arr.length - 1; i++) {
            int min = i;
            for (int j = i + 1; j < arr.length; j++) {
                if (arr[j] < arr[min]) {
                    min = j;
                }
            }
            if (min != i) {
                int temp =arr[min];
                arr[min] = arr[i];
                arr[i] = temp;
            }
        }
    }
3.给定字符串，消除没用的下划线：相邻的，前后的
  不能开辟新数组
  输入：
  ___aaa______bsd___sadf___
  输出：
  aaa_bsd_sadf
//思路：先用java的正则表达式将下划线超过2的替换成一个下划线；  
再判断过滤后的字符串前后是否还有一个下划线，有则进一步过滤
public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String s = sc.nextLine();
        String str = s.replaceAll("[_]{2,}", "_");
        if (str.charAt(0) == '_') {
            str = str.substring(1, str.length());
        }
        if (str.charAt(str.length() - 1) == '_') {
            str = str.substring(0, str.length() - 1);
        }
        System.out.println(str);
    }
4.给定一个数n，输出其所有的素数乘积
  使用递归的方法
  输入：
  100
  输出：
  2*2*5*5
  输入：
  12
  输出：
  2*2*3
/**
 * 分解质因数
 * 思路：
 *  1. 首先设置一个变量k，k的值等于最小素数2，注意变量k应该声明为类成员变量，不能声明在方法中，否则多次递归调用方***导致栈内存溢出
 *  2. 如果质数恰好等于n，代表分解已结束
 *  3. 若n>k，但n能被k整除，先打印k值，并用n除以k的商作为新的n，然后递归执行
 *  4. 若n不能被k整除，则用k+1作为k的值，然后递归执行
 */
public class Main {
    private static int k = 2;
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        f(n);
    }
    public static void f(int n) {
        while (k <= n) {
            if (k == n) {
                System.out.print(n);
                break;
            } else if (n > k && n % k == 0) {
                System.out.print(k + "*");
                n = n / k;
                f(n);
                break;
            } else if(n > k && n % k != 0) {
                k = k + 1;
                f(n);
                break;
            }
        }
    }
}
```

## 20200830
### [疯狂游戏8月30日笔试](https://www.nowcoder.com/discuss/493136)
```markdown
1.岛屿数量 LeetCode200
public int numIslands(char[][] grid) {
        if (grid == null || grid.length == 0) {
            return 0;
        }
        int nr = grid.length;
        int nc = grid[0].length;
        int num_islands = 0;
        for (int r = 0; r < nr; r++) {
            for (int c = 0; c < nc; c++) {
                if(grid[r][c]=='1'){
                    ++num_islands;
                    dfs(grid, r, c);
                }
            }
        }
        return num_islands;
    }
    void dfs(char[][] grid, int r, int c) {
        int nr = grid.length;
        int nc = grid[0].length;
        if (r < 0 || c < 0 || r >= nr || c >= nc || grid[r][c] == '0') {
            return;
        }
        grid[r][c] = '0';
        dfs(grid, r - 1, c);
        dfs(grid, r + 1, c);
        dfs(grid, r, c - 1);
        dfs(grid, r, c + 1);
    }
//2.LeetCode312. 戳气球
public int maxCoins(int[] nums) {
        int[] a = new int[nums.length+2];
        a[0] = 1;
        a[a.length-1] = 1;
        for(int i = 0;i<nums.length;i++){
            a[i+1] = nums[i];
        }
        return helper(a,0,a.length-1);
    }
    public int helper(int[] a,int i,int j){
        int max = 0;
        for(int k = i+1;k<j;k++){
            max = Math.max(max,helper(a,i,k)+a[i]*a[k]*a[j]+helper(a,k,j));
        }
        return max;
    }
```
### [8.30浪潮提前批Java笔试](https://blog.csdn.net/weixin_42226092/article/details/107409816)
```markdown
/*
沙滩按照线型摆放着n个大小不一的球形石头，已知第i个石头的半径为ri，且不存在两个石头有相同的半径。为了使石头的摆放更加美观，现要求摆放的石头的半径从左往右依次递增。因此，需要对一些石头进行移动，每次操作可以选择一个石头，并把它放在剩下n−1个石头在最左边或最右边。问最少需要操作多少次才能将这n个石头的半径变成升序？
输入
第一行一个整数n，表示石头的个数。(1 <= n <= 100000)
第二行n个整数，表示从左往右石头的半径r1，r2，…，rn。(1 <= ri <= n)，且保证不存在两个不同的石头拥有相同的半径。
输出
最少操作次数样例输入
5
4 1 2 5 3
样例输出
2
*/
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        while(sc.hasNextInt()){
            int m = sc.nextInt();
            int []arr = new int[m];
            for(int i = 0; i < m; i ++){
                arr[i] = sc.nextInt();
            }
            int[] dp = new int[m + 1];
            int res = 0;
            for(int num : arr) {
                dp[num] = dp[num - 1] + 1;
                res = Math.max(dp[num], res);
            }
            System.out.println(m - res);
        }
    }
}
/*
某条街道两侧分别种植了一排树木，并按如下编号：
1 3 5 7 … 45 47 49 … 99
2 4 6 8 … 46 48 50 … 100
但是有一些树被砍去，希望你能找出一边最长的连续的大树。
输入
第一行一个整数N
第二行N个整数表示被砍去树的编号
输出
M 和 X（表示从第M棵大树开始，共有连续的X棵大树，如果有多个解，输出M最小的解即可）
样例输入
5
9 15 27 35 6
样例输出
8 47
*/
import java.util.Arrays;
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        while(sc.hasNextInt()) {
            int m = sc.nextInt();
            int[] arr = new int[m + 2];
            for (int i = 0; i < m; i++) {
                arr[i] = sc.nextInt();
            }
            arr[m] = 101;
            arr[m + 1] = 102;
            Arrays.sort(arr);
            int[] res = new int[2];
            int preOdd = -1;
            int preEven = 0;
            for (int num : arr) {
                if (num % 2 == 1) {
                    int tmp = (num - preOdd) / 2 - 1;
                    if (tmp > res[1]) {
                        res[1] = tmp;
                        res[0] = preOdd + 2;
                    }
                    preOdd = num;
                } else {
                    int tmp = (num - preEven) / 2 - 1;
                    if (tmp > res[1]) {
                        res[1] = tmp;
                        res[0] = preEven + 2;
                    }
                    preEven = num;
                }
            }
            System.out.println(res[0] + " " + res[1]);
        }
    }
}
```

## 20200831
### [小红书8.30后端笔经](https://www.nowcoder.com/discuss/493533)
```markdown
1.消息分段
  static String[] splitMsg(String text) {
        int n = text.length();
        if (n <= 1024)
            return new String[]{text};
        char[] arr = text.toCharArray();
        ArrayList<String> list = new ArrayList<>(n/1024+1);
        int last = -1;
        for (int i=1023; i<n; ) {
            boolean flag = true;
            int next = -1;
            for (int j=i; j>last; j--) {
                if (arr[j] == '\n') {
                    list.add(text.substring(last+1, j+1));
                    flag = false;
                    last = j;
                    break;
                } else if (arr[j] == '.')
                    next = j;
            }
            if (flag) {
                list.add(text.substring(last+1, next+1));
                last = next;
            }
            i = last+1024;
        }
        if (last < n-1) {
            list.add(text.substring(last+1));
        }
        String[] res = new String[list.size()];
        return  list.toArray(res);
    }
2.嵌套盒子 LeetCode354
// envelopes = [[w, h], [w, h]...]
public int maxEnvelopes(int[][] envelopes) {
    int n = envelopes.length;
    // 按宽度升序排列，如果宽度一样，则按高度降序排列
    Arrays.sort(envelopes, new Comparator<int[]>() 
    {
        public int compare(int[] a, int[] b) {
            return a[0] == b[0] ? 
                b[1] - a[1] : a[0] - b[0];
        }
    });
    // 对高度数组寻找 LIS
    int[] height = new int[n];
    for (int i = 0; i < n; i++)
        height[i] = envelopes[i][1];
    return lengthOfLIS(height);
}
/* 返回 nums 中 LIS 的长度 */
public int lengthOfLIS(int[] nums) {
    int piles = 0, n = nums.length;
    int[] top = new int[n];
    for (int i = 0; i < n; i++) {
        // 要处理的扑克牌
        int poker = nums[i];
        int left = 0, right = piles;
        // 二分查找插入位置
        while (left < right) {
            int mid = (left + right) / 2;
            if (top[mid] >= poker)
                right = mid;
            else
                left = mid + 1;
        }
        if (left == piles) piles++;
        // 把这张牌放到牌堆顶
        top[left] = poker;
    }
    // 牌堆数就是 LIS 长度
    return piles;
}
3.矩阵谜题 
[子矩阵（NOIP2014T4）](https://www.cnblogs.com/GDOI2018/p/9732757.html)
```
### [2019年58同城笔试题](https://blog.csdn.net/chenkaibsw/article/details/79979106)
```markdown
题目1.输入一个字符串，输入整数n，找出长度为n的相同字符构成的子串。
例如：输入：
字符串“abbbccccddeeffffaaaddzzz”，整数3
输出：
(1,3,bbb)
(16,18,aaa)
(21,23,zzz)
基本思路：该题使用两个指针，i指向下标为0处，j指向下标为1处，如果i 指向的字符与j指向的字符相同，那么将将j向后挪动一位，并将计数器加一，重复该操作直到i 和j 指向的字符不同为止，此时如果count值为输入的长度n，那么就打印出从下标i到下标 j-1的字符。然后将i的值赋给j,j=i+1,重复上面的操作。
代码实现：
public class Main{
	public static void main(String[] args){
		int n = 3;
		String str = "abbbccccddeeffffaaaddzzz";
		int i = 0;
		int j = 1;
		int count;
		char[] ch = str.toCharArray();
		int N = ch.length - 1;
		while(j<=N&&i<=N)
		{
			count = 1;
			while(j<=N&&ch[i]==ch[j])
			{
				count++;
				j++;
			}
			if(count==n)
			{
				System.out.print("("+i+","+(j-1)+",");
				for(int k=0;k<count;k++)
				{
					System.out.print(ch[i]);
				}
				System.out.print(")");
				System.out.println();
			}
			if(count>n)
			{
				i = j;
				j = i + 1;
			}
			else
			{
				i = i+ 1;
				j = i + 1;
			}
		}
	}
}
题目2:计算数组最大的连续子序列的和
如：{14,-2,4,-3,5,7,2,-39,22},和最大子序列是{14,-2,4,-3,5,7,2}，返回27
思路一：暴力求解(时间复杂度n^2)：
列举出所有的自序列的组合，将他们相加：
[14]，[14,-2]，[14,-2,4]，[14,-2,4,3]..........
[-2]，[-2,4]，[-2,4,-3]..........
........
[22]
代码实现：
public class Main{
	public static void main(String[] args){
		int[] a = {14,-2,4,-3,5,7,2,-39,22};
		int N = a.length;
		int Max = Integer.MIN_VALUE;		//取最小整数
		int result;
		for(int i=0;i<N;i++){
			result = 0;
			for(int j=i;j<N;j++){
				result += a[j];
				Max = Math.max(Max, result);
			}
		}
		System.out.println("最大值为:"+Max);
	}
}
思路二：动态规划
思路：求n个数的数组的最大字段和，转为分别求以第1个、第2个........第n个数字结尾的最大字段和，再找出n个结果中最大的。
代码实现：
//数组的所有连续子段的最大和
public class Main{
	public static void main(String[] args){
		int[] a = {14,-2,4,-3,5,7,2,-39,22};
		maxSum(a,a.length);		
	}
	public static void maxSum(int[] a,int n){
		int[] dp = new int[a.length];
		dp[0] = a[0];
		for(int i=1;i<n;i++)
		{
			dp[i] = Math.max(dp[i-1]+a[i], a[i]); 
		}
		//System.out.println(Arrays.toString(dp));
		//取出dp数组中的最大值
		int max = Integer.MIN_VALUE;
		for(int i=0;i<dp.length;i++)
		{
			if(dp[i]>max)
				max = dp[i];
		}
		System.out.println(max);
	}
}

```
### [2018秋招58同城笔试题](https://www.nowcoder.com/discuss/69136)
```markdown
1、给定一个数组metrix，数组中只包含1和0，且数组中的1都不相邻，输入一个数n，问能否在将数组中n个0替代换成1后不破坏1都不相邻的条件。
例1 metrix=[1,0,0,0,1],n=1输出true
例2 metrix=[1,0,0,0,1],n=2输出false
编程1
public static boolean isCan(int[] a, int n) {
        int len = a.length;
        int c = a[0] == 0 ? 1 : 0;
        int count = 0;
        for (int i = 1; i < a.length; i++) {
            if (a[i] == 1) {
                if (c > 2) {
                    count += (c - 1) / 2;
                    c = 0;
                }
            } else {
                c++;
            }
            if (count >= n) {
                return true;
            }
        }
        return false;
    }
2、石家庄学生A在北京上大学，今年准备骑行去学校，A每天骑行公里数有三种可能：10公里，20公里，30公里，
一只石家庄距离北京300公里，请编程说明A骑行到学校有多少种组合。
 public static int perfectBag(int n, int a[]) {
        int[] f = new int[n + 1];
        f[0] = 1;
        for (int i = 0; i < a.length; i++) {
            for (int j = a[i]; j <= n; j++) {
                f[j] += f[j - a[i]];
            }
        }
        return f[n];
    }
```
### [58同城笔试](leetcode64,leetcode135)
```markdown
LeetCode64
public int minPathSum(int[][] grid) {
        // if(grid==null||grid.length==0) return 0;
        // int[][] dp = new int[grid.length][grid[0].length];
        // dp[0][0] = grid[0][0];
        // for(int i = 1;i<grid.length;i++){
        //     dp[i][0] = grid[i][0] + dp[i-1][0];
        // }
        // for(int j = 1;j<grid[0].length;j++){
        //     dp[0][j] = grid[0][j] + dp[0][j-1];
        // }
        // for(int i = 1;i<grid.length;i++){
        //     for(int j = 1;j<grid[0].length;j++){
        //         dp[i][j] = grid[i][j] + Math.min(dp[i-1][j],dp[i][j-1]);
        //     }
        // }
        // return dp[grid.length-1][grid[0].length-1];
        int len = grid[0].length;
        int[] dp = new int[len];
        dp[0] = grid[0][0];
        for(int i = 1;i<len;i++){
            dp[i] = dp[i-1] + grid[0][i];
        }
        for(int i = 1;i<grid.length;i++){
            dp[0] = dp[0] + grid[i][0];
            for(int j = 1;j<len;j++){
                dp[j] = Math.min(dp[j-1]+grid[i][j],dp[j]+grid[i][j]);
            }
        }
        return dp[len-1];
    }
LeetCode135
public int candy(int[] ratings) {
        if(ratings==null||ratings.length==0) return 0;
        int[] nums = new int[ratings.length];
        nums[0] = 1;
        for(int i = 1;i<ratings.length;i++){
            if(ratings[i]>ratings[i-1]){
                nums[i] = nums[i-1]+1;
            }else{
                nums[i] = 1;
            }
        }
        for(int i = ratings.length-2;i>=0;i--){
            if(ratings[i]>ratings[i+1]&&nums[i]<=nums[i+1]){
                nums[i] = nums[i+1]+1;
            }
        }
        int sum = 0;
        for(int i:nums){
            sum+=i;
        }
        return sum;
    }
```

## 20200901
### [58同城 8.31笔试](https://www.nowcoder.com/discuss/494560)
```markdown
1)找每个字符串数组都出现的字符串 ac
        //第一题
        public static ArrayList<String> findCommonString (ArrayList<ArrayList<String>> values) {
                // write code here
                Set<String> set = new LinkedHashSet<>();
                if(values.size()>1){
                    for(int i=0;i<values.get(0).size();i++){
                        set.add(values.get(0).get(i));
                    }
                }else{
                    return new ArrayList<String>();
                }
                for(int i=1;i<values.size();i++){
                    Set<String> temp = new LinkedHashSet<>();
                    for(int j=0;j<values.get(i).size();j++){
                        String t = values.get(i).get(j);
                        if(set.contains(t)){
                            temp.add(t);
                        }
                    }
                    set = temp;
                }
                return new ArrayList<>(set);
        }
    2)500内找加上a或b都为完全平方数的数 ac
    3)0代表a,z代表25,一个数字可以有多少种字母表达方式 ac leetCode91.解码方法
public int numDecodings(String s) {
        if(s==null||s.length()==0) return 0;
        int n = s.length();
        int[] dp = new int[n+1];
        dp[0] = 1;
        dp[1] = s.charAt(0)=='0'?0:1;
        for(int i = 2;i<=n;i++){
            int one = Integer.valueOf(s.substring(i-1,i));
            if(one!=0) dp[i] = dp[i] + dp[i-1];
            if(s.charAt(i-2)=='0') continue;
            int two = Integer.valueOf(s.substring(i-2,i));
            if(two<=26) dp[i] = dp[i] + dp[i-2];
        }
        return dp[n];
    }
```
### [中信证券8.31笔试](https://www.nowcoder.com/discuss/494541)
题型是11道选择，5道不定向，4题填空，2题编程，5题问答
```markdown
第一题 二叉树最近祖先
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root == null || root == p || root == q) {
        return root;
    }
    TreeNode left = lowestCommonAncestor(root.left, p, q);
    TreeNode right = lowestCommonAncestor(root.right, p, q);
    if (left != null && right != null) {
        return root;
    }
    if (left != null) {
        return left;
    }
    return right;
}
第二题 统计字符数量
public class Main {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        String str = input.nextLine();
        int count = 1;
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < str.length(); i++) {
            while (i < str.length() - 1 && str.charAt(i + 1) == str.charAt(i)) {
                count++;
                i++;
            }
            sb.append(str.charAt(i)).append(count);
            count = 1;
        }
        System.out.println(sb.toString());
    }
}
```
### [8.31欢聚时代笔试题目](https://www.nowcoder.com/discuss/494460)
```markdown
1.将字符串转换为整数输出 剑指 Offer 67. 把字符串转换成整数 leetcode8
2.返回反转后的链表
public ListNode reverseList(ListNode root){
    ListNode pre = null;
    ListNode curr = head;
    while(curr!=null){
        ListNode temp = curr.next;
        curr.next = pre;
        pre = curr;
        curr = temp;
    }
    return pre;
}
3.水仙花数是指：一个三位数，其各位数字的立方和等于该数本身
public int demo(int n,int m){
    int count = 0;
    for(int i = n;i<=m;i++){
        int ge = i%10;
        int shi = i/10 % 10;
        int bai = i/100 % 10;
        if(i==ge*ge*ge+shi*shi*shi+bai*bai*bai){
            System.out.println(i+"是水仙花数");
            count++;
        }
    }
    return count;
}
```