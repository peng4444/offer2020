# 笔试真题训练

## 20200819
### [2020搜狗笔试1](https://www.nowcoder.com/test/question/done?tid=36176943&qid=1009393#summary)
#### 1.
```markdown
import java.util.*;
/**
 * LRU 算法 LinkHashMap 或者 hashMap + Queue
 */
public class Main {
     public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        sc.nextLine();
        //记录数据
        LinkedHashMap<String , Long> LRUhashMap = new LinkedHashMap<>();
        while (sc.hasNext()){
            //输入k - v
            String[] insert = sc.nextLine().split(" ");
            String key = insert[0];
            String value = insert[1];
            if(LRUhashMap.containsKey(key)){
                if(LRUhashMap.get(key)-Long.valueOf(value) < 0){
                    LRUhashMap.remove(key);
                    LRUhashMap.put(key,Long.valueOf(value));
                }
            }else{
                if(LRUhashMap.size() < N){ //空间剩余
                    LRUhashMap.put(key,Long.valueOf(value));
                }else if(LRUhashMap.size() == N){ //空间不足
                    for(String s : LRUhashMap.keySet()){
                        System.out.println(s + " " + LRUhashMap.get(s));
                        LRUhashMap.remove(s);
                        LRUhashMap.put(key,Long.valueOf(value));
                        break;
                    }
                }
            }
        }
    }
}
```
#### 3
```markdown
import java.util.*;
 
/**
 *    1. 使用hashmap构建树形结构
 *    2. 递归分治法：假设已知 各个子节点的分发时间：
 *        则： 2.1 对子节点的分发时间进行降序排列
 *            2.2 当前节点优先对 子节点分发时间 较长的节点进行分发, 
 *                如:子节点分发时间 4 2 1 1 1 0, k=2, 则: 先后分发顺序(42)(11)(10),也就是
 *                     (42)+1 (11)+2 (10)+3 => 5 3 3 3 4 3 => 分三轮分发, 最终所需时间为 5 h。
 *             2.3 当节点为叶子结点, 分发时间为0
 *             2.4 最后使用分治法进行递归分发,相当于从叶子节点向上推。
 */
class Node{
    int id = 0;
    List<Node> sons = new ArrayList<>();
    Node parent = null;
}
 
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        HashMap<Integer , Node> hashMap = new HashMap<>();
        int K = sc.nextInt();
        int N = sc.nextInt();
        if(K == 0 || N == 0){
            System.out.println(0);
        }
        sc.nextLine();
        //树形构建
        for(int i = 0;i < N;i++){
            int node_n = sc.nextInt();
            //指定父节点
            int parent_id = sc.nextInt();
            Node my = null;
            if(hashMap.containsKey(parent_id)){
                //父节点存在
                my = hashMap.get(parent_id);
            }else{
                //父节点不存在
                my = new Node();
                my.id = parent_id;
                hashMap.put(parent_id,my);
            }
            //儿子节点
            for(int j = 0;j < node_n - 1;j++){
                int son_id = sc.nextInt();
                if(hashMap.containsKey(son_id)){
                    //儿子节点存在
                    hashMap.get(parent_id).sons.add(hashMap.get(son_id));
                }else{
                    //儿子节点不存在
                    Node son = new Node();
                    son.id = son_id;
                    son.parent = my;
                    hashMap.put(son.id,son);
                    hashMap.get(parent_id).sons.add(son);
                }
            }
            sc.nextLine();
        }
        //根节点存在
        Node root = hashMap.get(0);
        //分治法
        System.out.println(FZ(root , K));
    }
    public static int FZ(Node node , int k){
        int max = 0;
        if(node.sons.size() == 0){
            return 0;
        }else{
            Integer[] sons_time = new Integer[node.sons.size()];
            int i = 0;
            //统计分支时间
            for(Node son:node.sons){
                sons_time[i++] = FZ(son , k);
            }
            //合并分支与当前时间
            //降序排序
            Arrays.sort(sons_time, new Comparator<Integer>() {
                @Override
                public int compare(Integer o1, Integer o2) {
                    return o2 - o1;
                }
            });
            //计算当前节点为root所需要的时间
            int add = 1;
            for(int j = 0; j < sons_time.length ; j++){
                if(j!=0 && (j%k) == 0){
                    add++;
                }
                sons_time[j] += add;
                if(sons_time[j] > max){
                    max = sons_time[j];
                }
            }
        }
        return max;
    }
}
```

### [2020搜狗笔试2](https://www.nowcoder.com/test/question/done?tid=36179124&qid=1009391#summary)
#### 1
```markdown
import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int sum = 0;
        int password;
        int N = scanner.nextInt();
        int M = scanner.nextInt();
        int[] arr = new int[N];
        for (int i=0;i<M;i++){
            int L = scanner.nextInt();
            int R = scanner.nextInt();
            for(int j=L;j<R;j++){
                arr[j] = i+1;
            }
            arr[R] = i+1;
        }
        for (int i=0;i<arr.length;i++){
            sum+= i*arr[i];
        }
        password = sum % 100000009;
        System.out.println(password);
    }
}
```
#### 2.
```markdown
/**
 * 前缀 后缀 的匹配问题 easy
 */
 
import java.util.Scanner;
  
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int M = sc.nextInt();
        sc.nextLine();
        //读取规则
        String[] patterns = new String[N];
        for(int i =0 ;i < N;i++){
            patterns[i] = sc.nextLine();
        }
        //读取IP
        String[] IPs = new String[M];
        for(int i = 0;i < M; i++){
            IPs[i] = sc.nextLine();
        }
        //暴力匹配
        for(int i = 0; i < IPs.length;i++){
            boolean lock = false;
            for(int j = 0; j < patterns.length;j++){
                String t = "";
                if(patterns[j].charAt(0) == '*'){
                    t = patterns[j].replace("*","");
                    if(IPs[i].endsWith(t)){
                        System.out.print(1 + " ");
                        lock = true;
                        break;
                    }
                }else if(patterns[j].charAt(patterns[j].length()-1) == '*'){
                    t = patterns[j].replace("*","");
                    if(IPs[i].startsWith(t)){
                        System.out.print(1 + " ");
                        lock = true;
                        break;
                    }
                }else{
                    if(patterns[j].equals(IPs[i])){
                        System.out.print(1 + " ");
                        lock = true;
                        break;
                    }
                }
            }
            if(lock == false){
                System.out.print(0 + " ");
            }
        }
    }
}
```

## 20200820
### [2020 4399](https://www.nowcoder.com/profile/8791875/test/36202246/844365#summary)
#### 1.
```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        double ans1 = 100,ans2 = 100;
        for(int i = 0;i<n-1;i++){
            ans2*=0.5;
            ans1+=ans2*2;
        }
        ans2*=0.5;
        System.out.println(ans1+" "+ans2);
    }
}
```
#### 2.
```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int pNum = n;
        int index = 0;
        int countNum = 0;
        int[] arr = new int[n];
        while(pNum>1){
            if(arr[index]==0){
                countNum++;
                if(countNum==3){
                    countNum=0;
                    arr[index] = 1;
                    pNum--;
                }
            }
            index++;
            if(index==n) index = 0;
        }
        for(int i = 0;i<n;i++){
            if(arr[i]==0) System.out.println(i+1);
        }
    }
}
```
### [2020 4399](https://www.nowcoder.com/profile/8791875/test/36198670/110543#summary)
#### 1.
```java
//将20个球放进12个不同的袋子，每个袋子可以放0-20个球，有多少种放法？分析如何计算，然后编程解答。
//进阶问题：每个袋子只能放0个、2个或3个球，该如何计算？
public int ballBag(int bag, int ball) {
        int[][] dp = new int[bag + 1][ball + 1];
        int i, j, k, sum;
        for (i = 1; i <= bag; i++) {
            dp[i][0] = 1;
        }//无论几个包，放入0个球的方法只有一种
        for (j = 0; j <= ball; j++) {
            dp[1][j] = 1;
        }//无论几个球，放入1个包的方法也只有一种
        for (i = 2; i <= bag; i++) {
            for (j = 1; j <= ball; j++) {
                sum = 0;
                for (k = 0; k <= j; k++) {
                    sum += dp[i - 1][k];
                }
                dp[i][j] = sum;
            }
        }
        return dp[bag][ball];
    }
```
#### 2.
```java
import java.util.Scanner;
public class solution {
        public String findit(String str){
        Scanner scanner = new Scanner(System.in);
        String str1 = scanner.next();
        String str2 = scanner.next();
        char[] char1 = str1.toCharArray();
        char[] char2 = str2.toCharArray();
        int p1 = 0;
        int p2 = 0;
        while(p1<str1.length() && p2<str2.length()){
            while(p1<str1.length() && p2<str2.length() && char1[p1]!=char2[p2]){
                p1++;
            }
            p1++;
            p2++;
        }
        if(p2 >= char2.length){
            return new String("不可描述");
        }else{
            return str1;
        }        
    }
}
```

## 20200821
### [商汤科技2020-8-20开发笔试A卷](https://www.nowcoder.com/discuss/483879)
```markdown
//一：给定一个字符串，找“Good”，字符顺序不可变，每个字符只能用一次
class Solution {
    public int method(char[] chars) {
        if (chars.length < 4)
            return 0;
        int res = 0;
        int numOfG = 0, numOfO = 0;
        for (int i = 0; i < chars.length; i++) {
            if (chars[i] == 'G')
                numOfG++;
            if (chars[i] == 'o') {
                if (numOfG > 0)
                    numOfO++;
            }
            if (chars[i] == 'd') {
                if (numOfG > 0 && numOfO >= 2) {
                    res++;
                    numOfG--;
                    numOfO = numOfO - 2;
                }
            }
        }
        return res;
    }
}
//二、最常上升子序列，leetcode原题
class SolutionMainTwo {
    public int[][] cur = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    public int r, c;
    public int method(int[][] array, int n, int m) {
        if (n == 0 || m == 0 || array == null)
            return 0;
        r = n;
        c = m;
        int[][] curArray = new int[r][c];
        int ans = 0;
        for (int i = 0; i < r; ++i) {
            for (int j = 0; j < c; ++j) {
                ans = Math.max(ans, methodDFS(array, i, j, curArray));
            }
        }
        return ans;
    }
    private int methodDFS(int[][] matrix, int row, int column, int[][] curArray) {
        if (curArray[row][column] != 0)
            return curArray[row][column];
        ++curArray[row][column];
        for (int[] ints : cur) {
            int newRow = row + ints[0];
            int newColumn = column + ints[1];
            if (newRow >= 0 && newRow < r && newColumn >= 0 && newColumn < c && matrix[newRow][newColumn] > matrix[row][column]) {
                curArray[row][column] = Math.max(curArray[row][column], methodDFS(matrix, newRow, newColumn, curArray) + 1);
            }
        }
        return curArray[row][column];
    }
}
//三、大意是求删除区间的个数，可以使得删除后剩下的区间彼此不重叠（好像是这个意思）
class SolutionMainThree {
    /**
     *
     * @param intervals int整型二维数组
     * @return int整型
     */
    public int eraseOverlapIntervals (int[][] intervals) {
        // write code here
        if (intervals.length == 0)
            return 0;
        Arrays.sort(intervals, new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {
                return o1[0]-o2[0];
            }
        });
        int result = 0;
        int cur = 0;
        int len = intervals.length;
        for (int i = 1; i < len; i++) {
            if (intervals[cur][1]>intervals[i][0]){
                if (intervals[cur][1]>intervals[i][1])
                    cur = i;
                result++;
            }else{
                cur = i;
            }
        }
        return result;
    }
}
```
### [顺丰笔试，全A代码](https://www.nowcoder.com/discuss/483891)
[顺丰8月20笔试，java代码](https://www.nowcoder.com/discuss/483985)
```markdown
//第一题：出租服务器，求最大收益，对客户付出的金钱进行贪心
输入：第一行n,m。n服务器个数，m客户个数
     第二行 n个数，表示每台服务器的带宽大小
     剩下的m行 每行 需求的带宽大小，可以付出的金钱
3 3
1 2 3
5 100
3 2
1 2
输出 4
public static void main(String[] args) {
        Scanner in=new Scanner(System.in);
        int n=in.nextInt(),m=in.nextInt();//n服务器个数，m客户个数
        Integer[] a=new Integer[n];
        for (int i = 0; i < n; i++) {
            a[i]=in.nextInt();
        }
        int[][] b=new int[m][2];//第一个表示需要的带宽大小，第二个表示可以付出的金钱
        for (int i = 0; i < m; i++) {
                b[i][0]=in.nextInt();
                b[i][1]=in.nextInt();
        }
        Arrays.sort(b, new Comparator<int[]>() { @Override public int compare(int[] o1, int[] o2) {
                if(o1[1]!=o2[1]) return o2[1]-o1[1];//金钱降序排序
                return o1[0]-o1[0];//带宽大小升序排序
            }
        });
        Arrays.sort(a, new Comparator<Integer>() { @Override public int compare(Integer o1, Integer o2) {
                return o1-o2;//升序排序
            }
        });
        int ans=0,n_temp=n;
        for (int i = 0; i < m; i++) {//对客户进行遍历，贪心最大的金钱
            if(n_temp==0) break;//记录已经出租的服务器数
            int select=-1;
            for (int j = 0; j < n; j++) {//给客户安排带宽刚刚够的服务器，将更大的服务器留给后面的用户
                if(a[j]>=b[i][0]) {
                    select=j;
                    a[j]=-1;//用过的服务器标记为-1
                    break;
                }
            }
            if(select!=-1){
                n_temp--;
                ans+=b[i][1];
            }
        }
        System.out.println(ans);
    }
//第二题：赏金猎人，求最大收益，先按结束时间进行升序排序，然后DP
  给定n,以下n行，每行3个数 s e mon ，分别表示开始时间 结束时间 赏金，求赏金猎人能得到的最大赏金。
输入 ： 
4
1 2 3
2 3 5
2 8 10
3 9 11
输出:
3 8 13 19
19
class k{
    public int s;//开始时间
    public int e;//结束时间
    public int mon;//赏金
    public k(int s, int e, int mon) {
        this.s = s;
        this.e = e;
        this.mon = mon;
    }
} 

 public static void main(String[] args) {
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        k[] a=new k[n];
        for (int i = 0; i < n; i++) {
            int s=in.nextInt();
            int e=in.nextInt();
            int mon=in.nextInt();
            a[i]=new k(s,e,mon);
        }
        Arrays.sort(a, new Comparator<k>() { @Override public int compare(k o1, k o2) {
                return o1.e-o2.e;//按照结束时间升序排序
            }
        });
        int[] dp=new int[n];
        dp[0]=a[0].mon;
        for(int i=1;i<n;i++){
            k temp=a[i];
            int itemp=-1;
            for (int j = i-1; j >=0 ; j--) {
                //找出选择了第i个任务后，前边还能够接受的任务（只要接受的任务的结束时间《第i个任务的开始时间就可以，因为前边已经将区间按照结束时间来升序排序了）
                if(temp.s>=a[j].e){
                    itemp=j;
                    break;
                }
            }
            //dp[i-1]表示不选第i个任务，后边表示选第i个任务
            if(itemp==-1){
                dp[i]=Math.max(dp[i-1],temp.mon);
            }
            else dp[i]=Math.max(dp[i-1],temp.mon+dp[itemp]);
        }
        for (int i = 0; i < n; i++) {
            System.out.print(dp[i]+" ");
        }
        System.out.println();
        System.out.println(dp[n-1]);
    }
```

## 20200822
### [爱奇艺2018](https://www.nowcoder.com/test/question/done?tid=36373974&qid=137989#summary)
```markdown
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] num = new int[n];
        int ans = Integer.MIN_VALUE;
        for(int i = 0;i <n;i++){
            num[i] = sc.nextInt();
            num[i] = help(num[i]);
            ans = Math.max(ans,num[i]);
        }
        System.out.println(ans);
    }
    private static int help(int num){
        char[] cs = String.valueOf(num).toCharArray();
        Arrays.sort(cs);
        String s= new String(cs);
        return Integer.valueOf(s);
    }
}
//缺失的括号
public static void main(String args[]){
	    	 Scanner in = new Scanner(System.in);
	         String str = in.nextLine();
                 //count计数多出来的"("，n计数字符串最前面的")"
	         int count = 0, n=0;
	         for(int i = 0; i < str.length(); i++){
	             if(str.charAt(i) == '('){
	            	 count++;
	             }
	             if(str.charAt(i) == ')') {
	            	 if(count == 0){
	            		 n++;
	            	 }else{
	            		 count--;
	            	 }
	             }
	         }
	         System.out.println(count+n);
	     }
//DNA序列
//链接：https://www.nowcoder.com/questionTerminal/ab900f183e054c6d8769f2df977223b5
  来源：牛客网
  
  不需要讨论实际的序列，只要比较序列的个数就好了。从长度为1到长度为n分别进行讨论，将长度
  为i的子串加入到set容器中去，set容器会自动除去重复的元素，这样set容器的大小size（）就
  表示长度为i的种类数量了。长度为i的序列总共有4的i次方个（排列组合：每个位置都有四种
  选择），然后将set容器的size()与4的i次方进行比较，如果小于4的i次方，那肯定存在不包含的
  序列。
import java.util.*;
public class Main{
    public static void main(String args[]){
        Scanner scan = new Scanner(System.in);
        String input = scan.nextLine();
        int i,j,n = input.length();
        for(i=1;i<=n;i++){
            HashSet<String> set= new HashSet<String>();
            for(j=0;j<n-i;j++) set.add(input.substring(j,j+i));
            if(set.size()<Math.pow(4,i)){
                System.out.println(i);
                break;
            }
        }  
    }
}
    private static int solve(String s) {
        LinkedList<String> linkedList = new LinkedList<>();
        for (int i = 0; i < dns.length; i++) {
            String string = String.valueOf(dns[i]);
            if (s.contains(string)) {
                linkedList.add(String.valueOf(dns[i]));
            } else {
                return 1;
            }
        }
        return solve(s, linkedList);
    }
    private static int solve(String s, LinkedList<String> linkedList) {
        boolean find = false;
        int count = 0;
        while (!find) {
            String string = linkedList.poll();
            for (int i = 0; i < dns.length; i++) {
                String string2 = string + dns[i];
                if (!s.contains(string2)) {
                    find = true;
                    count = string2.length();
                    break;
                }
                linkedList.offer(string2);
            }
        }
        return count;
    }

```

## 20200823
### [爱奇艺2021-GUN]()
```markdown
//1.n的阶乘的末尾0-计算乘法因子里面有多少个5 - leetcode-172. 阶乘后的零
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int ans = 0;
        while(n>=5){
            ans +=n/5;
            n = n/5;
        }
        return ans;
    }
}
//2.路径是否相交 -leetcode 1496. 判断路径是否相交
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        Stirng paths = sc.nextLine();
        Set<String> set = new HashSet<>();
        int x = 0;
        int y = 0;
        set.add(x+","+y);
        for(int i = 0;i<paths.length();i++){
            char ch = paths.charAt(i);
            if('N'==ch){ y++;}
            if('S'==ch){ y--;}
            if('E'==ch){ x++;}
            if('W'==ch){ x--;}
            if(set.contains(x+","+y)) return true;
            else set.add(x+","+y);
        }
        return false;
    }
}
// leetcode -20. 有效的括号
//建立一个新的栈，然后遍历字符串的字符，进行比较
    public boolean isValid3(String s) {
        Stack<Character> stack = new Stack<>();
        for (char c : s.toCharArray()) {
            if(c=='(') stack.push(')');
            else if(c=='[') stack.push(']');
            else if(c=='{') stack.push('}');
            else if(stack.isEmpty()||c!=stack.pop()) return false;
        }
        return stack.isEmpty();
    }
```
### [8.23 老虎证券Java开发笔试](https://www.nowcoder.com/discuss/486494)
```markdown
//第一题 LeetCode 328. 奇偶链表
//一个链表，让位于奇数位的节点移到前面，且相对顺序不变。空间复杂度O(1),时间复杂度O(n)
//输入：2->3->1->5->4->NULL
//输出：2->1->4->3->5->NULL
    public static ListNode lineUp(ListNode head) {
        if (head == null) {
            return head;
        }
        ListNode single = head;
        ListNode doublePre = head.next;
        ListNode doubleAfter = head.next;
        while (single != null && doubleAfter != null) {
            single.next = doubleAfter.next;
            single = single.next;
            doubleAfter.next = single.next;
            doubleAfter = doubleAfter.next;
        }
        single.next = doublePre;
        return head;
    }
//LeetCode 39. 组合总和
//给定N支股票的价格和经理拥有的金钱m，经理可以选择买和不买。输出该经理最终花光m的所有组合
//输入：[3,8,6], 14
//输出：[[6,8]]
    public ArrayList<ArrayList<Integer>> combinationSum (int[] prices, int m) {
        ArrayList<ArrayList<Integer>> result = new ArrayList<>();
        if(prices == null || prices.length == 0 || m <= 0){
            return result;
        }
        Arrays.sort(prices);
        ArrayList<Integer> list = new ArrayList<>();
        combination(result, list, prices, m, 0);
        return result;
    }
    public void combination(ArrayList<ArrayList<Integer>> result, ArrayList<Integer> list, int[] prices, int target, int index){
        if(target <= 0){
            if(target == 0){
                result.add(new ArrayList<>(list));
            }
            return;
        }
        for(int i = index; i < prices.length; i++){
            list.add(prices[i]);
            combination(result, list, prices, target - prices[i], i + 1);
            list.remove(list.size() - 1);
        }
    }
```

## 20200824
### [腾讯笔试](https://www.nowcoder.com/discuss/486642)
[腾讯823校招笔试翻车经（请大家给点建议）](https://www.nowcoder.com/discuss/486707)
```java
//1.给一个长度为n的链表，挖掉第k个元素，问挖掉元素后的序列。
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        int[] arr = new int[n];
        for(int i = 1;i<=n;i++){
            arr[i] = sc.nextInt();
            if(i!=m){
                System.out.print(arr[i]+" ");
            }
        }
    }
//LeetCode-19. 删除链表的倒数第N个节点
    public ListNode removeNthFromEnd(ListNode head, int n) {
            ListNode dummy = new ListNode(0);
            dummy.next = head;
            ListNode first = dummy;
            ListNode second = dummy;
            for(int i = 1;i<n;i++){
                first = first.next;
                second = second.next;
            }
            while(first!=null){
                first = first.next;
                second = second.next;
            }
            second.next = second.next.next;
            return dummy.next;
        }
}
//2.给一个长度为n（n在5000内）的字符串，问字典序第k（k在5以内）大的子串是什么。
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        String str = sc.nextLine();
        int k = sc.nextInt();
        Set<String> set = new HashSet<>();
        int len = str.length();
        //// 大顶堆
        PriorityQueue<String> queue = new PriorityQueue<>((o1,o2)->o2.compareTo(o1));
        for(int i = 0;i<len;i++){
            for(int j = i+1;j<=len;j++){
                String temp = str.substring(i,j);
                if(queue.size()<k){
                    queue.add(temp);
                }else  if(temp.compareTo(queue.peek())>=0){//队列满，新的子串字典序>=队列里的子串字典序
                    continue;
                }else if(!queue.contains(temp)){//队列满，新的子串字典序<队列里的子串字典序,队列中不包含该子串
                    queue.poll();
                    queue.add(temp);
                }
            }
        }
        System.out.println(queue.peek());
    }
//3.给一个数n，把它拆成a+b=n，要求a和b的数位和最大，求这个数位和。
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        if(n<=18) return n;
        int res = 0;
        while(n>=10){
            long i = n%10+10;
            if(i<=18){
                res+=i;
                n = n - 10;
                n = n / 10;
            }else {
                res+=n%10;
                n/=10
            }
        }
        System.out.print(res+n);
    }
//4.有n（n在5000内）块木板，宽度是1，长度不固定，这些小木板拼接起来一块大木板。
//给一个宽度为1的刷子，每刷一次可以选择横着刷和竖着刷，过程中都不能离开木板。问最少要刷几次能把木板完全刷一遍。
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] nums = new int[n];
        for(int i =0;i<n;i++){
            nums[i] = sc.nextInt();
        }
        int[][] dp  = new int[n][n];
        dp[0][0] = 0;
        for(int i = 0;i<n;i++){
            for(int j = 0;j<=n;j++){
                int high;
                //竖着刷
                high = Math.min(j,nums[i+1]);
                dp[i+1][high] = Math.min(dp[i+1][high],dp[i][j]+1);
                //横着刷
                if(a[i+1]<n){
                    if(j>=a[i+1]) dp[i+1][a[i+1]] = Math.min(dp[i+1][a[i+1]],dp[i][j]);
                    else dp[i+1][a[i+1]] = Math.min(dp[i+1][a[i+1]],dp[i][j]+a[i+1]-j);
                }
            }
        }
        int ans = n;
        for(int i = 0;i<=n;i++) ans = Math.min(dp[n][i],ans);
        System.out.print(ans);//横着刷
    }
// 给定字符串str，给定范围[l, r]，求子串能拆成最少的回文串的个数。
import java.util.*;

public class Main {

    static HashMap<String, Integer> mem = new HashMap();
    private static int splitPa(String key) {
        if (mem.containsKey(key))
            return mem.get(key);
        int n = key.length();
        int best = n;
        for (int i = 0; i < n; i++) {
            String right = key.substring(i);
            if (isPa(right)) {
                String left = key.substring(0, i);
                best = Math.min(best, 1 + splitPa(left));
            }
        }
        mem.put(key, best);
        return best;
    }

    private static boolean isPa(String str) {
        int l = 0;
        int r = str.length() - 1;
        while (l < r) {
            if (str.charAt(l) != str.charAt(r))
                return false;
            l++;
            r--;
        }
        return true;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String str = sc.nextLine();
        int Q = sc.nextInt();
        mem.put("", 0);
        for (int q = 0; q < Q; q++) {
            int l = sc.nextInt();
            int r = sc.nextInt();
            System.out.println(splitPa(str.substring(l-1, r)));
        }
    }
}
```
### [306笔试8.24](https://www.nowcoder.com/discuss/487244)
[360Java笔试8月24日下午场](https://www.nowcoder.com/discuss/487177)
```java
//第一题:镜面反转，ABA 为NO，AHA为YES，ABC为NO，只需找到反转后和原来相同的字母（'A','H','I','M','O','T','U','V','W','X','Y'），并判断是不是回文
import java.util.*;
public class Main {

    public static void main(String[] args) {
        Set<Character> set=new HashSet<>();
        Character[] chars={'A','H','I','M','O','T','U','V','W','X','Y'};
        Arrays.stream(chars).forEach(set::add);
        Scanner input=new Scanner(System.in);
        while (input.hasNextLine()){
            System.out.println(IsExcept(set,input.nextLine()));
        }

    }
    private static String IsExcept(Set set,String string) {
        int left=0;
        int right=string.length()-1;
        while (left<=right){
            if (!set.contains(string.charAt(left))||!set.contains(string.charAt(right)))return "NO";
            if (string.charAt(left++)!=string.charAt(right--)){
                return "NO";
            }
        }
        return "YES";
    }
}
/**
 * 魔塔闯关  
 * 魔塔是一款时尚经典小游戏，我们将魔塔简化后的规则描述如下：
 * 魔塔有n关，而你可以自由选择前往攻略哪一关，每一关只能获得一次分数。
 * 第i关攻略完成后，你将会获得ai的分数。
 * 某些关有一个特殊的宝物，你只能在攻略完这一关的时候使用这个宝物（
 * 也可以不使用，额外的宝物并不能留到其他关卡使用），
 * 这个宝物将使得这一关不得分，但是将你现有的总得分乘以2作为新的得分。
 * 你现在知道了所有关卡的通关方法，也知道了每一关的得分和是否有宝物，你现在想知道，怎么选择攻略的顺序和使用宝物的方法才能让自己的得分最大化？
 * 输入描述
 * 输入第一行包含一个整数n
 * 接下来n行，每行两个整数ai,bi。ai表示第i关的分数，若bi为1，则第i关有宝物。
 * 输出描述
 * 输出包含一个数，即能获得的最大分数
闯关->只需将无道具的先冲关再将有道具的按照分数从大到小排序即可
 */
public class Main {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        long n = input.nextLong();
        PriorityQueue<Long> queue = new PriorityQueue<Long>((a, b) -> b.compareTo(a));
        long current=0;
        while (n > 0) {
            long[] item=new long[]{input.nextLong(), input.nextLong()};
            if (item[1]==0){
                current+=item[0];
            }else {
                queue.add(item[0]);
            }
            n--;
        }
        long max = getResult(queue, current);
        System.out.println(max);
    }

    private static long getResult(PriorityQueue<Long> queue, long current) {
        if (queue.isEmpty()) {
            return current;
        } else {
            while (!queue.isEmpty()) {
                current+=Math.max(current,queue.poll());
            }
            return current;
        }
    }
}
```
### [中兴0824]()
```java
//第一题子数组求平均最大值的
public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();

        int[] array = new int [n];
        for(int i = 0; i < n; i++){
            array[i] = sc.nextInt();
        }
        int max = array[0];
        int l = 0;
        int r = 0;
        int temp = array[0];
        for(int i = 1; i < array.length; i++){
            r++;
            temp = (array[i] + temp) / (r - l + 1);
            if(max < temp){
                max = temp;
            }
            if(max <= array[i]){
                max = array[i];
                temp = array[i];
                l = i;
                r = i;
            }
        }
        System.out.println(max);
    }
 //题目描述：
//输入:一个数字T，作为总共要输入的行数；接下来输入T行：每行
//  包括一个字符串s，进制数l和r，其中s只包括0-9和A-Z之间的字符，l<r
//输出：每行一个数字，是字符串转换为10进制后的数的和:sl+sl+1+...+sr-1+sr为奇数，输出1；为偶数输出0；
/**
 * 2
 * 101 2 3
 * 101 4 5
 */
public class test2 {
    public static void main(String args[]) {

        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        sc.nextLine();
        String[] arr = new String[n];
        for (int i = 0; i < n; i++) {
            arr[i] = sc.nextLine();
        }
        int[] a = isOddorEven(arr);
        for (int i = 0; i < n; i++) {
            System.out.println(a[i]);
        }
    }

    public static int[] isOddorEven(String[] arr) {
        int[] a = new int[arr.length];
        for (int i = 0; i < arr.length; i++) {
            String[] items = arr[i].split(" ");
            String s = items[0].toUpperCase();
            int ls = Integer.parseInt(items[1]);
            int rs = Integer.parseInt(items[2]);
            char[] char_arr = s.toCharArray();
            int res = 0;
            int tmp = 0;
            for (int k = ls; k <= rs; k++) {
                for (int j = char_arr.length - 1; j >= 0; j--) {
                    if (char_arr[j] >= 'A' && char_arr[j] <= 'Z') {
                        tmp = char_arr[j] - 'A' + 10;
                    } else if (char_arr[j] >= '0' && char_arr[j] <= '9') {
                        tmp = char_arr[j] - '0';
                    }else return null;
                    res += tmp * Math.pow(k, char_arr.length - j - 1);
                }
            }

            if (res % 2 == 0) {
                a[i] = 0;
            } else {
                a[i] = 1;
            }
        }
        return a;
    }
}
```
### [阿里0824]()
```markdown
import java.util.*;
public class Main{
    public static void main(String args[]) {
        Scanner input = new Scanner(System.in);
        while(input.hasNextInt()){
            long A = input.nextLong();
            long B = input.nextLong();
            long a = input.nextLong();
            long b = input.nextLong();
            long start = Math.min(A, (B*a)/b);
            for (long i = start; i >= 1 ; i--) {
                if((b*i)%a == 0 && (b*i)/a <= B){
                    long y = (b*i)/a;
                    System.out.println(i + " " + y);
                    break;
                }
            }
        }
    }
}
```

## 20200826
### [2020.08.26阿里巴巴笔试](https://www.nowcoder.com/discuss/488901)
```java
//1.第一题：给出两个长度均为n的字符串A, B（只包含小写字母），求字典序介于这两个字符串之间的且长度为n的字符串有多少个, 即满足 A < X < B；
//直接把字符串看出是一个26进制的数据，然后相减的结果 - 1 就是答案了！
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        for(int i = 0;i<T;i++){
            int n = sc.nextInt();
            String a = sc.next();
            String b = sc.next();
            System.out.print(help(a,b,n));
        }
    }

    public static long help(String a,Sting b,int n){
        if(a.compareTo(b)>=0) return 0;
        long res = 0;
        long base = 1;
        for(int i = n-1;i>=0;i--){
            int num1 = a.charAt(i)-'a';
            int num2 = b.charAt(i)-'a';
            res+=(num2-num1)*base;
            base*=26;
        }
        return res-1;
    }
}
//2. 有T个案例。每个案例有一个n代表怪兽数量，m代表宝剑耐久度。有n行，每一行是怪兽的hp和杀死后获得的奖励。
// 耐久度高于hp可以杀怪兽。奖励是可以不使用耐久度就可以杀死a个怪兽。对于每一个案例输出最多杀几个，花费的最少的耐久度。
static int[] solution(int[] w, int[] v, int V) {
        int len = w.length;
        int[] dp = new int[V + 1];
        int left;
        int n;
        for(int i = 0; i < len; ++i) {
            for(int j = V; j >= w[i]; --j) {
                left = v[i];
                n = 0;
                for(int k = 0; k < len; ++k) {
                    if(k != i && left > 0) {
                        ++n;
                        left--;
                        left += v[k];
                    }
                }
                dp[j] = Math.max(dp[j], n + 1);
            }
        }
        int[] ans = new int[2];
        ans[1] = dp[V];
        for(int i = 0; i <= V; ++i) {
            if(dp[i] == ans[1]) {
                ans[0] = i;
                break;
            }
        }
        return ans;
    }
```
### [20200826华为]()
```markdown
第一题：
输入一行32位的无符号整数数组，不定长，用空格分隔，要求对它们做“加密”：
步骤A：交换：对于每个整数，按二进制每两位交换，第一位和第二位换，第三和第四换，以此类推。如0010，交换成0001。
步骤B：循环右移：对于每个整数，按二进制右移两位，右移出来的最低2位放到下一个数的最高2位，以此类推。最后一个数的最低2位安到第一个数的最高2位。如果只有一个数，则右移后的最低两位放到自己的最高位。
输出“加密”后的数。
示例：输入1 2，输出1073747824  2147483648
public static void main(String[] args){
    Scanner sc = new Scanner(System.in);
    while(sc.hasNextLine()){
        String[] arr = sc.nextLine().split(" ");
        long[] arr1 = new long(arr.length);
        for(int i = 0;i<arr.length();i++){
            arr1[i] = Long.parseLong(arr[i]);
         }
        long[] res = help(arr1,arr1.length());
        int j = 0;
        while(j<arr1.length-1){
            System.out.print(res[j]+" ");
            j++;
        }
        System.out.print(res[j]);
    }
}
public static long []help(long []arr,int n){
        int[][]temp = new int[n][32];
        for(int i=0;i<n;i++){
            for(int j=0;j<32;j++){
                temp[i][j]=(int)arr[i]%2;
                arr[i]/=2;
            }
            for(int k=0;k<16;k++){
                int t = temp[i][2*k];
                temp[i][2*k]=temp[i][2*k+1];
                temp[i][2*k+1]=t;
            }
            arr[i]=0;
            for(int l=31;l>=0;l--){
                arr[i]*=2;
                arr[i]+=temp[i][l];
            }
        }
        if(n ==1){
            arr[0]=(long)(arr[0]/4+arr[0]%4*Math.pow(2,30));
            return arr;
        }
        long tt=0;
        long tt2=0;
        for(int i=0;i<n;i++){
            tt=arr[i]%4;
            arr[i]/=4;
            arr[i]+=tt2*Math.pow(2,30);
            tt2 = tt;
        }
        arr[0]+=tt2*Math.pow(2,30);
        return arr;
    }
第二题：输入一组矩形，分别给出宽和高，求这些矩形组成的连续最大面积（最大柱状图面积的变形）。
这题算法上leetcode有变形，算法倒是不难。比较费事的是输入格式，输入的是 “[1,2,3],[1,2,3]" 这样的一行字符串，第一个数组是宽，第二个数组是高，用c++费了好大劲一个个字符串处理的，这时候特别想念Python的split.
这题还考了边界处理，包括非法字符，两个数组长度不对等，宽<=0或高<=0的情况。不处理边界只能拿70%，别问我怎么知道的。 😣
LeetCode 84
public int largestRectangleArea(int[] heights) {
        int area = 0, n = heights.length;
        // 遍历每个柱子，以当前柱子的高度作为矩形的高 h，
        // 从当前柱子向左右遍历，找到矩形的宽度 w。
        for (int i = 0; i < n; i++) {
            int w = 1, h = heights[i], j = i;
            while (--j >= 0 && heights[j] >= h) {
                w++;
            }
            j = i;
            while (++j < n && heights[j] >= h) {
                w++;
            }
            area = Math.max(area, w * h);
        }

        return area;
    }
第三题：猜数字
给定一系列字符串，并告诉你每个字符串中有多少个字符是存在的并在最终位置上，有多少个字符存在，但是位置不对。请根据它们猜出正确的字符串。
示例：字符串，存在并位置对的个数，存在但是位置不对的个数
cloxy 3 0
cxmnu 1 1
kcotd  2 1
apqud  2 0
bldwz  1 1
答案：cloud
```
### [2020/8/26广联达java开发算法题]()
```markdown
1、跳舞机，用WSAD表示上下左右，踩对+20分，踩错-10分，当分数 为零时不会继续扣分（无负数分）
输入：两行字符串，完全由WSAD组成，长度一致，第一行时满分的步骤，第二行为小明踩的步骤
输出：一行一个数，表示得分。
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        String str = sc.nextLine();
        String youStr = sc.nextLine();
        int len = str.length();
        int[] dp = new int[len];
        if(str.charAt(0)==youStr.charAt(0)) dp[0] = 20;
        else dp[0] = 0;
        for(int i = 1;i<len;i++){
            if(str.charAt(i)!=youStr.charAt(i)){
                if(dp[i-1]-10<0) dp[i] = 0;
                else dp[i] = dp[i-1]-10;
            }else{
                dp[i] = dp[i-1] + 20;
            }
        }
        System.out.println(dp[len-1]);
    }
}
2、元素平衡
《XX魔法书》中记载，只有魔法师体内地火水风四种元素平衡的时候才是绝对安全的。
某魔法师在给自己做了一个体检，发现自己体内的四种元素数量分别是A，B，C，D，魔法师慌了，这时他看到魔法书中记载了一种转换魔法，可以把任意两个单位的元素转换成任意一种元素。
请问魔法师是否可以通过这种魔法，在保证自己体内的元素总量尽可能多的情况下， 使得自己体内的四种元素数量完全相同？如果可以，请输出平衡后体内元素总量，如果不能请输出-1。 
输入描述 输入仅包含一行，仅包含4个正整数A，B，C，D，分别表示四种元素的数量。(1<=A,B,C,D<=10^17) 
输出描述 输出仅包含一个整数,如题所示。 样例输入 1 2 2 4 样例输出 8
public int demo(int A,int B,int C,int D){
    int sum = A+B+C+D-1;
    int ave = sum/4;
    int remove = 2;
    int add = 1;
    help(A,ave,remove,add);
    help(B,ave,remove,add);
    help(C,ave,remove,add);
    help(D,ave,remove,add);
    if(remove==0&&add==0) return sum;
    else return -1;
}
public void help(int A,int ave,int remove,int add){
    if(A==ave) return;
    else if(A<ave){
        help(A+1,ave,remove,add-1);
    }else{
        help(A-1,ave,remove-1,add);
    }
}
3、排序
有一种排序算法定义如下，该排序算法每次只能把一个元素提到序列的开头，例如2，1，3，4，只需要一次操作把1提到序列起始位置就可以使得原序列从小到大有序。
现在给你个乱序的1-n的排列，请你计算最少需要多少次操作才可以使得原序列从小到大有序。
输入描述
输入有n个正整数，表示序列中的n个元素，中间用空格隔开。(1<=a_i<=n)
输出描述
输出仅包含一个整数，表示最少的操作次数。
public int demo(int[] num,int n){
    for()
}
```