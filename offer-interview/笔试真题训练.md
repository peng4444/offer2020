# 笔试真题训练

## 20200819
### [2020搜狗笔试1](https://www.nowcoder.com/test/question/done?tid=36176943&qid=1009393#summary)
#### 1.
```markdown
import java.util.*;
/**
 * LRU 算法 LinkHashMap 或者 hashMap + Queue
 */
public class Main {
     public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        sc.nextLine();
        //记录数据
        LinkedHashMap<String , Long> LRUhashMap = new LinkedHashMap<>();
        while (sc.hasNext()){
            //输入k - v
            String[] insert = sc.nextLine().split(" ");
            String key = insert[0];
            String value = insert[1];
            if(LRUhashMap.containsKey(key)){
                if(LRUhashMap.get(key)-Long.valueOf(value) < 0){
                    LRUhashMap.remove(key);
                    LRUhashMap.put(key,Long.valueOf(value));
                }
            }else{
                if(LRUhashMap.size() < N){ //空间剩余
                    LRUhashMap.put(key,Long.valueOf(value));
                }else if(LRUhashMap.size() == N){ //空间不足
                    for(String s : LRUhashMap.keySet()){
                        System.out.println(s + " " + LRUhashMap.get(s));
                        LRUhashMap.remove(s);
                        LRUhashMap.put(key,Long.valueOf(value));
                        break;
                    }
                }
            }
        }
    }
}
```
#### 3
```markdown
import java.util.*;
 
/**
 *    1. 使用hashmap构建树形结构
 *    2. 递归分治法：假设已知 各个子节点的分发时间：
 *        则： 2.1 对子节点的分发时间进行降序排列
 *            2.2 当前节点优先对 子节点分发时间 较长的节点进行分发, 
 *                如:子节点分发时间 4 2 1 1 1 0, k=2, 则: 先后分发顺序(42)(11)(10),也就是
 *                     (42)+1 (11)+2 (10)+3 => 5 3 3 3 4 3 => 分三轮分发, 最终所需时间为 5 h。
 *             2.3 当节点为叶子结点, 分发时间为0
 *             2.4 最后使用分治法进行递归分发,相当于从叶子节点向上推。
 */
class Node{
    int id = 0;
    List<Node> sons = new ArrayList<>();
    Node parent = null;
}
 
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        HashMap<Integer , Node> hashMap = new HashMap<>();
        int K = sc.nextInt();
        int N = sc.nextInt();
        if(K == 0 || N == 0){
            System.out.println(0);
        }
        sc.nextLine();
        //树形构建
        for(int i = 0;i < N;i++){
            int node_n = sc.nextInt();
            //指定父节点
            int parent_id = sc.nextInt();
            Node my = null;
            if(hashMap.containsKey(parent_id)){
                //父节点存在
                my = hashMap.get(parent_id);
            }else{
                //父节点不存在
                my = new Node();
                my.id = parent_id;
                hashMap.put(parent_id,my);
            }
            //儿子节点
            for(int j = 0;j < node_n - 1;j++){
                int son_id = sc.nextInt();
                if(hashMap.containsKey(son_id)){
                    //儿子节点存在
                    hashMap.get(parent_id).sons.add(hashMap.get(son_id));
                }else{
                    //儿子节点不存在
                    Node son = new Node();
                    son.id = son_id;
                    son.parent = my;
                    hashMap.put(son.id,son);
                    hashMap.get(parent_id).sons.add(son);
                }
            }
            sc.nextLine();
        }
        //根节点存在
        Node root = hashMap.get(0);
        //分治法
        System.out.println(FZ(root , K));
    }
    public static int FZ(Node node , int k){
        int max = 0;
        if(node.sons.size() == 0){
            return 0;
        }else{
            Integer[] sons_time = new Integer[node.sons.size()];
            int i = 0;
            //统计分支时间
            for(Node son:node.sons){
                sons_time[i++] = FZ(son , k);
            }
            //合并分支与当前时间
            //降序排序
            Arrays.sort(sons_time, new Comparator<Integer>() {
                @Override
                public int compare(Integer o1, Integer o2) {
                    return o2 - o1;
                }
            });
            //计算当前节点为root所需要的时间
            int add = 1;
            for(int j = 0; j < sons_time.length ; j++){
                if(j!=0 && (j%k) == 0){
                    add++;
                }
                sons_time[j] += add;
                if(sons_time[j] > max){
                    max = sons_time[j];
                }
            }
        }
        return max;
    }
}
```

### [2020搜狗笔试2](https://www.nowcoder.com/test/question/done?tid=36179124&qid=1009391#summary)
#### 1
```markdown
import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int sum = 0;
        int password;
        int N = scanner.nextInt();
        int M = scanner.nextInt();
        int[] arr = new int[N];
        for (int i=0;i<M;i++){
            int L = scanner.nextInt();
            int R = scanner.nextInt();
            for(int j=L;j<R;j++){
                arr[j] = i+1;
            }
            arr[R] = i+1;
        }
        for (int i=0;i<arr.length;i++){
            sum+= i*arr[i];
        }
        password = sum % 100000009;
        System.out.println(password);
    }
}
```
#### 2.
```markdown
/**
 * 前缀 后缀 的匹配问题 easy
 */
 
import java.util.Scanner;
  
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int M = sc.nextInt();
        sc.nextLine();
        //读取规则
        String[] patterns = new String[N];
        for(int i =0 ;i < N;i++){
            patterns[i] = sc.nextLine();
        }
        //读取IP
        String[] IPs = new String[M];
        for(int i = 0;i < M; i++){
            IPs[i] = sc.nextLine();
        }
        //暴力匹配
        for(int i = 0; i < IPs.length;i++){
            boolean lock = false;
            for(int j = 0; j < patterns.length;j++){
                String t = "";
                if(patterns[j].charAt(0) == '*'){
                    t = patterns[j].replace("*","");
                    if(IPs[i].endsWith(t)){
                        System.out.print(1 + " ");
                        lock = true;
                        break;
                    }
                }else if(patterns[j].charAt(patterns[j].length()-1) == '*'){
                    t = patterns[j].replace("*","");
                    if(IPs[i].startsWith(t)){
                        System.out.print(1 + " ");
                        lock = true;
                        break;
                    }
                }else{
                    if(patterns[j].equals(IPs[i])){
                        System.out.print(1 + " ");
                        lock = true;
                        break;
                    }
                }
            }
            if(lock == false){
                System.out.print(0 + " ");
            }
        }
    }
}
```

## 20200820
### [2020 4399](https://www.nowcoder.com/profile/8791875/test/36202246/844365#summary)
#### 1.
```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        double ans1 = 100,ans2 = 100;
        for(int i = 0;i<n-1;i++){
            ans2*=0.5;
            ans1+=ans2*2;
        }
        ans2*=0.5;
        System.out.println(ans1+" "+ans2);
    }
}
```
#### 2.
```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int pNum = n;
        int index = 0;
        int countNum = 0;
        int[] arr = new int[n];
        while(pNum>1){
            if(arr[index]==0){
                countNum++;
                if(countNum==3){
                    countNum=0;
                    arr[index] = 1;
                    pNum--;
                }
            }
            index++;
            if(index==n) index = 0;
        }
        for(int i = 0;i<n;i++){
            if(arr[i]==0) System.out.println(i+1);
        }
    }
}
```
### [2020 4399](https://www.nowcoder.com/profile/8791875/test/36198670/110543#summary)
#### 1.
```java
//将20个球放进12个不同的袋子，每个袋子可以放0-20个球，有多少种放法？分析如何计算，然后编程解答。
//进阶问题：每个袋子只能放0个、2个或3个球，该如何计算？
public int ballBag(int bag, int ball) {
        int[][] dp = new int[bag + 1][ball + 1];
        int i, j, k, sum;
        for (i = 1; i <= bag; i++) {
            dp[i][0] = 1;
        }//无论几个包，放入0个球的方法只有一种
        for (j = 0; j <= ball; j++) {
            dp[1][j] = 1;
        }//无论几个球，放入1个包的方法也只有一种
        for (i = 2; i <= bag; i++) {
            for (j = 1; j <= ball; j++) {
                sum = 0;
                for (k = 0; k <= j; k++) {
                    sum += dp[i - 1][k];
                }
                dp[i][j] = sum;
            }
        }
        return dp[bag][ball];
    }
```
#### 2.
```java
import java.util.Scanner;
public class solution {
        public String findit(String str){
        Scanner scanner = new Scanner(System.in);
        String str1 = scanner.next();
        String str2 = scanner.next();
        char[] char1 = str1.toCharArray();
        char[] char2 = str2.toCharArray();
        int p1 = 0;
        int p2 = 0;
        while(p1<str1.length() && p2<str2.length()){
            while(p1<str1.length() && p2<str2.length() && char1[p1]!=char2[p2]){
                p1++;
            }
            p1++;
            p2++;
        }
        if(p2 >= char2.length){
            return new String("不可描述");
        }else{
            return str1;
        }        
    }
}
```

## 20200821
### [商汤科技2020-8-20开发笔试A卷](https://www.nowcoder.com/discuss/483879)
```markdown
//一：给定一个字符串，找“Good”，字符顺序不可变，每个字符只能用一次
class Solution {
    public int method(char[] chars) {
        if (chars.length < 4)
            return 0;
        int res = 0;
        int numOfG = 0, numOfO = 0;
        for (int i = 0; i < chars.length; i++) {
            if (chars[i] == 'G')
                numOfG++;
            if (chars[i] == 'o') {
                if (numOfG > 0)
                    numOfO++;
            }
            if (chars[i] == 'd') {
                if (numOfG > 0 && numOfO >= 2) {
                    res++;
                    numOfG--;
                    numOfO = numOfO - 2;
                }
            }
        }
        return res;
    }
}
//二、最常上升子序列，leetcode原题
class SolutionMainTwo {
    public int[][] cur = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    public int r, c;
    public int method(int[][] array, int n, int m) {
        if (n == 0 || m == 0 || array == null)
            return 0;
        r = n;
        c = m;
        int[][] curArray = new int[r][c];
        int ans = 0;
        for (int i = 0; i < r; ++i) {
            for (int j = 0; j < c; ++j) {
                ans = Math.max(ans, methodDFS(array, i, j, curArray));
            }
        }
        return ans;
    }
    private int methodDFS(int[][] matrix, int row, int column, int[][] curArray) {
        if (curArray[row][column] != 0)
            return curArray[row][column];
        ++curArray[row][column];
        for (int[] ints : cur) {
            int newRow = row + ints[0];
            int newColumn = column + ints[1];
            if (newRow >= 0 && newRow < r && newColumn >= 0 && newColumn < c && matrix[newRow][newColumn] > matrix[row][column]) {
                curArray[row][column] = Math.max(curArray[row][column], methodDFS(matrix, newRow, newColumn, curArray) + 1);
            }
        }
        return curArray[row][column];
    }
}
//三、大意是求删除区间的个数，可以使得删除后剩下的区间彼此不重叠（好像是这个意思）
class SolutionMainThree {
    /**
     *
     * @param intervals int整型二维数组
     * @return int整型
     */
    public int eraseOverlapIntervals (int[][] intervals) {
        // write code here
        if (intervals.length == 0)
            return 0;
        Arrays.sort(intervals, new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {
                return o1[0]-o2[0];
            }
        });
        int result = 0;
        int cur = 0;
        int len = intervals.length;
        for (int i = 1; i < len; i++) {
            if (intervals[cur][1]>intervals[i][0]){
                if (intervals[cur][1]>intervals[i][1])
                    cur = i;
                result++;
            }else{
                cur = i;
            }
        }
        return result;
    }
}
```
### [顺丰笔试，全A代码](https://www.nowcoder.com/discuss/483891)
[顺丰8月20笔试，java代码](https://www.nowcoder.com/discuss/483985)
```markdown
//第一题：出租服务器，求最大收益，对客户付出的金钱进行贪心
输入：第一行n,m。n服务器个数，m客户个数
     第二行 n个数，表示每台服务器的带宽大小
     剩下的m行 每行 需求的带宽大小，可以付出的金钱
3 3
1 2 3
5 100
3 2
1 2
输出 4
public static void main(String[] args) {
        Scanner in=new Scanner(System.in);
        int n=in.nextInt(),m=in.nextInt();//n服务器个数，m客户个数
        Integer[] a=new Integer[n];
        for (int i = 0; i < n; i++) {
            a[i]=in.nextInt();
        }
        int[][] b=new int[m][2];//第一个表示需要的带宽大小，第二个表示可以付出的金钱
        for (int i = 0; i < m; i++) {
                b[i][0]=in.nextInt();
                b[i][1]=in.nextInt();
        }
        Arrays.sort(b, new Comparator<int[]>() { @Override public int compare(int[] o1, int[] o2) {
                if(o1[1]!=o2[1]) return o2[1]-o1[1];//金钱降序排序
                return o1[0]-o1[0];//带宽大小升序排序
            }
        });
        Arrays.sort(a, new Comparator<Integer>() { @Override public int compare(Integer o1, Integer o2) {
                return o1-o2;//升序排序
            }
        });
        int ans=0,n_temp=n;
        for (int i = 0; i < m; i++) {//对客户进行遍历，贪心最大的金钱
            if(n_temp==0) break;//记录已经出租的服务器数
            int select=-1;
            for (int j = 0; j < n; j++) {//给客户安排带宽刚刚够的服务器，将更大的服务器留给后面的用户
                if(a[j]>=b[i][0]) {
                    select=j;
                    a[j]=-1;//用过的服务器标记为-1
                    break;
                }
            }
            if(select!=-1){
                n_temp--;
                ans+=b[i][1];
            }
        }
        System.out.println(ans);
    }
//第二题：赏金猎人，求最大收益，先按结束时间进行升序排序，然后DP
  给定n,以下n行，每行3个数 s e mon ，分别表示开始时间 结束时间 赏金，求赏金猎人能得到的最大赏金。
输入 ： 
4
1 2 3
2 3 5
2 8 10
3 9 11
输出:
3 8 13 19
19
class k{
    public int s;//开始时间
    public int e;//结束时间
    public int mon;//赏金
    public k(int s, int e, int mon) {
        this.s = s;
        this.e = e;
        this.mon = mon;
    }
} 

 public static void main(String[] args) {
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        k[] a=new k[n];
        for (int i = 0; i < n; i++) {
            int s=in.nextInt();
            int e=in.nextInt();
            int mon=in.nextInt();
            a[i]=new k(s,e,mon);
        }
        Arrays.sort(a, new Comparator<k>() { @Override public int compare(k o1, k o2) {
                return o1.e-o2.e;//按照结束时间升序排序
            }
        });
        int[] dp=new int[n];
        dp[0]=a[0].mon;
        for(int i=1;i<n;i++){
            k temp=a[i];
            int itemp=-1;
            for (int j = i-1; j >=0 ; j--) {
                //找出选择了第i个任务后，前边还能够接受的任务（只要接受的任务的结束时间《第i个任务的开始时间就可以，因为前边已经将区间按照结束时间来升序排序了）
                if(temp.s>=a[j].e){
                    itemp=j;
                    break;
                }
            }
            //dp[i-1]表示不选第i个任务，后边表示选第i个任务
            if(itemp==-1){
                dp[i]=Math.max(dp[i-1],temp.mon);
            }
            else dp[i]=Math.max(dp[i-1],temp.mon+dp[itemp]);
        }
        for (int i = 0; i < n; i++) {
            System.out.print(dp[i]+" ");
        }
        System.out.println();
        System.out.println(dp[n-1]);
    }
```