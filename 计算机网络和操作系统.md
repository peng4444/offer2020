# 计算机网络和操作系统知识总结

[TOC]


## 一、计算机网络 [参考资料：cyc2018大佬](https://cyc2018.github.io/CS-Notes/#/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E7%9B%AE%E5%BD%951)
### 1.[参考资料：计算机网络常见面试题](https://www.cnblogs.com/wuwuyong/p/12198928.html)
### 三种体系结构&计算机网络的体系结构
#### OSI的体系结构
```markdown
应用层-表示层-会话层-运输层-网络层-数据链路层-物理层
```
#### 五层协议的体系结构
```markdown
应用层-运输层-网络层-数据链路层-物理层
```
#### TCP/IP的体系结构
```markdown
应用层-运输层-网际层-网络接口层
```
```markdown
1.应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）
间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如**域名系统DNS**，
支持万维网应用的**HTTP协议**，支持电子邮件的**SMTP协议**等等。我们把应用层交互的数据单元称为报文。
2.运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。
“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。
所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。
[参考资料：运输层 ,跑腿的秘书](https://www.cnblogs.com/king0/p/12932251.html)
运输层主要使用以下两种协议:   
    1.**传输控制协议 TCP**（Transmission Control Protocol）--提供面向连接的，可靠的数据传输服务。
    2.**用户数据协议 UDP**（User Datagram Protocol）--提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。
3.网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组
和包进行传送。在TCP/IP体系结构中，由于网络层使用**IP协议**，因此分组也叫IP数据报，简称数据报。
4.数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。 
在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。
每一帧包括数据和必要的控制信息（如**同步信息，地址信息，差错控制等**）。
5.物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。 
使其上面的数据链路层不必考虑网络的具体传输介质是什么。在物理层上所传送的数据单位是比特。
```
![](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E4%B8%83%E5%B1%82%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9B%BE.png)
### 2.[参考资料：总结12道最常见的计算机网络面试题](https://www.cnblogs.com/tanshaoshenghao/p/11835679.html)
#### 1. 请详细介绍一下TCP的三次握手机制，为什么要三次握手？
```markdown
1.首先服务器端处于 LISTEN（监听）状态，等待客户的连接请求。
2.客户端–发送带有 SYN=1 标志的数据包–一次握手–服务端
3.服务端–发送带有 SYN=1/ACK=1 标志的数据包–二次握手–客户端
4.客户端–发送带有带有 ACK=1 标志的数据包–三次握手–服务端
三次握手的目的是建立可靠的通信信道，通讯简单来说就是数据的发送与接收，
而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。
SYN:是 TCP/IP 建立连接时使用的握手信号。
ACK:确认字符 ,在数据通信传输中，接收站发给发送站的一种传输控制字符。它表示确认发来的数据已经接受无误。
```
#### 2. 为什么要传回SYN？传了SYN,为啥还要传ACK？讲一讲SYN超时，洪泛攻击，以及解决策略？
```markdown
**为什么要传回SYN？**
    接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。
**传了SYN,为啥还要传ACK？**
    双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。
**讲一讲SYN超时，洪泛攻击，以及解决策略？**
     在TCP的三次握手机制的第一步中，客户端会向服务器发送SYN报文段。服务器接收到SYN报文段后会为该TCP分配缓存和变量，
     如果攻击分子大量地往服务器发送SYN报文段，服务器的连接资源终将被耗尽，导致内存溢出无法继续服务。
     **解决策略**：当服务器接受到SYN报文段时，不直接为该TCP分配资源，而只是打开一个半开的套接字。接着会使用SYN报文段的源Id，目的Id，
     端口号以及只有服务器自己知道的一个秘密函数生成一个cookie，并把cookie作为序列号响应给客户端。
```
#### 3. 详细介绍一下TCP的四次挥手机制，为什么要有TIME_WAIT状态，为什么需要四次握手？服务器出现了大量CLOSE_WAIT状态如何解决
```markdown
1.客户端-发送一个 FIN=1，用来关闭客户端到服务器的数据传送
2.服务器-收到这个 FIN，它发回一 个 ACK=1，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号
3.服务器-关闭与客户端的连接，发送一个FIN给客户端
4.客户端-发回 ACK=1 报文确认，并将确认序号设置为收到序号加1
**为什么需要四次握手？**:任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。
当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。
**为什么要有TIME_WAIT状态**因为客户端最后向服务器发送的确认 ACK 是有可能丢失的，当出现超时，服务端会再次发送 FIN 报文段，
如果客户端已经关闭了就收不到了。还有一点是避免新旧连接混杂。
**大量CLOSE_WAIT**表示程序出现了问题，对方的socket已经关闭连接，而我方忙于读或写没有及时关闭连接，需要检查代码，特别是释放资源的代码，或者是处理请求的线程配置。
```
#### 4. 详细讲一下TCP的滑动窗口
![](https://www.cnblogs.com/images/cnblogs_com/tanshaoshenghao/1426602/o_%e7%bd%91%e7%bb%9c7.png)
```markdown
滑动窗口左边的是已发送并且被确认的分组，滑动窗口右边是还没有轮到的分组。滑动窗口里面也分为两块，一块是已经发送但是未被确认的分组，
另一块是窗口内等待发送的分组。随着已发送的分组不断被确认，窗口内等待发送的分组也会不断被发送。整个窗口就会往右移动，让还没轮到的分组进入窗口内。
滑动窗口起到了一个限流的作用，也就是说当前滑动窗口的大小决定了当前 TCP 发送包的速率，而滑动窗口的大小取决于拥塞控制窗口和流量控制窗口的两者间的最小值。
```
#### 5. 讲一下HTTP与HTTPS的区别
```markdown
HTTP和HTTPS的主要区别在于HTTP协议传递的是明文数据，而HTTPS传递的是加密过的数据，也就是说HTTPS更具有安全性。
也正由HTTPS需要保证安全性，所以它的性能要比HTTP差一点。
HTTPS中使用到的对称加密，非对称加密，CA，数字证书的概念HTTPS想要保证客户端与服务器之间的通信安全，就得使用对称加密算法进行加密。
协商对称加密算法的过程通过非对称加密算法来保证。在非对称加密算法中，客户端获得公钥的过程需要第三方机构（CA）通过颁发数字证书保证安全性。
```
#### 6. 讲一讲TCP和UDP各有什么特点，两者有什么区别
[聊聊UDP、TCP和实现一个简单的JAVA UDP小Demo](https://www.cnblogs.com/huangqingshi/p/12950639.html)
```markdown
UDP在传送数据之前不需要先建立连接，远地主机在收到UDP报文后，不需要给出任何确认。虽然UDP不提供可靠交付，
但在某些情况下UDP确是一种最有效的工作方式（一般用于即时通信）
TCP提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP不提供广播或多播服务。
由于TCP要提供可靠的，面向连接的传输服务。TCP一般用于文件传输、发送和接收邮件、远程登录等场景。
```
#### 6.1 TCP协议如何保证可靠传输
```markdown
1.应用数据被分割成TCP认为最适合发送的数据块。
2.TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。
3.校验和:TCP将保持它首部和数据的检验和。是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。
    如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。
4.TCP的接收端会丢弃重复的数据。
5.流量控制：TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。
    当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。
    TCP使用的流量控制协议是可变大小的滑动窗口协议。（TCP利用滑动窗口实现流量控制）
6.拥塞控制：当网络拥塞时，减少数据的发送，降低整个网络的拥塞程度。
    TCP的拥塞控制采用了四种算法，即慢开始、拥塞避免、快重传和快恢复。
7.ARQ协议(自动重传请求)：也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。
8.超时重传：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。
9.TCP利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，
    从而影响发送方的发送速率。将窗口字段设置为0，则发送方不能发送数据。
```
#### 7. 在地址栏键入URL后，网络世界发生了什么？
[一文摸透从输入URL到页面渲染的过程](https://www.cnblogs.com/AhuntSun-blog/p/12641050.html)
```markdown
1.在键入URL之前，刚开完机的时候，需要联网，然后才能上网。这个阶段包括了获取本机IP地址，获取DNS服务器IP地址，获得网关路由器IP和MAC地址等操作。
--获取本机IP地址，DNS服务器地址，网关路由器地址
--1.获取域名的IP地址 --DNS域名解析:获取域名对应IP
--2.三次握手建立TCP连接
--3.建立连接后进行数据交互 发送HTTP请求  服务器处理请求并返回HTTP报文 请求结束关闭TCP连接
--4.浏览器解析渲染页面 构建DOM树 样式计算 页面布局 生成分层树 栅格化 显示
--5.合成与显示
```
#### 8. HTTP的常见状态码有哪些，代表什么含义？
```markdown
**首先状态码的开头不同代表不同的类型：**
1xx：代表指示信息，表示请求已接收，继续处理
2xx：代表成功，表示请求已被成功接收，理解，接受
3xx：重定向，表示完成请求必须进行进一步的操作
4xx：客户端错误，请求有语法错误或请求无法实现
5xx：服务器端错误，服务器未能实现合法的请求
**常见状态码：**
200 OK：正常返回信息
400 Bad Request：客户端请求有语法错误，不能被服务器所理解
403 Forbidden：服务器收到请求，但是拒绝提供服务
404 Not Found：请求资源不存在，输入了错误的URL
500 Internal Server Error：服务器发生不可预期错误
503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常
```
#### 9. GET请求和POST请求的区别
```markdown
1.从HTTP报文层面来看，GET请求将信息放在URL，POST将请求信息放在请求体中。
2.从数据库层面来看，GET 符合幂等性和安全性，而 POST 请求不符合。
因为POST的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。
3.从其他层面来看，GET请求能够被缓存，GET请求能够保存在浏览器的浏览记录里，GET请求的URL能够保存为浏览器书签。这些都是POST请求所不具备的。
```
#### 10. 什么是Cookie，Cookie的使用过程是怎么样的？
```markdown
由于http协议是无状态协议，如果客户通过浏览器访问web应用时没有一个保存用户访问状态的机制，那么将不能持续跟踪应用的操作。
cookie是浏览器的一种缓存机制，它可用于维持客户端与服务器端之间的会话。HTTP/1.1 引入 Cookie 来保存状态信息。
随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本地。
**cookie的使用过程：**
    1.首先用户在客户端浏览器向服务器发起登陆请求
    2.登陆成功后，服务端会把登陆的用户信息设置cookie中，返回给客户端浏览器
    3.客户端浏览器接收到cookie请求后，会把cookie保存到本地（可能是内存，也可能是磁盘，看具体使用情况而定）
    4.以后再次访问该web应用时，客户端浏览器就会把本地的cookie带上，这样服务端就能根据cookie获得用户信息了
```
#### 11. 什么是session，有哪些实现session的机制？
```markdown
session是一种维持客户端与服务器端会话的机制。但是与cookie把会话信息保存在客户端本地不一样,session把会话保留在**浏览器端**。
存储在服务器端的信息更加安全。存储在服务器上的文件、数据库或者内存中。也可以将Session存储在Redis这种内存型数据库中，效率会更高。
**session 的使用过程：**
    1.首先用户在客户端浏览器发起登陆请求
    2.登陆成功后，服务端会把用户信息保存在服务端，并返回一个唯一的session标识给客户端浏览器。
    3.客户端浏览器会把这个唯一的session标识保存在起来
    4.以后再次访问web应用时，客户端浏览器会把这个唯一的session标识带上，这样服务端就能根据这个唯一标识找到用户信息。
```
#### 12. session和cookie有什么区别
```markdown
在许多web应用中，session机制就是通过cookie来实现的。
1.cookie是浏览器提供的一种缓存机制，它可以用于维持客户端与服务端之间的会话。**一般用来保存用户信息**。
2.session指的是维持客户端与服务端会话的一种机制，它可以通过cookie实现，也可以通过别的手段实现。
3.如果用cookie实现会话，那么会话会保存在客户端浏览器中，而session机制提供的会话是保存在服务端的。
4.Cookie只能存储 ASCII码字符串，而Session则可以存储任何类型的数据，因此在考虑数据复杂性时首选Session；
5.Cookie存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在Cookie中，可以将Cookie值进行加密，然后在服务器进行解密；
6.对于大型网站，如果用户所有的信息都存储在Session中，那么开销是非常大的，因此不建议将所有的用户信息都存储到Session中。
```
### 3.[30张图解HTTP常见的面试题](https://www.cnblogs.com/xiaolincoding/p/12442435.html)
```markdown

```

## 二、操作系统
### 1.[参考资料：操作系统总结](https://www.cnblogs.com/blknemo/p/12274600.html)
#### 基础概念：并发与并行，共享，虚拟，异步
```markdown
**并发**是指宏观上在一段时间内能同时运行多个程序，而**并行**则指同一时刻能运行多个指令。
并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。操作系统通过引入进程和线程，使得程序能够并发运行。
**共享**是指系统中的资源可以被多个并发进程共同使用。有两种共享方式：互斥共享和同时共享。
互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。
**虚拟技术**把一个物理实体转换为多个逻辑实体。主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。
多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。
**虚拟内存**使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，
地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。
```
###2.[我和面试官之间关于操作系统的一场对弈！写了很久，希望对你有帮助！](https://www.cnblogs.com/javaguide/p/operating-system.html)
#### 1.1 什么是操作系统？
```markdown
作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机系统的内核与基石；
操作系统本质上是运行在计算机上的软件程序 ；
操作系统为用户提供一个与系统交互的操作界面 ；
操作系统分内核与外壳（我们可以把外壳理解成围绕着内核的应用程序，而内核就是能操作硬件的程序）。
```
#### 1.2 什么是系统调用呢？ 
```markdown
操作系统提供的函数就被称为系统调用（system call）。程序的执行一般是在用户态下执行的，但当程序需要使用操作系统提供的服务时，
比如说打开某一设备、创建文件、读写文件（这些均属于系统调用）等，就需要向操作系统发出调用服务的请求，这就是系统调用。
根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：
    用户态(user mode) : 用户态运行的进程或可以直接读取用户程序的数据。
    系统态(kernel mode):可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。
在我们运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，
都必须通过系统调用方|式向操作系统提出服务请求，并由操作系统代为完成。
 异常：当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。
 外围设备的中断：当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程
序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。
```
#### 1.3 进程和线程的区别
```markdown
进程是资源分配的基本单位。线程是独立调度的基本单位。一个进程中可以有多个线程，它们共享进程资源。
**拥有资源**：进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。
**调度**：线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。
**系统开销**：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等，所付出的开销远大于创建或撤销线程时的开销。
类似地，在进行进程切换时，涉及当前执行进程CPU环境的保存及新调度进程CPU环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。
**通信方面**：线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。
```
#### 1.4 进程有哪几种状态?
```markdown
创建状态(new) ：进程正在被创建，尚未到就绪状态。
就绪状态(ready) ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。
运行状态(running) ：进程正在处理器上上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。
阻塞状态(waiting) ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。
结束状态(terminated) ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。
```
#### 1.5 进程间的通信方式
```markdown
**管道/匿名管道(Pipes)** ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。
**命名管道(Names Pipes)**: 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。
    有名管道严格遵循先进先出(first in first out)。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。
**信号(Signal)** ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；
**消息队列(Message Queuing)** ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。
    管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）
    不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。
    消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。
    消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺。
**信号量(Semaphores)** ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。
**共享内存(Shared memory)** ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。
    这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。
**套接字(Sockets)** : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，
    可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。
```
#### 1.6 线程间的同步的方式
```markdown
**同步与互斥**：同步：多个进程按一定顺序执行；互斥：多个进程在同一时刻只有一个进程能进入临界区。
    线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。
操作系统一般有下面三种线程同步的方式：
**互斥量(Mutex)**：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会
    被多个线程同时访问。比如Java中的synchronized关键词和各种Lock都是这种机制。
**信号量(Semphares)**：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量
**事件(Event) :Wait/Notify**：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操。
**临界区**：对临界资源进行访问的那段代码称为临界区。为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。
```
#### 1.7 进程的调度算法
```markdown
**批处理系统**:批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。
**先到先服务(FCFS)调度算法**:从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用CPU时再重新调度。
**短作业优先(SJF)的调度算法**:从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用CPU时再重新调度。
**时间片轮转调度算法**:时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称RR(Roundrobin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。
**多级反馈队列调度算法**:前面介绍的几种进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程 。
多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。因而它是目前被公认的一种较好的进程调度算法，UNIX操作系统采取的便是这种调度算法。
**优先级调度**：为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以FCFS方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。

**交互式系统**
**时间片轮转**:将所有就绪进程按FCFS的原则排成一个队列，每次调度时，把CPU时间分配给队首进程，该进程可以执行一个时间片。
当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把CPU时间分配给队首的进程。
**优先级调度**:为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。
**多级反馈队列**:可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。

**实时系统**:实时系统要求一个请求在一个确定时间内得到响应。分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。
```
#### 1.8 死锁
```markdown
死锁的必要条件：
     互斥条件 (Mutual exclusion)：资源不能被共享，只能由一个进程使用。
     请求与保持条件 (Hold and wait)：已经得到资源的进程可以再次申请新的资源。
     非抢占条件 (No pre-emption)：已经分配的资源不能从相应的进程中被强制地剥夺。
     循环等待条件 (Circular wait)：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源。
处理方法：鸵鸟策略、死锁检测与死锁恢复、死锁预防、死锁避免。
```
#### 1.9 内存管理
```markdown
虚拟内存：目的是为了让物理内存扩充为更大的逻辑内存，从而让程序获得更大的可用内存。
分页系统内存映射：内存管理单元管理者地址空间和物理内存否转换,其中的页表存储着页(程序地址空间)和页框(物理内存空间)的映射表。
页面置换算法：OPT,LRU,NRU，FIFO，第二次机会算法，CLOCK
分页:虚拟内存采用的就是分页技术，也就是将地址空间分成固定的大小的页，每一页再与内存进行映射。
段页式:程序的地址空间划分成多个拥有独立地址空间的段，每一个段上的地址空间划分为大小相同的页。
```
#### 1.10 CPU 的上下文切换有几种？系统中断进行了几次上下文切换？
```markdown
上下文切换(Context Switch)是一种将CPU资源从一个进程分配给另一个进程的机制。操作系统需要先存储当前进程的状态 
(包括内存空间的指针，当前执行完的指令等等)，再读入下一个进程的状态，然后执行此进程。
CPU 的上下文切换分三种：进程上下文切换、线程上下文切换、中断上下文切换。
     系统调用过程中也会发生CPU上下文切换。CPU寄存器会先保存用户态的状态，然后加载内核态相关内容。
    系统调用结束之后，CPU寄存器要恢复原来保存的用户态，继续运行进程。所以，一次系统调用，发生两次CPU上下文切换。
 进程是由内核管理和调度的，进程的切换只能发生在内核态。进程上下文切换与系统调用的不同在于，
    进程的调用会保存用户空间的虚拟内存，全局变量等信息，但是系统调用的上下文则不会，因为其未发生进程的变化。
 内核中的任务调度实际是在调度线程，进程只是给线程提供虚拟内存、全局变量等资源。
    线程上下文切换时，共享相同的虚拟内存和全局变量等资源不需要修改。
    而线程自己的私有数据，如栈和寄存器等，上下文切换时需要保存。
```
#### 1.11 页面置换算法？
```markdown
 最优页面置换算法（往后看）：最理想的状态下，我们给页面做个标记，挑选一个最远才会被再次用到的页面调出
 先进先出页面置换算法（FIFO）及其改进（往前看）：这种算法的思想和队列是一样的，该算法总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予淘汰。
 最近最少使用页面置换算法 LRU（往前看）：总是选择在最近一段时间内最久不用的页面予以淘汰。 即淘汰最近最长时间未访问过的页面。
```

## 三、计算机组成原理
### [计算机组成原理](https://www.cnblogs.com/reminis/p/12896053.html)

### [【重学计算机】计算机组成原理](https://www.cnblogs.com/flashsun/p/10628433.html)
```markdown

```
[随笔分类 - 重学计算机笔记](https://www.cnblogs.com/flashsun/category/1391951.html)

## 三、Linux
### Linux I/O
#### 1.1 I/O 模型
```markdown
Unix 有五种 I/O 模型：
    阻塞式I/O（blocking IO） : 应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。
    非阻塞式I/O（nonblocking IO）:应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知I/O是否完成，这种方式称为轮询（polling）。
    I/O复用（IO multiplexing）（select和poll）:使用select或者poll等待数据，并且可以等待多个套接字中的任何一个变为可读。
        这一过程会被阻塞，当某一个套接字可读时返回，之后再使用recvfrom把数据从内核复制到进程中。
    信号驱动式I/O（SIGIO）:应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。
    异步I/O（asynchronous IO）（AIO:应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。
```
#### 1.2 I/O复用
```markdown
同步I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段，应用进程会阻塞。
异步I/O：不会阻塞。
阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O 都是同步 I/O，它们的主要区别在第一个阶段。
非阻塞式 I/O 、信号驱动 I/O 和异步 I/O 在第一阶段不会阻塞。
```
#### 1.3 IO 多路复用的 select、poll和epoll函数的区别？
```markdown
 select函数监视文件描述符，调用后select函数会阻塞，直到有描述符就绪，或者超时，函数返回，当select函数返回后，就可以遍历描述符，找到就绪的描述符。
    select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制
 没有最大限制（但是数量过大后性能也是会下降）。和select函数一样，poll返回后，需要轮询来获取就绪的描述符。
 epoll 是Linux内核为处理大批量文件描述符而作了改进的poll，是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的
情况下的系统CPU利用率。另一点原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。
```
### Linux常用命令
[不可不知的 7 个 JDK 命令](https://www.cnblogs.com/wupeixuan/p/12965240.html)
```markdown
整机 top:    uptime
CPU vmstat -n 2 3  # 每两秒采样一次，采样三次。
    查看额外： mpstat -P ALL 2 查看所有CPU核信息
              pidstat -u 1 -p 进程编号  每个进程使用cpu的用量分解信息
内存 free 应用程序可用内存数 free -m ,free -g  查看内存的单位
    查看额外 pidstat -p 进程号 -r 采样间隔秒数
硬盘 df  查看磁盘剩余空闲数  df -h
磁盘IO iostat   磁盘I/O性能评估 iostat -xdk 2 3
    查看额外 pidstat -d 采样间隔秒数 -p 进程号
网络IO ifstat 默认本地没有，下载    ifstat l  查看网络I/O
```
### 假如生产环境出现CPU占用过高，谈一谈分析思路和定位
```markdown
结合Linux和JDK命令一起分析
    1.先用top命令找到CPU占用最高的
    2.ps -ef 或者jps 进一步定位，得知是一个怎么样的后台程序
    3.定位到具体线程或者代码 ps -mp 进程 -o THREAD,tid,time
            -m 显示所有线程
            -p pid进程使用cpu的时间
            -o 该参数后面是用户自定义格式
    4.将需要的线程ID转换为16进制格式(英文小写格式)
    5.jstack 进程 ID | grep tid(16进制线程ID小写英文) -A60
性能监控工具
    jps(虚拟机进程状况工具) 
    jinfo(Java配置信息工具)
    jmap(内存映射工具)
    jstat(统计信息监控工具)
```
##
###
